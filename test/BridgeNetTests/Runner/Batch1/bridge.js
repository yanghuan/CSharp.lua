/**
 * @version   : 17.6.0 - Bridge.NET
 * @author    : Object.NET, Inc. http://bridge.net/
 * @copyright : Copyright 2008-2018 Object.NET, Inc. http://object.net/
 * @license   : See license.txt and https://github.com/bridgedotnet/Bridge/blob/master/LICENSE.md
 */

    // @source Init.js

(function (globals) {
    "use strict";

    if (typeof module !== "undefined" && module.exports) {
        globals = global;
    }

    // @source Core.js

    var core = {
        global: globals,

        isNode: Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]",

        emptyFn: function () { },

        identity: function (x) {
            return x;
        },

        Deconstruct: function (obj) {
            var args = Array.prototype.slice.call(arguments, 1);

            for (var i = 0; i < args.length; i++) {
                args[i].v = i == 7 ? obj["Rest"] : obj["Item" + (i + 1)];
            }
        },

        toString: function (instance) {
            if (instance == null) {
                throw new System.ArgumentNullException();
            }

            var guardItem = Bridge.$toStringGuard[Bridge.$toStringGuard.length - 1];

            if (instance.toString === Object.prototype.toString || guardItem && guardItem === instance) {
                return Bridge.Reflection.getTypeFullName(instance);
            }

            Bridge.$toStringGuard.push(instance);

            var result = instance.toString();

            Bridge.$toStringGuard.pop();

            return result;
        },

        geti: function (scope, name1, name2) {
            if (scope[name1] !== undefined) {
                return name1;
            }

            if (name2 && scope[name2] != undefined) {
                return name2;
            }

            var name = name2 || name1;
            var idx = name.lastIndexOf("$");

            if (/\$\d+$/g.test(name)) {
                idx = name.lastIndexOf("$", idx - 1);
            }

            return name.substr(idx + 1);
        },

        box: function (v, T, toStr, hashCode) {
            if (v && v.$boxed) {
                return v;
            }

            if (v == null) {
                return v;
            }

            if (v.$clone) {
                v = v.$clone();
            }

            return {
                $boxed: true,
                fn: {
                    toString: toStr,
                    getHashCode: hashCode
                },
                v: v,
                type: T,
                constructor: T,
                getHashCode: function () {
                    return this.fn.getHashCode ? this.fn.getHashCode(this.v) : Bridge.getHashCode(this.v);
                },
                equals: function (o) {
                    if (this === o) {
                        return true;
                    }

                    var eq = this.equals;
                    this.equals = null;
                    var r = Bridge.equals(this.v, o);
                    this.equals = eq;

                    return r;
                },
                valueOf: function () {
                    return this.v;
                },
                toString: function () {
                    return this.fn.toString ? this.fn.toString(this.v) : this.v.toString();
                }
            };
        },

        unbox: function (o, noclone) {
            var T;

            if (noclone && Bridge.isFunction(noclone)) {
                T = noclone;
                noclone = false;
            }

            if (o && o.$boxed) {
                var v = o.v,
                    t = o.type;

                if (T && T.$nullable) {
                    T = T.$nullableType;
                }

                if (T && T.$kind === "enum") {
                    T = System.Enum.getUnderlyingType(T);
                }

                if (t.$nullable) {
                    t = t.$nullableType;
                }

                if (t.$kind === "enum") {
                    t = System.Enum.getUnderlyingType(t);
                }

                if (T && T !== t && !Bridge.isObject(T)) {
                    throw new System.InvalidCastException.$ctor1("Specified cast is not valid.");
                }

                if (!noclone && v && v.$clone) {
                    v = v.$clone();
                }

                return v;
            }

            if (Bridge.isArray(o)) {
                for (var i = 0; i < o.length; i++) {
                    var item = o[i];

                    if (item && item.$boxed) {
                        item = item.v;

                        if (item.$clone) {
                            item = item.$clone();
                        }
                    } else if (!noclone && item && item.$clone) {
                        item = item.$clone();
                    }

                    o[i] = item;
                }
            }

            if (o && !noclone && o.$clone) {
                o = o.$clone();
            }

            return o;
        },

        virtualc: function (name) {
            return Bridge.virtual(name, true);
        },

        virtual: function (name, isClass) {
            var type = Bridge.unroll(name);

            if (!type || !Bridge.isFunction(type)) {
                var old = Bridge.Class.staticInitAllow;
                type = isClass ? Bridge.define(name) : Bridge.definei(name);
                Bridge.Class.staticInitAllow = true;

                if (type.$staticInit) {
                    type.$staticInit();
                }

                Bridge.Class.staticInitAllow = old;
            }

            return type;
        },

        safe: function (fn) {
            try {
                return fn();
            } catch (ex) {
            }

            return false;
        },

        literal: function (type, obj) {
            obj.$getType = function () { return type };

            return obj;
        },

        isJSObject: function (value) {
            return Object.prototype.toString.call(value) === "[object Object]";
        },

        isPlainObject: function (obj) {
            if (typeof obj == "object" && obj !== null) {
                if (typeof Object.getPrototypeOf == "function") {
                    var proto = Object.getPrototypeOf(obj);

                    return proto === Object.prototype || proto === null;
                }

                return Object.prototype.toString.call(obj) === "[object Object]";
            }

            return false;
        },

        toPlain: function (o) {
            if (!o || Bridge.isPlainObject(o) || typeof o != "object") {
                return o;
            }

            if (typeof o.toJSON == "function") {
                return o.toJSON();
            }

            if (Bridge.isArray(o)) {
                var arr = [];

                for (var i = 0; i < o.length; i++) {
                    arr.push(Bridge.toPlain(o[i]));
                }

                return arr;
            }

            var newo = {},
                m;

            for (var key in o) {
                m = o[key];

                if (!Bridge.isFunction(m)) {
                    newo[key] = m;
                }
            }

            return newo;
        },

        ref: function (o, n) {
            if (Bridge.isArray(n)) {
                n = System.Array.toIndex(o, n);
            }

            var proxy = {};

            Object.defineProperty(proxy, "v", {
                get: function () {
                    if (n == null) {
                        return o;
                    }

                    return o[n];
                },

                set: function (value) {
                    if (n == null) {
                        if (value && value.$clone) {
                            value.$clone(o);
                        } else {
                            o = value;
                        }
                    }

                    o[n] = value;
                }
            });

            return proxy;
        },

        ensureBaseProperty: function (scope, name, alias) {
            var scopeType = Bridge.getType(scope),
                descriptors = scopeType.$descriptors || [];

            scope.$propMap = scope.$propMap || {};

            if (scope.$propMap[name]) {
                return scope;
            }

            if ((!scopeType.$descriptors || scopeType.$descriptors.length === 0) && alias) {
                var aliasCfg = {},
                    aliasName = "$" + alias + "$" + name;

                aliasCfg.get = function () {
                    return scope[name];
                };

                aliasCfg.set = function (value) {
                    scope[name] = value;
                };

                Bridge.property(scope, aliasName, aliasCfg, false, scopeType, true);
            }
            else {
                for (var j = 0; j < descriptors.length; j++) {
                    var d = descriptors[j];

                    if (d.name === name) {
                        var aliasCfg = {},
                            aliasName = "$" + Bridge.getTypeAlias(d.cls) + "$" + name;

                        if (d.get) {
                            aliasCfg.get = d.get;
                        }

                        if (d.set) {
                            aliasCfg.set = d.set;
                        }

                        Bridge.property(scope, aliasName, aliasCfg, false, scopeType, true);
                    }
                }
            }

            scope.$propMap[name] = true;

            return scope;
        },

        property: function (scope, name, v, statics, cls, alias) {
            var cfg = {
                enumerable: alias ? false : true,
                configurable: true
            };

            if (v && v.get) {
                cfg.get = v.get;
            }

            if (v && v.set) {
                cfg.set = v.set;
            }

            if (!v || !(v.get || v.set)) {
                var backingField = Bridge.getTypeAlias(cls) + "$" + name;

                cls.$init = cls.$init || {};

                if (statics) {
                    cls.$init[backingField] = v;
                }

                (function (cfg, scope, backingField, v) {
                    cfg.get = function () {
                        var o = this.$init[backingField];

                        return o === undefined ? v : o;
                    };

                    cfg.set = function (value) {
                        this.$init[backingField] = value;
                    };
                })(cfg, scope, backingField, v);
            }

            Object.defineProperty(scope, name, cfg);

            return cfg;
        },

        event: function (scope, name, v, statics) {
            scope[name] = v;

            var rs = name.charAt(0) === "$",
                cap = rs ? name.slice(1) : name,
                addName = "add" + cap,
                removeName = "remove" + cap,
                lastSep = name.lastIndexOf("$"),
                endsNum = lastSep > 0 && ((name.length - lastSep - 1) > 0) && !isNaN(parseInt(name.substr(lastSep + 1)));

            if (endsNum) {
                lastSep = name.substring(0, lastSep - 1).lastIndexOf("$");
            }

            if (lastSep > 0 && lastSep !== (name.length - 1)) {
                addName = name.substring(0, lastSep) + "add" + name.substr(lastSep + 1);
                removeName = name.substring(0, lastSep) + "remove" + name.substr(lastSep + 1);
            }

            scope[addName] = (function (name, scope, statics) {
                return statics ? function (value) {
                    scope[name] = Bridge.fn.combine(scope[name], value);
                } : function (value) {
                    this[name] = Bridge.fn.combine(this[name], value);
                };
            })(name, scope, statics);

            scope[removeName] = (function (name, scope, statics) {
                return statics ? function (value) {
                    scope[name] = Bridge.fn.remove(scope[name], value);
                } : function (value) {
                    this[name] = Bridge.fn.remove(this[name], value);
                };
            })(name, scope, statics);
        },

        createInstance: function (type, nonPublic, args) {
            if (Bridge.isArray(nonPublic)) {
                args = nonPublic;
                nonPublic = false;
            }

            if (type === System.Decimal) {
                return System.Decimal.Zero;
            }

            if (type === System.Int64) {
                return System.Int64.Zero;
            }

            if (type === System.UInt64) {
                return System.UInt64.Zero;
            }

            if (type === System.Double ||
                type === System.Single ||
                type === System.Byte ||
                type === System.SByte ||
                type === System.Int16 ||
                type === System.UInt16 ||
                type === System.Int32 ||
                type === System.UInt32 ||
                type === Bridge.Int) {
                return 0;
            }

            if (typeof (type.createInstance) === "function") {
                return type.createInstance();
            } else if (typeof (type.getDefaultValue) === "function") {
                return type.getDefaultValue();
            } else if (type === Boolean || type === System.Boolean) {
                return false;
            } else if (type === System.DateTime) {
                return System.DateTime.getDefaultValue();
            } else if (type === Date) {
                return new Date();
            } else if (type === Number) {
                return 0;
            } else if (type === String || type === System.String) {
                return "";
            } else if (type && type.$literal) {
                return type.ctor();
            } else if (args && args.length > 0) {
                return Bridge.Reflection.applyConstructor(type, args);
            }

            if (type.$kind === 'interface') {
                throw new System.MissingMethodException.$ctor1('Default constructor not found for type ' + Bridge.getTypeName(type));
            }

            var ctors = Bridge.Reflection.getMembers(type, 1, 54);

            if (ctors.length > 0) {
                var pctors = ctors.filter(function (c) { return !c.isSynthetic && !c.sm; });

                for (var idx = 0; idx < pctors.length; idx++) {
                    var c = pctors[idx],
                        isDefault = (c.pi || []).length === 0;

                    if (isDefault) {
                        if (nonPublic || c.a === 2) {
                            return Bridge.Reflection.invokeCI(c, []);
                        }
                        throw new System.MissingMethodException.$ctor1('Default constructor not found for type ' + Bridge.getTypeName(type));
                    }
                }

                if (type.$$name && !(ctors.length == 1 && ctors[0].isSynthetic)) {
                    throw new System.MissingMethodException.$ctor1('Default constructor not found for type ' + Bridge.getTypeName(type));
                }
            }

            return new type();
        },

        clone: function (obj) {
            if (obj == null) {
                return obj;
            }

            if (Bridge.isArray(obj)) {
                return System.Array.clone(obj);
            }

            if (Bridge.isString(obj)) {
                return obj;
            }

            var name;

            if (Bridge.isFunction(Bridge.getProperty(obj, name = "System$ICloneable$clone"))) {
                return obj[name]();
            }

            if (Bridge.is(obj, System.ICloneable)) {
                return obj.clone();
            }

            if (Bridge.isFunction(obj.$clone)) {
                return obj.$clone();
            }

            return null;
        },

        copy: function (to, from, keys, toIf) {
            if (typeof keys === "string") {
                keys = keys.split(/[,;\s]+/);
            }

            for (var name, i = 0, n = keys ? keys.length : 0; i < n; i++) {
                name = keys[i];

                if (toIf !== true || to[name] == undefined) {
                    if (Bridge.is(from[name], System.ICloneable)) {
                        to[name] = Bridge.clone(from[name]);
                    } else {
                        to[name] = from[name];
                    }
                }
            }

            return to;
        },

        get: function (t) {
            if (t && t.$staticInit !== null) {
                t.$staticInit();
            }

            return t;
        },

        ns: function (ns, scope) {
            var nsParts = ns.split("."),
                i = 0;

            if (!scope) {
                scope = Bridge.global;
            }

            for (i = 0; i < nsParts.length; i++) {
                if (typeof scope[nsParts[i]] === "undefined") {
                    scope[nsParts[i]] = {};
                }

                scope = scope[nsParts[i]];
            }

            return scope;
        },

        ready: function (fn, scope) {
            var delayfn = function () {
                if (scope) {
                    fn.apply(scope);
                } else {
                    fn();
                }
            };

            if (typeof Bridge.global.jQuery !== "undefined") {
                Bridge.global.jQuery(delayfn);
            } else {
                if (typeof Bridge.global.document === "undefined" ||
                    Bridge.global.document.readyState === "complete" ||
                    Bridge.global.document.readyState === "loaded" ||
                    Bridge.global.document.readyState === "interactive") {
                    delayfn();
                } else {
                    Bridge.on("DOMContentLoaded", Bridge.global.document, delayfn);
                }
            }
        },

        on: function (event, elem, fn, scope) {
            var listenHandler = function (e) {
                var ret = fn.apply(scope || this, arguments);

                if (ret === false) {
                    e.stopPropagation();
                    e.preventDefault();
                }

                return (ret);
            };

            var attachHandler = function () {
                var ret = fn.call(scope || elem, Bridge.global.event);

                if (ret === false) {
                    Bridge.global.event.returnValue = false;
                    Bridge.global.event.cancelBubble = true;
                }

                return (ret);
            };

            if (elem.addEventListener) {
                elem.addEventListener(event, listenHandler, false);
            } else {
                elem.attachEvent("on" + event, attachHandler);
            }
        },

        addHash: function (v, r, m) {
            if (isNaN(r)) {
                r = 17;
            }

            if (isNaN(m)) {
                m = 23;
            }

            if (Bridge.isArray(v)) {
                for (var i = 0; i < v.length; i++) {
                    r = r + ((r * m | 0) + (v[i] == null ? 0 : Bridge.getHashCode(v[i]))) | 0;
                }

                return r;
            }

            return r = r + ((r * m | 0) + (v == null ? 0 : Bridge.getHashCode(v))) | 0;
        },

        getHashCode: function (value, safe, deep) {
            // In CLR: mutable object should keep on returning same value
            // Bridge.NET goals: make it deterministic (to make testing easier) without breaking CLR contracts
            //     for value types it returns deterministic values (f.e. for int 3 it returns 3)
            //     for reference types it returns random value

            if (value && value.$boxed && value.type.getHashCode) {
                return value.type.getHashCode(Bridge.unbox(value, true));
            }

            value = Bridge.unbox(value, true);

            if (Bridge.isEmpty(value, true)) {
                if (safe) {
                    return 0;
                }

                throw new System.InvalidOperationException.$ctor1("HashCode cannot be calculated for empty value");
            }

            if (deep !== false && value.hasOwnProperty("Item1") && Bridge.isPlainObject(value)) {
                deep = true;
            }

            if (value.getHashCode && Bridge.isFunction(value.getHashCode) && !value.__insideHashCode && value.getHashCode.length === 0) {
                value.__insideHashCode = true;
                var r = value.getHashCode();

                delete value.__insideHashCode;

                return r;
            }

            if (Bridge.isBoolean(value)) {
                return value ? 1 : 0;
            }

            if (Bridge.isDate(value)) {
                return value.valueOf() & 0xFFFFFFFF;
            }

            if (value === Number.POSITIVE_INFINITY) {
                return 0x7FF00000;
            }

            if (value === Number.NEGATIVE_INFINITY) {
                return 0xFFF00000;
            }

            if (Bridge.isNumber(value)) {
                if (Math.floor(value) === value) {
                    return value;
                }

                value = value.toExponential();
            }

            if (Bridge.isString(value)) {
                var hash = 0,
                    i;

                for (i = 0; i < value.length; i++) {
                    hash = (((hash << 5) - hash) + value.charCodeAt(i)) & 0xFFFFFFFF;
                }

                return hash;
            }

            if (value.$$hashCode) {
                return value.$$hashCode;
            }

            if (deep && typeof value == "object") {
                var result = 0,
                    temp;

                for (var property in value) {
                    if (value.hasOwnProperty(property)) {
                        temp = Bridge.isEmpty(value[property], true) ? 0 : Bridge.getHashCode(value[property]);
                        result = 29 * result + temp;
                    }
                }

                if (result !== 0) {
                    value.$$hashCode = result;

                    return result;
                }
            }

            value.$$hashCode = (Math.random() * 0x100000000) | 0;

            return value.$$hashCode;
        },

        getDefaultValue: function (type) {
            if (type == null) {
                throw new System.ArgumentNullException.$ctor1("type");
            } else if ((type.getDefaultValue) && type.getDefaultValue.length === 0) {
                return type.getDefaultValue();
            } else if (Bridge.Reflection.isEnum(type)) {
                return System.Enum.parse(type, 0);
            } else if (type === Boolean || type === System.Boolean) {
                return false;
            } else if (type === System.DateTime) {
                return System.DateTime.getDefaultValue();
            } else if (type === Date) {
                return new Date();
            } else if (type === Number) {
                return 0;
            }

            return null;
        },

        $$aliasCache: [],

        getTypeAlias: function (obj) {
            if (obj.$$alias) {
                return obj.$$alias;
            }

            var type = (obj.$$name || typeof obj === "function") ? obj : Bridge.getType(obj),
                alias;

            if (type.$$alias) {
                return type.$$alias;
            }

            alias = Bridge.$$aliasCache[type];
            if (alias) {
                return alias;
            }

            if (type.$isArray) {
                var elementName = Bridge.getTypeAlias(type.$elementType);
                alias = elementName + "$Array" + (type.$rank > 1 ? ("$" + type.$rank) : "");

                if (type.$$name) {
                    type.$$alias = alias;
                } else {
                    Bridge.$$aliasCache[type] = alias;
                }

                return alias;
            }

            var name = obj.$$name || Bridge.getTypeName(obj);

            alias = name.replace(/[\.\(\)\,\+]/g, "$");

            if (type.$$name) {
                type.$$alias = alias;
            } else {
                Bridge.$$aliasCache[type] = alias;
            }

            return alias;
        },

        getTypeName: function (obj) {
            return Bridge.Reflection.getTypeFullName(obj);
        },

        hasValue: function (obj) {
            return Bridge.unbox(obj, true) != null;
        },

        hasValue$1: function () {
            if (arguments.length === 0) {
                return false;
            }

            var i = 0;

            for (i; i < arguments.length; i++) {
                if (Bridge.unbox(arguments[i], true) == null) {
                    return false;
                }
            }

            return true;
        },

        isObject: function (type) {
            return type === Object || type === System.Object;
        },

        is: function (obj, type, ignoreFn, allowNull) {
            if (obj == null) {
                return !!allowNull;
            }

            if (type === System.Object) {
                type = Object;
            }

            var tt = typeof type;

            if (tt === "boolean") {
                return type;
            }

            if (obj.$boxed) {
                if (obj.type.$kind === "enum" && (obj.type.prototype.$utype === type || type === System.Enum || type === System.IFormattable || type === System.IComparable)) {
                    return true;
                } else if (!Bridge.Reflection.isInterface(type) && !type.$nullable) {
                    return obj.type === type || Bridge.isObject(type) || type === System.ValueType && Bridge.Reflection.isValueType(obj.type);
                }

                if (ignoreFn !== true && type.$is) {
                    return type.$is(Bridge.unbox(obj, true));
                }

                if (Bridge.Reflection.isAssignableFrom(type, obj.type)) {
                    return true;
                }

                obj = Bridge.unbox(obj, true);
            }

            var ctor = obj.constructor === Object && obj.$getType ? obj.$getType() : Bridge.Reflection.convertType(obj.constructor);

            if (type.constructor === Function && obj instanceof type || ctor === type || Bridge.isObject(type)) {
                return true;
            }

            var hasObjKind = ctor.$kind || ctor.$$inherits,
                hasTypeKind = type.$kind;

            if (hasObjKind || hasTypeKind) {
                var isInterface = type.$isInterface;

                if (isInterface) {
                    if (hasObjKind) {
                        if (ctor.$isArrayEnumerator) {
                            return System.Array.is(obj, type);
                        }

                        return type.isAssignableFrom ? type.isAssignableFrom(ctor) : Bridge.Reflection.getInterfaces(ctor).indexOf(type) >= 0;
                    }

                    if (Bridge.isArray(obj, ctor)) {
                        return System.Array.is(obj, type);
                    }
                }

                if (ignoreFn !== true && type.$is) {
                    return type.$is(obj);
                }

                if (type.$literal) {
                    if (Bridge.isPlainObject(obj)) {
                        if (obj.$getType) {
                            return Bridge.Reflection.isAssignableFrom(type, obj.$getType());
                        }

                        return true;
                    }
                }

                return false;
            }

            if (tt === "string") {
                type = Bridge.unroll(type);
            }

            if (tt === "function" && (Bridge.getType(obj).prototype instanceof type)) {
                return true;
            }

            if (ignoreFn !== true) {
                if (typeof (type.$is) === "function") {
                    return type.$is(obj);
                }

                if (typeof (type.isAssignableFrom) === "function") {
                    return type.isAssignableFrom(Bridge.getType(obj));
                }
            }

            if (Bridge.isArray(obj)) {
                return System.Array.is(obj, type);
            }

            return tt === "object" && ((ctor === type) || (obj instanceof type));
        },

        as: function (obj, type, allowNull) {
            if (Bridge.is(obj, type, false, allowNull)) {
                return obj != null && obj.$boxed && type !== Object && type !== System.Object ? obj.v : obj;
            }
            return null;
        },

        cast: function (obj, type, allowNull) {
            if (obj == null) {
                return obj;
            }

            var result = Bridge.is(obj, type, false, allowNull) ? obj : null;

            if (result === null) {
                throw new System.InvalidCastException.$ctor1("Unable to cast type " + (obj ? Bridge.getTypeName(obj) : "'null'") + " to type " + Bridge.getTypeName(type));
            }

            if (obj.$boxed && type !== Object && type !== System.Object) {
                return obj.v;
            }

            return result;
        },

        apply: function (obj, values, callback) {
            var names = Bridge.getPropertyNames(values, true),
                i;

            for (i = 0; i < names.length; i++) {
                var name = names[i];

                if (typeof obj[name] === "function" && typeof values[name] !== "function") {
                    obj[name](values[name]);
                } else {
                    obj[name] = values[name];
                }
            }

            if (callback) {
                callback.call(obj, obj);
            }

            return obj;
        },

        copyProperties: function (to, from) {
            var names = Bridge.getPropertyNames(from, false),
                i;

            for (i = 0; i < names.length; i++) {
                var name = names[i],
                    own = from.hasOwnProperty(name),
                    dcount = name.split("$").length;

                if (own && (dcount === 1 || dcount === 2 && name.match("\$\d+$"))) {
                    to[name] = from[name];
                }

            }

            return to;
        },

        merge: function (to, from, callback, elemFactory) {
            if (to == null) {
                return from;
            }

            // Maps instance of plain JS value or Object into Bridge object.
            // Used for deserialization. Proper deserialization requires reflection that is currently not supported in Bridge.
            // It currently is only capable to deserialize:
            // -instance of single class or primitive
            // -array of primitives
            // -array of single class
            if (to instanceof System.Decimal && typeof from === "number") {
                return new System.Decimal(from);
            }

            if (to instanceof System.Int64 && Bridge.isNumber(from)) {
                return new System.Int64(from);
            }

            if (to instanceof System.UInt64 && Bridge.isNumber(from)) {
                return new System.UInt64(from);
            }

            if (to instanceof Boolean || Bridge.isBoolean(to) ||
                typeof to === "number" ||
                to instanceof String || Bridge.isString(to) ||
                to instanceof Function || Bridge.isFunction(to) ||
                to instanceof Date || Bridge.isDate(to) ||
                Bridge.getType(to).$number) {
                return from;
            }

            var key,
                i,
                value,
                toValue,
                fn;

            if (Bridge.isArray(from) && Bridge.isFunction(to.add || to.push)) {
                fn = Bridge.isArray(to) ? to.push : to.add;

                for (i = 0; i < from.length; i++) {
                    var item = from[i];

                    if (!Bridge.isArray(item)) {
                        item = [typeof elemFactory === "undefined" ? item : Bridge.merge(elemFactory(), item)];
                    }

                    fn.apply(to, item);
                }
            } else {
                var t = Bridge.getType(to),
                    descriptors = t && t.$descriptors;

                if (from) {
                    for (key in from) {
                        value = from[key];

                        var descriptor = null;

                        if (descriptors) {
                            for (var i = descriptors.length - 1; i >= 0; i--) {
                                if (descriptors[i].name === key) {
                                    descriptor = descriptors[i];

                                    break;
                                }
                            }
                        }

                        if (descriptor != null) {
                            if (descriptor.set) {
                                to[key] = Bridge.merge(to[key], value);
                            } else {
                                Bridge.merge(to[key], value);
                            }
                        } else if (typeof to[key] === "function") {
                            if (key.match(/^\s*get[A-Z]/)) {
                                Bridge.merge(to[key](), value);
                            } else {
                                to[key](value);
                            }
                        } else {
                            var setter1 = "set" + key.charAt(0).toUpperCase() + key.slice(1),
                                setter2 = "set" + key,
                                getter;

                            if (typeof to[setter1] === "function" && typeof value !== "function") {
                                getter = "g" + setter1.slice(1);

                                if (typeof to[getter] === "function") {
                                    to[setter1](Bridge.merge(to[getter](), value));
                                } else {
                                    to[setter1](value);
                                }
                            } else if (typeof to[setter2] === "function" && typeof value !== "function") {
                                getter = "g" + setter2.slice(1);

                                if (typeof to[getter] === "function") {
                                    to[setter2](Bridge.merge(to[getter](), value));
                                } else {
                                    to[setter2](value);
                                }
                            } else if (value && value.constructor === Object && to[key]) {
                                toValue = to[key];
                                Bridge.merge(toValue, value);
                            } else {
                                var isNumber = Bridge.isNumber(from);

                                if (to[key] instanceof System.Decimal && isNumber) {
                                    return new System.Decimal(from);
                                }

                                if (to[key] instanceof System.Int64 && isNumber) {
                                    return new System.Int64(from);
                                }

                                if (to[key] instanceof System.UInt64 && isNumber) {
                                    return new System.UInt64(from);
                                }

                                to[key] = value;
                            }
                        }
                    }
                } else {
                    if (callback) {
                        callback.call(to, to);
                    }

                    return from;
                }
            }

            if (callback) {
                callback.call(to, to);
            }

            return to;
        },

        getEnumerator: function (obj, fnName, T) {
            if (typeof obj === "string") {
                obj = System.String.toCharArray(obj);
            }

            if (arguments.length === 2 && Bridge.isFunction(fnName)) {
                T = fnName;
                fnName = null;
            }

            if (fnName && obj && obj[fnName]) {
                return obj[fnName].call(obj);
            }

            if (!T && obj && obj.GetEnumerator) {
                return obj.GetEnumerator();
            }

            var name;

            if (T && Bridge.isFunction(Bridge.getProperty(obj, name = "System$Collections$Generic$IEnumerable$1$" + Bridge.getTypeAlias(T) + "$GetEnumerator"))) {
                return obj[name]();
            }

            if (T && Bridge.isFunction(Bridge.getProperty(obj, name = "System$Collections$Generic$IEnumerable$1$GetEnumerator"))) {
                return obj[name]();
            }

            if (Bridge.isFunction(Bridge.getProperty(obj, name = "System$Collections$IEnumerable$GetEnumerator"))) {
                return obj[name]();
            }

            if (T && obj && obj.GetEnumerator) {
                return obj.GetEnumerator();
            }

            if ((Object.prototype.toString.call(obj) === "[object Array]") ||
                (obj && Bridge.isDefined(obj.length))) {
                return new Bridge.ArrayEnumerator(obj, T);
            }

            throw new System.InvalidOperationException.$ctor1("Cannot create Enumerator.");
        },

        getPropertyNames: function (obj, includeFunctions) {
            var names = [],
                name;

            for (name in obj) {
                if (includeFunctions || typeof obj[name] !== "function") {
                    names.push(name);
                }
            }

            return names;
        },

        getProperty: function (obj, propertyName) {
            if (Bridge.isHtmlAttributeCollection(obj) && !this.isValidHtmlAttributeName(propertyName)) {
                return undefined;
            }

            return obj[propertyName];
        },

        isValidHtmlAttributeName : function (name) {
            // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2

            if (!name || !name.length) {
                return false;
            }

            var r = /^[a-zA-Z_][\w\-]*$/;

            return r.test(name);
        },

        isHtmlAttributeCollection: function (obj) {
            return typeof obj !== "undefined" && (Object.prototype.toString.call(obj) === "[object NamedNodeMap]");
        },

        isDefined: function (value, noNull) {
            return typeof value !== "undefined" && (noNull ? value !== null : true);
        },

        isEmpty: function (value, allowEmpty) {
            return (typeof value === "undefined" || value === null) || (!allowEmpty ? value === "" : false) || ((!allowEmpty && Bridge.isArray(value)) ? value.length === 0 : false);
        },

        toArray: function (ienumerable) {
            var i,
                item,
                len,
                result = [];

            if (Bridge.isArray(ienumerable)) {
                for (i = 0, len = ienumerable.length; i < len; ++i) {
                    result.push(ienumerable[i]);
                }
            } else {
                i = Bridge.getEnumerator(ienumerable);

                while (i.moveNext()) {
                    item = i.Current;
                    result.push(item);
                }
            }

            return result;
        },

        toList: function (ienumerable, T) {
            return new (System.Collections.Generic.List$1(T || System.Object).$ctor1)(ienumerable);
        },

        arrayTypes: [globals.Array, globals.Uint8Array, globals.Int8Array, globals.Int16Array, globals.Uint16Array, globals.Int32Array, globals.Uint32Array, globals.Float32Array, globals.Float64Array, globals.Uint8ClampedArray],

        isArray: function (obj, ctor) {
            var c = ctor || (obj != null ? obj.constructor : null);

            if (!c) {
                return false;
            }

            return Bridge.arrayTypes.indexOf(c) >= 0 || c.$isArray || Array.isArray(obj);
        },

        isFunction: function (obj) {
            return typeof (obj) === "function";
        },

        isDate: function (obj) {
            return obj instanceof Date;
        },

        isNull: function (value) {
            return (value === null) || (value === undefined);
        },

        isBoolean: function (value) {
            return typeof value === "boolean";
        },

        isNumber: function (value) {
            return typeof value === "number" && isFinite(value);
        },

        isString: function (value) {
            return typeof value === "string";
        },

        unroll: function (value, scope) {
            if (Bridge.isArray(value)) {
                for (var i = 0; i < value.length; i++) {
                    var v = value[i];

                    if (Bridge.isString(v)) {
                        value[i] = Bridge.unroll(v, scope);
                    }
                }

                return;
            }

            var d = value.split("."),
                o = (scope || Bridge.global)[d[0]],
                i = 1;

            for (i; i < d.length; i++) {
                if (!o) {
                    return null;
                }

                o = o[d[i]];
            }

            return o;
        },

        referenceEquals: function (a, b) {
            return Bridge.hasValue(a) ? a === b : !Bridge.hasValue(b);
        },

        staticEquals: function (a, b) {
            if (!Bridge.hasValue(a)) {
                return !Bridge.hasValue(b);
            }

            return Bridge.hasValue(b) ? Bridge.equals(a, b) : false;
        },

        equals: function (a, b) {
            if (a == null && b == null) {
                return true;
            }

            var guardItem = Bridge.$equalsGuard[Bridge.$equalsGuard.length - 1];

            if (guardItem && guardItem.a === a && guardItem.b === b) {
                return a === b;
            }

            Bridge.$equalsGuard.push({a: a, b: b});

            var fn = function (a, b) {
                if (a && a.$boxed && a.type.equals && a.type.equals.length === 2) {
                    return a.type.equals(a, b);
                }

                if (b && b.$boxed && b.type.equals && b.type.equals.length === 2) {
                    return b.type.equals(b, a);
                }

                if (a && Bridge.isFunction(a.equals) && a.equals.length === 1) {
                    return a.equals(b);
                }

                if (b && Bridge.isFunction(b.equals) && b.equals.length === 1) {
                    return b.equals(a);
                } if (Bridge.isFunction(a) && Bridge.isFunction(b)) {
                    return Bridge.fn.equals.call(a, b);
                } else if (Bridge.isDate(a) && Bridge.isDate(b)) {
                    if (a.kind !== undefined && a.ticks !== undefined && b.kind !== undefined && b.ticks !== undefined) {
                        return a.ticks.equals(b.ticks);
                    }

                    return a.valueOf() === b.valueOf();
                } else if (Bridge.isNull(a) && Bridge.isNull(b)) {
                    return true;
                } else if (Bridge.isNull(a) !== Bridge.isNull(b)) {
                    return false;
                }

                var eq = a === b;

                if (!eq && typeof a === "object" && typeof b === "object" && a !== null && b !== null && a.$kind === "struct" && b.$kind === "struct" && a.$$name === b.$$name) {
                    return Bridge.getHashCode(a) === Bridge.getHashCode(b) && Bridge.objectEquals(a, b);
                }

                if (!eq && a && b && a.hasOwnProperty("Item1") && Bridge.isPlainObject(a) && b.hasOwnProperty("Item1") && Bridge.isPlainObject(b)) {
                    return Bridge.objectEquals(a, b);
                }

                return eq;
            };

            var result = fn(a, b);
            Bridge.$equalsGuard.pop();

            return result;
        },

        objectEquals: function (a, b) {
            Bridge.$$leftChain = [];
            Bridge.$$rightChain = [];

            var result = Bridge.deepEquals(a, b);

            delete Bridge.$$leftChain;
            delete Bridge.$$rightChain;

            return result;
        },

        deepEquals: function (a, b) {
            if (typeof a === "object" && typeof b === "object") {
                if (a === b) {
                    return true;
                }

                if (Bridge.$$leftChain.indexOf(a) > -1 || Bridge.$$rightChain.indexOf(b) > -1) {
                    return false;
                }

                var p;

                for (p in b) {
                    if (b.hasOwnProperty(p) !== a.hasOwnProperty(p)) {
                        return false;
                    } else if (typeof b[p] !== typeof a[p]) {
                        return false;
                    }
                }

                for (p in a) {
                    if (b.hasOwnProperty(p) !== a.hasOwnProperty(p)) {
                        return false;
                    } else if (typeof a[p] !== typeof b[p]) {
                        return false;
                    }

                    if (a[p] === b[p]) {
                        continue;
                    } else if (typeof (a[p]) === "object") {
                        Bridge.$$leftChain.push(a);
                        Bridge.$$rightChain.push(b);

                        if (!Bridge.deepEquals(a[p], b[p])) {
                            return false;
                        }

                        Bridge.$$leftChain.pop();
                        Bridge.$$rightChain.pop();
                    } else {
                        if (!Bridge.equals(a[p], b[p])) {
                            return false;
                        }
                    }
                }

                return true;
            } else {
                return Bridge.equals(a, b);
            }
        },

        numberCompare : function (a, b) {
            if (a < b) {
                return -1;
            }

            if (a > b) {
                return 1;
            }

            if (a == b) {
                return 0;
            }

            if (!isNaN(a)) {
                return 1;
            }

            if (!isNaN(b)) {
                return -1;
            }

            return 0;
        },

        compare: function (a, b, safe, T) {
            if (a && a.$boxed) {
                a = Bridge.unbox(a, true);
            }

            if (b && b.$boxed) {
                b = Bridge.unbox(b, true);
            }

            if (typeof a === "number" && typeof b === "number") {
                return Bridge.numberCompare(a, b);
            }

            if (!Bridge.isDefined(a, true)) {
                if (safe) {
                    return 0;
                }

                throw new System.NullReferenceException();
            } else if (Bridge.isString(a)) {
                return System.String.compare(a, b);
            } else if (Bridge.isNumber(a) || Bridge.isBoolean(a)) {
                return a < b ? -1 : (a > b ? 1 : 0);
            } else if (Bridge.isDate(a)) {
                if (a.kind !== undefined && a.ticks !== undefined) {
                    return Bridge.compare(a.ticks, b.ticks);
                }

                return Bridge.compare(a.valueOf(), b.valueOf());
            }

            var name;

            if (T && Bridge.isFunction(Bridge.getProperty(a, name = "System$IComparable$1$" + Bridge.getTypeAlias(T) + "$compareTo"))) {
                return a[name](b);
            }

            if (T && Bridge.isFunction(Bridge.getProperty(a, name = "System$IComparable$1$compareTo"))) {
                return a[name](b);
            }

            if (Bridge.isFunction(Bridge.getProperty(a, name = "System$IComparable$compareTo"))) {
                return a[name](b);
            }

            if (Bridge.isFunction(a.compareTo)) {
                return a.compareTo(b);
            }

            if (T && Bridge.isFunction(Bridge.getProperty(b, name = "System$IComparable$1$" + Bridge.getTypeAlias(T) + "$compareTo"))) {
                return -b[name](a);
            }

            if (T && Bridge.isFunction(Bridge.getProperty(b, name = "System$IComparable$1$compareTo"))) {
                return -b[name](a);
            }

            if (Bridge.isFunction(Bridge.getProperty(b, name = "System$IComparable$compareTo"))) {
                return -b[name](a);
            }

            if (Bridge.isFunction(b.compareTo)) {
                return -b.compareTo(a);
            }

            if (safe) {
                return 0;
            }

            throw new System.Exception("Cannot compare items");
        },

        equalsT: function (a, b, T) {
            if (a && a.$boxed && a.type.equalsT && a.type.equalsT.length === 2) {
                return a.type.equalsT(a, b);
            }

            if (b && b.$boxed && b.type.equalsT && b.type.equalsT.length === 2) {
                return b.type.equalsT(b, a);
            }

            if (!Bridge.isDefined(a, true)) {
                throw new System.NullReferenceException();
            } else if (Bridge.isNumber(a) || Bridge.isString(a) || Bridge.isBoolean(a)) {
                return a === b;
            } else if (Bridge.isDate(a)) {
                if (a.kind !== undefined && a.ticks !== undefined) {
                    return a.ticks.equals(b.ticks);
                }

                return a.valueOf() === b.valueOf();
            }

            var name;

            if (T && a != null && Bridge.isFunction(Bridge.getProperty(a, name = "System$IEquatable$1$" + Bridge.getTypeAlias(T) + "$equalsT"))) {
                return a[name](b);
            }

            if (T && b != null && Bridge.isFunction(Bridge.getProperty(b, name = "System$IEquatable$1$" + Bridge.getTypeAlias(T) + "$equalsT"))) {
                return b[name](a);
            }

            if (Bridge.isFunction(a) && Bridge.isFunction(b)) {
                return Bridge.fn.equals.call(a, b);
            }

            return a.equalsT ? a.equalsT(b) : b.equalsT(a);
        },

        format: function (obj, formatString, provider) {
            if (obj && obj.$boxed) {
                if (obj.type.$kind === "enum") {
                    return System.Enum.format(obj.type, obj.v, formatString);
                } else if (obj.type === System.Char) {
                    return System.Char.format(Bridge.unbox(obj, true), formatString, provider);
                } else if (obj.type.format) {
                    return obj.type.format(Bridge.unbox(obj, true), formatString, provider);
                }
            }

            if (Bridge.isNumber(obj)) {
                return Bridge.Int.format(obj, formatString, provider);
            } else if (Bridge.isDate(obj)) {
                return System.DateTime.format(obj, formatString, provider);
            }

            var name;

            if (Bridge.isFunction(Bridge.getProperty(obj, name = "System$IFormattable$format"))) {
                return obj[name](formatString, provider);
            }

            return obj.format(formatString, provider);
        },

        getType: function (instance, T) {
            if (instance && instance.$boxed) {
                return instance.type;
            }

            if (instance == null) {
                throw new System.NullReferenceException.$ctor1("instance is null");
            }

            if (T) {
                var type = Bridge.getType(instance);
                return Bridge.Reflection.isAssignableFrom(T, type) ? type : T;
            }

            if (typeof (instance) === "number") {
                if (!isNaN(instance) && isFinite(instance) && Math.floor(instance, 0) === instance) {
                    return System.Int32;
                } else {
                    return System.Double;
                }
            }

            if (instance.$type) {
                return instance.$type;
            }

            if (instance.$getType) {
                return instance.$getType();
            }

            var result = null;

            try {
                result = instance.constructor;
            } catch (ex) {
                result = Object;
            }

            if (result === Object) {
                var str = instance.toString(),
                    match = (/\[object (.{1,})\]/).exec(str),
                    name = (match && match.length > 1) ? match[1] : "Object";

                if (name != "Object") {
                    result = instance;
                }
            }

            return Bridge.Reflection.convertType(result);
        },

        isLower: function (c) {
            var s = String.fromCharCode(c);

            return s === s.toLowerCase() && s !== s.toUpperCase();
        },

        isUpper: function (c) {
            var s = String.fromCharCode(c);

            return s !== s.toLowerCase() && s === s.toUpperCase();
        },

        coalesce: function (a, b) {
            return Bridge.hasValue(a) ? a : b;
        },

        fn: {
            equals: function (fn) {
                if (this === fn) {
                    return true;
                }

                if (fn == null || (this.constructor !== fn.constructor)) {
                    return false;
                }

                return this.equals && (this.equals === fn.equals) && this.$method && (this.$method === fn.$method) && this.$scope && (this.$scope === fn.$scope);
            },

            call: function (obj, fnName) {
                var args = Array.prototype.slice.call(arguments, 2);

                obj = obj || Bridge.global;

                return obj[fnName].apply(obj, args);
            },

            makeFn: function (fn, length) {
                switch (length) {
                    case 0:
                        return function () {
                            return fn.apply(this, arguments);
                        };
                    case 1:
                        return function (a) {
                            return fn.apply(this, arguments);
                        };
                    case 2:
                        return function (a, b) {
                            return fn.apply(this, arguments);
                        };
                    case 3:
                        return function (a, b, c) {
                            return fn.apply(this, arguments);
                        };
                    case 4:
                        return function (a, b, c, d) {
                            return fn.apply(this, arguments);
                        };
                    case 5:
                        return function (a, b, c, d, e) {
                            return fn.apply(this, arguments);
                        };
                    case 6:
                        return function (a, b, c, d, e, f) {
                            return fn.apply(this, arguments);
                        };
                    case 7:
                        return function (a, b, c, d, e, f, g) {
                            return fn.apply(this, arguments);
                        };
                    case 8:
                        return function (a, b, c, d, e, f, g, h) {
                            return fn.apply(this, arguments);
                        };
                    case 9:
                        return function (a, b, c, d, e, f, g, h, i) {
                            return fn.apply(this, arguments);
                        };
                    case 10:
                        return function (a, b, c, d, e, f, g, h, i, j) {
                            return fn.apply(this, arguments);
                        };
                    case 11:
                        return function (a, b, c, d, e, f, g, h, i, j, k) {
                            return fn.apply(this, arguments);
                        };
                    case 12:
                        return function (a, b, c, d, e, f, g, h, i, j, k, l) {
                            return fn.apply(this, arguments);
                        };
                    case 13:
                        return function (a, b, c, d, e, f, g, h, i, j, k, l, m) {
                            return fn.apply(this, arguments);
                        };
                    case 14:
                        return function (a, b, c, d, e, f, g, h, i, j, k, l, m, n) {
                            return fn.apply(this, arguments);
                        };
                    case 15:
                        return function (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) {
                            return fn.apply(this, arguments);
                        };
                    case 16:
                        return function (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {
                            return fn.apply(this, arguments);
                        };
                    case 17:
                        return function (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q) {
                            return fn.apply(this, arguments);
                        };
                    case 18:
                        return function (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r) {
                            return fn.apply(this, arguments);
                        };
                    case 19:
                        return function (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s) {
                            return fn.apply(this, arguments);
                        };
                    default:
                        return function (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t) {
                            return fn.apply(this, arguments);
                        };
                }
            },

            cacheBind: function (obj, method, args, appendArgs) {
                return Bridge.fn.bind(obj, method, args, appendArgs, true);
            },

            bind: function (obj, method, args, appendArgs, cache) {
                if (method && method.$method === method && method.$scope === obj) {
                    return method;
                }

                if (obj && cache && obj.$$bind) {
                    for (var i = 0; i < obj.$$bind.length; i++) {
                        if (obj.$$bind[i].$method === method) {
                            return obj.$$bind[i];
                        }
                    }
                }

                var fn;

                if (arguments.length === 2) {
                    fn = Bridge.fn.makeFn(function () {
                        Bridge.caller.unshift(this);

                        var result = null;

                        try {
                            result = method.apply(obj, arguments);
                        } finally {
                            Bridge.caller.shift(this);
                        }

                        return result;
                    }, method.length);
                } else {
                    fn = Bridge.fn.makeFn(function () {
                        var callArgs = args || arguments;

                        if (appendArgs === true) {
                            callArgs = Array.prototype.slice.call(arguments, 0);
                            callArgs = callArgs.concat(args);
                        } else if (typeof appendArgs === "number") {
                            callArgs = Array.prototype.slice.call(arguments, 0);

                            if (appendArgs === 0) {
                                callArgs.unshift.apply(callArgs, args);
                            } else if (appendArgs < callArgs.length) {
                                callArgs.splice.apply(callArgs, [appendArgs, 0].concat(args));
                            } else {
                                callArgs.push.apply(callArgs, args);
                            }
                        }

                        Bridge.caller.unshift(this);

                        var result = null;

                        try {
                            result = method.apply(obj, callArgs);
                        } finally {
                            Bridge.caller.shift(this);
                        }

                        return result;
                    }, method.length);
                }

                if (obj && cache) {
                    obj.$$bind = obj.$$bind || [];
                    obj.$$bind.push(fn);
                }

                fn.$method = method;
                fn.$scope = obj;
                fn.equals = Bridge.fn.equals;

                return fn;
            },

            bindScope: function (obj, method) {
                var fn = Bridge.fn.makeFn(function () {
                    var callArgs = Array.prototype.slice.call(arguments, 0);

                    callArgs.unshift.apply(callArgs, [obj]);

                    Bridge.caller.unshift(this);

                    var result = null;

                    try {
                        result = method.apply(obj, callArgs);
                    } finally {
                        Bridge.caller.shift(this);
                    }

                    return result;
                }, method.length);

                fn.$method = method;
                fn.$scope = obj;
                fn.equals = Bridge.fn.equals;

                return fn;
            },

            $build: function (handlers) {
                if (!handlers || handlers.length === 0) {
                    return null;
                }

                var fn = function () {
                    var result = null,
                        i,
                        handler;

                    for (i = 0; i < handlers.length; i++) {
                        handler = handlers[i];
                        result = handler.apply(null, arguments);
                    }

                    return result;
                };

                fn.$invocationList = handlers ? Array.prototype.slice.call(handlers, 0) : [];
                handlers = fn.$invocationList.slice();

                return fn;
            },

            combine: function (fn1, fn2) {
                if (!fn1 || !fn2) {
                    var fn = fn1 || fn2;

                    return fn ? Bridge.fn.$build([fn]) : fn;
                }

                var list1 = fn1.$invocationList ? fn1.$invocationList : [fn1],
                    list2 = fn2.$invocationList ? fn2.$invocationList : [fn2];

                return Bridge.fn.$build(list1.concat(list2));
            },

            getInvocationList: function (fn) {
                if (fn == null) {
                    throw new System.ArgumentNullException();
                }

                if (!fn.$invocationList) {
                    fn.$invocationList = [fn];
                }

                return fn.$invocationList;
            },

            remove: function (fn1, fn2) {
                if (!fn1 || !fn2) {
                    return fn1 || null;
                }

                var list1 = fn1.$invocationList ? fn1.$invocationList : [fn1],
                    list2 = fn2.$invocationList ? fn2.$invocationList : [fn2],
                    result = [],
                    exclude,
                    i,
                    j;

                for (j = 0; j < list2.length; j++) {
                    exclude = -1;

                    for (i = list1.length - 1; i >= 0; i--) {
                        if (list1[i] === list2[j] ||
                            ((list1[i].$method && (list1[i].$method === list2[j].$method)) && (list1[i].$scope && (list1[i].$scope === list2[j].$scope)))) {
                            exclude = i;

                            break;
                        }
                    }

                    if (exclude > -1) {
                        list1.splice(exclude, 1);
                    }
                }

                return Bridge.fn.$build(list1);
            }
        },

        sleep: function (ms, timeout) {
            if (Bridge.hasValue(timeout)) {
                ms = timeout.getTotalMilliseconds();
            }

            if (isNaN(ms) || ms < -1 || ms > 2147483647) {
                throw new System.ArgumentOutOfRangeException.$ctor4("timeout", "Number must be either non-negative and less than or equal to Int32.MaxValue or -1");
            }

            if (ms == -1) {
                ms = 2147483647;
            }

            var start = new Date().getTime();

            while ((new Date().getTime() - start) < ms) {
                if ((new Date().getTime() - start) > 2147483647) {
                    break;
                }
            }
        },

        getMetadata: function (t) {
            var m = t.$getMetadata ? t.$getMetadata() : t.$metadata;

            return m;
        },

        loadModule: function (config, callback) {
            var amd = config.amd,
                cjs = config.cjs,
                fnName = config.fn;

            var tcs = new System.Threading.Tasks.TaskCompletionSource(),
                fn = Bridge.global[fnName || "require"];

            if (amd && amd.length > 0) {
                fn(amd, function () {
                    var loads = Array.prototype.slice.call(arguments, 0);

                    if (cjs && cjs.length > 0) {
                        for (var i = 0; i < cjs.length; i++) {
                            loads.push(fn(cjs[i]));
                        }
                    }

                    callback.apply(Bridge.global, loads);
                    tcs.setResult();
                });
            } else if (cjs && cjs.length > 0) {
                var t = new System.Threading.Tasks.Task();
                t.status = System.Threading.Tasks.TaskStatus.ranToCompletion;

                var loads = [];

                for (var j = 0; j < cjs.length; j++) {
                    loads.push(fn(cjs[j]));
                }

                callback.apply(Bridge.global, loads);

                return t;
            } else {
                var t = new System.Threading.Tasks.Task();
                t.status = System.Threading.Tasks.TaskStatus.ranToCompletion;

                return t;
            }

            return tcs.task;
        }
    };

    if (!globals.setImmediate) {
        core.setImmediate = (function () {
            var head = {},
                tail = head;

            var id = Math.random();

            function onmessage (e) {
                if (e.data != id) {
                    return;
                }

                head = head.next;
                var func = head.func;
                delete head.func;
                func();
            }

            if (typeof window !== "undefined") {
                if (window.addEventListener) {
                    window.addEventListener("message", onmessage);
                } else {
                    window.attachEvent("onmessage", onmessage);
                }
            }

            return function (func) {
                tail = tail.next = { func: func };

                if (typeof window !== "undefined") {
                    window.postMessage(id, "*");
                }
            };
        }());
    } else {
        core.setImmediate = globals.setImmediate.bind(globals);
    }

    globals.Bridge = core;
    globals.Bridge.caller = [];
    globals.Bridge.$equalsGuard = [];
    globals.Bridge.$toStringGuard = [];

    if (globals.console) {
        globals.Bridge.Console = globals.console;
    }

    globals.System = {};
    globals.System.Diagnostics = {};
    globals.System.Diagnostics.Contracts = {};
    globals.System.Threading = {};

    // @source Browser.js

    var check = function (regex) {
        return Bridge.global.navigator && regex.test(Bridge.global.navigator.userAgent.toLowerCase());
    },

    isStrict = Bridge.global.document && Bridge.global.document.compatMode === "CSS1Compat",

    version = function (is, regex) {
        var m;

        return Bridge.global.navigator && (is && (m = regex.exec(navigator.userAgent.toLowerCase()))) ? parseFloat(m[1]) : 0;
    },

    docMode = Bridge.global.document ? Bridge.global.document.documentMode : null,
    isOpera = check(/opera/),
    isOpera10_5 = isOpera && check(/version\/10\.5/),
    isChrome = check(/\bchrome\b/),
    isWebKit = check(/webkit/),
    isSafari = !isChrome && check(/safari/),
    isSafari2 = isSafari && check(/applewebkit\/4/),
    isSafari3 = isSafari && check(/version\/3/),
    isSafari4 = isSafari && check(/version\/4/),
    isSafari5_0 = isSafari && check(/version\/5\.0/),
    isSafari5 = isSafari && check(/version\/5/),
    isIE = !isOpera && (check(/msie/) || check(/trident/)),
    isIE7 = isIE && ((check(/msie 7/) && docMode !== 8 && docMode !== 9 && docMode !== 10) || docMode === 7),
    isIE8 = isIE && ((check(/msie 8/) && docMode !== 7 && docMode !== 9 && docMode !== 10) || docMode === 8),
    isIE9 = isIE && ((check(/msie 9/) && docMode !== 7 && docMode !== 8 && docMode !== 10) || docMode === 9),
    isIE10 = isIE && ((check(/msie 10/) && docMode !== 7 && docMode !== 8 && docMode !== 9) || docMode === 10),
    isIE11 = isIE && ((check(/trident\/7\.0/) && docMode !== 7 && docMode !== 8 && docMode !== 9 && docMode !== 10) || docMode === 11),
    isIE6 = isIE && check(/msie 6/),
    isGecko = !isWebKit && !isIE && check(/gecko/),
    isGecko3 = isGecko && check(/rv:1\.9/),
    isGecko4 = isGecko && check(/rv:2\.0/),
    isGecko5 = isGecko && check(/rv:5\./),
    isGecko10 = isGecko && check(/rv:10\./),
    isFF3_0 = isGecko3 && check(/rv:1\.9\.0/),
    isFF3_5 = isGecko3 && check(/rv:1\.9\.1/),
    isFF3_6 = isGecko3 && check(/rv:1\.9\.2/),
    isWindows = check(/windows|win32/),
    isMac = check(/macintosh|mac os x/),
    isLinux = check(/linux/),
    scrollbarSize = null,
    chromeVersion = version(true, /\bchrome\/(\d+\.\d+)/),
    firefoxVersion = version(true, /\bfirefox\/(\d+\.\d+)/),
    ieVersion = version(isIE, /msie (\d+\.\d+)/),
    operaVersion = version(isOpera, /version\/(\d+\.\d+)/),
    safariVersion = version(isSafari, /version\/(\d+\.\d+)/),
    webKitVersion = version(isWebKit, /webkit\/(\d+\.\d+)/),
    isSecure = Bridge.global.location ? /^https/i.test(Bridge.global.location.protocol) : false,
    isiPhone = Bridge.global.navigator && /iPhone/i.test(Bridge.global.navigator.platform),
    isiPod = Bridge.global.navigator && /iPod/i.test(Bridge.global.navigator.platform),
    isiPad = Bridge.global.navigator && /iPad/i.test(Bridge.global.navigator.userAgent),
    isBlackberry = Bridge.global.navigator && /Blackberry/i.test(Bridge.global.navigator.userAgent),
    isAndroid = Bridge.global.navigator && /Android/i.test(Bridge.global.navigator.userAgent),
    isDesktop = isMac || isWindows || (isLinux && !isAndroid),
    isTablet = isiPad,
    isPhone = !isDesktop && !isTablet;

    var browser = {
        isStrict: isStrict,
        isIEQuirks: isIE && (!isStrict && (isIE6 || isIE7 || isIE8 || isIE9)),
        isOpera: isOpera,
        isOpera10_5: isOpera10_5,
        isWebKit: isWebKit,
        isChrome: isChrome,
        isSafari: isSafari,
        isSafari3: isSafari3,
        isSafari4: isSafari4,
        isSafari5: isSafari5,
        isSafari5_0: isSafari5_0,
        isSafari2: isSafari2,
        isIE: isIE,
        isIE6: isIE6,
        isIE7: isIE7,
        isIE7m: isIE6 || isIE7,
        isIE7p: isIE && !isIE6,
        isIE8: isIE8,
        isIE8m: isIE6 || isIE7 || isIE8,
        isIE8p: isIE && !(isIE6 || isIE7),
        isIE9: isIE9,
        isIE9m: isIE6 || isIE7 || isIE8 || isIE9,
        isIE9p: isIE && !(isIE6 || isIE7 || isIE8),
        isIE10: isIE10,
        isIE10m: isIE6 || isIE7 || isIE8 || isIE9 || isIE10,
        isIE10p: isIE && !(isIE6 || isIE7 || isIE8 || isIE9),
        isIE11: isIE11,
        isIE11m: isIE6 || isIE7 || isIE8 || isIE9 || isIE10 || isIE11,
        isIE11p: isIE && !(isIE6 || isIE7 || isIE8 || isIE9 || isIE10),
        isGecko: isGecko,
        isGecko3: isGecko3,
        isGecko4: isGecko4,
        isGecko5: isGecko5,
        isGecko10: isGecko10,
        isFF3_0: isFF3_0,
        isFF3_5: isFF3_5,
        isFF3_6: isFF3_6,
        isFF4: 4 <= firefoxVersion && firefoxVersion < 5,
        isFF5: 5 <= firefoxVersion && firefoxVersion < 6,
        isFF10: 10 <= firefoxVersion && firefoxVersion < 11,
        isLinux: isLinux,
        isWindows: isWindows,
        isMac: isMac,
        chromeVersion: chromeVersion,
        firefoxVersion: firefoxVersion,
        ieVersion: ieVersion,
        operaVersion: operaVersion,
        safariVersion: safariVersion,
        webKitVersion: webKitVersion,
        isSecure: isSecure,
        isiPhone: isiPhone,
        isiPod: isiPod,
        isiPad: isiPad,
        isBlackberry: isBlackberry,
        isAndroid: isAndroid,
        isDesktop: isDesktop,
        isTablet: isTablet,
        isPhone: isPhone,
        iOS: isiPhone || isiPad || isiPod,
        standalone: Bridge.global.navigator ? !!Bridge.global.navigator.standalone : false
    };

    Bridge.Browser = browser;

    // @source Class.js

        var base = {
        _initialize: function () {
            if (this.$init) {
                return;
            }

            this.$init = {};

            if (this.$staticInit) {
                this.$staticInit();
            }

            if (this.$initMembers) {
                this.$initMembers();
            }
        },

        initConfig: function (extend, base, config, statics, scope, prototype) {
            var initFn,
                name,
                cls = (statics ? scope : scope.ctor),
                descriptors = cls.$descriptors,
                aliases = cls.$aliases;

            if (config.fields) {
                for (name in config.fields) {
                    scope[name] = config.fields[name];
                }
            }

            var props = config.properties;
            if (props) {
                for (name in props) {
                    var v = props[name],
                        d,
                        cfg;

                    if (v != null && Bridge.isPlainObject(v) && (!v.get || !v.set)) {
                        for (var k = 0; k < descriptors.length; k++) {
                            if (descriptors[k].name === name) {
                                d = descriptors[k];
                            }
                        }

                        if (d && d.get && !v.get) {
                            v.get = d.get;
                        }

                        if (d && d.set && !v.set) {
                            v.set = d.set;
                        }
                    }

                    cfg = Bridge.property(statics ? scope : prototype, name, v, statics, cls);
                    cfg.name = name;
                    cfg.cls = cls;

                    descriptors.push(cfg);
                }
            }

            if (config.events) {
                for (name in config.events) {
                    Bridge.event(scope, name, config.events[name], statics);
                }
            }

            if (config.alias) {
                for (var i = 0; i < config.alias.length; i++) {
                    (function (obj, name, alias, cls) {
                        var descriptor = null;

                        for (var i = descriptors.length - 1; i >= 0; i--) {
                            if (descriptors[i].name === name) {
                                descriptor = descriptors[i];

                                break;
                            }
                        }

                        var arr = Array.isArray(alias) ? alias : [alias];

                        for (var j = 0; j < arr.length; j++) {
                            alias = arr[j];

                            if (descriptor != null) {
                                Object.defineProperty(obj, alias, descriptor);
                                aliases.push({ alias: alias, descriptor: descriptor });
                            } else {
                                var m = scope[name];

                                if (m === undefined && prototype) {
                                    m = prototype[name];
                                }

                                if (!Bridge.isFunction(m)) {
                                    descriptor = {
                                        get: function () {
                                            return this[name];
                                        },

                                        set: function (value) {
                                            this[name] = value;
                                        }
                                    };
                                    Object.defineProperty(obj, alias, descriptor);
                                    aliases.push({ alias: alias, descriptor: descriptor });
                                } else {
                                    obj[alias] = m;
                                    aliases.push({ fn: name, alias: alias });
                                }
                            }
                        }
                    })(statics ? scope : prototype, config.alias[i], config.alias[i + 1], cls);

                    i++;
                }
            }

            if (config.init) {
                initFn = config.init;
            }

            if (initFn || (extend && !statics && base.$initMembers)) {
                scope.$initMembers = function () {
                    if (extend && !statics && base.$initMembers) {
                        base.$initMembers.call(this);
                    }

                    if (initFn) {
                        initFn.call(this);
                    }
                };
            }
        },

        convertScheme: function (obj) {
            var result = {},
                copy = function (obj, to) {

                var reserved = ["fields", "methods", "events", "props", "properties", "alias", "ctors"],
                    keys = Object.keys(obj);

                for (var i = 0; i < keys.length; i++) {
                    var name = keys[i];

                    if (reserved.indexOf(name) === -1) {
                        to[name] = obj[name];
                    }
                }

                if (obj.fields) {
                    Bridge.apply(to, obj.fields);
                }

                if (obj.methods) {
                    Bridge.apply(to, obj.methods);
                }

                var config = {},
                    write = false;

                if (obj.props) {
                    config.properties = obj.props;
                    write = true;
                } else if (obj.properties) {
                    config.properties = obj.properties;
                    write = true;
                }

                if (obj.events) {
                    config.events = obj.events;
                    write = true;
                }

                if (obj.alias) {
                    config.alias = obj.alias;
                    write = true;
                }

                if (obj.ctors) {
                    if (obj.ctors.init) {
                        config.init = obj.ctors.init;
                        write = true;
                        delete obj.ctors.init;
                    }

                    Bridge.apply(to, obj.ctors);
                }

                if (write) {
                    to.$config = config;
                }
            };

            if (obj.main) {
                result.$main = obj.main;
                delete obj.main;
            }

            copy(obj, result);

            if (obj.statics || obj.$statics) {
                result.$statics = {};
                copy(obj.statics || obj.$statics, result.$statics);
            }

            return result;
        },

        definei: function (className, gscope, prop) {
            if ((prop === true || !prop) && gscope) {
                gscope.$kind = "interface";
            } else if (prop) {
                prop.$kind = "interface";
            } else {
                gscope = { $kind: "interface" };
            }

            var c = Bridge.define(className, gscope, prop);

            c.$kind = "interface";
            c.$isInterface = true;

            return c;
        },

        // Create a new Class that inherits from this class
        define: function (className, gscope, prop, gCfg) {
            var isGenericInstance = false;

            if (prop === true) {
                isGenericInstance = true;
                prop = gscope;
                gscope = Bridge.global;
            } else if (!prop) {
                prop = gscope;
                gscope = Bridge.global;
            }

            var fn;

            if (Bridge.isFunction(prop)) {
                fn = function () {
                    var args,
                        key,
                        obj,
                        c;

                    key = Bridge.Class.getCachedType(fn, arguments);

                    if (key) {
                        return key.type;
                    }

                    args = Array.prototype.slice.call(arguments);
                    obj = prop.apply(null, args);
                    c = Bridge.define(Bridge.Class.genericName(className, args), obj, true, { fn: fn, args: args });

                    if (!Bridge.Class.staticInitAllow && !Bridge.Class.queueIsBlocked) {
                        Bridge.Class.$queue.push(c);
                    }

                    return Bridge.get(c);
                };

                fn.$cache = [];

                return Bridge.Class.generic(className, gscope, fn, prop);
            }

            if (!isGenericInstance) {
                Bridge.Class.staticInitAllow = false;
            }

            prop = prop || {};
            prop.$kind = prop.$kind || "class";

            var isNested = false;

            if (prop.$kind.match("^nested ") !== null) {
                isNested = true;
                prop.$kind = prop.$kind.substr(7);
            }

            if (prop.$kind === "enum" && !prop.inherits) {
                prop.inherits = [System.IComparable, System.IFormattable];
            }

            var rNames = ["fields", "events", "props", "ctors", "methods"],
                defaultScheme = Bridge.isFunction(prop.main) ? 0 : 1,
                check = function (scope) {
                    if (scope.config && Bridge.isPlainObject(scope.config) ||
                        scope.$main && Bridge.isFunction(scope.$main) ||
                        scope.hasOwnProperty("ctor") && Bridge.isFunction(scope.ctor)) {
                        defaultScheme = 1;

                        return false;
                    }

                    if (scope.alias && Bridge.isArray(scope.alias) && scope.alias.length > 0 && scope.alias.length % 2 === 0) {
                        return true;
                    }

                    for (var j = 0; j < rNames.length; j++) {
                        if (scope[rNames[j]] && Bridge.isPlainObject(scope[rNames[j]])) {
                            return true;
                        }
                    }

                    return false;
                },
                alternateScheme = check(prop);

            if (!alternateScheme && prop.statics) {
                alternateScheme = check(prop.statics);
            }

            if (!alternateScheme) {
                alternateScheme = defaultScheme == 0;
            }

            if (alternateScheme) {
                prop = Bridge.Class.convertScheme(prop);
            }

            var extend = prop.$inherits || prop.inherits,
                statics = prop.$statics || prop.statics,
                isEntryPoint = prop.$entryPoint,
                base,
                prototype,
                scope = prop.$scope || gscope || Bridge.global,
                objectType = Bridge.global.System && Bridge.global.System.Object || Object,
                i,
                v,
                isCtor,
                ctorName,
                name,
                registerT = true;

            if (prop.$kind === "enum") {
                extend = [System.Enum];
            }

            if (prop.$noRegister === true) {
                registerT = false;
                delete prop.$noRegister;
            }

            if (prop.$inherits) {
                delete prop.$inherits;
            } else {
                delete prop.inherits;
            }

            if (isEntryPoint) {
                delete prop.$entryPoint;
            }

            if (Bridge.isFunction(statics)) {
                statics = null;
            } else if (prop.$statics) {
                delete prop.$statics;
            } else {
                delete prop.statics;
            }

            var Class,
                cls = prop.hasOwnProperty("ctor") && prop.ctor;

            if (!cls) {
                if (prop.$literal) {
                    Class = function (obj) {
                        obj = obj || {};
                        obj.$getType = function () { return Class };

                        return obj;
                    };
                } else {
                    Class = function () {
                        this.$initialize();

                        if (Class.$base) {
                            if (Class.$$inherits && Class.$$inherits.length > 0 && Class.$$inherits[0].$staticInit) {
                                Class.$$inherits[0].$staticInit();
                            }

                            if (Class.$base.ctor) {
                                Class.$base.ctor.call(this);
                            } else if (Bridge.isFunction(Class.$base.constructor)) {
                                Class.$base.constructor.call(this);
                            }
                        }
                    };
                }

                prop.ctor = Class;
            } else {
                Class = cls;
            }

            if (prop.$literal) {
                if ((!statics || !statics.createInstance)) {
                    Class.createInstance = function () {
                        var obj = {};

                        obj.$getType = function () { return Class };

                        return obj;
                    };
                }

                Class.$literal = true;
                delete prop.$literal;
            }

            if (!isGenericInstance && registerT) {
                scope = Bridge.Class.set(scope, className, Class);
            }

            if (gCfg) {
                gCfg.fn.$cache.push({ type: Class, args: gCfg.args });
            }

            Class.$$name = className;

            if (isNested) {
                var lastIndex = Class.$$name.lastIndexOf(".");

                Class.$$name = Class.$$name.substr(0, lastIndex) + "+" + Class.$$name.substr(lastIndex + 1)
            }

            Class.$kind = prop.$kind;

            if (prop.$metadata) {
                Class.$metadata = prop.$metadata;
            }

            if (gCfg && isGenericInstance) {
                Class.$genericTypeDefinition = gCfg.fn;
                Class.$typeArguments = gCfg.args;
                Class.$assembly = gCfg.fn.$assembly || Bridge.$currentAssembly;

                var result = Bridge.Reflection.getTypeFullName(gCfg.fn);

                for (i = 0; i < gCfg.args.length; i++) {
                    result += (i === 0 ? "[" : ",") + "[" + Bridge.Reflection.getTypeQName(gCfg.args[i]) + "]";
                }

                result += "]";

                Class.$$fullname = result;
            } else {
                Class.$$fullname = Class.$$name;
            }

            if (extend && Bridge.isFunction(extend)) {
                extend = extend();
            }

            Bridge.Class.createInheritors(Class, extend);

            var noBase = extend ? extend[0].$kind === "interface" : true;

            if (noBase) {
                extend = null;
            }

            base = extend ? extend[0].prototype : this.prototype;
            Class.$base = base;

            if (extend && !extend[0].$$initCtor) {
                var cls = extend[0];
                var $$initCtor = function () { };
                $$initCtor.prototype = cls.prototype;
                $$initCtor.prototype.constructor = cls;
                $$initCtor.prototype.$$fullname = Bridge.Reflection.getTypeFullName(cls);

                prototype = new $$initCtor();
            }
            else {
                prototype = extend ? new extend[0].$$initCtor() : (objectType.$$initCtor ? new objectType.$$initCtor() : new objectType());
            }

            Class.$$initCtor = function () { };
            Class.$$initCtor.prototype = prototype;
            Class.$$initCtor.prototype.constructor = Class;
            Class.$$initCtor.prototype.$$fullname = gCfg && isGenericInstance ? Class.$$fullname : Class.$$name;

            if (statics) {
                var staticsConfig = statics.$config || statics.config;

                if (staticsConfig && !Bridge.isFunction(staticsConfig)) {
                    Bridge.Class.initConfig(extend, base, staticsConfig, true, Class);

                    if (statics.$config) {
                        delete statics.$config;
                    } else {
                        delete statics.config;
                    }
                }
            }

            var instanceConfig = prop.$config || prop.config;

            if (instanceConfig && !Bridge.isFunction(instanceConfig)) {
                Bridge.Class.initConfig(extend, base, instanceConfig, false, prop, prototype);

                if (prop.$config) {
                    delete prop.$config;
                } else {
                    delete prop.config;
                }
            } else if (extend && base.$initMembers) {
                prop.$initMembers = function () {
                    base.$initMembers.call(this);
                };
            }

            prop.$initialize = Bridge.Class._initialize;

            var keys = [];

            for (name in prop) {
                keys.push(name);
            }

            for (i = 0; i < keys.length; i++) {
                name = keys[i];

                v = prop[name];
                isCtor = name === "ctor";
                ctorName = name;

                if (Bridge.isFunction(v) && (isCtor || name.match("^\\$ctor") !== null)) {
                    isCtor = true;
                }

                var member = prop[name];

                if (isCtor) {
                    Class[ctorName] = member;
                    Class[ctorName].prototype = prototype;
                    Class[ctorName].prototype.constructor = Class;
                    prototype[ctorName] = member;
                } else {
                    prototype[ctorName] = member;
                }
            }

            prototype.$$name = className;

            if (!prototype.toJSON) {
                prototype.toJSON = Bridge.Class.toJSON;
            }

            if (statics) {
                for (name in statics) {
                    var member = statics[name];

                    if (name === "ctor") {
                        Class["$ctor"] = member;
                    } else {
                        if (prop.$kind === "enum" && !Bridge.isFunction(member) && name.charAt(0) !== "$") {
                            Class.$names = Class.$names || [];
                            Class.$names.push({name: name, value: member});
                        }

                        Class[name] = member;
                    }
                }

                if (prop.$kind === "enum" && Class.$names) {
                    Class.$names = Class.$names.sort(function (i1, i2) {
                        if (Bridge.isFunction(i1.value.eq)) {
                            return i1.value.sub(i2.value).sign();
                        }

                        return i1.value - i2.value;
                    }).map(function (i) {
                        return i.name;
                    });
                }
            }

            if (!extend) {
                extend = [objectType].concat(Class.$interfaces);
            }

            Bridge.Class.setInheritors(Class, extend);

            fn = function () {
                if (Bridge.Class.staticInitAllow && !Class.$isGenericTypeDefinition) {
                    Class.$staticInit = null;

                    if (Class.$initMembers) {
                        Class.$initMembers();
                    }

                    if (Class.$ctor) {
                        Class.$ctor();
                    }
                }
            };

            if (isEntryPoint || Bridge.isFunction(prototype.$main)) {
                if (prototype.$main) {
                    var entryName = prototype.$main.name || "Main";

                    if (!Class[entryName]) {
                        Class[entryName] = prototype.$main;
                    }
                }

                Bridge.Class.$queueEntry.push(Class);
            }

            Class.$staticInit = fn;

            if (!isGenericInstance && registerT) {
                Bridge.Class.registerType(className, Class);
            }

            if (Bridge.Reflection) {
                Class.$getMetadata = Bridge.Reflection.getMetadata;
            }

            if (Class.$kind === "enum") {
                if (!Class.prototype.$utype) {
                    Class.prototype.$utype = System.Int32;
                }
                Class.$is = function (instance) {
                    var utype = Class.prototype.$utype;

                    if (utype === String) {
                        return typeof (instance) == "string";
                    }

                    if (utype && utype.$is) {
                        return utype.$is(instance);
                    }

                    return typeof (instance) == "number";
                };

                Class.getDefaultValue = function () {
                    var utype = Class.prototype.$utype;

                    if (utype === String || utype === System.String) {
                        return null;
                    }

                    return 0;
                };
            }

            if (Class.$kind === "interface") {
                if (Class.prototype.$variance) {
                    Class.isAssignableFrom = Bridge.Class.varianceAssignable;
                }

                Class.$isInterface = true;
            }

            return Class;
        },

        toCtorString: function () {
            return Bridge.Reflection.getTypeName(this);
        },

        createInheritors: function (cls, extend) {
            var interfaces = [],
                baseInterfaces = [],
                descriptors = [],
                aliases = [];

            if (extend) {
                for (var j = 0; j < extend.length; j++) {
                    var baseType = extend[j],
                        baseI = (baseType.$interfaces || []).concat(baseType.$baseInterfaces || []),
                        baseDescriptors = baseType.$descriptors,
                        baseAliases = baseType.$aliases;

                    if (baseDescriptors && baseDescriptors.length > 0) {
                        for (var d = 0; d < baseDescriptors.length; d++) {
                            descriptors.push(baseDescriptors[d]);
                        }
                    }

                    if (baseAliases && baseAliases.length > 0) {
                        for (var d = 0; d < baseAliases.length; d++) {
                            aliases.push(baseAliases[d]);
                        }
                    }

                    if (baseI.length > 0) {
                        for (var k = 0; k < baseI.length; k++) {
                            if (baseInterfaces.indexOf(baseI[k]) < 0) {
                                baseInterfaces.push(baseI[k]);
                            }
                        }
                    }

                    if (baseType.$kind === "interface") {
                        interfaces.push(baseType);
                    }
                }
            }

            cls.$descriptors = descriptors;
            cls.$aliases = aliases;
            cls.$baseInterfaces = baseInterfaces;
            cls.$interfaces = interfaces;
            cls.$allInterfaces = interfaces.concat(baseInterfaces);
        },

        toJSON: function () {
            var obj = {},
                t = Bridge.getType(this),
                descriptors = t.$descriptors || [];

            for (var key in this) {
                var own = this.hasOwnProperty(key),
                    descriptor = null;

                if (!own) {
                    for (var i = descriptors.length - 1; i >= 0; i--) {
                        if (descriptors[i].name === key) {
                            descriptor = descriptors[i];

                            break;
                        }
                    }
                }

                var dcount = key.split("$").length;

                if ((own || descriptor != null) && (dcount === 1 || dcount === 2 && key.match("\$\d+$"))) {
                    obj[key] = this[key];
                }
            }

            return obj;
        },

        setInheritors: function (cls, extend) {
            cls.$$inherits = extend;

            for (var i = 0; i < extend.length; i++) {
                var scope = extend[i];

                if (!scope.$$inheritors) {
                    scope.$$inheritors = [];
                }

                scope.$$inheritors.push(cls);
            }
        },

        varianceAssignable: function (source) {
            var check = function (target, type) {
                if (type.$genericTypeDefinition === target.$genericTypeDefinition && type.$typeArguments.length === target.$typeArguments.length) {
                    for (var i = 0; i < target.$typeArguments.length; i++) {
                        var v = target.prototype.$variance[i], t = target.$typeArguments[i], s = type.$typeArguments[i];

                        switch (v) {
                            case 1: if (!Bridge.Reflection.isAssignableFrom(t, s))
                                return false;

                                break;
                            case 2: if (!Bridge.Reflection.isAssignableFrom(s, t))
                                return false;

                                break;
                            default: if (s !== t)
                                return false;
                        }
                    }

                    return true;
                }

                return false;
            };

            if (source.$kind === "interface" && check(this, source)) {
                return true;
            }

            var ifs = Bridge.Reflection.getInterfaces(source);

            for (var i = 0; i < ifs.length; i++) {
                if (ifs[i] === this || check(this, ifs[i])) {
                    return true;
                }
            }

            return false;
        },

        registerType: function (className, cls) {
            if (Bridge.$currentAssembly) {
                Bridge.$currentAssembly.$types[className] = cls;
                cls.$assembly = Bridge.$currentAssembly;
            }
        },

        addExtend: function (cls, extend) {
            var i,
                scope;

            Array.prototype.push.apply(cls.$$inherits, extend);
            cls.$interfaces = cls.$interfaces || [];
            cls.$baseInterfaces = cls.$baseInterfaces || [];

            for (i = 0; i < extend.length; i++) {
                scope = extend[i];

                if (!scope.$$inheritors) {
                    scope.$$inheritors = [];
                }

                scope.$$inheritors.push(cls);

                var baseI = (scope.$interfaces || []).concat(scope.$baseInterfaces || []);

                if (baseI.length > 0) {
                    for (var k = 0; k < baseI.length; k++) {
                        if (cls.$baseInterfaces.indexOf(baseI[k]) < 0) {
                            cls.$baseInterfaces.push(baseI[k]);
                        }
                    }
                }

                if (scope.$kind === "interface") {
                    cls.$interfaces.push(scope);
                }
            }

            cls.$allInterfaces = cls.$interfaces.concat(cls.$baseInterfaces);
        },

        set: function (scope, className, cls, noDefineProp) {
            var nameParts = className.split("."),
                name,
                key,
                exists,
                i;

            for (i = 0; i < (nameParts.length - 1) ; i++) {
                if (typeof scope[nameParts[i]] == "undefined") {
                    scope[nameParts[i]] = {};
                }

                scope = scope[nameParts[i]];
            }

            name = nameParts[nameParts.length - 1];
            exists = scope[name];

            if (exists) {
                if (exists.$$name === className) {
                    throw "Class '" + className + "' is already defined";
                }

                for (key in exists) {
                    var o = exists[key];

                    if (typeof o === "function" && o.$$name) {
                        (function (cls, key, o) {
                            Object.defineProperty(cls, key, {
                                get: function () {
                                    if (Bridge.Class.staticInitAllow) {
                                        if (o.$staticInit) {
                                            o.$staticInit();
                                        }

                                        Bridge.Class.defineProperty(cls, key, o);
                                    }

                                    return o;
                                },

                                set: function (newValue) {
                                    o = newValue;
                                },

                                enumerable: true,

                                configurable: true
                            });
                        })(cls, key, o);
                    }
                }
            }

            if (noDefineProp !== true) {
                (function (scope, name, cls) {
                    Object.defineProperty(scope, name, {
                        get: function () {
                            if (Bridge.Class.staticInitAllow) {
                                if (cls.$staticInit) {
                                    cls.$staticInit();
                                }

                                Bridge.Class.defineProperty(scope, name, cls);
                            }

                            return cls;
                        },

                        set: function (newValue) {
                            cls = newValue;
                        },

                        enumerable: true,

                        configurable: true
                    });
                })(scope, name, cls);
            } else {
                scope[name] = cls;
            }

            return scope;
        },

        defineProperty: function (scope, name, cls) {
            Object.defineProperty(scope, name, {
                value: cls,
                enumerable: true,
                configurable: true
            });
        },

        genericName: function (name, typeArguments) {
            var gName = name;

            for (var i = 0; i < typeArguments.length; i++) {
                var ta = typeArguments[i];

                gName += "$" + (ta.$$name || Bridge.getTypeName(ta));
            }

            return gName;
        },

        getCachedType: function (fn, args) {
            var arr = fn.$cache,
                len = arr.length,
                key,
                found,
                i, g;

            for (i = 0; i < len; i++) {
                key = arr[i];

                if (key.args.length === args.length) {
                    found = true;

                    for (g = 0; g < key.args.length; g++) {
                        if (key.args[g] !== args[g]) {
                            found = false;

                            break;
                        }
                    }

                    if (found) {
                        return key;
                    }
                }
            }

            return null;
        },

        generic: function (className, scope, fn, prop) {
            fn.$$name = className;
            fn.$kind = "class";

            Bridge.Class.set(scope, className, fn, true);
            Bridge.Class.registerType(className, fn);

            fn.$typeArgumentCount = prop.length;
            fn.$isGenericTypeDefinition = true;
            fn.$getMetadata = Bridge.Reflection.getMetadata;

            fn.$staticInit = function () {
                fn.$typeArguments = Bridge.Reflection.createTypeParams(prop);

                var old = Bridge.Class.staticInitAllow,
                    oldIsBlocked = Bridge.Class.queueIsBlocked;

                Bridge.Class.staticInitAllow = false;
                Bridge.Class.queueIsBlocked = true;

                var cfg = prop.apply(null, fn.$typeArguments),
                    extend = cfg.$inherits || cfg.inherits;

                Bridge.Class.staticInitAllow = old;
                Bridge.Class.queueIsBlocked = oldIsBlocked;

                if (extend && Bridge.isFunction(extend)) {
                    extend = extend();
                }

                Bridge.Class.createInheritors(fn, extend);

                var objectType = Bridge.global.System && Bridge.global.System.Object || Object;

                if (!extend) {
                    extend = [objectType].concat(fn.$interfaces);
                }

                Bridge.Class.setInheritors(fn, extend);

                var prototype = extend ? (extend[0].$$initCtor ? new extend[0].$$initCtor() : new extend[0]()) : new objectType();

                fn.prototype = prototype;
                fn.prototype.constructor = fn;
                fn.$kind = cfg.$kind || "class";
            };

            Bridge.Class.$queue.push(fn);

            return fn;
        },

        init: function (fn) {
            if (Bridge.Reflection) {
                var metas = Bridge.Reflection.deferredMeta,
                    len = metas.length;

                if (len > 0) {
                    Bridge.Reflection.deferredMeta = [];

                    for (var i = 0; i < len; i++) {
                        var item = metas[i];

                        Bridge.setMetadata(item.typeName, item.metadata, item.ns);
                    }
                }
            }

            if (fn) {
                var old = Bridge.Class.staticInitAllow;

                Bridge.Class.staticInitAllow = true;
                fn();
                Bridge.Class.staticInitAllow = old;

                return;
            }

            Bridge.Class.staticInitAllow = true;

            var queue = Bridge.Class.$queue.concat(Bridge.Class.$queueEntry);

            Bridge.Class.$queue.length = 0;
            Bridge.Class.$queueEntry.length = 0;

            for (var i = 0; i < queue.length; i++) {
                var t = queue[i];

                if (t.$staticInit) {
                    t.$staticInit();
                }

                if (t.prototype.$main) {
                    (function (cls, name) {
                        Bridge.ready(function () {
                            var task = cls[name]();

                            if (task && task.continueWith) {
                                task.continueWith(function () {
                                    setTimeout(function () {
                                        task.getAwaitedResult();
                                    }, 0);
                                });
                            }
                        });
                    })(t, t.prototype.$main.name || "Main");

                    t.prototype.$main = null;
                }
            }
        }
    };

    Bridge.Class = base;
    Bridge.Class.$queue = [];
    Bridge.Class.$queueEntry = [];
    Bridge.define = Bridge.Class.define;
    Bridge.definei = Bridge.Class.definei;
    Bridge.init = Bridge.Class.init;

    // @source ReflectionAssembly.js

    Bridge.assembly = function (assemblyName, res, callback, restore) {
        if (!callback) {
            callback = res;
            res = {};
        }

        assemblyName = assemblyName || "Bridge.$Unknown";

        var asm = System.Reflection.Assembly.assemblies[assemblyName];

        if (!asm) {
            asm = new System.Reflection.Assembly(assemblyName, res);
        } else {
            Bridge.apply(asm.res, res || {});
        }

        var oldAssembly = Bridge.$currentAssembly;

        Bridge.$currentAssembly = asm;

        if (callback) {
            var old = Bridge.Class.staticInitAllow;
            Bridge.Class.staticInitAllow = false;

            callback.call(Bridge.global, asm, Bridge.global);

            Bridge.Class.staticInitAllow = old;
        }

        Bridge.init();

        if (restore) {
            Bridge.$currentAssembly = oldAssembly;
        }
    };

    Bridge.define("System.Reflection.Assembly", {
        statics: {
            assemblies: {}
        },

        ctor: function (name, res) {
            this.$initialize();
            this.name = name;
            this.res = res || {};
            this.$types = {};
            this.$ = {};

            System.Reflection.Assembly.assemblies[name] = this;
        },

        toString: function () {
            return this.name;
        },

        getManifestResourceNames: function () {
            return Object.keys(this.res);
        },

        getManifestResourceDataAsBase64: function (type, name) {
            if (arguments.length === 1) {
                name = type;
                type = null;
            }

            if (type) {
                name = Bridge.Reflection.getTypeNamespace(type) + "." + name;
            }

            return this.res[name] || null;
        },

        getManifestResourceData: function (type, name) {
            if (arguments.length === 1) {
                name = type;
                type = null;
            }

            if (type) {
                name = Bridge.Reflection.getTypeNamespace(type) + '.' + name;
            }

            var r = this.res[name];

            return r ? System.Convert.fromBase64String(r) : null;
        },

        getCustomAttributes: function (attributeType) {
            if (this.attr && attributeType && !Bridge.isBoolean(attributeType)) {
                return this.attr.filter(function (a) {
                    return Bridge.is(a, attributeType);
                });
            }

            return this.attr || [];
        }
    });

    Bridge.$currentAssembly = new System.Reflection.Assembly("mscorlib");
    Bridge.SystemAssembly = Bridge.$currentAssembly;
    Bridge.SystemAssembly.$types["System.Reflection.Assembly"] = System.Reflection.Assembly;
    System.Reflection.Assembly.$assembly = Bridge.SystemAssembly;

    var $asm = Bridge.$currentAssembly;

    // @source Object.js

    Bridge.define("System.Object", { });

    // @source Void.js

    Bridge.define("System.Void", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new System.Void(); }
            }
        },
        methods: {
            $clone: function (to) { return this; }
        }
    });

    // @source SystemAssemblyVersion.js

    Bridge.init(function () {
        Bridge.SystemAssembly.version = "17.6.0";
        Bridge.SystemAssembly.compiler = "17.6.0";
    });

    Bridge.define("Bridge.Utils.SystemAssemblyVersion");

    // @source Reflection.js

    Bridge.Reflection = {
        deferredMeta: [],

        setMetadata: function (type, metadata, ns) {
            if (Bridge.isString(type)) {
                var typeName = type;
                type = Bridge.unroll(typeName);

                if (type == null) {
                    Bridge.Reflection.deferredMeta.push({ typeName: typeName, metadata: metadata, ns: ns });
                    return;
                }
            }

            ns = Bridge.unroll(ns);
            type.$getMetadata = Bridge.Reflection.getMetadata;
            type.$metadata = metadata;
        },

        initMetaData: function (type, metadata) {
            if (metadata.m) {
                for (var i = 0; i < metadata.m.length; i++) {
                    var m = metadata.m[i];

                    m.td = type;

                    if (m.ad) {
                        m.ad.td = type;
                    }

                    if (m.r) {
                        m.r.td = type;
                    }

                    if (m.g) {
                        m.g.td = type;
                    }

                    if (m.s) {
                        m.s.td = type;
                    }

                    if (m.tprm && Bridge.isArray(m.tprm)) {
                        for (var j = 0; j < m.tprm.length; j++) {
                            m.tprm[j] = Bridge.Reflection.createTypeParam(m.tprm[j], type);
                        }
                    }
                }
            }

            type.$metadata = metadata;
            type.$initMetaData = true;
        },

        getMetadata: function () {
            if (!this.$metadata && this.$genericTypeDefinition) {
                this.$metadata = this.$genericTypeDefinition.$factoryMetadata || this.$genericTypeDefinition.$metadata;
            }

            var metadata = this.$metadata;

            if (typeof (metadata) === "function") {
                if (this.$isGenericTypeDefinition && !this.$factoryMetadata) {
                    this.$factoryMetadata = this.$metadata;
                }

                if (this.$typeArguments) {
                    metadata = this.$metadata.apply(null, this.$typeArguments);
                } else if (this.$isGenericTypeDefinition) {
                    var arr = Bridge.Reflection.createTypeParams(this.$metadata);
                    this.$typeArguments = arr;
                    metadata = this.$metadata.apply(null, arr);
                } else {
                    metadata = this.$metadata();
                }
            }

            if (!this.$initMetaData && metadata) {
                Bridge.Reflection.initMetaData(this, metadata);
            }

            return metadata;
        },

        createTypeParams: function (fn, t) {
            var args,
                names = [],
                fnStr = fn.toString();

            args = fnStr.slice(fnStr.indexOf("(") + 1, fnStr.indexOf(")")).match(/([^\s,]+)/g) || [];

            for (var i = 0; i < args.length; i++) {
                names.push(Bridge.Reflection.createTypeParam(args[i], t));
            }

            return names;
        },

        createTypeParam: function (name, t) {
            var fn = function TypeParameter() { };

            fn.$$name = name;
            fn.$isTypeParameter = true;

            if (t) {
                fn.td = t;
            }

            return fn;
        },

        load: function (name) {
            return System.Reflection.Assembly.assemblies[name] || require(name);
        },

        getGenericTypeDefinition: function (type) {
            if (type.$isGenericTypeDefinition) {
                return type;
            }

            if (!type.$genericTypeDefinition) {
                throw new System.InvalidOperationException.$ctor1("This operation is only valid on generic types.");
            }

            return type.$genericTypeDefinition;
        },

        getGenericParameterCount: function (type) {
            return type.$typeArgumentCount || 0;
        },

        getGenericArguments: function (type) {
            return type.$typeArguments || [];
        },

        getMethodGenericArguments: function (m) {
            return m.tprm || [];
        },

        isGenericTypeDefinition: function (type) {
            return type.$isGenericTypeDefinition || false;
        },

        isGenericType: function (type) {
            return type.$genericTypeDefinition != null || Bridge.Reflection.isGenericTypeDefinition(type);
        },

        convertType: function (type) {
            if (type === Boolean) {
                return System.Boolean;
            }

            if (type === String) {
                return System.String;
            }

            if (type === Object) {
                return System.Object;
            }

            if (type === Date) {
                return System.DateTime;
            }

            return type;
        },

        getBaseType: function (type) {
            if (Bridge.isObject(type) || Bridge.Reflection.isInterface(type) || type.prototype == null) {
                return null;
            } else if (Object.getPrototypeOf) {
                return Bridge.Reflection.convertType(Object.getPrototypeOf(type.prototype).constructor);
            } else {
                var p = type.prototype;

                if (Object.prototype.hasOwnProperty.call(p, "constructor")) {
                    var ownValue;

                    try {
                        ownValue = p.constructor;
                        delete p.constructor;
                        return Bridge.Reflection.convertType(p.constructor);
                    } finally {
                        p.constructor = ownValue;
                    }
                }

                return Bridge.Reflection.convertType(p.constructor);
            }
        },

        getTypeFullName: function (obj) {
            var str;

            if (obj.$$fullname) {
                str = obj.$$fullname;
            } else if (obj.$$name) {
                str = obj.$$name;
            }

            if (str) {
                var ns = Bridge.Reflection.getTypeNamespace(obj, str);

                if (ns) {
                    var idx = str.indexOf("[");
                    var name = str.substring(ns.length + 1, idx === -1 ? str.length : idx);

                    if (new RegExp(/[\.\$]/).test(name)) {
                        str = ns + "." + name.replace(/\.|\$/g, function (match) { return (match === ".") ? "+" : "`"; }) + (idx === -1 ? "" : str.substring(idx));
                    }
                }

                return str;
            }

            if (obj.constructor === Object) {
                str = obj.toString();

                var match = (/\[object (.{1,})\]/).exec(str);
                var name = (match && match.length > 1) ? match[1] : "Object";

                return name == "Object" ? "System.Object" : name;
            } else if (obj.constructor === Function) {
                str = obj.toString();
            } else {
                str = obj.constructor.toString();
            }

            var results = (/function (.{1,})\(/).exec(str);

            return (results && results.length > 1) ? results[1] : "System.Object";
        },

        _makeQName: function (name, asm) {
            return name + (asm ? ", " + asm.name : "");
        },

        getTypeQName: function (type) {
            return Bridge.Reflection._makeQName(Bridge.Reflection.getTypeFullName(type), type.$assembly);
        },

        getTypeName: function (type) {
            var fullName = Bridge.Reflection.getTypeFullName(type),
                bIndex = fullName.indexOf("["),
                pIndex = fullName.lastIndexOf("+", bIndex >= 0 ? bIndex : fullName.length),
                nsIndex = pIndex > -1 ? pIndex : fullName.lastIndexOf(".", bIndex >= 0 ? bIndex : fullName.length);

            var name = nsIndex > 0 ? (bIndex >= 0 ? fullName.substring(nsIndex + 1, bIndex) : fullName.substr(nsIndex + 1)) : fullName;

            return type.$isArray ? name + "[]" : name;
        },

        getTypeNamespace: function (type, name) {
            var fullName = name || Bridge.Reflection.getTypeFullName(type),
                bIndex = fullName.indexOf("["),
                nsIndex = fullName.lastIndexOf(".", bIndex >= 0 ? bIndex : fullName.length),
                ns = nsIndex > 0 ? fullName.substr(0, nsIndex) : "";

            if (type.$assembly) {
                var parentType = Bridge.Reflection._getAssemblyType(type.$assembly, ns);

                if (parentType) {
                    ns = Bridge.Reflection.getTypeNamespace(parentType);
                }
            }

            return ns;
        },

        getTypeAssembly: function (type) {
            if (type.$isArray) {
                return type.$elementType.$assembly;
            }

            if (System.Array.contains([Date, Number, Boolean, String, Function, Array], type)) {
                return Bridge.SystemAssembly;
            }

            return type.$assembly || Bridge.SystemAssembly;
        },

        _extractArrayRank: function (name) {
            var rank = -1,
                m = (/<(\d+)>$/g).exec(name);

            if (m) {
                name = name.substring(0, m.index);
                rank = parseInt(m[1]);
            }

            m = (/\[(,*)\]$/g).exec(name);

            if (m) {
                name = name.substring(0, m.index);
                rank = m[1].length + 1;
            }

            return {
                rank: rank,
                name: name
            };
        },

        _getAssemblyType: function (asm, name) {
            var noAsm = false,
                rank = -1;

            if (new RegExp(/[\+\`]/).test(name)) {
                name = name.replace(/\+|\`/g, function (match) { return match === "+" ? "." : "$"});
            }

            if (!asm) {
                asm = Bridge.SystemAssembly;
                noAsm = true;
            }

            var rankInfo = Bridge.Reflection._extractArrayRank(name);
            rank = rankInfo.rank;
            name = rankInfo.name;

            if (asm.$types) {
                var t = asm.$types[name] || null;

                if (t) {
                    return rank > -1 ? System.Array.type(t, rank) : t;
                }

                if (asm.name === "mscorlib") {
                    asm = Bridge.global;
                } else {
                    return null;
                }
            }

            var a = name.split("."),
                scope = asm;

            for (var i = 0; i < a.length; i++) {
                scope = scope[a[i]];

                if (!scope) {
                    return null;
                }
            }

            if (typeof scope !== "function" || !noAsm && scope.$assembly && asm.name !== scope.$assembly.name) {
                return null;
            }

            return rank > -1 ? System.Array.type(scope, rank) : scope;
        },

        getAssemblyTypes: function (asm) {
            var result = [];

            if (asm.$types) {
                for (var t in asm.$types) {
                    if (asm.$types.hasOwnProperty(t)) {
                        result.push(asm.$types[t]);
                    }
                }
            } else {
                var traverse = function (s, n) {
                    for (var c in s) {
                        if (s.hasOwnProperty(c)) {
                            traverse(s[c], c);
                        }
                    }

                    if (typeof (s) === "function" && Bridge.isUpper(n.charCodeAt(0))) {
                        result.push(s);
                    }
                };

                traverse(asm, "");
            }

            return result;
        },

        createAssemblyInstance: function (asm, typeName) {
            var t = Bridge.Reflection.getType(typeName, asm);

            return t ? Bridge.createInstance(t) : null;
        },

        getInterfaces: function (type) {
            var t;

            if (type.$allInterfaces) {
                return type.$allInterfaces;
            } else if (type === Date) {
                return [System.IComparable$1(Date), System.IEquatable$1(Date), System.IComparable, System.IFormattable];
            } else if (type === Number) {
                return [System.IComparable$1(Bridge.Int), System.IEquatable$1(Bridge.Int), System.IComparable, System.IFormattable];
            } else if (type === Boolean) {
                return [System.IComparable$1(Boolean), System.IEquatable$1(Boolean), System.IComparable];
            } else if (type === String) {
                return [System.IComparable$1(String), System.IEquatable$1(String), System.IComparable, System.ICloneable, System.Collections.IEnumerable, System.Collections.Generic.IEnumerable$1(System.Char)];
            } else if (type === Array || type.$isArray || (t = System.Array._typedArrays[Bridge.getTypeName(type)])) {
                t = t || type.$elementType || System.Object;
                return [System.Collections.IEnumerable, System.Collections.ICollection, System.ICloneable, System.Collections.IList, System.Collections.Generic.IEnumerable$1(t), System.Collections.Generic.ICollection$1(t), System.Collections.Generic.IList$1(t)];
            } else {
                return [];
            }
        },

        isInstanceOfType: function (instance, type) {
            return Bridge.is(instance, type);
        },

        isAssignableFrom: function (baseType, type) {
            if (baseType == null) {
                throw new System.NullReferenceException();
            }

            if (type == null) {
                return false;
            }

            if (baseType === type || Bridge.isObject(baseType)) {
                return true;
            }

            if (Bridge.isFunction(baseType.isAssignableFrom)) {
                return baseType.isAssignableFrom(type);
            }

            if (type === Array) {
                return System.Array.is([], baseType);
            }

            if (Bridge.Reflection.isInterface(baseType) && System.Array.contains(Bridge.Reflection.getInterfaces(type), baseType)) {
                return true;
            }

            var inheritors = type.$$inherits,
                i,
                r;

            if (inheritors) {
                for (i = 0; i < inheritors.length; i++) {
                    r = Bridge.Reflection.isAssignableFrom(baseType, inheritors[i]);

                    if (r) {
                        return true;
                    }
                }
            }

            return false;
        },

        isClass: function (type) {
            return (type.$kind === "class" || type.$kind === "nested class" || type === Array || type === Function || type === RegExp || type === String || type === Error || type === Object);
        },

        isEnum: function (type) {
            return type.$kind === "enum";
        },

        isFlags: function (type) {
            return !!(type.prototype && type.prototype.$flags);
        },

        isInterface: function (type) {
            return type.$kind === "interface" || type.$kind === "nested interface";
        },

        isAbstract: function (type) {
            if (type === Function) {
                return true;
            }
            return ((Bridge.Reflection.getMetaValue(type, "att", 0) & 128) != 0);
        },

        _getType: function (typeName, asm, re, noinit) {
            var outer = !re;

            if (outer) {
                typeName = typeName.replace(/\[(,*)\]/g, function (match, g1) {
                    return "<" + (g1.length + 1) + ">"
                });
            }

            var next = function () {
                for (; ;) {
                    var m = re.exec(typeName);

                    if (m && m[0] == "[" && (typeName[m.index + 1] === "]" || typeName[m.index + 1] === ",")) {
                        continue;
                    }

                    if (m && m[0] == "]" && (typeName[m.index - 1] === "[" || typeName[m.index - 1] === ",")) {
                        continue;
                    }

                    if (m && m[0] == "," && (typeName[m.index + 1] === "]" || typeName[m.index + 1] === ",")) {
                        continue;
                    }

                    return m;
                }
            };

            re = re || /[[,\]]/g;

            var last = re.lastIndex,
                m = next(),
                tname,
                targs = [],
                t,
                noasm = !asm;

            //asm = asm || Bridge.$currentAssembly;

            if (m) {
                tname = typeName.substring(last, m.index);

                switch (m[0]) {
                    case "[":
                        if (typeName[m.index + 1] !== "[") {
                            return null;
                        }

                        for (; ;) {
                            next();
                            t = Bridge.Reflection._getType(typeName, null, re);

                            if (!t) {
                                return null;
                            }

                            targs.push(t);
                            m = next();

                            if (m[0] === "]") {
                                break;
                            } else if (m[0] !== ",") {
                                return null;
                            }
                        }

                        var arrMatch = (/^\s*<(\d+)>/g).exec(typeName.substring(m.index + 1));

                        if (arrMatch) {
                            tname = tname + "<" + parseInt(arrMatch[1]) + ">";
                        }

                        m = next();

                        if (m && m[0] === ",") {
                            next();

                            if (!(asm = System.Reflection.Assembly.assemblies[(re.lastIndex > 0 ? typeName.substring(m.index + 1, re.lastIndex - 1) : typeName.substring(m.index + 1)).trim()])) {
                                return null;
                            }
                        }
                        break;

                    case "]":
                        break;

                    case ",":
                        next();

                        if (!(asm = System.Reflection.Assembly.assemblies[(re.lastIndex > 0 ? typeName.substring(m.index + 1, re.lastIndex - 1) : typeName.substring(m.index + 1)).trim()])) {
                            return null;
                        }

                        break;
                }
            } else {
                tname = typeName.substring(last);
            }

            if (outer && re.lastIndex) {
                return null;
            }

            tname = tname.trim();

            var rankInfo = Bridge.Reflection._extractArrayRank(tname);
            var rank = rankInfo.rank;

            tname = rankInfo.name;

            t = Bridge.Reflection._getAssemblyType(asm, tname);

            if (noinit) {
                return t;
            }

            if (!t && noasm) {
                for (var asmName in System.Reflection.Assembly.assemblies) {
                    if (System.Reflection.Assembly.assemblies.hasOwnProperty(asmName) && System.Reflection.Assembly.assemblies[asmName] !== asm) {
                        t = Bridge.Reflection._getType(typeName, System.Reflection.Assembly.assemblies[asmName], null,true);

                        if (t) {
                            break;
                        }
                    }
                }
            }

            t = targs.length ? t.apply(null, targs) : t;

            if (t && t.$staticInit) {
                t.$staticInit();
            }

            if (rank > -1) {
                t = System.Array.type(t, rank);
            }

            return t;
        },

        getType: function (typeName, asm) {
            if (typeName == null) {
                throw new System.ArgumentNullException.$ctor1("typeName");
            }

            return typeName ? Bridge.Reflection._getType(typeName, asm) : null;
        },

        canAcceptNull: function (type) {
            if (type.$kind === "struct" ||
                type.$kind === "enum" ||
                type === System.Decimal ||
                type === System.Int64 ||
                type === System.UInt64 ||
                type === System.Double ||
                type === System.Single ||
                type === System.Byte ||
                type === System.SByte ||
                type === System.Int16 ||
                type === System.UInt16 ||
                type === System.Int32 ||
                type === System.UInt32 ||
                type === Bridge.Int ||
                type === System.Boolean ||
                type === System.DateTime ||
                type === Boolean ||
                type === Date ||
                type === Number) {
                return false;
            }

            return true;
        },

        applyConstructor: function (constructor, args) {
            if (!args || args.length === 0) {
                return new constructor();
            }

            if (constructor.$$initCtor && constructor.$kind !== "anonymous") {
                var md = Bridge.getMetadata(constructor),
                    count = 0;

                if (md) {
                    var ctors = Bridge.Reflection.getMembers(constructor, 1, 28),
                        found;

                    for (var j = 0; j < ctors.length; j++) {
                        var ctor = ctors[j];

                        if (ctor.p && ctor.p.length === args.length) {
                            found = true;

                            for (var k = 0; k < ctor.p.length; k++) {
                                var p = ctor.p[k];

                                if (!Bridge.is(args[k], p) || args[k] == null && !Bridge.Reflection.canAcceptNull(p)) {
                                    found = false;

                                    break;
                                }
                            }

                            if (found) {
                                constructor = constructor[ctor.sn];
                                count++;
                            }
                        }
                    }
                } else {
                    if (Bridge.isFunction(constructor.ctor) && constructor.ctor.length === args.length) {
                        constructor = constructor.ctor;
                    } else {
                        var name = "$ctor",
                            i = 1;

                        while (Bridge.isFunction(constructor[name + i])) {
                            if (constructor[name + i].length === args.length) {
                                constructor = constructor[name + i];
                                count++;
                            }

                            i++;
                        }
                    }
                }

                if (count > 1) {
                    throw new System.Exception("The ambiguous constructor call");
                }
            }

            var f = function () {
                constructor.apply(this, args);
            };

            f.prototype = constructor.prototype;

            return new f();
        },

        getAttributes: function (type, attrType, inherit) {
            var result = [],
                i,
                t,
                a,
                md,
                type_md;

            if (inherit) {
                var b = Bridge.Reflection.getBaseType(type);

                if (b) {
                    a = Bridge.Reflection.getAttributes(b, attrType, true);

                    for (i = 0; i < a.length; i++) {
                        t = Bridge.getType(a[i]);
                        md = Bridge.getMetadata(t);

                        if (!md || !md.ni) {
                            result.push(a[i]);
                        }
                    }
                }
            }

            type_md = Bridge.getMetadata(type);

            if (type_md && type_md.at) {
                for (i = 0; i < type_md.at.length; i++) {
                    a = type_md.at[i];

                    if (attrType == null || Bridge.Reflection.isInstanceOfType(a, attrType)) {
                        t = Bridge.getType(a);
                        md = Bridge.getMetadata(t);

                        if (!md || !md.am) {
                            for (var j = result.length - 1; j >= 0; j--) {
                                if (Bridge.Reflection.isInstanceOfType(result[j], t)) {
                                    result.splice(j, 1);
                                }
                            }
                        }

                        result.push(a);
                    }
                }
            }

            return result;
        },

        getMembers: function (type, memberTypes, bindingAttr, name, params) {
            var result = [];

            if ((bindingAttr & 72) === 72 || (bindingAttr & 6) === 4) {
                var b = Bridge.Reflection.getBaseType(type);

                if (b) {
                    result = Bridge.Reflection.getMembers(b, memberTypes & ~1, bindingAttr & (bindingAttr & 64 ? 255 : 247) & (bindingAttr & 2 ? 251 : 255), name, params);
                }
            }

            var idx = 0,
                f = function (m) {
                if ((memberTypes & m.t) && (((bindingAttr & 4) && !m.is) || ((bindingAttr & 8) && m.is)) && (!name || ((bindingAttr & 1) === 1 ? (m.n.toUpperCase() === name.toUpperCase()) : (m.n === name)))) {
                    if ((bindingAttr & 16) === 16 && m.a === 2 ||
                        (bindingAttr & 32) === 32 && m.a !== 2) {
                        if (params) {
                            if ((m.p || []).length !== params.length) {
                                return;
                            }

                            for (var i = 0; i < params.length; i++) {
                                if (params[i] !== m.p[i]) {
                                    return;
                                }
                            }
                        }

                        if (m.ov || m.v) {
                            result = result.filter(function (a) {
                                return !(a.n == m.n && a.t == m.t);
                            });
                        }

                        result.splice(idx++, 0, m);
                    }
                }
            };

            var type_md = Bridge.getMetadata(type);

            if (type_md && type_md.m) {
                var mNames = ["g", "s", "ad", "r"];

                for (var i = 0; i < type_md.m.length; i++) {
                    var m = type_md.m[i];

                    f(m);

                    for (var j = 0; j < 4; j++) {
                        var a = mNames[j];

                        if (m[a]) {
                            f(m[a]);
                        }
                    }
                }
            }

            if (bindingAttr & 256) {
                while (type) {
                    var r = [];

                    for (var i = 0; i < result.length; i++) {
                        if (result[i].td === type) {
                            r.push(result[i]);
                        }
                    }

                    if (r.length > 1) {
                        throw new System.Reflection.AmbiguousMatchException.$ctor1("Ambiguous match");
                    } else if (r.length === 1) {
                        return r[0];
                    }

                    type = Bridge.Reflection.getBaseType(type);
                }

                return null;
            }

            return result;
        },

        createDelegate: function (mi, firstArgument) {
            var isStatic = mi.is || mi.sm,
                bind = firstArgument != null && !isStatic,
                method = Bridge.Reflection.midel(mi, firstArgument, null, bind);

            if (!bind) {
                if (isStatic) {
                    return function () {
                        var args = firstArgument != null ? [firstArgument] : [];

                        return method.apply(mi.td, args.concat(Array.prototype.slice.call(arguments, 0)));
                    };
                } else {
                    return function (target) {
                        return method.apply(target, Array.prototype.slice.call(arguments, 1));
                    };
                }
            }

            return method;
        },

        midel: function (mi, target, typeArguments, bind) {
            if (bind !== false) {
                if (mi.is && !!target) {
                    throw new System.ArgumentException.$ctor1("Cannot specify target for static method");
                } else if (!mi.is && !target) {
                    throw new System.ArgumentException.$ctor1("Must specify target for instance method");
                }
            }

            var method;

            if (mi.fg) {
                method = function () { return (mi.is ? mi.td : this)[mi.fg]; };
            } else if (mi.fs) {
                method = function (v) { (mi.is ? mi.td : this)[mi.fs] = v; };
            } else {
                method = mi.def || (mi.is || mi.sm ? mi.td[mi.sn] : (target ? target[mi.sn] : mi.td.prototype[mi.sn]));

                if (mi.tpc) {
                    if (!typeArguments || typeArguments.length !== mi.tpc) {
                        throw new System.ArgumentException.$ctor1("Wrong number of type arguments");
                    }

                    var gMethod = method;

                    method = function () {
                        return gMethod.apply(this, typeArguments.concat(Array.prototype.slice.call(arguments)));
                    }
                } else {
                    if (typeArguments && typeArguments.length) {
                        throw new System.ArgumentException.$ctor1("Cannot specify type arguments for non-generic method");
                    }
                }

                if (mi.exp) {
                    var _m1 = method;

                    method = function () { return _m1.apply(this, Array.prototype.slice.call(arguments, 0, arguments.length - 1).concat(arguments[arguments.length - 1])); };
                }

                if (mi.sm) {
                    var _m2 = method;

                    method = function () { return _m2.apply(null, [this].concat(Array.prototype.slice.call(arguments))); };
                }
            }

            var orig = method;

            method = function () {
                var args = [],
                    params = mi.pi || [],
                    p;

                for (var i = 0; i < arguments.length; i++) {
                    p = params[i] || params[params.length - 1];
                    args[i] = p && p.pt === System.Object ? arguments[i] : Bridge.unbox(arguments[i]);
                }

                var v = orig.apply(this, args);

                return v != null && mi.box ? mi.box(v) : v;
            };

            return bind !== false ? Bridge.fn.bind(target, method) : method;
        },

        invokeCI: function (ci, args) {
            if (ci.exp) {
                args = args.slice(0, args.length - 1).concat(args[args.length - 1]);
            }

            if (ci.def) {
                return ci.def.apply(null, args);
            } else if (ci.sm) {
                return ci.td[ci.sn].apply(null, args);
            } else {
                if (ci.td.$literal) {
                    return (ci.sn ? ci.td[ci.sn] : ci.td).apply(ci.td, args);
                }

                return Bridge.Reflection.applyConstructor(ci.sn ? ci.td[ci.sn] : ci.td, args);
            }
        },

        fieldAccess: function (fi, obj) {
            if (fi.is && !!obj) {
                throw new System.ArgumentException.$ctor1("Cannot specify target for static field");
            } else if (!fi.is && !obj) {
                throw new System.ArgumentException.$ctor1("Must specify target for instance field");
            }

            obj = fi.is ? fi.td : obj;

            if (arguments.length === 3) {
                obj[fi.sn] = arguments[2];
            } else {
                return fi.box ? fi.box(obj[fi.sn]) : obj[fi.sn];
            }
        },

        getMetaValue: function (type, name, dv) {
            var md = type.$isTypeParameter ? type : Bridge.getMetadata(type);

            return md ? (md[name] || dv) : dv;
        },

        isArray: function (type) {
            return Bridge.arrayTypes.indexOf(type) >= 0;
        },

        hasGenericParameters: function (type) {
            if (type.$typeArguments) {
                for (var i = 0; i < type.$typeArguments.length; i++) {
                    if (type.$typeArguments[i].$isTypeParameter) {
                        return true;
                    }
                }
            }

            return false;
        },

        isValueType: function (type) {
            return !Bridge.Reflection.canAcceptNull(type);
        },

        getNestedTypes: function (type, flags) {
            var types = Bridge.Reflection.getMetaValue(type, "nested", []);

            if (flags) {
                var tmp = [];
                for (var i = 0; i < types.length; i++) {
                    var nestedType = types[i],
                        attrs = Bridge.Reflection.getMetaValue(nestedType, "att", 0),
                        access = attrs & 7,
                        isPublic = access === 1 || access === 2;

                    if ((flags & 16) === 16 && isPublic ||
                        (flags & 32) === 32 && !isPublic) {
                        tmp.push(nestedType);
                    }
                }

                types = tmp;
            }

            return types;
        },

        getNestedType: function (type, name, flags) {
            var types = Bridge.Reflection.getNestedTypes(type, flags);

            for (var i = 0; i < types.length; i++) {
                if (Bridge.Reflection.getTypeName(types[i]) === name) {
                    return types[i];
                }
            }

            return null;
        }
    };

    Bridge.setMetadata = Bridge.Reflection.setMetadata;

    System.Reflection.ConstructorInfo = {
        $is: function (obj) {
            return obj != null && obj.t === 1;
        }
    };

    System.Reflection.EventInfo = {
        $is: function (obj) {
            return obj != null && obj.t === 2;
        }
    };

    System.Reflection.FieldInfo = {
        $is: function (obj) {
            return obj != null && obj.t === 4;
        }
    };

    System.Reflection.MethodBase = {
        $is: function (obj) {
            return obj != null && (obj.t === 1 || obj.t === 8);
        }
    };

    System.Reflection.MethodInfo = {
        $is: function (obj) {
            return obj != null && obj.t === 8;
        }
    };

    System.Reflection.PropertyInfo = {
        $is: function (obj) {
            return obj != null && obj.t === 16;
        }
    };

    System.AppDomain = {
        getAssemblies: function () {
            return Object.keys(System.Reflection.Assembly.assemblies).map(function (n) { return System.Reflection.Assembly.assemblies[n]; });
        }
    };

    // @source Interfaces.js

    Bridge.define("System.IFormattable", {
        $kind: "interface",
        statics: {
            $is: function (obj) {
                if (Bridge.isNumber(obj) || Bridge.isDate(obj)) {
                    return true;
                }

                return Bridge.is(obj, System.IFormattable, true);
            }
        }
    });

    Bridge.define("System.IComparable", {
        $kind: "interface",

        statics: {
            $is: function (obj) {
                if (Bridge.isNumber(obj) || Bridge.isDate(obj) || Bridge.isBoolean(obj) || Bridge.isString(obj)) {
                    return true;
                }

                return Bridge.is(obj, System.IComparable, true);
            }
        }
    });

    Bridge.define("System.IFormatProvider", {
        $kind: "interface"
    });

    Bridge.define("System.ICloneable", {
        $kind: "interface"
    });

    Bridge.define("System.IComparable$1", function (T) {
        return {
            $kind: "interface",

            statics: {
                $is: function (obj) {
                    if (Bridge.isNumber(obj) && T.$number && T.$is(obj) || Bridge.isDate(obj) && (T === Date || T === System.DateTime) || Bridge.isBoolean(obj) && (T === Boolean || T === System.Boolean) || Bridge.isString(obj) && (T === String || T === System.String)) {
                        return true;
                    }

                    return Bridge.is(obj, System.IComparable$1(T), true);
                },

                isAssignableFrom: function (type) {
                    if (type === System.DateTime && T === Date) {
                        return true;
                    }

                    return Bridge.Reflection.getInterfaces(type).indexOf(System.IComparable$1(T)) >= 0;
                }
            }
        };
    });

    Bridge.define("System.IEquatable$1", function (T) {
        return {
            $kind: "interface",

            statics: {
                $is: function (obj) {
                    if (Bridge.isNumber(obj) && T.$number && T.$is(obj) || Bridge.isDate(obj) && (T === Date || T === System.DateTime) || Bridge.isBoolean(obj) && (T === Boolean || T === System.Boolean) || Bridge.isString(obj) && (T === String || T === System.String)) {
                        return true;
                    }

                    return Bridge.is(obj, System.IEquatable$1(T), true);
                },

                isAssignableFrom: function (type) {
                    if (type === System.DateTime && T === Date) {
                        return true;
                    }

                    return Bridge.Reflection.getInterfaces(type).indexOf(System.IEquatable$1(T)) >= 0;
                }
            }
        };
    });

    Bridge.define("Bridge.IPromise", {
        $kind: "interface"
    });

    Bridge.define("System.IDisposable", {
        $kind: "interface"
    });

    Bridge.define("System.IAsyncResult", {
        $kind: "interface"
    });

    // @source ValueType.js

Bridge.define("System.ValueType", {
    statics: {
        methods: {
            $is: function (obj) {
                return Bridge.Reflection.isValueType(Bridge.getType(obj));
            }
        }
    }
});

    // @source Enum.js

    var enumMethods = {
        nameEquals: function (n1, n2, ignoreCase) {
            if (ignoreCase) {
                return n1.toLowerCase() === n2.toLowerCase();
            }

            return (n1.charAt(0).toLowerCase() + n1.slice(1)) === (n2.charAt(0).toLowerCase() + n2.slice(1));
        },

        checkEnumType: function (enumType) {
            if (!enumType) {
                throw new System.ArgumentNullException.$ctor1("enumType");
            }

            if (enumType.prototype && enumType.$kind !== "enum") {
                throw new System.ArgumentException.$ctor1("", "enumType");
            }
        },

        getUnderlyingType: function (type) {
            System.Enum.checkEnumType(type);

            return type.prototype.$utype || System.Int32;
        },

        toName: function (name) {
            return name;
        },

        parse: function (enumType, s, ignoreCase, silent) {
            System.Enum.checkEnumType(enumType);

            if (s != null) {
                if (enumType === Number || enumType === System.String || enumType.$number) {
                    return s;
                }

                var intValue = {};

                if (System.Int32.tryParse(s, intValue)) {
                    return Bridge.box(intValue.v, enumType, function (obj) { return System.Enum.toString(enumType, obj); });
                }

                var names = System.Enum.getNames(enumType),
                    values = enumType;

                if (!enumType.prototype || !enumType.prototype.$flags) {
                    for (var i = 0; i < names.length; i++) {
                        var name = names[i];

                        if (enumMethods.nameEquals(name, s, ignoreCase)) {
                            return Bridge.box(values[name], enumType, function (obj) { return System.Enum.toString(enumType, obj); });
                        }
                    }
                } else {
                    var parts = s.split(","),
                        value = 0,
                        parsed = true;

                    for (var i = parts.length - 1; i >= 0; i--) {
                        var part = parts[i].trim(),
                            found = false;

                        for (var n = 0; n < names.length; n++) {
                            var name = names[n];

                            if (enumMethods.nameEquals(name, part, ignoreCase)) {
                                value |= values[name];
                                found = true;

                                break;
                            }
                        }

                        if (!found) {
                            parsed = false;

                            break;
                        }
                    }

                    if (parsed) {
                        return Bridge.box(value, enumType, function (obj) { return System.Enum.toString(enumType, obj); });
                    }
                }
            }

            if (silent !== true) {
                throw new System.ArgumentException.$ctor3("silent", "Invalid Enumeration Value");
            }

            return null;
        },

        toStringFn: function (type) {
            return function (value) {
                return System.Enum.toString(type, value);
            };
        },

        toString: function (enumType, value, forceFlags) {
            if (arguments.length === 0) {
                return "System.Enum";
            }

            if (value && value.$boxed && enumType === System.Enum) {
                enumType = value.type;
            }

            value = Bridge.unbox(value, true);

            if (enumType === Number || enumType === System.String || enumType.$number) {
                return value.toString();
            }

            System.Enum.checkEnumType(enumType);

            var values = enumType,
                names = System.Enum.getNames(enumType),
                isLong = System.Int64.is64Bit(value);

            if (((!enumType.prototype || !enumType.prototype.$flags) && forceFlags !== true) || (value === 0)) {
                for (var i = 0; i < names.length; i++) {
                    var name = names[i];

                    if (isLong && System.Int64.is64Bit(values[name]) ? (values[name].eq(value)) : (values[name] === value)) {
                        return enumMethods.toName(name);
                    }
                }

                return value.toString();
            } else {
                var parts = [],
                    entries = System.Enum.getValuesAndNames(enumType),
                    index = entries.length - 1,
                    saveResult = value;

                while (index >= 0) {
                    var entry = entries[index],
                        long = isLong && System.Int64.is64Bit(entry.value);

                    if ((index == 0) && (long ? entry.value.isZero() : entry.value == 0)) {
                        break;
                    }

                    if (long ? (value.and(entry.value).eq(entry.value)) : ((value & entry.value) == entry.value)) {
                        if (long) {
                            value = value.sub(entry.value);
                        } else {
                            value -= entry.value;
                        }

                        parts.unshift(entry.name);
                    }

                    index--;
                }

                if (isLong ? !value.isZero() : value !== 0) {
                    return saveResult.toString();
                }

                if (isLong ? saveResult.isZero() : saveResult === 0) {
                    var entry = entries[0];

                    if (entry && (System.Int64.is64Bit(entry.value) ? entry.value.isZero() : (entry.value == 0))) {
                        return entry.name;
                    }

                    return "0";
                }

                return parts.join(", ");
            }
        },

        getValuesAndNames: function (enumType) {
            System.Enum.checkEnumType(enumType);

            var parts = [],
                names = System.Enum.getNames(enumType),
                values = enumType;

            for (var i = 0; i < names.length; i++) {
                parts.push({ name: names[i], value: values[names[i]] });
            }

            return parts.sort(function (i1, i2) {
                return System.Int64.is64Bit(i1.value) ? i1.value.sub(i2.value).sign() : (i1.value - i2.value);
            });
        },

        getValues: function (enumType) {
            System.Enum.checkEnumType(enumType);

            var parts = [],
                names = System.Enum.getNames(enumType),
                values = enumType;

            for (var i = 0; i < names.length; i++) {
                parts.push(values[names[i]]);
            }

            return parts.sort(function (i1, i2) {
                return System.Int64.is64Bit(i1) ? i1.sub(i2).sign() : (i1 - i2);
            });
        },

        format: function (enumType, value, format) {
            System.Enum.checkEnumType(enumType);

            var name;

            if (!Bridge.hasValue(value) && (name = "value") || !Bridge.hasValue(format) && (name = "format")) {
                throw new System.ArgumentNullException.$ctor1(name);
            }

            value = Bridge.unbox(value, true);

            switch (format) {
                case "G":
                case "g":
                    return System.Enum.toString(enumType, value);
                case "x":
                case "X":
                    return value.toString(16);
                case "d":
                case "D":
                    return value.toString();
                case "f":
                case "F":
                    return System.Enum.toString(enumType, value, true);
                default:
                    throw new System.FormatException();
            }
        },

        getNames: function (enumType) {
            System.Enum.checkEnumType(enumType);

            var parts = [],
                values = enumType;

            if (enumType.$names) {
                return enumType.$names.slice(0);
            }

            for (var i in values) {
                if (values.hasOwnProperty(i) && i.indexOf("$") < 0 && typeof values[i] !== "function") {
                    parts.push([enumMethods.toName(i), values[i]]);
                }
            }

            return parts.sort(function (i1, i2) {
                return System.Int64.is64Bit(i1[1]) ? i1[1].sub(i2[1]).sign() : (i1[1] - i2[1]);
            }).map(function (i) {
                return i[0];
            });
        },

        getName: function (enumType, value) {
            value = Bridge.unbox(value, true);

            if (value == null) {
                throw new System.ArgumentNullException.$ctor1("value");
            }

            var isLong = System.Int64.is64Bit(value);

            if (!isLong && !(typeof (value) === "number" && Math.floor(value, 0) === value)) {
                throw new System.ArgumentException.$ctor1("Argument must be integer", "value");
            }

            System.Enum.checkEnumType(enumType);

            var names = System.Enum.getNames(enumType),
                values = enumType;

            for (var i = 0; i < names.length; i++) {
                var name = names[i];

                if (isLong ? value.eq(values[name]) : (values[name] === value)) {
                    return name;
                }
            }

            return null;
        },

        hasFlag: function (value, flag) {
            flag = Bridge.unbox(flag, true);
            var isLong = System.Int64.is64Bit(value);

            return flag === 0 || (isLong ? !value.and(flag).isZero() : !!(value & flag));
        },

        isDefined: function (enumType, value) {
            value = Bridge.unbox(value, true);

            System.Enum.checkEnumType(enumType);

            var values = enumType,
                names = System.Enum.getNames(enumType),
                isString = Bridge.isString(value),
                isLong = System.Int64.is64Bit(value);

            for (var i = 0; i < names.length; i++) {
                var name = names[i];

                if (isString ? enumMethods.nameEquals(name, value, false) : (isLong ? value.eq(values[name]) : (values[name] === value))) {
                    return true;
                }
            }

            return false;
        },

        tryParse: function (enumType, value, result, ignoreCase) {
            result.v = Bridge.unbox(enumMethods.parse(enumType, value, ignoreCase, true), true);

            if (result.v == null) {
                result.v = 0;

                return false;
            }

            return true;
        },

        equals: function (v1, v2, T) {
            if (v2 && v2.$boxed && (v1 && v1.$boxed || T)) {
                if (v2.type !== (v1.type || T)) {
                    return false;
                }
            }

            return System.Enum.equalsT(v1, v2);
        },

        equalsT: function (v1, v2) {
            return Bridge.equals(Bridge.unbox(v1, true), Bridge.unbox(v2, true));
        }
    };

    Bridge.define("System.Enum", {
        inherits: [System.IComparable, System.IFormattable],
        statics: {
            methods: enumMethods
        }
    });

    // @source Nullable.js

    var nullable = {
        hasValue: Bridge.hasValue,

        getValue: function (obj) {
            obj = Bridge.unbox(obj, true);

            if (!Bridge.hasValue(obj)) {
                throw new System.InvalidOperationException.$ctor1("Nullable instance doesn't have a value.");
            }

            return obj;
        },

        getValueOrDefault: function (obj, defValue) {
            return Bridge.hasValue(obj) ? obj : defValue;
        },

        add: function (a, b) {
            return Bridge.hasValue$1(a, b) ? a + b : null;
        },

        band: function (a, b) {
            return Bridge.hasValue$1(a, b) ? a & b : null;
        },

        bor: function (a, b) {
            return Bridge.hasValue$1(a, b) ? a | b : null;
        },

        and: function (a, b) {
            if (a === true && b === true) {
                return true;
            } else if (a === false || b === false) {
                return false;
            }

            return null;
        },

        or: function (a, b) {
            if (a === true || b === true) {
                return true;
            } else if (a === false && b === false) {
                return false;
            }

            return null;
        },

        div: function (a, b) {
            return Bridge.hasValue$1(a, b) ? a / b : null;
        },

        eq: function (a, b) {
            return !Bridge.hasValue(a) ? !Bridge.hasValue(b) : (a === b);
        },

        equals: function (a, b, fn) {
            return !Bridge.hasValue(a) ? !Bridge.hasValue(b) : (fn ? fn(a, b) : Bridge.equals(a, b));
        },

        toString: function (a, fn) {
            return !Bridge.hasValue(a) ? "" : (fn ? fn(a) : a.toString());
        },

        toStringFn: function (fn) {
            return function (v) {
                return System.Nullable.toString(v, fn);
            };
        },

        getHashCode: function (a, fn) {
            return !Bridge.hasValue(a) ? 0 : (fn ? fn(a) : Bridge.getHashCode(a));
        },

        getHashCodeFn: function (fn) {
            return function (v) {
                return System.Nullable.getHashCode(v, fn);
            };
        },

        xor: function (a, b) {
            return Bridge.hasValue$1(a, b) ? a ^ b : null;
        },

        gt: function (a, b) {
            return Bridge.hasValue$1(a, b) && a > b;
        },

        gte: function (a, b) {
            return Bridge.hasValue$1(a, b) && a >= b;
        },

        neq: function (a, b) {
            return !Bridge.hasValue(a) ? Bridge.hasValue(b) : (a !== b);
        },

        lt: function (a, b) {
            return Bridge.hasValue$1(a, b) && a < b;
        },

        lte: function (a, b) {
            return Bridge.hasValue$1(a, b) && a <= b;
        },

        mod: function (a, b) {
            return Bridge.hasValue$1(a, b) ? a % b : null;
        },

        mul: function (a, b) {
            return Bridge.hasValue$1(a, b) ? a * b : null;
        },

        imul: function (a, b) {
            return Bridge.hasValue$1(a, b) ? Bridge.Int.mul(a, b) : null;
        },

        sl: function (a, b) {
            return Bridge.hasValue$1(a, b) ? a << b : null;
        },

        sr: function (a, b) {
            return Bridge.hasValue$1(a, b) ? a >> b : null;
        },

        srr: function (a, b) {
            return Bridge.hasValue$1(a, b) ? a >>> b : null;
        },

        sub: function (a, b) {
            return Bridge.hasValue$1(a, b) ? a - b : null;
        },

        bnot: function (a) {
            return Bridge.hasValue(a) ? ~a : null;
        },

        neg: function (a) {
            return Bridge.hasValue(a) ? -a : null;
        },

        not: function (a) {
            return Bridge.hasValue(a) ? !a : null;
        },

        pos: function (a) {
            return Bridge.hasValue(a) ? +a : null;
        },

        lift: function () {
            for (var i = 1; i < arguments.length; i++) {
                if (!Bridge.hasValue(arguments[i])) {
                    return null;
                }
            }

            if (arguments[0] == null) {
                return null;
            }

            if (arguments[0].apply == undefined) {
                return arguments[0];
            }

            return arguments[0].apply(null, Array.prototype.slice.call(arguments, 1));
        },

        lift1: function (f, o) {
            return Bridge.hasValue(o) ? (typeof f === "function" ? f.apply(null, Array.prototype.slice.call(arguments, 1)) : o[f].apply(o, Array.prototype.slice.call(arguments, 2))) : null;
        },

        lift2: function (f, a, b) {
            return Bridge.hasValue$1(a, b) ? (typeof f === "function" ? f.apply(null, Array.prototype.slice.call(arguments, 1)) : a[f].apply(a, Array.prototype.slice.call(arguments, 2))) : null;
        },

        liftcmp: function (f, a, b) {
            return Bridge.hasValue$1(a, b) ? (typeof f === "function" ? f.apply(null, Array.prototype.slice.call(arguments, 1)) : a[f].apply(a, Array.prototype.slice.call(arguments, 2))) : false;
        },

        lifteq: function (f, a, b) {
            var va = Bridge.hasValue(a),
                vb = Bridge.hasValue(b);

            return (!va && !vb) || (va && vb && (typeof f === "function" ? f.apply(null, Array.prototype.slice.call(arguments, 1)) : a[f].apply(a, Array.prototype.slice.call(arguments, 2))));
        },

        liftne: function (f, a, b) {
            var va = Bridge.hasValue(a),
                vb = Bridge.hasValue(b);

            return (va !== vb) || (va && (typeof f === "function" ? f.apply(null, Array.prototype.slice.call(arguments, 1)) : a[f].apply(a, Array.prototype.slice.call(arguments, 2))));
        },

        getUnderlyingType: function (nullableType) {
            if (!nullableType) {
                throw new System.ArgumentNullException.$ctor1("nullableType");
            }

            if (Bridge.Reflection.isGenericType(nullableType) &&
                !Bridge.Reflection.isGenericTypeDefinition(nullableType)) {
                var genericType = Bridge.Reflection.getGenericTypeDefinition(nullableType);

                if (genericType === System.Nullable$1) {
                    return Bridge.Reflection.getGenericArguments(nullableType)[0];
                }
            }

            return null;
        },

        compare: function (n1, n2) {
            return System.Collections.Generic.Comparer$1.$default.compare(n1, n2);
        }
    };

    System.Nullable = nullable;

    Bridge.define("System.Nullable$1", function (T) {
        return {
            $kind: "struct",

            statics: {
                $nullable: true,
                $nullableType: T,
                getDefaultValue: function () {
                    return null;
                },

                $is: function (obj) {
                    return Bridge.is(obj, T);
                }
            }
        };
    });

    // @source Char.js

    Bridge.define("System.Char", {
        inherits: [System.IComparable, System.IFormattable],
        $kind: "struct",
        statics: {
            min: 0,

            max: 65535,

            $is: function (instance) {
                return typeof (instance) === "number" && Math.round(instance, 0) == instance && instance >= System.Char.min && instance <= System.Char.max;
            },

            getDefaultValue: function () {
                return 0;
            },

            parse: function (s) {
                if (!Bridge.hasValue(s)) {
                    throw new System.ArgumentNullException.$ctor1("s");
                }

                if (s.length !== 1) {
                    throw new System.FormatException();
                }

                return s.charCodeAt(0);
            },

            tryParse: function (s, result) {
                var b = s && s.length === 1;

                result.v = b ? s.charCodeAt(0) : 0;

                return b;
            },

            format: function (number, format, provider) {
                return Bridge.Int.format(number, format, provider);
            },

            charCodeAt: function (str, index) {
                if (str == null) {
                    throw new System.ArgumentNullException();
                }

                if (str.length != 1) {
                    throw new System.FormatException.$ctor1("String must be exactly one character long");
                }

                return str.charCodeAt(index);
            },

            isWhiteSpace: function (s) {
                return !/[^\s\x09-\x0D\x85\xA0]/.test(s);
            },

            isDigit: function (value) {
                if (value < 256) {
                    return (value >= 48 && value <= 57);
                }

                return new RegExp(/[0-9\u0030-\u0039\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19]/).test(String.fromCharCode(value));
            },

            isLetter: function (value) {
                if (value < 256) {
                    return (value >= 65 && value <= 90) || (value >= 97 && value <= 122);
                }

                return new RegExp(/[A-Za-z\u0061-\u007A\u00B5\u00DF-\u00F6\u00F8-\u00FF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0561-\u0587\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7FA\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A\u0041-\u005A\u00C0-\u00D6\u00D8-\u00DE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2183\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA\uFF21-\uFF3A\u01C5\u01C8\u01CB\u01F2\u1F88-\u1F8F\u1F98-\u1F9F\u1FA8-\u1FAF\u1FBC\u1FCC\u1FFC\u02B0-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0374\u037A\u0559\u0640\u06E5\u06E6\u07F4\u07F5\u07FA\u081A\u0824\u0828\u0971\u0E46\u0EC6\u10FC\u17D7\u1843\u1AA7\u1C78-\u1C7D\u1D2C-\u1D6A\u1D78\u1D9B-\u1DBF\u2071\u207F\u2090-\u209C\u2C7C\u2C7D\u2D6F\u2E2F\u3005\u3031-\u3035\u303B\u309D\u309E\u30FC-\u30FE\uA015\uA4F8-\uA4FD\uA60C\uA67F\uA717-\uA71F\uA770\uA788\uA7F8\uA7F9\uA9CF\uAA70\uAADD\uAAF3\uAAF4\uFF70\uFF9E\uFF9F\u00AA\u00BA\u01BB\u01C0-\u01C3\u0294\u05D0-\u05EA\u05F0-\u05F2\u0620-\u063F\u0641-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u0800-\u0815\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0972-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E45\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10D0-\u10FA\u10FD-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17DC\u1820-\u1842\u1844-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C77\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u2135-\u2138\u2D30-\u2D67\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3006\u303C\u3041-\u3096\u309F\u30A1-\u30FA\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA014\uA016-\uA48C\uA4D0-\uA4F7\uA500-\uA60B\uA610-\uA61F\uA62A\uA62B\uA66E\uA6A0-\uA6E5\uA7FB-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA6F\uAA71-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB\uAADC\uAAE0-\uAAEA\uAAF2\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF66-\uFF6F\uFF71-\uFF9D\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/).test(String.fromCharCode(value));
            },

            isHighSurrogate: function (value) {
                return new RegExp(/[\uD800-\uDBFF]/).test(String.fromCharCode(value));
            },

            isLowSurrogate: function (value) {
                return new RegExp(/[\uDC00-\uDFFF]/).test(String.fromCharCode(value));
            },

            isSurrogate: function (value) {
                return new RegExp(/[\uD800-\uDFFF]/).test(String.fromCharCode(value));
            },

            isNull: function (value) {
                return new RegExp("\u0000").test(String.fromCharCode(value));
            },

            isSymbol: function (value) {
                if (value < 256) {
                    return ([36, 43, 60, 61, 62, 94, 96, 124, 126, 162, 163, 164, 165, 166, 167, 168, 169, 172, 174, 175, 176, 177, 180, 182, 184, 215, 247].indexOf(value) != -1);
                }

                return new RegExp(/[\u20A0-\u20CF\u20D0-\u20FF\u2100-\u214F\u2150-\u218F\u2190-\u21FF\u2200-\u22FF\u2300-\u23FF\u25A0-\u25FF\u2600-\u26FF\u2700-\u27BF\u27C0-\u27EF\u27F0-\u27FF\u2800-\u28FF\u2900-\u297F\u2980-\u29FF\u2A00-\u2AFF\u2B00-\u2BFF]/).test(String.fromCharCode(value));
            },

            isSeparator: function (value) {
                if (value < 256) {
                    return (value == 32 || value == 160);
                }

                return new RegExp(/[\u2028\u2029\u0020\u00A0\u1680\u180E\u2000-\u200A\u202F\u205F\u3000]/).test(String.fromCharCode(value));
            },

            isPunctuation: function (value) {
                if (value < 256) {
                    return ([33, 34, 35, 37, 38, 39, 40, 41, 42, 44, 45, 46, 47, 58, 59, 63, 64, 91, 92, 93, 95, 123, 125, 161, 171, 173, 183, 187, 191].indexOf(value) != -1);
                }

                return new RegExp(/[\u0021-\u0023\u0025-\u002A\u002C-\u002F\u003A\u003B\u003F\u0040\u005B-\u005D\u005F\u007B\u007D\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E3B\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65\u002D\u058A\u05BE\u1400\u1806\u2010-\u2015\u2E17\u2E1A\u2E3A\u2E3B\u301C\u3030\u30A0\uFE31\uFE32\uFE58\uFE63\uFF0D\u0028\u005B\u007B\u0F3A\u0F3C\u169B\u201A\u201E\u2045\u207D\u208D\u2329\u2768\u276A\u276C\u276E\u2770\u2772\u2774\u27C5\u27E6\u27E8\u27EA\u27EC\u27EE\u2983\u2985\u2987\u2989\u298B\u298D\u298F\u2991\u2993\u2995\u2997\u29D8\u29DA\u29FC\u2E22\u2E24\u2E26\u2E28\u3008\u300A\u300C\u300E\u3010\u3014\u3016\u3018\u301A\u301D\uFD3E\uFE17\uFE35\uFE37\uFE39\uFE3B\uFE3D\uFE3F\uFE41\uFE43\uFE47\uFE59\uFE5B\uFE5D\uFF08\uFF3B\uFF5B\uFF5F\uFF62\u0029\u005D\u007D\u0F3B\u0F3D\u169C\u2046\u207E\u208E\u232A\u2769\u276B\u276D\u276F\u2771\u2773\u2775\u27C6\u27E7\u27E9\u27EB\u27ED\u27EF\u2984\u2986\u2988\u298A\u298C\u298E\u2990\u2992\u2994\u2996\u2998\u29D9\u29DB\u29FD\u2E23\u2E25\u2E27\u2E29\u3009\u300B\u300D\u300F\u3011\u3015\u3017\u3019\u301B\u301E\u301F\uFD3F\uFE18\uFE36\uFE38\uFE3A\uFE3C\uFE3E\uFE40\uFE42\uFE44\uFE48\uFE5A\uFE5C\uFE5E\uFF09\uFF3D\uFF5D\uFF60\uFF63\u00AB\u2018\u201B\u201C\u201F\u2039\u2E02\u2E04\u2E09\u2E0C\u2E1C\u2E20\u00BB\u2019\u201D\u203A\u2E03\u2E05\u2E0A\u2E0D\u2E1D\u2E21\u005F\u203F\u2040\u2054\uFE33\uFE34\uFE4D-\uFE4F\uFF3F\u0021-\u0023\u0025-\u0027\u002A\u002C\u002E\u002F\u003A\u003B\u003F\u0040\u005C\u00A1\u00A7\u00B6\u00B7\u00BF\u037E\u0387\u055A-\u055F\u0589\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u166D\u166E\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u1805\u1807-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2016\u2017\u2020-\u2027\u2030-\u2038\u203B-\u203E\u2041-\u2043\u2047-\u2051\u2053\u2055-\u205E\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00\u2E01\u2E06-\u2E08\u2E0B\u2E0E-\u2E16\u2E18\u2E19\u2E1B\u2E1E\u2E1F\u2E2A-\u2E2E\u2E30-\u2E39\u3001-\u3003\u303D\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFE10-\uFE16\uFE19\uFE30\uFE45\uFE46\uFE49-\uFE4C\uFE50-\uFE52\uFE54-\uFE57\uFE5F-\uFE61\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF07\uFF0A\uFF0C\uFF0E\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3C\uFF61\uFF64\uFF65]/).test(String.fromCharCode(value));
            },

            isNumber: function (value) {
                if (value < 256) {
                    return ([48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 178, 179, 185, 188, 189, 190].indexOf(value) != -1);
                }

                return new RegExp(/[\u0030-\u0039\u00B2\u00B3\u00B9\u00BC-\u00BE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D66-\u0D75\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19\u0030-\u0039\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19\u16EE-\u16F0\u2160-\u2182\u2185-\u2188\u3007\u3021-\u3029\u3038-\u303A\uA6E6-\uA6EF\u00B2\u00B3\u00B9\u00BC-\u00BE\u09F4-\u09F9\u0B72-\u0B77\u0BF0-\u0BF2\u0C78-\u0C7E\u0D70-\u0D75\u0F2A-\u0F33\u1369-\u137C\u17F0-\u17F9\u19DA\u2070\u2074-\u2079\u2080-\u2089\u2150-\u215F\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA830-\uA835]/).test(String.fromCharCode(value));
            },

            isControl: function (value) {
                if (value < 256) {
                    return (value >= 0 && value <= 31) || (value >= 127 && value <= 159);
                }

                return new RegExp(/[\u0000-\u001F\u007F\u0080-\u009F]/).test(String.fromCharCode(value));
            },

            isLatin1: function (ch) {
                return (ch <= 255);
            },

            isAscii: function (ch) {
                return (ch <= 127);
            },

            isUpper: function (s, index) {
                if (s == null) {
                    throw new System.ArgumentNullException.$ctor1("s");
                }

                if ((index >>> 0) >= ((s.length) >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("index");
                }

                var c = s.charCodeAt(index);

                if (System.Char.isLatin1(c)) {
                    if (System.Char.isAscii(c)) {
                        return (c >= 65 && c <= 90);
                    }
                }

                return Bridge.isUpper(c);
            },

            equals: function (v1, v2) {
                if (Bridge.is(v1, System.Char) && Bridge.is(v2, System.Char)) {
                    return Bridge.unbox(v1, true) === Bridge.unbox(v2, true);
                }

                return false;
            },

            equalsT: function (v1, v2) {
                return Bridge.unbox(v1, true) === Bridge.unbox(v2, true);
            },

            getHashCode: function (v) {
                return v | (v << 16);
            }
        }
    });

    Bridge.Class.addExtend(System.Char, [System.IComparable$1(System.Char), System.IEquatable$1(System.Char)]);

    // @source Ref.js

    Bridge.define("Bridge.Ref$1", function (T) { return {
        statics: {
            methods: {
                op_Implicit: function (reference) {
                    return reference.Value;
                }
            }
        },
        fields: {
            getter: null,
            setter: null
        },
        props: {
            Value: {
                get: function () {
                    return this.getter();
                },
                set: function (value) {
                    this.setter(value);
                }
            },
            v: {
                get: function () {
                    return this.Value;
                },
                set: function (value) {
                    this.Value = value;
                }
            }
        },
        ctors: {
            ctor: function (getter, setter) {
                this.$initialize();
                this.getter = getter;
                this.setter = setter;
            }
        },
        methods: {
            toString: function () {
                return Bridge.toString(this.Value);
            },
            valueOf: function () {
                return this.Value;
            }
        }
    }; });

    // @source IConvertible.js

    Bridge.define("System.IConvertible", {
        $kind: "interface"
    });

    // @source HResults.js

    Bridge.define("System.HResults");

    // @source Exception.js

    Bridge.define("System.Exception", {
        config: {
            properties: {
                Message: {
                    get: function () {
                        return this.message;
                    }
                },

                InnerException: {
                    get: function () {
                        return this.innerException;
                    }
                },

                StackTrace: {
                    get: function () {
                        return this.errorStack.stack;
                    }
                },

                Data: {
                    get: function () {
                        return this.data;
                    }
                },

                HResult: {
                    get: function () {
                        return this._HResult;
                    },
                    set: function (value) {
                        this._HResult = value;
                    }
                }
            }
        },

        ctor: function (message, innerException) {
            this.$initialize();
            this.message = message ? message : ("Exception of type '" + Bridge.getTypeName(this) + "' was thrown.");
            this.innerException = innerException ? innerException : null;
            this.errorStack = new Error(this.message);
            this.data = new (System.Collections.Generic.Dictionary$2(System.Object, System.Object))();
        },

        getBaseException: function () {
            var inner = this.innerException;
            var back = this;

            while (inner != null) {
                back = inner;
                inner = inner.innerException;
            }

            return back;
        },

        toString: function () {
            var builder = Bridge.getTypeName(this);

            if (this.Message != null) {
                builder += ": " + this.Message + "\n";
            } else {
                builder += "\n";
            }

            if (this.StackTrace != null) {
                builder += this.StackTrace + "\n";
            }

            return builder;
        },

        statics: {
            create: function (error) {
                if (Bridge.is(error, System.Exception)) {
                    return error;
                }

                var ex;

                if (error instanceof TypeError) {
                    ex = new System.NullReferenceException.$ctor1(error.message);
                } else if (error instanceof RangeError) {
                    ex = new System.ArgumentOutOfRangeException.$ctor1(error.message);
                } else if (error instanceof Error) {
                    return new System.SystemException.$ctor1(error);
                } else if (error && error.error && error.error.stack) {
                    ex = new System.Exception(error.error.stack);
                } else {
                    ex = new System.Exception(error ? error.message ? error.message : error.toString() : null);
                }

                ex.errorStack = error;

                return ex;
            }
        }
    });

    // @source SystemException.js

    Bridge.define("System.SystemException", {
        inherits: [System.Exception],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Exception.ctor.call(this, "System error.");
                this.HResult = -2146233087;
            },
            $ctor1: function (message) {
                this.$initialize();
                System.Exception.ctor.call(this, message);
                this.HResult = -2146233087;
            },
            $ctor2: function (message, innerException) {
                this.$initialize();
                System.Exception.ctor.call(this, message, innerException);
                this.HResult = -2146233087;
            }
        }
    });

    // @source OutOfMemoryException.js

    Bridge.define("System.OutOfMemoryException", {
        inherits: [System.SystemException],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.SystemException.$ctor1.call(this, "Insufficient memory to continue the execution of the program.");
                this.HResult = -2147024362;
            },
            $ctor1: function (message) {
                this.$initialize();
                System.SystemException.$ctor1.call(this, message);
                this.HResult = -2147024362;
            },
            $ctor2: function (message, innerException) {
                this.$initialize();
                System.SystemException.$ctor2.call(this, message, innerException);
                this.HResult = -2147024362;
            }
        }
    });

    // @source ArrayTypeMismatchException.js

    Bridge.define("System.ArrayTypeMismatchException", {
        inherits: [System.SystemException],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.SystemException.$ctor1.call(this, "Attempted to access an element as a type incompatible with the array.");
                this.HResult = -2146233085;
            },
            $ctor1: function (message) {
                this.$initialize();
                System.SystemException.$ctor1.call(this, message);
                this.HResult = -2146233085;
            },
            $ctor2: function (message, innerException) {
                this.$initialize();
                System.SystemException.$ctor2.call(this, message, innerException);
                this.HResult = -2146233085;
            }
        }
    });

    // @source MissingManifestResourceException.js

    Bridge.define("System.Resources.MissingManifestResourceException", {
        inherits: [System.SystemException],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.SystemException.$ctor1.call(this, "Unable to find manifest resource.");
                this.HResult = -2146233038;
            },
            $ctor1: function (message) {
                this.$initialize();
                System.SystemException.$ctor1.call(this, message);
                this.HResult = -2146233038;
            },
            $ctor2: function (message, inner) {
                this.$initialize();
                System.SystemException.$ctor2.call(this, message, inner);
                this.HResult = -2146233038;
            }
        }
    });

    // @source TextInfo.js

    Bridge.define("System.Globalization.TextInfo", {
        inherits: [System.ICloneable],
        fields: {
            listSeparator: null
        },
        props: {
            ANSICodePage: 0,
            CultureName: null,
            EBCDICCodePage: 0,
            IsReadOnly: false,
            IsRightToLeft: false,
            LCID: 0,
            ListSeparator: {
                get: function () {
                    return this.listSeparator;
                },
                set: function (value) {
                    this.VerifyWritable();

                    this.listSeparator = value;
                }
            },
            MacCodePage: 0,
            OEMCodePage: 0
        },
        alias: ["clone", "System$ICloneable$clone"],
        methods: {
            clone: function () {
                return Bridge.copy(new System.Globalization.TextInfo(), this, System.Array.init(["ANSICodePage", "CultureName", "EBCDICCodePage", "IsRightToLeft", "LCID", "listSeparator", "MacCodePage", "OEMCodePage", "IsReadOnly"], System.String));
            },
            VerifyWritable: function () {
                if (this.IsReadOnly) {
                    throw new System.InvalidOperationException.$ctor1("Instance is read-only.");
                }
            }
        }
    });

    // @source BidiCategory.js

    Bridge.define("System.Globalization.BidiCategory", {
        $kind: "enum",
        statics: {
            fields: {
                LeftToRight: 0,
                LeftToRightEmbedding: 1,
                LeftToRightOverride: 2,
                RightToLeft: 3,
                RightToLeftArabic: 4,
                RightToLeftEmbedding: 5,
                RightToLeftOverride: 6,
                PopDirectionalFormat: 7,
                EuropeanNumber: 8,
                EuropeanNumberSeparator: 9,
                EuropeanNumberTerminator: 10,
                ArabicNumber: 11,
                CommonNumberSeparator: 12,
                NonSpacingMark: 13,
                BoundaryNeutral: 14,
                ParagraphSeparator: 15,
                SegmentSeparator: 16,
                Whitespace: 17,
                OtherNeutrals: 18,
                LeftToRightIsolate: 19,
                RightToLeftIsolate: 20,
                FirstStrongIsolate: 21,
                PopDirectionIsolate: 22
            }
        }
    });

    // @source SortVersion.js

    Bridge.define("System.Globalization.SortVersion", {
        inherits: function () { return [System.IEquatable$1(System.Globalization.SortVersion)]; },
        statics: {
            methods: {
                op_Equality: function (left, right) {
                    if (left != null) {
                        return left.equalsT(right);
                    }

                    if (right != null) {
                        return right.equalsT(left);
                    }

                    return true;
                },
                op_Inequality: function (left, right) {
                    return !(System.Globalization.SortVersion.op_Equality(left, right));
                }
            }
        },
        fields: {
            m_NlsVersion: 0,
            m_SortId: null
        },
        props: {
            FullVersion: {
                get: function () {
                    return this.m_NlsVersion;
                }
            },
            SortId: {
                get: function () {
                    return this.m_SortId;
                }
            }
        },
        alias: ["equalsT", "System$IEquatable$1$System$Globalization$SortVersion$equalsT"],
        ctors: {
            init: function () {
                this.m_SortId = new System.Guid();
            },
            ctor: function (fullVersion, sortId) {
                this.$initialize();
                this.m_SortId = sortId;
                this.m_NlsVersion = fullVersion;
            },
            $ctor1: function (nlsVersion, effectiveId, customVersion) {
                this.$initialize();
                this.m_NlsVersion = nlsVersion;

                if (System.Guid.op_Equality(customVersion, System.Guid.Empty)) {
                    var b1 = (effectiveId >> 24) & 255;
                    var b2 = ((effectiveId & 16711680) >> 16) & 255;
                    var b3 = ((effectiveId & 65280) >> 8) & 255;
                    var b4 = (effectiveId & 255) & 255;
                    customVersion = new System.Guid.$ctor2(0, 0, 0, 0, 0, 0, 0, b1, b2, b3, b4);
                }

                this.m_SortId = customVersion;
            }
        },
        methods: {
            equals: function (obj) {
                var n = Bridge.as(obj, System.Globalization.SortVersion);
                if (System.Globalization.SortVersion.op_Inequality(n, null)) {
                    return this.equalsT(n);
                }

                return false;
            },
            equalsT: function (other) {
                if (System.Globalization.SortVersion.op_Equality(other, null)) {
                    return false;
                }

                return this.m_NlsVersion === other.m_NlsVersion && System.Guid.op_Equality(this.m_SortId, other.m_SortId);
            },
            getHashCode: function () {
                return Bridge.Int.mul(this.m_NlsVersion, 7) | this.m_SortId.getHashCode();
            }
        }
    });

    // @source UnicodeCategory.js

    Bridge.define("System.Globalization.UnicodeCategory", {
        $kind: "enum",
        statics: {
            fields: {
                UppercaseLetter: 0,
                LowercaseLetter: 1,
                TitlecaseLetter: 2,
                ModifierLetter: 3,
                OtherLetter: 4,
                NonSpacingMark: 5,
                SpacingCombiningMark: 6,
                EnclosingMark: 7,
                DecimalDigitNumber: 8,
                LetterNumber: 9,
                OtherNumber: 10,
                SpaceSeparator: 11,
                LineSeparator: 12,
                ParagraphSeparator: 13,
                Control: 14,
                Format: 15,
                Surrogate: 16,
                PrivateUse: 17,
                ConnectorPunctuation: 18,
                DashPunctuation: 19,
                OpenPunctuation: 20,
                ClosePunctuation: 21,
                InitialQuotePunctuation: 22,
                FinalQuotePunctuation: 23,
                OtherPunctuation: 24,
                MathSymbol: 25,
                CurrencySymbol: 26,
                ModifierSymbol: 27,
                OtherSymbol: 28,
                OtherNotAssigned: 29
            }
        }
    });

    // @source DaylightTimeStruct.js

    Bridge.define("System.Globalization.DaylightTimeStruct", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new System.Globalization.DaylightTimeStruct(); }
            }
        },
        fields: {
            Start: null,
            End: null,
            Delta: null
        },
        ctors: {
            init: function () {
                this.Start = System.DateTime.getDefaultValue();
                this.End = System.DateTime.getDefaultValue();
                this.Delta = new System.TimeSpan();
            },
            $ctor1: function (start, end, delta) {
                this.$initialize();
                this.Start = start;
                this.End = end;
                this.Delta = delta;
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
                var h = Bridge.addHash([7445027511, this.Start, this.End, this.Delta]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, System.Globalization.DaylightTimeStruct)) {
                    return false;
                }
                return Bridge.equals(this.Start, o.Start) && Bridge.equals(this.End, o.End) && Bridge.equals(this.Delta, o.Delta);
            },
            $clone: function (to) {
                var s = to || new System.Globalization.DaylightTimeStruct();
                s.Start = this.Start;
                s.End = this.End;
                s.Delta = this.Delta;
                return s;
            }
        }
    });

    // @source DaylightTime.js

    Bridge.define("System.Globalization.DaylightTime", {
        fields: {
            _start: null,
            _end: null,
            _delta: null
        },
        props: {
            Start: {
                get: function () {
                    return this._start;
                }
            },
            End: {
                get: function () {
                    return this._end;
                }
            },
            Delta: {
                get: function () {
                    return this._delta;
                }
            }
        },
        ctors: {
            init: function () {
                this._start = System.DateTime.getDefaultValue();
                this._end = System.DateTime.getDefaultValue();
                this._delta = new System.TimeSpan();
            },
            ctor: function () {
                this.$initialize();
            },
            $ctor1: function (start, end, delta) {
                this.$initialize();
                this._start = start;
                this._end = end;
                this._delta = delta;
            }
        }
    });

    // @source Globalization.js

    Bridge.define("System.Globalization.DateTimeFormatInfo", {
        inherits: [System.IFormatProvider, System.ICloneable],

        config: {
            alias: [
                "getFormat", "System$IFormatProvider$getFormat"
            ]
        },

        statics: {
            $allStandardFormats: {
                "d": "shortDatePattern",
                "D": "longDatePattern",
                "f": "longDatePattern shortTimePattern",
                "F": "longDatePattern longTimePattern",
                "g": "shortDatePattern shortTimePattern",
                "G": "shortDatePattern longTimePattern",
                "m": "monthDayPattern",
                "M": "monthDayPattern",
                "o": "roundtripFormat",
                "O": "roundtripFormat",
                "r": "rfc1123",
                "R": "rfc1123",
                "s": "sortableDateTimePattern",
                "S": "sortableDateTimePattern1",
                "t": "shortTimePattern",
                "T": "longTimePattern",
                "u": "universalSortableDateTimePattern",
                "U": "longDatePattern longTimePattern",
                "y": "yearMonthPattern",
                "Y": "yearMonthPattern"
            },

            ctor: function () {
                this.invariantInfo = Bridge.merge(new System.Globalization.DateTimeFormatInfo(), {
                    abbreviatedDayNames: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
                    abbreviatedMonthGenitiveNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", ""],
                    abbreviatedMonthNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", ""],
                    amDesignator: "AM",
                    dateSeparator: "/",
                    dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
                    firstDayOfWeek: 0,
                    fullDateTimePattern: "dddd, dd MMMM yyyy HH:mm:ss",
                    longDatePattern: "dddd, dd MMMM yyyy",
                    longTimePattern: "HH:mm:ss",
                    monthDayPattern: "MMMM dd",
                    monthGenitiveNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December", ""],
                    monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December", ""],
                    pmDesignator: "PM",
                    rfc1123: "ddd, dd MMM yyyy HH':'mm':'ss 'GMT'",
                    shortDatePattern: "MM/dd/yyyy",
                    shortestDayNames: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
                    shortTimePattern: "HH:mm",
                    sortableDateTimePattern: "yyyy'-'MM'-'dd'T'HH':'mm':'ss",
                    sortableDateTimePattern1: "yyyy'-'MM'-'dd",
                    timeSeparator: ":",
                    universalSortableDateTimePattern: "yyyy'-'MM'-'dd HH':'mm':'ss'Z'",
                    yearMonthPattern: "yyyy MMMM",
                    roundtripFormat: "yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffzzz"
                });
            }
        },

        getFormat: function (type) {
            switch (type) {
                case System.Globalization.DateTimeFormatInfo:
                    return this;
                default:
                    return null;
            }
        },

        getAbbreviatedDayName: function (dayofweek) {
            if (dayofweek < 0 || dayofweek > 6) {
                throw new System.ArgumentOutOfRangeException$ctor1("dayofweek");
            }

            return this.abbreviatedDayNames[dayofweek];
        },

        getAbbreviatedMonthName: function (month) {
            if (month < 1 || month > 13) {
                throw new System.ArgumentOutOfRangeException.$ctor1("month");
            }

            return this.abbreviatedMonthNames[month - 1];
        },

        getAllDateTimePatterns: function (format, returnNull) {
            var f = System.Globalization.DateTimeFormatInfo.$allStandardFormats,
                formats,
                names,
                pattern,
                i,
                result = [];

            if (format) {
                if (!f[format]) {
                    if (returnNull) {
                        return null;
                    }

                    throw new System.ArgumentException.$ctor3("", "format");
                }

                formats = {};
                formats[format] = f[format];
            } else {
                formats = f;
            }

            for (f in formats) {
                names = formats[f].split(" ");
                pattern = "";

                for (i = 0; i < names.length; i++) {
                    pattern = (i === 0 ? "" : (pattern + " ")) + this[names[i]];
                }

                result.push(pattern);
            }

            return result;
        },

        getDayName: function (dayofweek) {
            if (dayofweek < 0 || dayofweek > 6) {
                throw new System.ArgumentOutOfRangeException.$ctor1("dayofweek");
            }

            return this.dayNames[dayofweek];
        },

        getMonthName: function (month) {
            if (month < 1 || month > 13) {
                throw new System.ArgumentOutOfRangeException.$ctor1("month");
            }

            return this.monthNames[month - 1];
        },

        getShortestDayName: function (dayOfWeek) {
            if (dayOfWeek < 0 || dayOfWeek > 6) {
                throw new System.ArgumentOutOfRangeException.$ctor1("dayOfWeek");
            }

            return this.shortestDayNames[dayOfWeek];
        },

        clone: function () {
            return Bridge.copy(new System.Globalization.DateTimeFormatInfo(), this, [
                "abbreviatedDayNames",
                "abbreviatedMonthGenitiveNames",
                "abbreviatedMonthNames",
                "amDesignator",
                "dateSeparator",
                "dayNames",
                "firstDayOfWeek",
                "fullDateTimePattern",
                "longDatePattern",
                "longTimePattern",
                "monthDayPattern",
                "monthGenitiveNames",
                "monthNames",
                "pmDesignator",
                "rfc1123",
                "shortDatePattern",
                "shortestDayNames",
                "shortTimePattern",
                "sortableDateTimePattern",
                "timeSeparator",
                "universalSortableDateTimePattern",
                "yearMonthPattern",
                "roundtripFormat"
            ]);
        }
    });

    Bridge.define("System.Globalization.NumberFormatInfo", {
        inherits: [System.IFormatProvider, System.ICloneable],

        config: {
            alias: [
                "getFormat", "System$IFormatProvider$getFormat"
            ]
        },

        statics: {
            ctor: function () {
                this.numberNegativePatterns = ["(n)", "-n", "- n", "n-", "n -"];
                this.currencyNegativePatterns = ["($n)", "-$n", "$-n", "$n-", "(n$)", "-n$", "n-$", "n$-", "-n $", "-$ n", "n $-", "$ n-", "$ -n", "n- $", "($ n)", "(n $)"];
                this.currencyPositivePatterns = ["$n", "n$", "$ n", "n $"];
                this.percentNegativePatterns = ["-n %", "-n%", "-%n", "%-n", "%n-", "n-%", "n%-", "-% n", "n %-", "% n-", "% -n", "n- %"];
                this.percentPositivePatterns = ["n %", "n%", "%n", "% n"];

                this.invariantInfo = Bridge.merge(new System.Globalization.NumberFormatInfo(), {
                    nanSymbol: "NaN",
                    negativeSign: "-",
                    positiveSign: "+",
                    negativeInfinitySymbol: "-Infinity",
                    positiveInfinitySymbol: "Infinity",

                    percentSymbol: "%",
                    percentGroupSizes: [3],
                    percentDecimalDigits: 2,
                    percentDecimalSeparator: ".",
                    percentGroupSeparator: ",",
                    percentPositivePattern: 0,
                    percentNegativePattern: 0,

                    currencySymbol: "",
                    currencyGroupSizes: [3],
                    currencyDecimalDigits: 2,
                    currencyDecimalSeparator: ".",
                    currencyGroupSeparator: ",",
                    currencyNegativePattern: 0,
                    currencyPositivePattern: 0,

                    numberGroupSizes: [3],
                    numberDecimalDigits: 2,
                    numberDecimalSeparator: ".",
                    numberGroupSeparator: ",",
                    numberNegativePattern: 1
                });
            }
        },

        getFormat: function (type) {
            switch (type) {
                case System.Globalization.NumberFormatInfo:
                    return this;
                default:
                    return null;
            }
        },

        clone: function () {
            return Bridge.copy(new System.Globalization.NumberFormatInfo(), this, [
                "nanSymbol",
                "negativeSign",
                "positiveSign",
                "negativeInfinitySymbol",
                "positiveInfinitySymbol",
                "percentSymbol",
                "percentGroupSizes",
                "percentDecimalDigits",
                "percentDecimalSeparator",
                "percentGroupSeparator",
                "percentPositivePattern",
                "percentNegativePattern",
                "currencySymbol",
                "currencyGroupSizes",
                "currencyDecimalDigits",
                "currencyDecimalSeparator",
                "currencyGroupSeparator",
                "currencyNegativePattern",
                "currencyPositivePattern",
                "numberGroupSizes",
                "numberDecimalDigits",
                "numberDecimalSeparator",
                "numberGroupSeparator",
                "numberNegativePattern"
            ]);
        }
    });

    Bridge.define("System.Globalization.CultureInfo", {
        inherits: [System.IFormatProvider, System.ICloneable],

        config: {
            alias: [
                "getFormat", "System$IFormatProvider$getFormat"
            ]
        },

        $entryPoint: true,

        statics: {
            ctor: function () {
                this.cultures = this.cultures || {};

                this.invariantCulture = Bridge.merge(new System.Globalization.CultureInfo("iv", true), {
                    englishName: "Invariant Language (Invariant Country)",
                    nativeName: "Invariant Language (Invariant Country)",
                    numberFormat: System.Globalization.NumberFormatInfo.invariantInfo,
                    dateTimeFormat: System.Globalization.DateTimeFormatInfo.invariantInfo,
                    TextInfo: Bridge.merge(new System.Globalization.TextInfo(), {
                        ANSICodePage: 1252,
                        CultureName: "",
                        EBCDICCodePage: 37,
                        listSeparator: ",",
                        IsRightToLeft: false,
                        LCID: 127,
                        MacCodePage: 10000,
                        OEMCodePage: 437,
                        IsReadOnly: true
                    })
                });

                this.setCurrentCulture(System.Globalization.CultureInfo.invariantCulture);
            },

            getCurrentCulture: function () {
                return this.currentCulture;
            },

            setCurrentCulture: function (culture) {
                this.currentCulture = culture;

                System.Globalization.DateTimeFormatInfo.currentInfo = culture.dateTimeFormat;
                System.Globalization.NumberFormatInfo.currentInfo = culture.numberFormat;
            },

            getCultureInfo: function (name) {
                if (name == null) {
                    throw new System.ArgumentNullException.$ctor1("name");
                } else if (name === "") {
                    return System.Globalization.CultureInfo.invariantCulture;
                }

                var c = this.cultures[name];

                if (c == null) {
                    throw new System.Globalization.CultureNotFoundException.$ctor5("name", name);
                }

                return c;
            },

            getCultures: function () {
                var names = Bridge.getPropertyNames(this.cultures),
                    result = [],
                    i;

                for (i = 0; i < names.length; i++) {
                    result.push(this.cultures[names[i]]);
                }

                return result;
            }
        },

        ctor: function (name, create) {
            this.$initialize();
            this.name = name;

            if (!System.Globalization.CultureInfo.cultures) {
                System.Globalization.CultureInfo.cultures = {};
            }

            if (name == null) {
                throw new System.ArgumentNullException.$ctor1("name");
            }

            var c;

            if (name === "") {
                c =  System.Globalization.CultureInfo.invariantCulture;
            } else {
                c = System.Globalization.CultureInfo.cultures[name];
            }

            if (c == null) {
                if (!create) {
                    throw new System.Globalization.CultureNotFoundException.$ctor5("name", name);
                }

                System.Globalization.CultureInfo.cultures[name] = this;
            } else {
                Bridge.copy(this, c, [
                            "englishName",
                            "nativeName",
                            "numberFormat",
                            "dateTimeFormat",
                            "TextInfo"
                ]);

                this.TextInfo.IsReadOnly = false;
            }
        },

        getFormat: function (type) {
            switch (type) {
                case System.Globalization.NumberFormatInfo:
                    return this.numberFormat;
                case System.Globalization.DateTimeFormatInfo:
                    return this.dateTimeFormat;
                default:
                    return null;
            }
        },

        clone: function () {
            return new System.Globalization.CultureInfo(this.name);
        }
    });

    // @source Environment.js

    Bridge.define("System.Environment", {
        statics: {
            fields: {
                Variables: null
            },
            props: {
                Location: {
                    get: function () {
                        var g = Bridge.global;

                        if (g && g.location) {
                            return g.location;
                        }

                        return null;
                    }
                },
                CommandLine: {
                    get: function () {
                        return System.Environment.GetCommandLineArgs().join(" ");
                    }
                },
                CurrentDirectory: {
                    get: function () {
                        var l = System.Environment.Location;

                        return l ? l.pathname : "";
                    },
                    set: function (value) {
                        var l = System.Environment.Location;

                        if (l) {
                            l.pathname = value;
                        }
                    }
                },
                ExitCode: 0,
                Is64BitOperatingSystem: {
                    get: function () {
                        var n = Bridge.global ? Bridge.global.navigator : null;

                        if (n && (!Bridge.referenceEquals(n.userAgent.indexOf("WOW64"), -1) || !Bridge.referenceEquals(n.userAgent.indexOf("Win64"), -1))) {
                            return true;
                        }

                        return false;
                    }
                },
                ProcessorCount: {
                    get: function () {
                        var n = Bridge.global ? Bridge.global.navigator : null;

                        if (n && n.hardwareConcurrency) {
                            return n.hardwareConcurrency;
                        }

                        return 1;
                    }
                },
                StackTrace: {
                    get: function () {
                        var err = new Error();
                        var s = err.stack;

                        if (!System.String.isNullOrEmpty(s)) {
                            if (System.String.indexOf(s, "at") >= 0) {
                                return s.substr(System.String.indexOf(s, "at"));
                            }
                        }

                        return "";
                    }
                },
                Version: {
                    get: function () {
                        var s = Bridge.SystemAssembly.compiler;

                        var v = { };

                        if (System.Version.tryParse(s, v)) {
                            return v.v;
                        }

                        return new System.Version.ctor();
                    }
                }
            },
            ctors: {
                init: function () {
                    this.ExitCode = 0;
                },
                ctor: function () {
                    System.Environment.Variables = new (System.Collections.Generic.Dictionary$2(System.String,System.String))();
                    System.Environment.PatchDictionary(System.Environment.Variables);
                }
            },
            methods: {
                GetResourceString: function (key) {
                    return key;
                },
                GetResourceString$1: function (key, values) {
                    if (values === void 0) { values = []; }
                    var s = System.Environment.GetResourceString(key);
                    return System.String.formatProvider.apply(System.String, [System.Globalization.CultureInfo.getCurrentCulture(), s].concat(values));
                },
                PatchDictionary: function (d) {
                    d.noKeyCheck = true;

                    return d;
                },
                Exit: function (exitCode) {
                    System.Environment.ExitCode = exitCode;
                },
                ExpandEnvironmentVariables: function (name) {
                    var $t;
                    if (name == null) {
                        throw new System.ArgumentNullException.$ctor1(name);
                    }

                    $t = Bridge.getEnumerator(System.Environment.Variables);
                    try {
                        while ($t.moveNext()) {
                            var pair = $t.Current;
                            name = System.String.replaceAll(name, "%" + (pair.key || "") + "%", pair.value);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    return name;
                },
                FailFast: function (message) {
                    throw new System.Exception(message);
                },
                FailFast$1: function (message, exception) {
                    throw new System.Exception(message, exception);
                },
                GetCommandLineArgs: function () {
                    var l = System.Environment.Location;

                    if (l) {
                        var args = new (System.Collections.Generic.List$1(System.String)).ctor();

                        var path = l.pathname;

                        if (!System.String.isNullOrEmpty(path)) {
                            args.add(path);
                        }

                        var search = l.search;

                        if (!System.String.isNullOrEmpty(search) && search.length > 1) {
                            var query = System.String.split(search.substr(1), [38].map(function (i) {{ return String.fromCharCode(i); }}));

                            for (var i = 0; i < query.length; i = (i + 1) | 0) {
                                var param = System.String.split(query[System.Array.index(i, query)], [61].map(function (i) {{ return String.fromCharCode(i); }}));

                                for (var j = 0; j < param.length; j = (j + 1) | 0) {
                                    args.add(param[System.Array.index(j, param)]);
                                }
                            }
                        }

                        return args.ToArray();
                    }

                    return System.Array.init(0, null, System.String);
                },
                GetEnvironmentVariable: function (variable) {
                    if (variable == null) {
                        throw new System.ArgumentNullException.$ctor1("variable");
                    }

                    var r = { };

                    if (System.Environment.Variables.tryGetValue(variable.toLowerCase(), r)) {
                        return r.v;
                    }

                    return null;
                },
                GetEnvironmentVariable$1: function (variable, target) {
                    return System.Environment.GetEnvironmentVariable(variable);
                },
                GetEnvironmentVariables: function () {
                    return System.Environment.PatchDictionary(new (System.Collections.Generic.Dictionary$2(System.String,System.String))(System.Environment.Variables));
                },
                GetEnvironmentVariables$1: function (target) {
                    return System.Environment.GetEnvironmentVariables();
                },
                GetLogicalDrives: function () {
                    return System.Array.init(0, null, System.String);
                },
                SetEnvironmentVariable: function (variable, value) {
                    if (variable == null) {
                        throw new System.ArgumentNullException.$ctor1("variable");
                    }

                    if (System.String.isNullOrEmpty(variable) || System.String.startsWith(variable, String.fromCharCode(0)) || System.String.contains(variable,"=") || variable.length > 32767) {
                        throw new System.ArgumentException.$ctor1("Incorrect variable (cannot be empty, contain zero character nor equal sign, be longer than 32767).");
                    }

                    variable = variable.toLowerCase();

                    if (System.String.isNullOrEmpty(value)) {
                        if (System.Environment.Variables.containsKey(variable)) {
                            System.Environment.Variables.remove(variable);
                        }
                    } else {
                        System.Environment.Variables.set(variable, value);
                    }
                },
                SetEnvironmentVariable$1: function (variable, value, target) {
                    System.Environment.SetEnvironmentVariable(variable, value);
                }
            }
        }
    });

    // @source StringSplitOptions.js

    Bridge.define("System.StringSplitOptions", {
        $kind: "enum",
        statics: {
            fields: {
                None: 0,
                RemoveEmptyEntries: 1
            }
        },
        $flags: true
    });

    // @source Math.js

    Bridge.Math = {
        divRem: function (a, b, result) {
            var remainder = a % b;

            result.v = remainder;

            return (a - remainder) / b;
        },

        round: function (n, d, rounding) {
            var m = Math.pow(10, d || 0);

            n *= m;

            var sign = (n > 0) | -(n < 0);

            if (n % 1 === 0.5 * sign) {
                var f = Math.floor(n);

                return (f + (rounding === 4 ? (sign > 0) : (f % 2 * sign))) / m;
            }

            return Math.round(n) / m;
        },

        log10: Math.log10 || function (x) {
            return Math.log(x) / Math.LN10;
        },

        logWithBase: function (x, newBase) {
            if (isNaN(x)) {
                return x;
            }

            if (isNaN(newBase)) {
                return newBase;
            }

            if (newBase === 1) {
                return NaN
            }

            if (x !== 1 && (newBase === 0 || newBase === Number.POSITIVE_INFINITY)) {
                return NaN;
            }

            return Bridge.Math.log10(x) / Bridge.Math.log10(newBase);
        },

        log: function (x) {
            if (x === 0.0) {
                return Number.NEGATIVE_INFINITY;
            }

            if (x < 0.0 || isNaN(x)) {
                return NaN;
            }

            if (x === Number.POSITIVE_INFINITY) {
                return Number.POSITIVE_INFINITY;
            }

            if (x === Number.NEGATIVE_INFINITY) {
                return NaN;
            }

            return Math.log(x);
        },

        sinh: Math.sinh || function (x) {
            return (Math.exp(x) - Math.exp(-x)) / 2;
        },

        cosh: Math.cosh || function (x) {
            return (Math.exp(x) + Math.exp(-x)) / 2;
        },

        tanh: Math.tanh || function (x) {
            if (x === Infinity) {
                return 1;
            } else if (x === -Infinity) {
                return -1;
            } else {
                var y = Math.exp(2 * x);

                return (y - 1) / (y + 1);
            }
        }
    };

    // @source Bool.js

    Bridge.define("System.Boolean", {
        inherits: [System.IComparable],

        statics: {
            trueString: "True",
            falseString: "False",

            $is: function (instance) {
                return typeof (instance) === "boolean";
            },

            getDefaultValue: function () {
                return false;
            },

            createInstance: function () {
                return false;
            },

            toString: function (v) {
                return v ? System.Boolean.trueString : System.Boolean.falseString;
            },

            parse: function (value) {
                if (!Bridge.hasValue(value)) {
                    throw new System.ArgumentNullException.$ctor1("value");
                }

                var result = {
                    v: false
                };

                if (!System.Boolean.tryParse(value, result)) {
                    throw new System.FormatException.$ctor1("Bad format for Boolean value");
                }

                return result.v;
            },

            tryParse: function (value, result) {
                result.v = false;

                if (!Bridge.hasValue(value)) {
                    return false;
                }

                if (System.String.equals(System.Boolean.trueString, value, 5)) {
                    result.v = true;
                    return true;
                }

                if (System.String.equals(System.Boolean.falseString, value, 5)) {
                    result.v = false;
                    return true;
                }

                var start = 0,
                    end = value.length - 1;

                while (start < value.length) {
                    if (!System.Char.isWhiteSpace(value[start]) && !System.Char.isNull(value.charCodeAt(start))) {
                        break;
                    }

                    start++;
                }

                while (end >= start) {
                    if (!System.Char.isWhiteSpace(value[end]) && !System.Char.isNull(value.charCodeAt(end))) {
                        break;
                    }

                    end--;
                }

                value = value.substr(start, end - start + 1);

                if (System.String.equals(System.Boolean.trueString, value, 5)) {
                    result.v = true;

                    return true;
                }

                if (System.String.equals(System.Boolean.falseString, value, 5)) {
                    result.v = false;

                    return true;
                }

                return false;
            }
        }
    });

    System.Boolean.$kind = "";
    Bridge.Class.addExtend(System.Boolean, [System.IComparable$1(System.Boolean), System.IEquatable$1(System.Boolean)]);

    // @source Integer.js

    (function () {
        var createIntType = function (name, min, max, precision) {
            var type = Bridge.define(name, {
                inherits: [System.IComparable, System.IFormattable],

                statics: {
                    $number: true,
                    min: min,
                    max: max,
                    precision: precision,

                    $is: function (instance) {
                        return typeof (instance) === "number" && Math.floor(instance, 0) === instance && instance >= min && instance <= max;
                    },
                    getDefaultValue: function () {
                        return 0;
                    },
                    parse: function (s, radix) {
                        return Bridge.Int.parseInt(s, min, max, radix);
                    },
                    tryParse: function (s, result, radix) {
                        return Bridge.Int.tryParseInt(s, result, min, max, radix);
                    },
                    format: function (number, format, provider) {
                        return Bridge.Int.format(number, format, provider, type);
                    },
                    equals: function (v1, v2) {
                        if (Bridge.is(v1, type) && Bridge.is(v2, type)) {
                            return Bridge.unbox(v1, true) === Bridge.unbox(v2, true);
                        }

                        return false;
                    },
                    equalsT: function (v1, v2) {
                        return Bridge.unbox(v1, true) === Bridge.unbox(v2, true);
                    }
                }
            });

            type.$kind = "";
            Bridge.Class.addExtend(type, [System.IComparable$1(type), System.IEquatable$1(type)]);
        };

        createIntType("System.Byte", 0, 255, 3);
        createIntType("System.SByte", -128, 127, 3);
        createIntType("System.Int16", -32768, 32767, 5);
        createIntType("System.UInt16", 0, 65535, 5);
        createIntType("System.Int32", -2147483648, 2147483647, 10);
        createIntType("System.UInt32", 0, 4294967295, 10);
    })();

    Bridge.define("Bridge.Int", {
        inherits: [System.IComparable, System.IFormattable],
        statics: {
            $number: true,

            MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1,
            MIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER || -(Math.pow(2, 53) - 1),

            $is: function (instance) {
                return typeof (instance) === "number" && isFinite(instance) && Math.floor(instance, 0) === instance;
            },

            getDefaultValue: function () {
                return 0;
            },

            format: function (number, format, provider, T) {
                var nf = (provider || System.Globalization.CultureInfo.getCurrentCulture()).getFormat(System.Globalization.NumberFormatInfo),
                    decimalSeparator = nf.numberDecimalSeparator,
                    groupSeparator = nf.numberGroupSeparator,
                    isDecimal = number instanceof System.Decimal,
                    isLong = number instanceof System.Int64 || number instanceof System.UInt64,
                    isNeg = isDecimal || isLong ? (number.isZero() ? false : number.isNegative()) : number < 0,
                    match,
                    precision,
                    groups,
                    fs;

                if (!isLong && (isDecimal ? !number.isFinite() : !isFinite(number))) {
                    return Number.NEGATIVE_INFINITY === number || (isDecimal && isNeg) ? nf.negativeInfinitySymbol : (isNaN(number) ? nf.nanSymbol : nf.positiveInfinitySymbol);
                }

                if (!format) {
                    format = "G";
                }

                match = format.match(/^([a-zA-Z])(\d*)$/);

                if (match) {
                    fs = match[1].toUpperCase();
                    precision = parseInt(match[2], 10);
                    //precision = precision > 15 ? 15 : precision;

                    switch (fs) {
                        case "D":
                            return this.defaultFormat(number, isNaN(precision) ? 1 : precision, 0, 0, nf, true);
                        case "F":
                        case "N":
                            if (isNaN(precision)) {
                                precision = nf.numberDecimalDigits;
                            }

                            return this.defaultFormat(number, 1, precision, precision, nf, fs === "F");
                        case "G":
                        case "E":
                            var exponent = 0,
                                coefficient = isDecimal || isLong ? (isLong && number.eq(System.Int64.MinValue) ? System.Int64(number.value.toUnsigned()) : number.abs()) : Math.abs(number),
                                exponentPrefix = match[1],
                                exponentPrecision = 3,
                                minDecimals,
                                maxDecimals;

                            while (isDecimal || isLong ? coefficient.gte(10) : (coefficient >= 10)) {
                                if (isDecimal || isLong) {
                                    coefficient = coefficient.div(10);
                                } else {
                                    coefficient /= 10;
                                }

                                exponent++;
                            }

                            while (isDecimal || isLong ? (coefficient.ne(0) && coefficient.lt(1)) : (coefficient !== 0 && coefficient < 1)) {
                                if (isDecimal || isLong) {
                                    coefficient = coefficient.mul(10);
                                } else {
                                    coefficient *= 10;
                                }

                                exponent--;
                            }

                            if (fs === "G") {
                                var noPrecision = isNaN(precision);

                                if (noPrecision) {
                                    if (isDecimal) {
                                        precision = 29;
                                    } else if (isLong) {
                                        precision = number instanceof System.Int64 ? 19 : 20;
                                    } else if (T && T.precision) {
                                        precision = T.precision;
                                    } else {
                                        precision = 15;
                                    }
                                }

                                if ((exponent > -5 && exponent < precision) || isDecimal && noPrecision) {
                                    minDecimals = 0;
                                    maxDecimals = precision - (exponent > 0 ? exponent + 1 : 1);

                                    return this.defaultFormat(number, 1, minDecimals, maxDecimals, nf, true);
                                }

                                exponentPrefix = exponentPrefix === "G" ? "E" : "e";
                                exponentPrecision = 2;
                                minDecimals = 0;
                                maxDecimals = (precision || 15) - 1;
                            } else {
                                minDecimals = maxDecimals = isNaN(precision) ? 6 : precision;
                            }

                            if (exponent >= 0) {
                                exponentPrefix += nf.positiveSign;
                            } else {
                                exponentPrefix += nf.negativeSign;
                                exponent = -exponent;
                            }

                            if (isNeg) {
                                if (isDecimal || isLong) {
                                    coefficient = coefficient.mul(-1);
                                } else {
                                    coefficient *= -1;
                                }
                            }

                            return this.defaultFormat(coefficient, 1, minDecimals, maxDecimals, nf) + exponentPrefix + this.defaultFormat(exponent, exponentPrecision, 0, 0, nf, true);
                        case "P":
                            if (isNaN(precision)) {
                                precision = nf.percentDecimalDigits;
                            }

                            return this.defaultFormat(number * 100, 1, precision, precision, nf, false, "percent");
                        case "X":
                            var result = isDecimal ? number.round().value.toHex().substr(2) : (isLong ? number.toString(16) : Math.round(number).toString(16));

                            if (match[1] === "X") {
                                result = result.toUpperCase();
                            }

                            precision -= result.length;

                            while (precision-- > 0) {
                                result = "0" + result;
                            }

                            return result;
                        case "C":
                            if (isNaN(precision)) {
                                precision = nf.currencyDecimalDigits;
                            }

                            return this.defaultFormat(number, 1, precision, precision, nf, false, "currency");
                        case "R":
                            var r_result = isDecimal || isLong ? (number.toString()) : ("" + number);

                            if (decimalSeparator !== ".") {
                                r_result = r_result.replace(".", decimalSeparator);
                            }

                            r_result = r_result.replace("e", "E");

                            return r_result;
                    }
                }

                if (format.indexOf(",.") !== -1 || System.String.endsWith(format, ",")) {
                    var count = 0,
                        index = format.indexOf(",.");

                    if (index === -1) {
                        index = format.length - 1;
                    }

                    while (index > -1 && format.charAt(index) === ",") {
                        count++;
                        index--;
                    }

                    if (isDecimal || isLong) {
                        number = number.div(Math.pow(1000, count));
                    } else {
                        number /= Math.pow(1000, count);
                    }
                }

                if (format.indexOf("%") !== -1) {
                    if (isDecimal || isLong) {
                        number = number.mul(100);
                    } else {
                        number *= 100;
                    }
                }

                if (format.indexOf("") !== -1) {
                    if (isDecimal || isLong) {
                        number = number.mul(1000);
                    } else {
                        number *= 1000;
                    }
                }

                groups = format.split(";");

                if ((isDecimal || isLong ? number.lt(0) : (number < 0)) && groups.length > 1) {
                    if (isDecimal || isLong) {
                        number = number.mul(-1);
                    } else {
                        number *= -1;
                    }

                    format = groups[1];
                } else {
                    format = groups[(isDecimal || isLong ? number.ne(0) : !number) && groups.length > 2 ? 2 : 0];
                }

                return this.customFormat(number, format, nf, !format.match(/^[^\.]*[0#],[0#]/));
            },

            defaultFormat: function (number, minIntLen, minDecLen, maxDecLen, provider, noGroup, name) {
                name = name || "number";

                var nf = (provider || System.Globalization.CultureInfo.getCurrentCulture()).getFormat(System.Globalization.NumberFormatInfo),
                    str,
                    decimalIndex,
                    pattern,
                    roundingFactor,
                    groupIndex,
                    groupSize,
                    groups = nf[name + "GroupSizes"],
                    decimalPart,
                    index,
                    done,
                    startIndex,
                    length,
                    part,
                    sep,
                    buffer = "",
                    isDecimal = number instanceof System.Decimal,
                    isLong = number instanceof System.Int64 || number instanceof System.UInt64,
                    isNeg = isDecimal || isLong ? (number.isZero() ? false : number.isNegative()) : number < 0,
                    isZero = false;

                roundingFactor = Math.pow(10, maxDecLen);

                if (isDecimal) {
                    str = number.abs().toDecimalPlaces(maxDecLen).toFixed();
                } else if (isLong) {
                    str = number.eq(System.Int64.MinValue) ? number.value.toUnsigned().toString() : number.abs().toString();
                } else {
                    str = "" + (+Math.abs(number).toFixed(maxDecLen));
                }

                isZero = str.split("").every(function (s) { return s === "0" || s === "."; });

                decimalIndex = str.indexOf(".");

                if (decimalIndex > 0) {
                    decimalPart = nf[name + "DecimalSeparator"] + str.substr(decimalIndex + 1);
                    str = str.substr(0, decimalIndex);
                }

                if (str.length < minIntLen) {
                    str = Array(minIntLen - str.length + 1).join("0") + str;
                }

                if (decimalPart) {
                    if ((decimalPart.length - 1) < minDecLen) {
                        decimalPart += Array(minDecLen - decimalPart.length + 2).join("0");
                    }

                    if (maxDecLen === 0) {
                        decimalPart = null;
                    } else if ((decimalPart.length - 1) > maxDecLen) {
                        decimalPart = decimalPart.substr(0, maxDecLen + 1);
                    }
                } else if (minDecLen > 0) {
                    decimalPart = nf[name + "DecimalSeparator"] + Array(minDecLen + 1).join("0");
                }

                groupIndex = 0;
                groupSize = groups[groupIndex];

                if (str.length < groupSize) {
                    buffer = str;

                    if (decimalPart) {
                        buffer += decimalPart;
                    }
                } else {
                    index = str.length;
                    done = false;
                    sep = noGroup ? "" : nf[name + "GroupSeparator"];

                    while (!done) {
                        length = groupSize;
                        startIndex = index - length;

                        if (startIndex < 0) {
                            groupSize += startIndex;
                            length += startIndex;
                            startIndex = 0;
                            done = true;
                        }

                        if (!length) {
                            break;
                        }

                        part = str.substr(startIndex, length);

                        if (buffer.length) {
                            buffer = part + sep + buffer;
                        } else {
                            buffer = part;
                        }

                        index -= length;

                        if (groupIndex < groups.length - 1) {
                            groupIndex++;
                            groupSize = groups[groupIndex];
                        }
                    }

                    if (decimalPart) {
                        buffer += decimalPart;
                    }
                }

                if (isNeg && !isZero) {
                    pattern = System.Globalization.NumberFormatInfo[name + "NegativePatterns"][nf[name + "NegativePattern"]];

                    return pattern.replace("-", nf.negativeSign).replace("%", nf.percentSymbol).replace("$", nf.currencySymbol).replace("n", buffer);
                } else if (System.Globalization.NumberFormatInfo[name + "PositivePatterns"]) {
                    pattern = System.Globalization.NumberFormatInfo[name + "PositivePatterns"][nf[name + "PositivePattern"]];

                    return pattern.replace("%", nf.percentSymbol).replace("$", nf.currencySymbol).replace("n", buffer);
                }

                return buffer;
            },

            customFormat: function (number, format, nf, noGroup) {
                var digits = 0,
                    forcedDigits = -1,
                    integralDigits = -1,
                    decimals = 0,
                    forcedDecimals = -1,
                    atDecimals = 0,
                    unused = 1,
                    c, i, f,
                    endIndex,
                    roundingFactor,
                    decimalIndex,
                    isNegative = false,
                    isZero = false,
                    name,
                    groupCfg,
                    buffer = "",
                    isZeroInt = false,
                    wasSeparator = false,
                    wasIntPart = false,
                    isDecimal = number instanceof System.Decimal,
                    isLong = number instanceof System.Int64 || number instanceof System.UInt64,
                    isNeg = isDecimal || isLong ? (number.isZero() ? false : number.isNegative()) : number < 0;

                name = "number";

                if (format.indexOf("%") !== -1) {
                    name = "percent";
                } else if (format.indexOf("$") !== -1) {
                    name = "currency";
                }

                for (i = 0; i < format.length; i++) {
                    c = format.charAt(i);

                    if (c === "'" || c === '"') {
                        i = format.indexOf(c, i + 1);

                        if (i < 0) {
                            break;
                        }
                    } else if (c === "\\") {
                        i++;
                    } else {
                        if (c === "0" || c === "#") {
                            decimals += atDecimals;

                            if (c === "0") {
                                if (atDecimals) {
                                    forcedDecimals = decimals;
                                } else if (forcedDigits < 0) {
                                    forcedDigits = digits;
                                }
                            }

                            digits += !atDecimals;
                        }

                        atDecimals = atDecimals || c === ".";
                    }
                }
                forcedDigits = forcedDigits < 0 ? 1 : digits - forcedDigits;

                if (isNeg) {
                    isNegative = true;
                }

                roundingFactor = Math.pow(10, decimals);

                if (isDecimal) {
                    number = System.Decimal.round(number.abs().mul(roundingFactor), 4).div(roundingFactor).toString();
                } else if (isLong) {
                    number = (number.eq(System.Int64.MinValue) ? System.Int64(number.value.toUnsigned()) : number.abs()).mul(roundingFactor).div(roundingFactor).toString();
                } else {
                    number = "" + (Math.round(Math.abs(number) * roundingFactor) / roundingFactor);
                }

                isZero = number.split("").every(function (s) { return s === "0" || s === "."; });

                decimalIndex = number.indexOf(".");
                integralDigits = decimalIndex < 0 ? number.length : decimalIndex;
                i = integralDigits - digits;

                groupCfg = {
                    groupIndex: Math.max(integralDigits, forcedDigits),
                    sep: noGroup ? "" : nf[name + "GroupSeparator"]
                };

                if (integralDigits === 1 && number.charAt(0) === "0") {
                    isZeroInt = true;
                }

                for (f = 0; f < format.length; f++) {
                    c = format.charAt(f);

                    if (c === "'" || c === '"') {
                        endIndex = format.indexOf(c, f + 1);

                        buffer += format.substring(f + 1, endIndex < 0 ? format.length : endIndex);

                        if (endIndex < 0) {
                            break;
                        }

                        f = endIndex;
                    } else if (c === "\\") {
                        buffer += format.charAt(f + 1);
                        f++;
                    } else if (c === "#" || c === "0") {
                        wasIntPart = true;

                        if (!wasSeparator && isZeroInt && c === "#") {
                            i++;
                        } else {
                            groupCfg.buffer = buffer;

                            if (i < integralDigits) {
                                if (i >= 0) {
                                    if (unused) {
                                        this.addGroup(number.substr(0, i), groupCfg);
                                    }

                                    this.addGroup(number.charAt(i), groupCfg);
                                } else if (i >= integralDigits - forcedDigits) {
                                    this.addGroup("0", groupCfg);
                                }

                                unused = 0;
                            } else if (forcedDecimals-- > 0 || i < number.length) {
                                this.addGroup(i >= number.length ? "0" : number.charAt(i), groupCfg);
                            }

                            buffer = groupCfg.buffer;

                            i++;
                        }
                    } else if (c === ".") {
                        if (!wasIntPart && !isZeroInt) {
                            buffer += number.substr(0, integralDigits);
                            wasIntPart = true;
                        }

                        if (number.length > ++i || forcedDecimals > 0) {
                            wasSeparator = true;
                            buffer += nf[name + "DecimalSeparator"];
                        }
                    } else if (c !== ",") {
                        buffer += c;
                    }
                }

                if (isNegative && !isZero) {
                    buffer = "-" + buffer;
                }

                return buffer;
            },

            addGroup: function (value, cfg) {
                var buffer = cfg.buffer,
                    sep = cfg.sep,
                    groupIndex = cfg.groupIndex;

                for (var i = 0, length = value.length; i < length; i++) {
                    buffer += value.charAt(i);

                    if (sep && groupIndex > 1 && groupIndex-- % 3 === 1) {
                        buffer += sep;
                    }
                }

                cfg.buffer = buffer;
                cfg.groupIndex = groupIndex;
            },

            parseFloat: function (s, provider) {
                var res = { };

                Bridge.Int.tryParseFloat(s, provider, res, false);

                return res.v;
            },

            tryParseFloat: function (s, provider, result, safe) {
                result.v = 0;

                if (safe == null) {
                    safe = true;
                }

                if (s == null) {
                    if (safe) {
                        return false;
                    }

                    throw new System.ArgumentNullException.$ctor1("s");
                }

                s = s.trim();

                var nfInfo = (provider || System.Globalization.CultureInfo.getCurrentCulture()).getFormat(System.Globalization.NumberFormatInfo),
                    point = nfInfo.numberDecimalSeparator,
                    thousands = nfInfo.numberGroupSeparator;

                var errMsg = "Input string was not in a correct format.";

                var pointIndex = s.indexOf(point);
                var thousandIndex = thousands ? s.indexOf(thousands) : -1;

                if (pointIndex > -1) {
                    // point before thousands is not allowed
                    // "10.2,5" -> FormatException
                    // "1,0.2,5" -> FormatException
                    if (((pointIndex < thousandIndex) || ((thousandIndex > -1) && (pointIndex < s.indexOf(thousands, pointIndex))))
                        // only one point is allowed
                        || (s.indexOf(point, pointIndex + 1) > -1)) {
                        if (safe) {
                            return false;
                        }

                        throw new System.FormatException.$ctor1(errMsg);
                    }
                }

                if ((point !== ".") && (thousands !== ".") && (s.indexOf(".") > -1)) {
                    if (safe) {
                        return false;
                    }

                    throw new System.FormatException.$ctor1(errMsg);
                }

                if (thousandIndex > -1) {
                    // mutiple thousands are allowed, so we remove them before going further
                    var tmpStr = "";

                    for (var i = 0; i < s.length; i++) {
                        if (s[i] !== thousands) {
                            tmpStr += s[i];
                        }
                    }

                    s = tmpStr;
                }

                if (s === nfInfo.negativeInfinitySymbol) {
                    result.v = Number.NEGATIVE_INFINITY;

                    return true;
                } else if (s === nfInfo.positiveInfinitySymbol) {
                    result.v = Number.POSITIVE_INFINITY;

                    return true;
                } else if (s === nfInfo.nanSymbol) {
                    result.v = Number.NaN;

                    return true;
                }

                var countExp = 0;

                for (var i = 0; i < s.length; i++) {
                    if (!System.Char.isNumber(s[i].charCodeAt(0)) &&
                        s[i] !== "." &&
                        s[i] !== "," &&
                        s[i] !== nfInfo.positiveSign &&
                        s[i] !== nfInfo.negativeSign &&
                        s[i] !== point &&
                        s[i] !== thousands) {
                        if (s[i].toLowerCase() === "e") {
                            countExp++;

                            if (countExp > 1) {
                                if (safe) {
                                    return false;
                                }

                                throw new System.FormatException.$ctor1(errMsg);
                            }
                        } else {
                            if (safe) {
                                return false;
                            }

                            throw new System.FormatException.$ctor1(errMsg);
                        }
                    }
                }

                var r = parseFloat(s.replace(point, "."));

                if (isNaN(r)) {
                    if (safe) {
                        return false;
                    }

                    throw new System.FormatException.$ctor1(errMsg);
                }

                result.v = r;

                return true;
            },

            parseInt: function (str, min, max, radix) {
                radix = radix || 10;

                if (str == null) {
                    throw new System.ArgumentNullException.$ctor1("str");
                }

                str = str.trim();

                if ((radix <= 10 && !/^[+-]?[0-9]+$/.test(str))
                    || (radix == 16 && !/^[+-]?[0-9A-F]+$/gi.test(str))) {
                    throw new System.FormatException.$ctor1("Input string was not in a correct format.");
                }

                var result = parseInt(str, radix);

                if (isNaN(result)) {
                    throw new System.FormatException.$ctor1("Input string was not in a correct format.");
                }

                if (result < min || result > max) {
                    throw new System.OverflowException();
                }

                return result;
            },

            tryParseInt: function (str, result, min, max, radix) {
                result.v = 0;
                radix = radix || 10;

                if (str != null && str.trim === "".trim) {
                    str = str.trim();
                }

                if ((radix <= 10 && !/^[+-]?[0-9]+$/.test(str))
                    || (radix == 16 && !/^[+-]?[0-9A-F]+$/gi.test(str))) {
                    return false;
                }

                result.v = parseInt(str, radix);

                if (result.v < min || result.v > max) {
                    result.v = 0;

                    return false;
                }

                return true;
            },

            isInfinite: function (x) {
                return x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY;
            },

            trunc: function (num) {
                if (!Bridge.isNumber(num)) {
                    return Bridge.Int.isInfinite(num) ? num : null;
                }

                return num > 0 ? Math.floor(num) : Math.ceil(num);
            },

            div: function (x, y) {
                if (x == null || y == null) {
                    return null;
                }

                if (y === 0) {
                    throw new System.DivideByZeroException();
                }

                return this.trunc(x / y);
            },

            mod: function (x, y) {
                if (x == null || y == null) {
                    return null;
                }

                if (y === 0) {
                    throw new System.DivideByZeroException();
                }

                return x % y;
            },

            check: function (x, type) {
                if (System.Int64.is64Bit(x)) {
                    return System.Int64.check(x, type);
                } else if (x instanceof System.Decimal) {
                    return System.Decimal.toInt(x, type);
                }

                if (Bridge.isNumber(x)) {
                    if (System.Int64.is64BitType(type)) {
                        if (type === System.UInt64 && x < 0) {
                            throw new System.OverflowException();
                        }

                        return type === System.Int64 ? System.Int64(x) : System.UInt64(x);
                    } else if (!type.$is(x)) {
                        throw new System.OverflowException();
                    }
                }

                if (Bridge.Int.isInfinite(x) || isNaN(x)) {
                    if (System.Int64.is64BitType(type)) {
                        return type.MinValue;
                    }

                    return type.min;
                }

                return x;
            },

            sxb: function (x) {
                return Bridge.isNumber(x) ? (x | (x & 0x80 ? 0xffffff00 : 0)) : ((Bridge.Int.isInfinite(x) || isNaN(x)) ? System.SByte.min : null);
            },

            sxs: function (x) {
                return Bridge.isNumber(x) ? (x | (x & 0x8000 ? 0xffff0000 : 0)) : ((Bridge.Int.isInfinite(x) || isNaN(x)) ? System.Int16.min : null);
            },

            clip8: function (x) {
                return Bridge.isNumber(x) ? Bridge.Int.sxb(x & 0xff) : ((Bridge.Int.isInfinite(x) || isNaN(x)) ? System.SByte.min : null);
            },

            clipu8: function (x) {
                return Bridge.isNumber(x) ? x & 0xff : ((Bridge.Int.isInfinite(x) || isNaN(x)) ? System.Byte.min : null);
            },

            clip16: function (x) {
                return Bridge.isNumber(x) ? Bridge.Int.sxs(x & 0xffff) : ((Bridge.Int.isInfinite(x) || isNaN(x)) ? System.Int16.min : null);
            },

            clipu16: function (x) {
                return Bridge.isNumber(x) ? x & 0xffff : ((Bridge.Int.isInfinite(x) || isNaN(x)) ? System.UInt16.min : null);
            },

            clip32: function (x) {
                return Bridge.isNumber(x) ? x | 0 : ((Bridge.Int.isInfinite(x) || isNaN(x)) ? System.Int32.min : null);
            },

            clipu32: function (x) {
                return Bridge.isNumber(x) ? x >>> 0 : ((Bridge.Int.isInfinite(x) || isNaN(x)) ? System.UInt32.min : null);
            },

            clip64: function (x) {
                return Bridge.isNumber(x) ? System.Int64(Bridge.Int.trunc(x)) : ((Bridge.Int.isInfinite(x) || isNaN(x)) ? System.Int64.MinValue : null);
            },

            clipu64: function (x) {
                return Bridge.isNumber(x) ? System.UInt64(Bridge.Int.trunc(x)) : ((Bridge.Int.isInfinite(x) || isNaN(x)) ? System.UInt64.MinValue : null);
            },

            sign: function (x) {
                return Bridge.isNumber(x) ? (x === 0 ? 0 : (x < 0 ? -1 : 1)) : null;
            },

            $mul: Math.imul || function (a, b) {
                var ah = (a >>> 16) & 0xffff,
                    al = a & 0xffff,
                    bh = (b >>> 16) & 0xffff,
                    bl = b & 0xffff;

                return ((al * bl) + (((ah * bl + al * bh) << 16) >>> 0) | 0);
            },

            mul: function (a, b, overflow) {
                if (a == null || b == null) {
                    return null;
                }

                if (overflow) {
                    Bridge.Int.check(a * b, System.Int32)
                }

                return Bridge.Int.$mul(a, b);
            },

            umul: function (a, b, overflow) {
                if (a == null || b == null) {
                    return null;
                }

                if (overflow) {
                    Bridge.Int.check(a * b, System.UInt32)
                }

                return Bridge.Int.$mul(a, b) >>> 0;
            }
        }
    });

    Bridge.Int.$kind = "";
    Bridge.Class.addExtend(Bridge.Int, [System.IComparable$1(Bridge.Int), System.IEquatable$1(Bridge.Int)]);

    // @source Double.js

    Bridge.define("System.Double", {
        inherits: [System.IComparable, System.IFormattable],
        statics: {
            min: -Number.MAX_VALUE,

            max: Number.MAX_VALUE,

            precision: 15,

            $number: true,

            $is: function (instance) {
                return typeof (instance) === "number";
            },

            getDefaultValue: function () {
                return 0;
            },

            parse: function (s, provider) {
                return Bridge.Int.parseFloat(s, provider);
            },

            tryParse: function (s, provider, result) {
                return Bridge.Int.tryParseFloat(s, provider, result);
            },

            format: function (number, format, provider) {
                return Bridge.Int.format(number, format || 'G', provider, System.Double);
            },

            equals: function (v1, v2) {
                if (Bridge.is(v1, System.Double) && Bridge.is(v2, System.Double)) {
                    v1 = Bridge.unbox(v1, true);
                    v2 = Bridge.unbox(v2, true);

                    if (isNaN(v1) && isNaN(v2)) {
                        return true;
                    }

                    return v1 === v2;
                }

                return false;
            },

            equalsT: function (v1, v2) {
                return Bridge.unbox(v1, true) === Bridge.unbox(v2, true);
            },

            getHashCode: function (v) {
                var value = Bridge.unbox(v, true);

                if (value === 0) {
                    return 0;
                }

                if (value === Number.POSITIVE_INFINITY) {
                    return 0x7FF00000;
                }

                if (value === Number.NEGATIVE_INFINITY) {
                    return 0xFFF00000;
                }

                return Bridge.getHashCode(value.toExponential());
            }
        }
    });

    System.Double.$kind = "";
    Bridge.Class.addExtend(System.Double, [System.IComparable$1(System.Double), System.IEquatable$1(System.Double)]);

    Bridge.define("System.Single", {
        inherits: [System.IComparable, System.IFormattable],
        statics: {
            min: -3.40282346638528859e+38,

            max: 3.40282346638528859e+38,

            precision: 7,

            $number: true,

            $is: System.Double.$is,

            getDefaultValue: System.Double.getDefaultValue,

            parse: System.Double.parse,

            tryParse: System.Double.tryParse,

            format: function (number, format, provider) {
                return Bridge.Int.format(number, format || 'G', provider, System.Single);
            },

            equals: function (v1, v2) {
                if (Bridge.is(v1, System.Single) && Bridge.is(v2, System.Single)) {
                    v1 = Bridge.unbox(v1, true);
                    v2 = Bridge.unbox(v2, true);

                    if (isNaN(v1) && isNaN(v2)) {
                        return true;
                    }

                    return v1 === v2;
                }

                return false;
            },

            equalsT: function (v1, v2) {
                return Bridge.unbox(v1, true) === Bridge.unbox(v2, true);
            },

            getHashCode: System.Double.getHashCode
        }
    });

    System.Single.$kind = "";
    Bridge.Class.addExtend(System.Single, [System.IComparable$1(System.Single), System.IEquatable$1(System.Single)]);

    // @source Long.js

    /* long.js https://github.com/dcodeIO/long.js/blob/master/LICENSE */
    (function (b) {
        function d(a, b, c) { this.low = a | 0; this.high = b | 0; this.unsigned = !!c } function g(a) { return !0 === (a && a.__isLong__) } function m(a, b) { var c, u; if (b) { a >>>= 0; if (u = 0 <= a && 256 > a) if (c = A[a]) return c; c = e(a, 0 > (a | 0) ? -1 : 0, !0); u && (A[a] = c) } else { a |= 0; if (u = -128 <= a && 128 > a) if (c = B[a]) return c; c = e(a, 0 > a ? -1 : 0, !1); u && (B[a] = c) } return c } function n(a, b) {
            if (isNaN(a) || !isFinite(a)) return b ? p : k; if (b) { if (0 > a) return p; if (a >= C) return D } else { if (a <= -E) return l; if (a + 1 >= E) return F } return 0 > a ? n(-a, b).neg() : e(a % 4294967296 | 0, a / 4294967296 |
            0, b)
        } function e(a, b, c) { return new d(a, b, c) } function y(a, b, c) {
            if (0 === a.length) throw Error("empty string"); if ("NaN" === a || "Infinity" === a || "+Infinity" === a || "-Infinity" === a) return k; "number" === typeof b ? (c = b, b = !1) : b = !!b; c = c || 10; if (2 > c || 36 < c) throw RangeError("radix"); var u; if (0 < (u = a.indexOf("-"))) throw Error("interior hyphen"); if (0 === u) return y(a.substring(1), b, c).neg(); u = n(w(c, 8)); for (var e = k, f = 0; f < a.length; f += 8) {
                var d = Math.min(8, a.length - f), g = parseInt(a.substring(f, f + d), c); 8 > d ? (d = n(w(c, d)), e = e.mul(d).add(n(g))) :
                (e = e.mul(u), e = e.add(n(g)))
            } e.unsigned = b; return e
        } function q(a) { return a instanceof d ? a : "number" === typeof a ? n(a) : "string" === typeof a ? y(a) : e(a.low, a.high, a.unsigned) } b.Bridge.$Long = d; d.__isLong__; Object.defineProperty(d.prototype, "__isLong__", { value: !0, enumerable: !1, configurable: !1 }); d.isLong = g; var B = {}, A = {}; d.fromInt = m; d.fromNumber = n; d.fromBits = e; var w = Math.pow; d.fromString = y; d.fromValue = q; var C = 4294967296 * 4294967296, E = C / 2, G = m(16777216), k = m(0); d.ZERO = k; var p = m(0, !0); d.UZERO = p; var r = m(1); d.ONE = r; var H =
        m(1, !0); d.UONE = H; var z = m(-1); d.NEG_ONE = z; var F = e(-1, 2147483647, !1); d.MAX_VALUE = F; var D = e(-1, -1, !0); d.MAX_UNSIGNED_VALUE = D; var l = e(0, -2147483648, !1); d.MIN_VALUE = l; b = d.prototype; b.toInt = function () { return this.unsigned ? this.low >>> 0 : this.low }; b.toNumber = function () { return this.unsigned ? 4294967296 * (this.high >>> 0) + (this.low >>> 0) : 4294967296 * this.high + (this.low >>> 0) }; b.toString = function (a) {
            a = a || 10; if (2 > a || 36 < a) throw RangeError("radix"); if (this.isZero()) return "0"; if (this.isNegative()) {
                if (this.eq(l)) {
                    var b =
                    n(a), c = this.div(b), b = c.mul(b).sub(this); return c.toString(a) + b.toInt().toString(a)
                } return ("undefined" === typeof a || 10 === a ? "-" : "") + this.neg().toString(a)
            } for (var c = n(w(a, 6), this.unsigned), b = this, e = ""; ;) { var d = b.div(c), f = (b.sub(d.mul(c)).toInt() >>> 0).toString(a), b = d; if (b.isZero()) return f + e; for (; 6 > f.length;) f = "0" + f; e = "" + f + e }
        }; b.getHighBits = function () { return this.high }; b.getHighBitsUnsigned = function () { return this.high >>> 0 }; b.getLowBits = function () { return this.low }; b.getLowBitsUnsigned = function () {
            return this.low >>>
            0
        }; b.getNumBitsAbs = function () { if (this.isNegative()) return this.eq(l) ? 64 : this.neg().getNumBitsAbs(); for (var a = 0 != this.high ? this.high : this.low, b = 31; 0 < b && 0 == (a & 1 << b) ; b--); return 0 != this.high ? b + 33 : b + 1 }; b.isZero = function () { return 0 === this.high && 0 === this.low }; b.isNegative = function () { return !this.unsigned && 0 > this.high }; b.isPositive = function () { return this.unsigned || 0 <= this.high }; b.isOdd = function () { return 1 === (this.low & 1) }; b.isEven = function () { return 0 === (this.low & 1) }; b.equals = function (a) {
            g(a) || (a = q(a)); return this.unsigned !==
            a.unsigned && 1 === this.high >>> 31 && 1 === a.high >>> 31 ? !1 : this.high === a.high && this.low === a.low
        }; b.eq = b.equals; b.notEquals = function (a) { return !this.eq(a) }; b.neq = b.notEquals; b.lessThan = function (a) { return 0 > this.comp(a) }; b.lt = b.lessThan; b.lessThanOrEqual = function (a) { return 0 >= this.comp(a) }; b.lte = b.lessThanOrEqual; b.greaterThan = function (a) { return 0 < this.comp(a) }; b.gt = b.greaterThan; b.greaterThanOrEqual = function (a) { return 0 <= this.comp(a) }; b.gte = b.greaterThanOrEqual; b.compare = function (a) {
            g(a) || (a = q(a)); if (this.eq(a)) return 0;
            var b = this.isNegative(), c = a.isNegative(); return b && !c ? -1 : !b && c ? 1 : this.unsigned ? a.high >>> 0 > this.high >>> 0 || a.high === this.high && a.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(a).isNegative() ? -1 : 1
        }; b.comp = b.compare; b.negate = function () { return !this.unsigned && this.eq(l) ? l : this.not().add(r) }; b.neg = b.negate; b.add = function (a) {
            g(a) || (a = q(a)); var b = this.high >>> 16, c = this.high & 65535, d = this.low >>> 16, l = a.high >>> 16, f = a.high & 65535, n = a.low >>> 16, k; k = 0 + ((this.low & 65535) + (a.low & 65535)); a = 0 + (k >>> 16); a += d + n; d = 0 + (a >>> 16); d += c + f; c =
            0 + (d >>> 16); c = c + (b + l) & 65535; return e((a & 65535) << 16 | k & 65535, c << 16 | d & 65535, this.unsigned)
        }; b.subtract = function (a) { g(a) || (a = q(a)); return this.add(a.neg()) }; b.sub = b.subtract; b.multiply = function (a) {
            if (this.isZero()) return k; g(a) || (a = q(a)); if (a.isZero()) return k; if (this.eq(l)) return a.isOdd() ? l : k; if (a.eq(l)) return this.isOdd() ? l : k; if (this.isNegative()) return a.isNegative() ? this.neg().mul(a.neg()) : this.neg().mul(a).neg(); if (a.isNegative()) return this.mul(a.neg()).neg(); if (this.lt(G) && a.lt(G)) return n(this.toNumber() *
            a.toNumber(), this.unsigned); var b = this.high >>> 16, c = this.high & 65535, d = this.low >>> 16, x = this.low & 65535, f = a.high >>> 16, m = a.high & 65535, p = a.low >>> 16; a = a.low & 65535; var v, h, t, r; r = 0 + x * a; t = 0 + (r >>> 16); t += d * a; h = 0 + (t >>> 16); t = (t & 65535) + x * p; h += t >>> 16; t &= 65535; h += c * a; v = 0 + (h >>> 16); h = (h & 65535) + d * p; v += h >>> 16; h &= 65535; h += x * m; v += h >>> 16; h &= 65535; v = v + (b * a + c * p + d * m + x * f) & 65535; return e(t << 16 | r & 65535, v << 16 | h, this.unsigned)
        }; b.mul = b.multiply; b.divide = function (a) {
            g(a) || (a = q(a)); if (a.isZero()) throw Error("division by zero"); if (this.isZero()) return this.unsigned ?
                    p : k; var b, c, d; if (this.unsigned) a.unsigned || (a = a.toUnsigned()); else { if (this.eq(l)) { if (a.eq(r) || a.eq(z)) return l; if (a.eq(l)) return r; b = this.shr(1).div(a).shl(1); if (b.eq(k)) return a.isNegative() ? r : z; c = this.sub(a.mul(b)); return d = b.add(c.div(a)) } if (a.eq(l)) return this.unsigned ? p : k; if (this.isNegative()) return a.isNegative() ? this.neg().div(a.neg()) : this.neg().div(a).neg(); if (a.isNegative()) return this.div(a.neg()).neg() } if (this.unsigned) { if (a.gt(this)) return p; if (a.gt(this.shru(1))) return H; d = p } else d =
                    k; for (c = this; c.gte(a) ;) { b = Math.max(1, Math.floor(c.toNumber() / a.toNumber())); for (var e = Math.ceil(Math.log(b) / Math.LN2), e = 48 >= e ? 1 : w(2, e - 48), f = n(b), m = f.mul(a) ; m.isNegative() || m.gt(c) ;) b -= e, f = n(b, this.unsigned), m = f.mul(a); f.isZero() && (f = r); d = d.add(f); c = c.sub(m) } return d
        }; b.div = b.divide; b.modulo = function (a) { g(a) || (a = q(a)); return this.sub(this.div(a).mul(a)) }; b.mod = b.modulo; b.not = function () { return e(~this.low, ~this.high, this.unsigned) }; b.and = function (a) {
            g(a) || (a = q(a)); return e(this.low & a.low, this.high &
            a.high, this.unsigned)
        }; b.or = function (a) { g(a) || (a = q(a)); return e(this.low | a.low, this.high | a.high, this.unsigned) }; b.xor = function (a) { g(a) || (a = q(a)); return e(this.low ^ a.low, this.high ^ a.high, this.unsigned) }; b.shiftLeft = function (a) { g(a) && (a = a.toInt()); return 0 === (a &= 63) ? this : 32 > a ? e(this.low << a, this.high << a | this.low >>> 32 - a, this.unsigned) : e(0, this.low << a - 32, this.unsigned) }; b.shl = b.shiftLeft; b.shiftRight = function (a) {
            g(a) && (a = a.toInt()); return 0 === (a &= 63) ? this : 32 > a ? e(this.low >>> a | this.high << 32 - a, this.high >>
            a, this.unsigned) : e(this.high >> a - 32, 0 <= this.high ? 0 : -1, this.unsigned)
        }; b.shr = b.shiftRight; b.shiftRightUnsigned = function (a) { g(a) && (a = a.toInt()); a &= 63; if (0 === a) return this; var b = this.high; return 32 > a ? e(this.low >>> a | b << 32 - a, b >>> a, this.unsigned) : 32 === a ? e(b, 0, this.unsigned) : e(b >>> a - 32, 0, this.unsigned) }; b.shru = b.shiftRightUnsigned; b.toSigned = function () { return this.unsigned ? e(this.low, this.high, !1) : this }; b.toUnsigned = function () { return this.unsigned ? this : e(this.low, this.high, !0) }
    })(Bridge.global);

    System.Int64 = function (l) {
        if (this.constructor !== System.Int64) {
            return new System.Int64(l);
        }

        if (!Bridge.hasValue(l)) {
            l = 0;
        }

        this.T = System.Int64;
        this.unsigned = false;
        this.value = System.Int64.getValue(l);
    }

    System.Int64.$number = true;
    System.Int64.TWO_PWR_16_DBL = 1 << 16;
    System.Int64.TWO_PWR_32_DBL = System.Int64.TWO_PWR_16_DBL * System.Int64.TWO_PWR_16_DBL;
    System.Int64.TWO_PWR_64_DBL = System.Int64.TWO_PWR_32_DBL * System.Int64.TWO_PWR_32_DBL;
    System.Int64.TWO_PWR_63_DBL = System.Int64.TWO_PWR_64_DBL / 2;

    System.Int64.$$name = "System.Int64";
    System.Int64.prototype.$$name = "System.Int64";
    System.Int64.$kind = "struct";
    System.Int64.prototype.$kind = "struct";

    System.Int64.$$inherits = [];
    Bridge.Class.addExtend(System.Int64, [System.IComparable, System.IFormattable, System.IComparable$1(System.Int64), System.IEquatable$1(System.Int64)]);

    System.Int64.$is = function (instance) {
        return instance instanceof System.Int64;
    };

    System.Int64.is64Bit = function (instance) {
        return instance instanceof System.Int64 || instance instanceof System.UInt64;
    };

    System.Int64.is64BitType = function (type) {
        return type === System.Int64 || type === System.UInt64;
    };

    System.Int64.getDefaultValue = function () {
        return System.Int64.Zero;
    };

    System.Int64.getValue = function (l) {
        if (!Bridge.hasValue(l)) {
            return null;
        }

        if (l instanceof Bridge.$Long) {
            return l;
        }

        if (l instanceof System.Int64) {
            return l.value;
        }

        if (l instanceof System.UInt64) {
            return l.value.toSigned();
        }

        if (Bridge.isArray(l)) {
            return new Bridge.$Long(l[0], l[1]);
        }

        if (Bridge.isString(l)) {
            return Bridge.$Long.fromString(l);
        }

        if (Bridge.isNumber(l)) {
            if (l + 1 >= System.Int64.TWO_PWR_63_DBL) {
                return (new System.UInt64(l)).value.toSigned();
            }
            return Bridge.$Long.fromNumber(l);
        }

        if (l instanceof System.Decimal) {
            return Bridge.$Long.fromString(l.toString());
        }

        return Bridge.$Long.fromValue(l);
    };

    System.Int64.create = function (l) {
        if (!Bridge.hasValue(l)) {
            return null;
        }

        if (l instanceof System.Int64) {
            return l;
        }

        return new System.Int64(l);
    };

    System.Int64.lift = function (l) {
        if (!Bridge.hasValue(l)) {
            return null;
        }
        return System.Int64.create(l);
    };

    System.Int64.toNumber = function (value) {
        if (!value) {
            return null;
        }

        return value.toNumber();
    };

    System.Int64.prototype.toNumberDivided = function (divisor) {
        var integral = this.div(divisor),
            remainder = this.mod(divisor),
            scaledRemainder = remainder.toNumber() / divisor;

        return integral.toNumber() + scaledRemainder;
    };

    System.Int64.prototype.toJSON = function () {
        return this.gt(Bridge.Int.MAX_SAFE_INTEGER) || this.lt(Bridge.Int.MIN_SAFE_INTEGER) ? this.toString() : this.toNumber();
    };

    System.Int64.prototype.toString = function (format, provider) {
        if (!format && !provider) {
            return this.value.toString();
        }

        if (Bridge.isNumber(format) && !provider) {
            return this.value.toString(format);
        }

        return Bridge.Int.format(this, format, provider);
    };

    System.Int64.prototype.format = function (format, provider) {
        return Bridge.Int.format(this, format, provider);
    };

    System.Int64.prototype.isNegative = function () {
        return this.value.isNegative();
    };

    System.Int64.prototype.abs = function () {
        if (this.T === System.Int64 && this.eq(System.Int64.MinValue)) {
            throw new System.OverflowException();
        }
        return new this.T(this.value.isNegative() ? this.value.neg() : this.value);
    };

    System.Int64.prototype.compareTo = function (l) {
        return this.value.compare(this.T.getValue(l));
    };

    System.Int64.prototype.add = function (l, overflow) {
        var addl = this.T.getValue(l),
            r = new this.T(this.value.add(addl));

        if (overflow) {
            var neg1 = this.value.isNegative(),
                neg2 = addl.isNegative(),
                rneg = r.value.isNegative();

            if ((neg1 && neg2 && !rneg) ||
                (!neg1 && !neg2 && rneg) ||
                (this.T === System.UInt64 && r.lt(System.UInt64.max(this, addl)))) {
                throw new System.OverflowException();
            }
        }

        return r;
    };

    System.Int64.prototype.sub = function (l, overflow) {
        var subl = this.T.getValue(l),
            r = new this.T(this.value.sub(subl));

        if (overflow) {
            var neg1 = this.value.isNegative(),
                neg2 = subl.isNegative(),
                rneg = r.value.isNegative();

            if ((neg1 && !neg2 && !rneg) ||
                (!neg1 && neg2 && rneg) ||
                (this.T === System.UInt64 && this.value.lt(subl))) {
                throw new System.OverflowException();
            }
        }

        return r;
    };

    System.Int64.prototype.isZero = function () {
        return this.value.isZero();
    };

    System.Int64.prototype.mul = function (l, overflow) {
        var arg = this.T.getValue(l),
            r = new this.T(this.value.mul(arg));

        if (overflow) {
            var s1 = this.sign(),
                s2 = arg.isZero() ? 0 : (arg.isNegative() ? -1 : 1),
                rs = r.sign();

            if (this.T === System.Int64) {
                if (this.eq(System.Int64.MinValue) || this.eq(System.Int64.MaxValue)) {
                    if (arg.neq(1) && arg.neq(0)) {
                        throw new System.OverflowException();
                    }

                    return r;
                }

                if (arg.eq(Bridge.$Long.MIN_VALUE) || arg.eq(Bridge.$Long.MAX_VALUE)) {
                    if (this.neq(1) && this.neq(0)) {
                        throw new System.OverflowException();
                    }

                    return r;
                }

                if ((s1 === -1 && s2 === -1 && rs !== 1) ||
                    (s1 === 1 && s2 === 1 && rs !== 1) ||
                    (s1 === -1 && s2 === 1 && rs !== -1) ||
                    (s1 === 1 && s2 === -1 && rs !== -1)) {
                    throw new System.OverflowException();
                }

                var r_abs = r.abs();

                if (r_abs.lt(this.abs()) || r_abs.lt(System.Int64(arg).abs())) {
                    throw new System.OverflowException();
                }
            } else {
                if (this.eq(System.UInt64.MaxValue)) {
                    if (arg.neq(1) && arg.neq(0)) {
                        throw new System.OverflowException();
                    }

                    return r;
                }

                if (arg.eq(Bridge.$Long.MAX_UNSIGNED_VALUE)) {
                    if (this.neq(1) && this.neq(0)) {
                        throw new System.OverflowException();
                    }

                    return r;
                }

                var r_abs = r.abs();

                if (r_abs.lt(this.abs()) || r_abs.lt(System.Int64(arg).abs())) {
                    throw new System.OverflowException();
                }
            }
        }

        return r;
    };

    System.Int64.prototype.div = function (l) {
        return new this.T(this.value.div(this.T.getValue(l)));
    };

    System.Int64.prototype.mod = function (l) {
        return new this.T(this.value.mod(this.T.getValue(l)));
    };

    System.Int64.prototype.neg = function (overflow) {
        if (overflow && this.T === System.Int64 && this.eq(System.Int64.MinValue)) {
            throw new System.OverflowException();
        }
        return new this.T(this.value.neg());
    };

    System.Int64.prototype.inc = function (overflow) {
        return this.add(1, overflow);
    };

    System.Int64.prototype.dec = function (overflow) {
        return this.sub(1, overflow);
    };

    System.Int64.prototype.sign = function () {
        return this.value.isZero() ? 0 : (this.value.isNegative() ? -1 : 1);
    };

    System.Int64.prototype.clone = function () {
        return new this.T(this);
    };

    System.Int64.prototype.ne = function (l) {
        return this.value.neq(this.T.getValue(l));
    };

    System.Int64.prototype.neq = function (l) {
        return this.value.neq(this.T.getValue(l));
    };

    System.Int64.prototype.eq = function (l) {
        return this.value.eq(this.T.getValue(l));
    };

    System.Int64.prototype.lt = function (l) {
        return this.value.lt(this.T.getValue(l));
    };

    System.Int64.prototype.lte = function (l) {
        return this.value.lte(this.T.getValue(l));
    };

    System.Int64.prototype.gt = function (l) {
        return this.value.gt(this.T.getValue(l));
    };

    System.Int64.prototype.gte = function (l) {
        return this.value.gte(this.T.getValue(l));
    };

    System.Int64.prototype.equals = function (l) {
        return this.value.eq(this.T.getValue(l));
    };

    System.Int64.prototype.equalsT = function (l) {
        return this.equals(l);
    };

    System.Int64.prototype.getHashCode = function () {
        var n = (this.sign() * 397 + this.value.high) | 0;
        n = (n * 397 + this.value.low) | 0;

        return n;
    };

    System.Int64.prototype.toNumber = function () {
        return this.value.toNumber();
    };

    System.Int64.parse = function (str) {
        if (str == null) {
            throw new System.ArgumentNullException.$ctor1("str");
        }

        if (!/^[+-]?[0-9]+$/.test(str)) {
            throw new System.FormatException.$ctor1("Input string was not in a correct format.");
        }

        var result = new System.Int64(str);

        if (System.String.trimStartZeros(str) !== result.toString()) {
            throw new System.OverflowException();
        }

        return result;
    };

    System.Int64.tryParse = function (str, v) {
        try {
            if (str == null || !/^[+-]?[0-9]+$/.test(str)) {
                v.v = System.Int64(Bridge.$Long.ZERO);
                return false;
            }

            v.v = new System.Int64(str);

            if (System.String.trimStartZeros(str) !== v.v.toString()) {
                v.v = System.Int64(Bridge.$Long.ZERO);
                return false;
            }

            return true;
        } catch (e) {
            v.v = System.Int64(Bridge.$Long.ZERO);
            return false;
        }
    };

    System.Int64.divRem = function (a, b, result) {
        a = System.Int64(a);
        b = System.Int64(b);
        var remainder = a.mod(b);
        result.v = remainder;
        return a.sub(remainder).div(b);
    };

    System.Int64.min = function () {
        var values = [],
            min, i, len;

        for (i = 0, len = arguments.length; i < len; i++) {
            values.push(System.Int64.getValue(arguments[i]));
        }

        i = 0;
        min = values[0];
        for (; ++i < values.length;) {
            if (values[i].lt(min)) {
                min = values[i];
            }
        }

        return new System.Int64(min);
    };

    System.Int64.max = function () {
        var values = [],
            max, i, len;

        for (i = 0, len = arguments.length; i < len; i++) {
            values.push(System.Int64.getValue(arguments[i]));
        }

        i = 0;
        max = values[0];
        for (; ++i < values.length;) {
            if (values[i].gt(max)) {
                max = values[i];
            }
        }

        return new System.Int64(max);
    };

    System.Int64.prototype.and = function (l) {
        return new this.T(this.value.and(this.T.getValue(l)));
    };

    System.Int64.prototype.not = function () {
        return new this.T(this.value.not());
    };

    System.Int64.prototype.or = function (l) {
        return new this.T(this.value.or(this.T.getValue(l)));
    };

    System.Int64.prototype.shl = function (l) {
        return new this.T(this.value.shl(l));
    };

    System.Int64.prototype.shr = function (l) {
        return new this.T(this.value.shr(l));
    };

    System.Int64.prototype.shru = function (l) {
        return new this.T(this.value.shru(l));
    };

    System.Int64.prototype.xor = function (l) {
        return new this.T(this.value.xor(this.T.getValue(l)));
    };

    System.Int64.check = function (v, tp) {
        if (Bridge.Int.isInfinite(v)) {
            if (tp === System.Int64 || tp === System.UInt64) {
                return tp.MinValue;
            }
            return tp.min;
        }

        if (!v) {
            return null;
        }

        var str, r;
        if (tp === System.Int64) {
            if (v instanceof System.Int64) {
                return v;
            }

            str = v.value.toString();
            r = new System.Int64(str);

            if (str !== r.value.toString()) {
                throw new System.OverflowException();
            }

            return r;
        }

        if (tp === System.UInt64) {
            if (v instanceof System.UInt64) {
                return v;
            }

            if (v.value.isNegative()) {
                throw new System.OverflowException();
            }
            str = v.value.toString();
            r = new System.UInt64(str);

            if (str !== r.value.toString()) {
                throw new System.OverflowException();
            }

            return r;
        }

        return Bridge.Int.check(v.toNumber(), tp);
    };

    System.Int64.clip8 = function (x) {
        return x ? Bridge.Int.sxb(x.value.low & 0xff) : (Bridge.Int.isInfinite(x) ? System.SByte.min : null);
    };

    System.Int64.clipu8 = function (x) {
        return x ? x.value.low & 0xff : (Bridge.Int.isInfinite(x) ? System.Byte.min : null);
    };

    System.Int64.clip16 = function (x) {
        return x ? Bridge.Int.sxs(x.value.low & 0xffff) : (Bridge.Int.isInfinite(x) ? System.Int16.min : null);
    };

    System.Int64.clipu16 = function (x) {
        return x ? x.value.low & 0xffff : (Bridge.Int.isInfinite(x) ? System.UInt16.min : null);
    };

    System.Int64.clip32 = function (x) {
        return x ? x.value.low | 0 : (Bridge.Int.isInfinite(x) ? System.Int32.min : null);
    };

    System.Int64.clipu32 = function (x) {
        return x ? x.value.low >>> 0 : (Bridge.Int.isInfinite(x) ? System.UInt32.min : null);
    };

    System.Int64.clip64 = function (x) {
        return x ? new System.Int64(x.value.toSigned()) : (Bridge.Int.isInfinite(x) ? System.Int64.MinValue : null);
    };

    System.Int64.clipu64 = function (x) {
        return x ? new System.UInt64(x.value.toUnsigned()) : (Bridge.Int.isInfinite(x) ? System.UInt64.MinValue : null);
    };

    System.Int64.Zero = System.Int64(Bridge.$Long.ZERO);
    System.Int64.MinValue = System.Int64(Bridge.$Long.MIN_VALUE);
    System.Int64.MaxValue = System.Int64(Bridge.$Long.MAX_VALUE);
    System.Int64.precision = 19;

    /* ULONG */

    System.UInt64 = function (l) {
        if (this.constructor !== System.UInt64) {
            return new System.UInt64(l);
        }

        if (!Bridge.hasValue(l)) {
            l = 0;
        }

        this.T = System.UInt64;
        this.unsigned = true;
        this.value = System.UInt64.getValue(l, true);
    }

    System.UInt64.$number = true;
    System.UInt64.$$name = "System.UInt64";
    System.UInt64.prototype.$$name = "System.UInt64";
    System.UInt64.$kind = "struct";
    System.UInt64.prototype.$kind = "struct";
    System.UInt64.$$inherits = [];
    Bridge.Class.addExtend(System.UInt64, [System.IComparable, System.IFormattable, System.IComparable$1(System.UInt64), System.IEquatable$1(System.UInt64)]);

    System.UInt64.$is = function (instance) {
        return instance instanceof System.UInt64;
    };

    System.UInt64.getDefaultValue = function () {
        return System.UInt64.Zero;
    };

    System.UInt64.getValue = function (l) {
        if (!Bridge.hasValue(l)) {
            return null;
        }

        if (l instanceof Bridge.$Long) {
            return l;
        }

        if (l instanceof System.UInt64) {
            return l.value;
        }

        if (l instanceof System.Int64) {
            return l.value.toUnsigned();
        }

        if (Bridge.isArray(l)) {
            return new Bridge.$Long(l[0], l[1], true);
        }

        if (Bridge.isString(l)) {
            return Bridge.$Long.fromString(l, true);
        }

        if (Bridge.isNumber(l)) {
            if (l < 0) {
                return (new System.Int64(l)).value.toUnsigned();
            }

            return Bridge.$Long.fromNumber(l, true);
        }

        if (l instanceof System.Decimal) {
            return Bridge.$Long.fromString(l.toString(), true);
        }

        return Bridge.$Long.fromValue(l);
    };

    System.UInt64.create = function (l) {
        if (!Bridge.hasValue(l)) {
            return null;
        }

        if (l instanceof System.UInt64) {
            return l;
        }

        return new System.UInt64(l);
    };

    System.UInt64.lift = function (l) {
        if (!Bridge.hasValue(l)) {
            return null;
        }
        return System.UInt64.create(l);
    };

    System.UInt64.prototype.toString = System.Int64.prototype.toString;
    System.UInt64.prototype.format = System.Int64.prototype.format;
    System.UInt64.prototype.isNegative = System.Int64.prototype.isNegative;
    System.UInt64.prototype.abs = System.Int64.prototype.abs;
    System.UInt64.prototype.compareTo = System.Int64.prototype.compareTo;
    System.UInt64.prototype.add = System.Int64.prototype.add;
    System.UInt64.prototype.sub = System.Int64.prototype.sub;
    System.UInt64.prototype.isZero = System.Int64.prototype.isZero;
    System.UInt64.prototype.mul = System.Int64.prototype.mul;
    System.UInt64.prototype.div = System.Int64.prototype.div;
    System.UInt64.prototype.toNumberDivided = System.Int64.prototype.toNumberDivided;
    System.UInt64.prototype.mod = System.Int64.prototype.mod;
    System.UInt64.prototype.neg = System.Int64.prototype.neg;
    System.UInt64.prototype.inc = System.Int64.prototype.inc;
    System.UInt64.prototype.dec = System.Int64.prototype.dec;
    System.UInt64.prototype.sign = System.Int64.prototype.sign;
    System.UInt64.prototype.clone = System.Int64.prototype.clone;
    System.UInt64.prototype.ne = System.Int64.prototype.ne;
    System.UInt64.prototype.neq = System.Int64.prototype.neq;
    System.UInt64.prototype.eq = System.Int64.prototype.eq;
    System.UInt64.prototype.lt = System.Int64.prototype.lt;
    System.UInt64.prototype.lte = System.Int64.prototype.lte;
    System.UInt64.prototype.gt = System.Int64.prototype.gt;
    System.UInt64.prototype.gte = System.Int64.prototype.gte;
    System.UInt64.prototype.equals = System.Int64.prototype.equals;
    System.UInt64.prototype.equalsT = System.Int64.prototype.equalsT;
    System.UInt64.prototype.getHashCode = System.Int64.prototype.getHashCode;
    System.UInt64.prototype.toNumber = System.Int64.prototype.toNumber;

    System.UInt64.parse = function (str) {
        if (str == null) {
            throw new System.ArgumentNullException.$ctor1("str");
        }

        if (!/^[+-]?[0-9]+$/.test(str)) {
            throw new System.FormatException.$ctor1("Input string was not in a correct format.");
        }

        var result = new System.UInt64(str);

        if (result.value.isNegative()) {
            throw new System.OverflowException();
        }

        if (System.String.trimStartZeros(str) !== result.toString()) {
            throw new System.OverflowException();
        }

        return result;
    };

    System.UInt64.tryParse = function (str, v) {
        try {
            if (str == null || !/^[+-]?[0-9]+$/.test(str)) {
                v.v = System.UInt64(Bridge.$Long.UZERO);
                return false;
            }

            v.v = new System.UInt64(str);

            if (v.v.isNegative()) {
                v.v = System.UInt64(Bridge.$Long.UZERO);
                return false;
            }

            if (System.String.trimStartZeros(str) !== v.v.toString()) {
                v.v = System.UInt64(Bridge.$Long.UZERO);
                return false;
            }

            return true;
        } catch (e) {
            v.v = System.UInt64(Bridge.$Long.UZERO);
            return false;
        }
    };

    System.UInt64.min = function () {
        var values = [],
            min, i, len;

        for (i = 0, len = arguments.length; i < len; i++) {
            values.push(System.UInt64.getValue(arguments[i]));
        }

        i = 0;
        min = values[0];
        for (; ++i < values.length;) {
            if (values[i].lt(min)) {
                min = values[i];
            }
        }

        return new System.UInt64(min);
    };

    System.UInt64.max = function () {
        var values = [],
            max, i, len;

        for (i = 0, len = arguments.length; i < len; i++) {
            values.push(System.UInt64.getValue(arguments[i]));
        }

        i = 0;
        max = values[0];
        for (; ++i < values.length;) {
            if (values[i].gt(max)) {
                max = values[i];
            }
        }

        return new System.UInt64(max);
    };

    System.UInt64.divRem = function (a, b, result) {
        a = System.UInt64(a);
        b = System.UInt64(b);
        var remainder = a.mod(b);
        result.v = remainder;
        return a.sub(remainder).div(b);
    };

    System.UInt64.prototype.toJSON = function () {
        return this.gt(Bridge.Int.MAX_SAFE_INTEGER) ? this.toString() : this.toNumber();
    };

    System.UInt64.prototype.and = System.Int64.prototype.and;
    System.UInt64.prototype.not = System.Int64.prototype.not;
    System.UInt64.prototype.or = System.Int64.prototype.or;
    System.UInt64.prototype.shl = System.Int64.prototype.shl;
    System.UInt64.prototype.shr = System.Int64.prototype.shr;
    System.UInt64.prototype.shru = System.Int64.prototype.shru;
    System.UInt64.prototype.xor = System.Int64.prototype.xor;

    System.UInt64.Zero = System.UInt64(Bridge.$Long.UZERO);
    System.UInt64.MinValue = System.UInt64.Zero;
    System.UInt64.MaxValue = System.UInt64(Bridge.$Long.MAX_UNSIGNED_VALUE);
    System.UInt64.precision = 20;

    // @source Decimal.js

    /* decimal.js v7.1.0 https://github.com/MikeMcl/decimal.js/LICENCE */
    !function (n) { "use strict"; function e(n) { var e, i, t, r = n.length - 1, s = "", o = n[0]; if (r > 0) { for (s += o, e = 1; r > e; e++) t = n[e] + "", i = Rn - t.length, i && (s += l(i)), s += t; o = n[e], t = o + "", i = Rn - t.length, i && (s += l(i)) } else if (0 === o) return "0"; for (; o % 10 === 0;) o /= 10; return s + o } function i(n, e, i) { if (n !== ~~n || e > n || n > i) throw Error(En + n) } function t(n, e, i, t) { var r, s, o, u; for (s = n[0]; s >= 10; s /= 10)--e; return --e < 0 ? (e += Rn, r = 0) : (r = Math.ceil((e + 1) / Rn), e %= Rn), s = On(10, Rn - e), u = n[r] % s | 0, null == t ? 3 > e ? (0 == e ? u = u / 100 | 0 : 1 == e && (u = u / 10 | 0), o = 4 > i && 99999 == u || i > 3 && 49999 == u || 5e4 == u || 0 == u) : o = (4 > i && u + 1 == s || i > 3 && u + 1 == s / 2) && (n[r + 1] / s / 100 | 0) == On(10, e - 2) - 1 || (u == s / 2 || 0 == u) && 0 == (n[r + 1] / s / 100 | 0) : 4 > e ? (0 == e ? u = u / 1e3 | 0 : 1 == e ? u = u / 100 | 0 : 2 == e && (u = u / 10 | 0), o = (t || 4 > i) && 9999 == u || !t && i > 3 && 4999 == u) : o = ((t || 4 > i) && u + 1 == s || !t && i > 3 && u + 1 == s / 2) && (n[r + 1] / s / 1e3 | 0) == On(10, e - 3) - 1, o } function r(n, e, i) { for (var t, r, s = [0], o = 0, u = n.length; u > o;) { for (r = s.length; r--;) s[r] *= e; for (s[0] += wn.indexOf(n.charAt(o++)), t = 0; t < s.length; t++) s[t] > i - 1 && (void 0 === s[t + 1] && (s[t + 1] = 0), s[t + 1] += s[t] / i | 0, s[t] %= i) } return s.reverse() } function s(n, e) { var i, t, r = e.d.length; 32 > r ? (i = Math.ceil(r / 3), t = Math.pow(4, -i).toString()) : (i = 16, t = "2.3283064365386962890625e-10"), n.precision += i, e = E(n, 1, e.times(t), new n(1)); for (var s = i; s--;) { var o = e.times(e); e = o.times(o).minus(o).times(8).plus(1) } return n.precision -= i, e } function o(n, e, i, t) { var r, s, o, u, c, f, a, h, l, d = n.constructor; n: if (null != e) { if (h = n.d, !h) return n; for (r = 1, u = h[0]; u >= 10; u /= 10) r++; if (s = e - r, 0 > s) s += Rn, o = e, a = h[l = 0], c = a / On(10, r - o - 1) % 10 | 0; else if (l = Math.ceil((s + 1) / Rn), u = h.length, l >= u) { if (!t) break n; for (; u++ <= l;) h.push(0); a = c = 0, r = 1, s %= Rn, o = s - Rn + 1 } else { for (a = u = h[l], r = 1; u >= 10; u /= 10) r++; s %= Rn, o = s - Rn + r, c = 0 > o ? 0 : a / On(10, r - o - 1) % 10 | 0 } if (t = t || 0 > e || void 0 !== h[l + 1] || (0 > o ? a : a % On(10, r - o - 1)), f = 4 > i ? (c || t) && (0 == i || i == (n.s < 0 ? 3 : 2)) : c > 5 || 5 == c && (4 == i || t || 6 == i && (s > 0 ? o > 0 ? a / On(10, r - o) : 0 : h[l - 1]) % 10 & 1 || i == (n.s < 0 ? 8 : 7)), 1 > e || !h[0]) return h.length = 0, f ? (e -= n.e + 1, h[0] = On(10, (Rn - e % Rn) % Rn), n.e = -e || 0) : h[0] = n.e = 0, n; if (0 == s ? (h.length = l, u = 1, l--) : (h.length = l + 1, u = On(10, Rn - s), h[l] = o > 0 ? (a / On(10, r - o) % On(10, o) | 0) * u : 0), f) for (; ;) { if (0 == l) { for (s = 1, o = h[0]; o >= 10; o /= 10) s++; for (o = h[0] += u, u = 1; o >= 10; o /= 10) u++; s != u && (n.e++, h[0] == Pn && (h[0] = 1)); break } if (h[l] += u, h[l] != Pn) break; h[l--] = 0, u = 1 } for (s = h.length; 0 === h[--s];) h.pop() } return bn && (n.e > d.maxE ? (n.d = null, n.e = NaN) : n.e < d.minE && (n.e = 0, n.d = [0])), n } function u(n, i, t) { if (!n.isFinite()) return v(n); var r, s = n.e, o = e(n.d), u = o.length; return i ? (t && (r = t - u) > 0 ? o = o.charAt(0) + "." + o.slice(1) + l(r) : u > 1 && (o = o.charAt(0) + "." + o.slice(1)), o = o + (n.e < 0 ? "e" : "e+") + n.e) : 0 > s ? (o = "0." + l(-s - 1) + o, t && (r = t - u) > 0 && (o += l(r))) : s >= u ? (o += l(s + 1 - u), t && (r = t - s - 1) > 0 && (o = o + "." + l(r))) : ((r = s + 1) < u && (o = o.slice(0, r) + "." + o.slice(r)), t && (r = t - u) > 0 && (s + 1 === u && (o += "."), o += l(r))), o } function c(n, e) { for (var i = 1, t = n[0]; t >= 10; t /= 10) i++; return i + e * Rn - 1 } function f(n, e, i) { if (e > Un) throw bn = !0, i && (n.precision = i), Error(Mn); return o(new n(mn), e, 1, !0) } function a(n, e, i) { if (e > _n) throw Error(Mn); return o(new n(vn), e, i, !0) } function h(n) { var e = n.length - 1, i = e * Rn + 1; if (e = n[e]) { for (; e % 10 == 0; e /= 10) i--; for (e = n[0]; e >= 10; e /= 10) i++ } return i } function l(n) { for (var e = ""; n--;) e += "0"; return e } function d(n, e, i, t) { var r, s = new n(1), o = Math.ceil(t / Rn + 4); for (bn = !1; ;) { if (i % 2 && (s = s.times(e), q(s.d, o) && (r = !0)), i = qn(i / 2), 0 === i) { i = s.d.length - 1, r && 0 === s.d[i] && ++s.d[i]; break } e = e.times(e), q(e.d, o) } return bn = !0, s } function p(n) { return 1 & n.d[n.d.length - 1] } function g(n, e, i) { for (var t, r = new n(e[0]), s = 0; ++s < e.length;) { if (t = new n(e[s]), !t.s) { r = t; break } r[i](t) && (r = t) } return r } function w(n, i) { var r, s, u, c, f, a, h, l = 0, d = 0, p = 0, g = n.constructor, w = g.rounding, m = g.precision; if (!n.d || !n.d[0] || n.e > 17) return new g(n.d ? n.d[0] ? n.s < 0 ? 0 : 1 / 0 : 1 : n.s ? n.s < 0 ? 0 : n : NaN); for (null == i ? (bn = !1, h = m) : h = i, a = new g(.03125) ; n.e > -2;) n = n.times(a), p += 5; for (s = Math.log(On(2, p)) / Math.LN10 * 2 + 5 | 0, h += s, r = c = f = new g(1), g.precision = h; ;) { if (c = o(c.times(n), h, 1), r = r.times(++d), a = f.plus(Sn(c, r, h, 1)), e(a.d).slice(0, h) === e(f.d).slice(0, h)) { for (u = p; u--;) f = o(f.times(f), h, 1); if (null != i) return g.precision = m, f; if (!(3 > l && t(f.d, h - s, w, l))) return o(f, g.precision = m, w, bn = !0); g.precision = h += 10, r = c = a = new g(1), d = 0, l++ } f = a } } function m(n, i) { var r, s, u, c, a, h, l, d, p, g, w, v = 1, N = 10, b = n, x = b.d, E = b.constructor, M = E.rounding, y = E.precision; if (b.s < 0 || !x || !x[0] || !b.e && 1 == x[0] && 1 == x.length) return new E(x && !x[0] ? -1 / 0 : 1 != b.s ? NaN : x ? 0 : b); if (null == i ? (bn = !1, p = y) : p = i, E.precision = p += N, r = e(x), s = r.charAt(0), !(Math.abs(c = b.e) < 15e14)) return d = f(E, p + 2, y).times(c + ""), b = m(new E(s + "." + r.slice(1)), p - N).plus(d), E.precision = y, null == i ? o(b, y, M, bn = !0) : b; for (; 7 > s && 1 != s || 1 == s && r.charAt(1) > 3;) b = b.times(n), r = e(b.d), s = r.charAt(0), v++; for (c = b.e, s > 1 ? (b = new E("0." + r), c++) : b = new E(s + "." + r.slice(1)), g = b, l = a = b = Sn(b.minus(1), b.plus(1), p, 1), w = o(b.times(b), p, 1), u = 3; ;) { if (a = o(a.times(w), p, 1), d = l.plus(Sn(a, new E(u), p, 1)), e(d.d).slice(0, p) === e(l.d).slice(0, p)) { if (l = l.times(2), 0 !== c && (l = l.plus(f(E, p + 2, y).times(c + ""))), l = Sn(l, new E(v), p, 1), null != i) return E.precision = y, l; if (!t(l.d, p - N, M, h)) return o(l, E.precision = y, M, bn = !0); E.precision = p += N, d = a = b = Sn(g.minus(1), g.plus(1), p, 1), w = o(b.times(b), p, 1), u = h = 1 } l = d, u += 2 } } function v(n) { return String(n.s * n.s / 0) } function N(n, e) { var i, t, r; for ((i = e.indexOf(".")) > -1 && (e = e.replace(".", "")), (t = e.search(/e/i)) > 0 ? (0 > i && (i = t), i += +e.slice(t + 1), e = e.substring(0, t)) : 0 > i && (i = e.length), t = 0; 48 === e.charCodeAt(t) ; t++); for (r = e.length; 48 === e.charCodeAt(r - 1) ; --r); if (e = e.slice(t, r)) { if (r -= t, n.e = i = i - t - 1, n.d = [], t = (i + 1) % Rn, 0 > i && (t += Rn), r > t) { for (t && n.d.push(+e.slice(0, t)), r -= Rn; r > t;) n.d.push(+e.slice(t, t += Rn)); e = e.slice(t), t = Rn - e.length } else t -= r; for (; t--;) e += "0"; n.d.push(+e), bn && (n.e > n.constructor.maxE ? (n.d = null, n.e = NaN) : n.e < n.constructor.minE && (n.e = 0, n.d = [0])) } else n.e = 0, n.d = [0]; return n } function b(n, e) { var i, t, s, o, u, f, a, h, l; if ("Infinity" === e || "NaN" === e) return +e || (n.s = NaN), n.e = NaN, n.d = null, n; if (An.test(e)) i = 16, e = e.toLowerCase(); else if (Fn.test(e)) i = 2; else { if (!Dn.test(e)) throw Error(En + e); i = 8 } for (o = e.search(/p/i), o > 0 ? (a = +e.slice(o + 1), e = e.substring(2, o)) : e = e.slice(2), o = e.indexOf("."), u = o >= 0, t = n.constructor, u && (e = e.replace(".", ""), f = e.length, o = f - o, s = d(t, new t(i), o, 2 * o)), h = r(e, i, Pn), l = h.length - 1, o = l; 0 === h[o]; --o) h.pop(); return 0 > o ? new t(0 * n.s) : (n.e = c(h, l), n.d = h, bn = !1, u && (n = Sn(n, s, 4 * f)), a && (n = n.times(Math.abs(a) < 54 ? Math.pow(2, a) : Nn.pow(2, a))), bn = !0, n) } function x(n, e) { var i, t = e.d.length; if (3 > t) return E(n, 2, e, e); i = 1.4 * Math.sqrt(t), i = i > 16 ? 16 : 0 | i, e = e.times(Math.pow(5, -i)), e = E(n, 2, e, e); for (var r, s = new n(5), o = new n(16), u = new n(20) ; i--;) r = e.times(e), e = e.times(s.plus(r.times(o.times(r).minus(u)))); return e } function E(n, e, i, t, r) { var s, o, u, c, f = 1, a = n.precision, h = Math.ceil(a / Rn); for (bn = !1, c = i.times(i), u = new n(t) ; ;) { if (o = Sn(u.times(c), new n(e++ * e++), a, 1), u = r ? t.plus(o) : t.minus(o), t = Sn(o.times(c), new n(e++ * e++), a, 1), o = u.plus(t), void 0 !== o.d[h]) { for (s = h; o.d[s] === u.d[s] && s--;); if (-1 == s) break } s = u, u = t, t = o, o = s, f++ } return bn = !0, o.d.length = h + 1, o } function M(n, e) { var i, t = e.s < 0, r = a(n, n.precision, 1), s = r.times(.5); if (e = e.abs(), e.lte(s)) return dn = t ? 4 : 1, e; if (i = e.divToInt(r), i.isZero()) dn = t ? 3 : 2; else { if (e = e.minus(i.times(r)), e.lte(s)) return dn = p(i) ? t ? 2 : 3 : t ? 4 : 1, e; dn = p(i) ? t ? 1 : 4 : t ? 3 : 2 } return e.minus(r).abs() } function y(n, e, t, s) { var o, c, f, a, h, l, d, p, g, w = n.constructor, m = void 0 !== t; if (m ? (i(t, 1, gn), void 0 === s ? s = w.rounding : i(s, 0, 8)) : (t = w.precision, s = w.rounding), n.isFinite()) { for (d = u(n), f = d.indexOf("."), m ? (o = 2, 16 == e ? t = 4 * t - 3 : 8 == e && (t = 3 * t - 2)) : o = e, f >= 0 && (d = d.replace(".", ""), g = new w(1), g.e = d.length - f, g.d = r(u(g), 10, o), g.e = g.d.length), p = r(d, 10, o), c = h = p.length; 0 == p[--h];) p.pop(); if (p[0]) { if (0 > f ? c-- : (n = new w(n), n.d = p, n.e = c, n = Sn(n, g, t, s, 0, o), p = n.d, c = n.e, l = hn), f = p[t], a = o / 2, l = l || void 0 !== p[t + 1], l = 4 > s ? (void 0 !== f || l) && (0 === s || s === (n.s < 0 ? 3 : 2)) : f > a || f === a && (4 === s || l || 6 === s && 1 & p[t - 1] || s === (n.s < 0 ? 8 : 7)), p.length = t, l) for (; ++p[--t] > o - 1;) p[t] = 0, t || (++c, p.unshift(1)); for (h = p.length; !p[h - 1]; --h); for (f = 0, d = ""; h > f; f++) d += wn.charAt(p[f]); if (m) { if (h > 1) if (16 == e || 8 == e) { for (f = 16 == e ? 4 : 3, --h; h % f; h++) d += "0"; for (p = r(d, o, e), h = p.length; !p[h - 1]; --h); for (f = 1, d = "1."; h > f; f++) d += wn.charAt(p[f]) } else d = d.charAt(0) + "." + d.slice(1); d = d + (0 > c ? "p" : "p+") + c } else if (0 > c) { for (; ++c;) d = "0" + d; d = "0." + d } else if (++c > h) for (c -= h; c--;) d += "0"; else h > c && (d = d.slice(0, c) + "." + d.slice(c)) } else d = m ? "0p+0" : "0"; d = (16 == e ? "0x" : 2 == e ? "0b" : 8 == e ? "0o" : "") + d } else d = v(n); return n.s < 0 ? "-" + d : d } function q(n, e) { return n.length > e ? (n.length = e, !0) : void 0 } function O(n) { return new this(n).abs() } function F(n) { return new this(n).acos() } function A(n) { return new this(n).acosh() } function D(n, e) { return new this(n).plus(e) } function Z(n) { return new this(n).asin() } function P(n) { return new this(n).asinh() } function R(n) { return new this(n).atan() } function L(n) { return new this(n).atanh() } function U(n, e) { n = new this(n), e = new this(e); var i, t = this.precision, r = this.rounding, s = t + 4; return n.s && e.s ? n.d || e.d ? !e.d || n.isZero() ? (i = e.s < 0 ? a(this, t, r) : new this(0), i.s = n.s) : !n.d || e.isZero() ? (i = a(this, s, 1).times(.5), i.s = n.s) : e.s < 0 ? (this.precision = s, this.rounding = 1, i = this.atan(Sn(n, e, s, 1)), e = a(this, s, 1), this.precision = t, this.rounding = r, i = n.s < 0 ? i.minus(e) : i.plus(e)) : i = this.atan(Sn(n, e, s, 1)) : (i = a(this, s, 1).times(e.s > 0 ? .25 : .75), i.s = n.s) : i = new this(NaN), i } function _(n) { return new this(n).cbrt() } function k(n) { return o(n = new this(n), n.e + 1, 2) } function S(n) { if (!n || "object" != typeof n) throw Error(xn + "Object expected"); var e, i, t, r = ["precision", 1, gn, "rounding", 0, 8, "toExpNeg", -pn, 0, "toExpPos", 0, pn, "maxE", 0, pn, "minE", -pn, 0, "modulo", 0, 9]; for (e = 0; e < r.length; e += 3) if (void 0 !== (t = n[i = r[e]])) { if (!(qn(t) === t && t >= r[e + 1] && t <= r[e + 2])) throw Error(En + i + ": " + t); this[i] = t } if (void 0 !== (t = n[i = "crypto"])) { if (t !== !0 && t !== !1 && 0 !== t && 1 !== t) throw Error(En + i + ": " + t); if (t) { if ("undefined" == typeof crypto || !crypto || !crypto.getRandomValues && !crypto.randomBytes) throw Error(yn); this[i] = !0 } else this[i] = !1 } return this } function T(n) { return new this(n).cos() } function C(n) { return new this(n).cosh() } function I(n) { function e(n) { var i, t, r, s = this; if (!(s instanceof e)) return new e(n); if (s.constructor = e, n instanceof e) return s.s = n.s, s.e = n.e, void (s.d = (n = n.d) ? n.slice() : n); if (r = typeof n, "number" === r) { if (0 === n) return s.s = 0 > 1 / n ? -1 : 1, s.e = 0, void (s.d = [0]); if (0 > n ? (n = -n, s.s = -1) : s.s = 1, n === ~~n && 1e7 > n) { for (i = 0, t = n; t >= 10; t /= 10) i++; return s.e = i, void (s.d = [n]) } return 0 * n !== 0 ? (n || (s.s = NaN), s.e = NaN, void (s.d = null)) : N(s, n.toString()) } if ("string" !== r) throw Error(En + n); return 45 === n.charCodeAt(0) ? (n = n.slice(1), s.s = -1) : s.s = 1, Zn.test(n) ? N(s, n) : b(s, n) } var i, t, r; if (e.prototype = kn, e.ROUND_UP = 0, e.ROUND_DOWN = 1, e.ROUND_CEIL = 2, e.ROUND_FLOOR = 3, e.ROUND_HALF_UP = 4, e.ROUND_HALF_DOWN = 5, e.ROUND_HALF_EVEN = 6, e.ROUND_HALF_CEIL = 7, e.ROUND_HALF_FLOOR = 8, e.EUCLID = 9, e.config = e.set = S, e.clone = I, e.abs = O, e.acos = F, e.acosh = A, e.add = D, e.asin = Z, e.asinh = P, e.atan = R, e.atanh = L, e.atan2 = U, e.cbrt = _, e.ceil = k, e.cos = T, e.cosh = C, e.div = H, e.exp = B, e.floor = V, e.hypot = $, e.ln = j, e.log = W, e.log10 = z, e.log2 = J, e.max = G, e.min = K, e.mod = Q, e.mul = X, e.pow = Y, e.random = nn, e.round = en, e.sign = tn, e.sin = rn, e.sinh = sn, e.sqrt = on, e.sub = un, e.tan = cn, e.tanh = fn, e.trunc = an, void 0 === n && (n = {}), n) for (r = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"], i = 0; i < r.length;) n.hasOwnProperty(t = r[i++]) || (n[t] = this[t]); return e.config(n), e } function H(n, e) { return new this(n).div(e) } function B(n) { return new this(n).exp() } function V(n) { return o(n = new this(n), n.e + 1, 3) } function $() { var n, e, i = new this(0); for (bn = !1, n = 0; n < arguments.length;) if (e = new this(arguments[n++]), e.d) i.d && (i = i.plus(e.times(e))); else { if (e.s) return bn = !0, new this(1 / 0); i = e } return bn = !0, i.sqrt() } function j(n) { return new this(n).ln() } function W(n, e) { return new this(n).log(e) } function J(n) { return new this(n).log(2) } function z(n) { return new this(n).log(10) } function G() { return g(this, arguments, "lt") } function K() { return g(this, arguments, "gt") } function Q(n, e) { return new this(n).mod(e) } function X(n, e) { return new this(n).mul(e) } function Y(n, e) { return new this(n).pow(e) } function nn(n) { var e, t, r, s, o = 0, u = new this(1), c = []; if (void 0 === n ? n = this.precision : i(n, 1, gn), r = Math.ceil(n / Rn), this.crypto) if (crypto.getRandomValues) for (e = crypto.getRandomValues(new Uint32Array(r)) ; r > o;) s = e[o], s >= 429e7 ? e[o] = crypto.getRandomValues(new Uint32Array(1))[0] : c[o++] = s % 1e7; else { if (!crypto.randomBytes) throw Error(yn); for (e = crypto.randomBytes(r *= 4) ; r > o;) s = e[o] + (e[o + 1] << 8) + (e[o + 2] << 16) + ((127 & e[o + 3]) << 24), s >= 214e7 ? crypto.randomBytes(4).copy(e, o) : (c.push(s % 1e7), o += 4); o = r / 4 } else for (; r > o;) c[o++] = 1e7 * Math.random() | 0; for (r = c[--o], n %= Rn, r && n && (s = On(10, Rn - n), c[o] = (r / s | 0) * s) ; 0 === c[o]; o--) c.pop(); if (0 > o) t = 0, c = [0]; else { for (t = -1; 0 === c[0]; t -= Rn) c.shift(); for (r = 1, s = c[0]; s >= 10; s /= 10) r++; Rn > r && (t -= Rn - r) } return u.e = t, u.d = c, u } function en(n) { return o(n = new this(n), n.e + 1, this.rounding) } function tn(n) { return n = new this(n), n.d ? n.d[0] ? n.s : 0 * n.s : n.s || NaN } function rn(n) { return new this(n).sin() } function sn(n) { return new this(n).sinh() } function on(n) { return new this(n).sqrt() } function un(n, e) { return new this(n).sub(e) } function cn(n) { return new this(n).tan() } function fn(n) { return new this(n).tanh() } function an(n) { return o(n = new this(n), n.e + 1, 1) } var hn, ln, dn, pn = 9e15, gn = 1e9, wn = "0123456789abcdef", mn = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058", vn = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789", Nn = { precision: 20, rounding: 4, modulo: 1, toExpNeg: -7, toExpPos: 21, minE: -pn, maxE: pn, crypto: !1 }, bn = !0, xn = "[DecimalError] ", En = xn + "Invalid argument: ", Mn = xn + "Precision limit exceeded", yn = xn + "crypto unavailable", qn = Math.floor, On = Math.pow, Fn = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i, An = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i, Dn = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i, Zn = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, Pn = 1e7, Rn = 7, Ln = 9007199254740991, Un = mn.length - 1, _n = vn.length - 1, kn = {}; kn.absoluteValue = kn.abs = function () { var n = new this.constructor(this); return n.s < 0 && (n.s = 1), o(n) }, kn.ceil = function () { return o(new this.constructor(this), this.e + 1, 2) }, kn.comparedTo = kn.cmp = function (n) { var e, i, t, r, s = this, o = s.d, u = (n = new s.constructor(n)).d, c = s.s, f = n.s; if (!o || !u) return c && f ? c !== f ? c : o === u ? 0 : !o ^ 0 > c ? 1 : -1 : NaN; if (!o[0] || !u[0]) return o[0] ? c : u[0] ? -f : 0; if (c !== f) return c; if (s.e !== n.e) return s.e > n.e ^ 0 > c ? 1 : -1; for (t = o.length, r = u.length, e = 0, i = r > t ? t : r; i > e; ++e) if (o[e] !== u[e]) return o[e] > u[e] ^ 0 > c ? 1 : -1; return t === r ? 0 : t > r ^ 0 > c ? 1 : -1 }, kn.cosine = kn.cos = function () { var n, e, i = this, t = i.constructor; return i.d ? i.d[0] ? (n = t.precision, e = t.rounding, t.precision = n + Math.max(i.e, i.sd()) + Rn, t.rounding = 1, i = s(t, M(t, i)), t.precision = n, t.rounding = e, o(2 == dn || 3 == dn ? i.neg() : i, n, e, !0)) : new t(1) : new t(NaN) }, kn.cubeRoot = kn.cbrt = function () { var n, i, t, r, s, u, c, f, a, h, l = this, d = l.constructor; if (!l.isFinite() || l.isZero()) return new d(l); for (bn = !1, u = l.s * Math.pow(l.s * l, 1 / 3), u && Math.abs(u) != 1 / 0 ? r = new d(u.toString()) : (t = e(l.d), n = l.e, (u = (n - t.length + 1) % 3) && (t += 1 == u || -2 == u ? "0" : "00"), u = Math.pow(t, 1 / 3), n = qn((n + 1) / 3) - (n % 3 == (0 > n ? -1 : 2)), u == 1 / 0 ? t = "5e" + n : (t = u.toExponential(), t = t.slice(0, t.indexOf("e") + 1) + n), r = new d(t), r.s = l.s), c = (n = d.precision) + 3; ;) if (f = r, a = f.times(f).times(f), h = a.plus(l), r = Sn(h.plus(l).times(f), h.plus(a), c + 2, 1), e(f.d).slice(0, c) === (t = e(r.d)).slice(0, c)) { if (t = t.slice(c - 3, c + 1), "9999" != t && (s || "4999" != t)) { (!+t || !+t.slice(1) && "5" == t.charAt(0)) && (o(r, n + 1, 1), i = !r.times(r).times(r).eq(l)); break } if (!s && (o(f, n + 1, 0), f.times(f).times(f).eq(l))) { r = f; break } c += 4, s = 1 } return bn = !0, o(r, n, d.rounding, i) }, kn.decimalPlaces = kn.dp = function () { var n, e = this.d, i = NaN; if (e) { if (n = e.length - 1, i = (n - qn(this.e / Rn)) * Rn, n = e[n]) for (; n % 10 == 0; n /= 10) i--; 0 > i && (i = 0) } return i }, kn.dividedBy = kn.div = function (n) { return Sn(this, new this.constructor(n)) }, kn.dividedToIntegerBy = kn.divToInt = function (n) { var e = this, i = e.constructor; return o(Sn(e, new i(n), 0, 1, 1), i.precision, i.rounding) }, kn.equals = kn.eq = function (n) { return 0 === this.cmp(n) }, kn.floor = function () { return o(new this.constructor(this), this.e + 1, 3) }, kn.greaterThan = kn.gt = function (n) { return this.cmp(n) > 0 }, kn.greaterThanOrEqualTo = kn.gte = function (n) { var e = this.cmp(n); return 1 == e || 0 === e }, kn.hyperbolicCosine = kn.cosh = function () { var n, e, i, t, r, s = this, u = s.constructor, c = new u(1); if (!s.isFinite()) return new u(s.s ? 1 / 0 : NaN); if (s.isZero()) return c; i = u.precision, t = u.rounding, u.precision = i + Math.max(s.e, s.sd()) + 4, u.rounding = 1, r = s.d.length, 32 > r ? (n = Math.ceil(r / 3), e = Math.pow(4, -n).toString()) : (n = 16, e = "2.3283064365386962890625e-10"), s = E(u, 1, s.times(e), new u(1), !0); for (var f, a = n, h = new u(8) ; a--;) f = s.times(s), s = c.minus(f.times(h.minus(f.times(h)))); return o(s, u.precision = i, u.rounding = t, !0) }, kn.hyperbolicSine = kn.sinh = function () { var n, e, i, t, r = this, s = r.constructor; if (!r.isFinite() || r.isZero()) return new s(r); if (e = s.precision, i = s.rounding, s.precision = e + Math.max(r.e, r.sd()) + 4, s.rounding = 1, t = r.d.length, 3 > t) r = E(s, 2, r, r, !0); else { n = 1.4 * Math.sqrt(t), n = n > 16 ? 16 : 0 | n, r = r.times(Math.pow(5, -n)), r = E(s, 2, r, r, !0); for (var u, c = new s(5), f = new s(16), a = new s(20) ; n--;) u = r.times(r), r = r.times(c.plus(u.times(f.times(u).plus(a)))) } return s.precision = e, s.rounding = i, o(r, e, i, !0) }, kn.hyperbolicTangent = kn.tanh = function () { var n, e, i = this, t = i.constructor; return i.isFinite() ? i.isZero() ? new t(i) : (n = t.precision, e = t.rounding, t.precision = n + 7, t.rounding = 1, Sn(i.sinh(), i.cosh(), t.precision = n, t.rounding = e)) : new t(i.s) }, kn.inverseCosine = kn.acos = function () { var n, e = this, i = e.constructor, t = e.abs().cmp(1), r = i.precision, s = i.rounding; return -1 !== t ? 0 === t ? e.isNeg() ? a(i, r, s) : new i(0) : new i(NaN) : e.isZero() ? a(i, r + 4, s).times(.5) : (i.precision = r + 6, i.rounding = 1, e = e.asin(), n = a(i, r + 4, s).times(.5), i.precision = r, i.rounding = s, n.minus(e)) }, kn.inverseHyperbolicCosine = kn.acosh = function () { var n, e, i = this, t = i.constructor; return i.lte(1) ? new t(i.eq(1) ? 0 : NaN) : i.isFinite() ? (n = t.precision, e = t.rounding, t.precision = n + Math.max(Math.abs(i.e), i.sd()) + 4, t.rounding = 1, bn = !1, i = i.times(i).minus(1).sqrt().plus(i), bn = !0, t.precision = n, t.rounding = e, i.ln()) : new t(i) }, kn.inverseHyperbolicSine = kn.asinh = function () { var n, e, i = this, t = i.constructor; return !i.isFinite() || i.isZero() ? new t(i) : (n = t.precision, e = t.rounding, t.precision = n + 2 * Math.max(Math.abs(i.e), i.sd()) + 6, t.rounding = 1, bn = !1, i = i.times(i).plus(1).sqrt().plus(i), bn = !0, t.precision = n, t.rounding = e, i.ln()) }, kn.inverseHyperbolicTangent = kn.atanh = function () { var n, e, i, t, r = this, s = r.constructor; return r.isFinite() ? r.e >= 0 ? new s(r.abs().eq(1) ? r.s / 0 : r.isZero() ? r : NaN) : (n = s.precision, e = s.rounding, t = r.sd(), Math.max(t, n) < 2 * -r.e - 1 ? o(new s(r), n, e, !0) : (s.precision = i = t - r.e, r = Sn(r.plus(1), new s(1).minus(r), i + n, 1), s.precision = n + 4, s.rounding = 1, r = r.ln(), s.precision = n, s.rounding = e, r.times(.5))) : new s(NaN) }, kn.inverseSine = kn.asin = function () { var n, e, i, t, r = this, s = r.constructor; return r.isZero() ? new s(r) : (e = r.abs().cmp(1), i = s.precision, t = s.rounding, -1 !== e ? 0 === e ? (n = a(s, i + 4, t).times(.5), n.s = r.s, n) : new s(NaN) : (s.precision = i + 6, s.rounding = 1, r = r.div(new s(1).minus(r.times(r)).sqrt().plus(1)).atan(), s.precision = i, s.rounding = t, r.times(2))) }, kn.inverseTangent = kn.atan = function () { var n, e, i, t, r, s, u, c, f, h = this, l = h.constructor, d = l.precision, p = l.rounding; if (h.isFinite()) { if (h.isZero()) return new l(h); if (h.abs().eq(1) && _n >= d + 4) return u = a(l, d + 4, p).times(.25), u.s = h.s, u } else { if (!h.s) return new l(NaN); if (_n >= d + 4) return u = a(l, d + 4, p).times(.5), u.s = h.s, u } for (l.precision = c = d + 10, l.rounding = 1, i = Math.min(28, c / Rn + 2 | 0), n = i; n; --n) h = h.div(h.times(h).plus(1).sqrt().plus(1)); for (bn = !1, e = Math.ceil(c / Rn), t = 1, f = h.times(h), u = new l(h), r = h; -1 !== n;) if (r = r.times(f), s = u.minus(r.div(t += 2)), r = r.times(f), u = s.plus(r.div(t += 2)), void 0 !== u.d[e]) for (n = e; u.d[n] === s.d[n] && n--;); return i && (u = u.times(2 << i - 1)), bn = !0, o(u, l.precision = d, l.rounding = p, !0) }, kn.isFinite = function () { return !!this.d }, kn.isInteger = kn.isInt = function () { return !!this.d && qn(this.e / Rn) > this.d.length - 2 }, kn.isNaN = function () { return !this.s }, kn.isNegative = kn.isNeg = function () { return this.s < 0 }, kn.isPositive = kn.isPos = function () { return this.s > 0 }, kn.isZero = function () { return !!this.d && 0 === this.d[0] }, kn.lessThan = kn.lt = function (n) { return this.cmp(n) < 0 }, kn.lessThanOrEqualTo = kn.lte = function (n) { return this.cmp(n) < 1 }, kn.logarithm = kn.log = function (n) { var i, r, s, u, c, a, h, l, d = this, p = d.constructor, g = p.precision, w = p.rounding, v = 5; if (null == n) n = new p(10), i = !0; else { if (n = new p(n), r = n.d, n.s < 0 || !r || !r[0] || n.eq(1)) return new p(NaN); i = n.eq(10) } if (r = d.d, d.s < 0 || !r || !r[0] || d.eq(1)) return new p(r && !r[0] ? -1 / 0 : 1 != d.s ? NaN : r ? 0 : 1 / 0); if (i) if (r.length > 1) c = !0; else { for (u = r[0]; u % 10 === 0;) u /= 10; c = 1 !== u } if (bn = !1, h = g + v, a = m(d, h), s = i ? f(p, h + 10) : m(n, h), l = Sn(a, s, h, 1), t(l.d, u = g, w)) do if (h += 10, a = m(d, h), s = i ? f(p, h + 10) : m(n, h), l = Sn(a, s, h, 1), !c) { +e(l.d).slice(u + 1, u + 15) + 1 == 1e14 && (l = o(l, g + 1, 0)); break } while (t(l.d, u += 10, w)); return bn = !0, o(l, g, w) }, kn.minus = kn.sub = function (n) { var e, i, t, r, s, u, f, a, h, l, d, p, g = this, w = g.constructor; if (n = new w(n), !g.d || !n.d) return g.s && n.s ? g.d ? n.s = -n.s : n = new w(n.d || g.s !== n.s ? g : NaN) : n = new w(NaN), n; if (g.s != n.s) return n.s = -n.s, g.plus(n); if (h = g.d, p = n.d, f = w.precision, a = w.rounding, !h[0] || !p[0]) { if (p[0]) n.s = -n.s; else { if (!h[0]) return new w(3 === a ? -0 : 0); n = new w(g) } return bn ? o(n, f, a) : n } if (i = qn(n.e / Rn), l = qn(g.e / Rn), h = h.slice(), s = l - i) { for (d = 0 > s, d ? (e = h, s = -s, u = p.length) : (e = p, i = l, u = h.length), t = Math.max(Math.ceil(f / Rn), u) + 2, s > t && (s = t, e.length = 1), e.reverse(), t = s; t--;) e.push(0); e.reverse() } else { for (t = h.length, u = p.length, d = u > t, d && (u = t), t = 0; u > t; t++) if (h[t] != p[t]) { d = h[t] < p[t]; break } s = 0 } for (d && (e = h, h = p, p = e, n.s = -n.s), u = h.length, t = p.length - u; t > 0; --t) h[u++] = 0; for (t = p.length; t > s;) { if (h[--t] < p[t]) { for (r = t; r && 0 === h[--r];) h[r] = Pn - 1; --h[r], h[t] += Pn } h[t] -= p[t] } for (; 0 === h[--u];) h.pop(); for (; 0 === h[0]; h.shift())--i; return h[0] ? (n.d = h, n.e = c(h, i), bn ? o(n, f, a) : n) : new w(3 === a ? -0 : 0) }, kn.modulo = kn.mod = function (n) { var e, i = this, t = i.constructor; return n = new t(n), !i.d || !n.s || n.d && !n.d[0] ? new t(NaN) : !n.d || i.d && !i.d[0] ? o(new t(i), t.precision, t.rounding) : (bn = !1, 9 == t.modulo ? (e = Sn(i, n.abs(), 0, 3, 1), e.s *= n.s) : e = Sn(i, n, 0, t.modulo, 1), e = e.times(n), bn = !0, i.minus(e)) }, kn.naturalExponential = kn.exp = function () { return w(this) }, kn.naturalLogarithm = kn.ln = function () { return m(this) }, kn.negated = kn.neg = function () { var n = new this.constructor(this); return n.s = -n.s, o(n) }, kn.plus = kn.add = function (n) { var e, i, t, r, s, u, f, a, h, l, d = this, p = d.constructor; if (n = new p(n), !d.d || !n.d) return d.s && n.s ? d.d || (n = new p(n.d || d.s === n.s ? d : NaN)) : n = new p(NaN), n; if (d.s != n.s) return n.s = -n.s, d.minus(n); if (h = d.d, l = n.d, f = p.precision, a = p.rounding, !h[0] || !l[0]) return l[0] || (n = new p(d)), bn ? o(n, f, a) : n; if (s = qn(d.e / Rn), t = qn(n.e / Rn), h = h.slice(), r = s - t) { for (0 > r ? (i = h, r = -r, u = l.length) : (i = l, t = s, u = h.length), s = Math.ceil(f / Rn), u = s > u ? s + 1 : u + 1, r > u && (r = u, i.length = 1), i.reverse() ; r--;) i.push(0); i.reverse() } for (u = h.length, r = l.length, 0 > u - r && (r = u, i = l, l = h, h = i), e = 0; r;) e = (h[--r] = h[r] + l[r] + e) / Pn | 0, h[r] %= Pn; for (e && (h.unshift(e), ++t), u = h.length; 0 == h[--u];) h.pop(); return n.d = h, n.e = c(h, t), bn ? o(n, f, a) : n }, kn.precision = kn.sd = function (n) { var e, i = this; if (void 0 !== n && n !== !!n && 1 !== n && 0 !== n) throw Error(En + n); return i.d ? (e = h(i.d), n && i.e + 1 > e && (e = i.e + 1)) : e = NaN, e }, kn.round = function () { var n = this, e = n.constructor; return o(new e(n), n.e + 1, e.rounding) }, kn.sine = kn.sin = function () { var n, e, i = this, t = i.constructor; return i.isFinite() ? i.isZero() ? new t(i) : (n = t.precision, e = t.rounding, t.precision = n + Math.max(i.e, i.sd()) + Rn, t.rounding = 1, i = x(t, M(t, i)), t.precision = n, t.rounding = e, o(dn > 2 ? i.neg() : i, n, e, !0)) : new t(NaN) }, kn.squareRoot = kn.sqrt = function () { var n, i, t, r, s, u, c = this, f = c.d, a = c.e, h = c.s, l = c.constructor; if (1 !== h || !f || !f[0]) return new l(!h || 0 > h && (!f || f[0]) ? NaN : f ? c : 1 / 0); for (bn = !1, h = Math.sqrt(+c), 0 == h || h == 1 / 0 ? (i = e(f), (i.length + a) % 2 == 0 && (i += "0"), h = Math.sqrt(i), a = qn((a + 1) / 2) - (0 > a || a % 2), h == 1 / 0 ? i = "1e" + a : (i = h.toExponential(), i = i.slice(0, i.indexOf("e") + 1) + a), r = new l(i)) : r = new l(h.toString()), t = (a = l.precision) + 3; ;) if (u = r, r = u.plus(Sn(c, u, t + 2, 1)).times(.5), e(u.d).slice(0, t) === (i = e(r.d)).slice(0, t)) { if (i = i.slice(t - 3, t + 1), "9999" != i && (s || "4999" != i)) { (!+i || !+i.slice(1) && "5" == i.charAt(0)) && (o(r, a + 1, 1), n = !r.times(r).eq(c)); break } if (!s && (o(u, a + 1, 0), u.times(u).eq(c))) { r = u; break } t += 4, s = 1 } return bn = !0, o(r, a, l.rounding, n) }, kn.tangent = kn.tan = function () { var n, e, i = this, t = i.constructor; return i.isFinite() ? i.isZero() ? new t(i) : (n = t.precision, e = t.rounding, t.precision = n + 10, t.rounding = 1, i = i.sin(), i.s = 1, i = Sn(i, new t(1).minus(i.times(i)).sqrt(), n + 10, 0), t.precision = n, t.rounding = e, o(2 == dn || 4 == dn ? i.neg() : i, n, e, !0)) : new t(NaN) }, kn.times = kn.mul = function (n) { var e, i, t, r, s, u, f, a, h, l = this, d = l.constructor, p = l.d, g = (n = new d(n)).d; if (n.s *= l.s, !(p && p[0] && g && g[0])) return new d(!n.s || p && !p[0] && !g || g && !g[0] && !p ? NaN : p && g ? 0 * n.s : n.s / 0); for (i = qn(l.e / Rn) + qn(n.e / Rn), a = p.length, h = g.length, h > a && (s = p, p = g, g = s, u = a, a = h, h = u), s = [], u = a + h, t = u; t--;) s.push(0); for (t = h; --t >= 0;) { for (e = 0, r = a + t; r > t;) f = s[r] + g[t] * p[r - t - 1] + e, s[r--] = f % Pn | 0, e = f / Pn | 0; s[r] = (s[r] + e) % Pn | 0 } for (; !s[--u];) s.pop(); for (e ? ++i : s.shift(), t = s.length; !s[--t];) s.pop(); return n.d = s, n.e = c(s, i), bn ? o(n, d.precision, d.rounding) : n }, kn.toBinary = function (n, e) { return y(this, 2, n, e) }, kn.toDecimalPlaces = kn.toDP = function (n, e) { var t = this, r = t.constructor; return t = new r(t), void 0 === n ? t : (i(n, 0, gn), void 0 === e ? e = r.rounding : i(e, 0, 8), o(t, n + t.e + 1, e)) }, kn.toExponential = function (n, e) { var t, r = this, s = r.constructor; return void 0 === n ? t = u(r, !0) : (i(n, 0, gn), void 0 === e ? e = s.rounding : i(e, 0, 8), r = o(new s(r), n + 1, e), t = u(r, !0, n + 1)), r.isNeg() && !r.isZero() ? "-" + t : t }, kn.toFixed = function (n, e) { var t, r, s = this, c = s.constructor; return void 0 === n ? t = u(s) : (i(n, 0, gn), void 0 === e ? e = c.rounding : i(e, 0, 8), r = o(new c(s), n + s.e + 1, e), t = u(r, !1, n + r.e + 1)), s.isNeg() && !s.isZero() ? "-" + t : t }, kn.toFraction = function (n) { var i, t, r, s, o, u, c, f, a, l, d, p, g = this, w = g.d, m = g.constructor; if (!w) return new m(g); if (a = t = new m(1), r = f = new m(0), i = new m(r), o = i.e = h(w) - g.e - 1, u = o % Rn, i.d[0] = On(10, 0 > u ? Rn + u : u), null == n) n = o > 0 ? i : a; else { if (c = new m(n), !c.isInt() || c.lt(a)) throw Error(En + c); n = c.gt(i) ? o > 0 ? i : a : c } for (bn = !1, c = new m(e(w)), l = m.precision, m.precision = o = w.length * Rn * 2; d = Sn(c, i, 0, 1, 1), s = t.plus(d.times(r)), 1 != s.cmp(n) ;) t = r, r = s, s = a, a = f.plus(d.times(s)), f = s, s = i, i = c.minus(d.times(s)), c = s; return s = Sn(n.minus(t), r, 0, 1, 1), f = f.plus(s.times(a)), t = t.plus(s.times(r)), f.s = a.s = g.s, p = Sn(a, r, o, 1).minus(g).abs().cmp(Sn(f, t, o, 1).minus(g).abs()) < 1 ? [a, r] : [f, t], m.precision = l, bn = !0, p }, kn.toHexadecimal = kn.toHex = function (n, e) { return y(this, 16, n, e) }, kn.toNearest = function (n, e) { var t = this, r = t.constructor; if (t = new r(t), null == n) { if (!t.d) return t; n = new r(1), e = r.rounding } else { if (n = new r(n), void 0 !== e && i(e, 0, 8), !t.d) return n.s ? t : n; if (!n.d) return n.s && (n.s = t.s), n } return n.d[0] ? (bn = !1, 4 > e && (e = [4, 5, 7, 8][e]), t = Sn(t, n, 0, e, 1).times(n), bn = !0, o(t)) : (n.s = t.s, t = n), t }, kn.toNumber = function () { return +this }, kn.toOctal = function (n, e) { return y(this, 8, n, e) }, kn.toPower = kn.pow = function (n) { var i, r, s, u, c, f, a, h = this, l = h.constructor, p = +(n = new l(n)); if (!(h.d && n.d && h.d[0] && n.d[0])) return new l(On(+h, p)); if (h = new l(h), h.eq(1)) return h; if (s = l.precision, c = l.rounding, n.eq(1)) return o(h, s, c); if (i = qn(n.e / Rn), r = n.d.length - 1, a = i >= r, f = h.s, a) { if ((r = 0 > p ? -p : p) <= Ln) return u = d(l, h, r, s), n.s < 0 ? new l(1).div(u) : o(u, s, c) } else if (0 > f) return new l(NaN); return f = 0 > f && 1 & n.d[Math.max(i, r)] ? -1 : 1, r = On(+h, p), i = 0 != r && isFinite(r) ? new l(r + "").e : qn(p * (Math.log("0." + e(h.d)) / Math.LN10 + h.e + 1)), i > l.maxE + 1 || i < l.minE - 1 ? new l(i > 0 ? f / 0 : 0) : (bn = !1, l.rounding = h.s = 1, r = Math.min(12, (i + "").length), u = w(n.times(m(h, s + r)), s), u = o(u, s + 5, 1), t(u.d, s, c) && (i = s + 10, u = o(w(n.times(m(h, i + r)), i), i + 5, 1), +e(u.d).slice(s + 1, s + 15) + 1 == 1e14 && (u = o(u, s + 1, 0))), u.s = f, bn = !0, l.rounding = c, o(u, s, c)) }, kn.toPrecision = function (n, e) { var t, r = this, s = r.constructor; return void 0 === n ? t = u(r, r.e <= s.toExpNeg || r.e >= s.toExpPos) : (i(n, 1, gn), void 0 === e ? e = s.rounding : i(e, 0, 8), r = o(new s(r), n, e), t = u(r, n <= r.e || r.e <= s.toExpNeg, n)), r.isNeg() && !r.isZero() ? "-" + t : t }, kn.toSignificantDigits = kn.toSD = function (n, e) { var t = this, r = t.constructor; return void 0 === n ? (n = r.precision, e = r.rounding) : (i(n, 1, gn), void 0 === e ? e = r.rounding : i(e, 0, 8)), o(new r(t), n, e) }, kn.toString = function () { var n = this, e = n.constructor, i = u(n, n.e <= e.toExpNeg || n.e >= e.toExpPos); return n.isNeg() && !n.isZero() ? "-" + i : i }, kn.truncated = kn.trunc = function () { return o(new this.constructor(this), this.e + 1, 1) }, kn.valueOf = kn.toJSON = function () { var n = this, e = n.constructor, i = u(n, n.e <= e.toExpNeg || n.e >= e.toExpPos); return n.isNeg() ? "-" + i : i }; var Sn = function () { function n(n, e, i) { var t, r = 0, s = n.length; for (n = n.slice() ; s--;) t = n[s] * e + r, n[s] = t % i | 0, r = t / i | 0; return r && n.unshift(r), n } function e(n, e, i, t) { var r, s; if (i != t) s = i > t ? 1 : -1; else for (r = s = 0; i > r; r++) if (n[r] != e[r]) { s = n[r] > e[r] ? 1 : -1; break } return s } function i(n, e, i, t) { for (var r = 0; i--;) n[i] -= r, r = n[i] < e[i] ? 1 : 0, n[i] = r * t + n[i] - e[i]; for (; !n[0] && n.length > 1;) n.shift() } return function (t, r, s, u, c, f) { var a, h, l, d, p, g, w, m, v, N, b, x, E, M, y, q, O, F, A, D, Z = t.constructor, P = t.s == r.s ? 1 : -1, R = t.d, L = r.d; if (!(R && R[0] && L && L[0])) return new Z(t.s && r.s && (R ? !L || R[0] != L[0] : L) ? R && 0 == R[0] || !L ? 0 * P : P / 0 : NaN); for (f ? (p = 1, h = t.e - r.e) : (f = Pn, p = Rn, h = qn(t.e / p) - qn(r.e / p)), A = L.length, O = R.length, v = new Z(P), N = v.d = [], l = 0; L[l] == (R[l] || 0) ; l++); if (L[l] > (R[l] || 0) && h--, null == s ? (M = s = Z.precision, u = Z.rounding) : M = c ? s + (t.e - r.e) + 1 : s, 0 > M) N.push(1), g = !0; else { if (M = M / p + 2 | 0, l = 0, 1 == A) { for (d = 0, L = L[0], M++; (O > l || d) && M--; l++) y = d * f + (R[l] || 0), N[l] = y / L | 0, d = y % L | 0; g = d || O > l } else { for (d = f / (L[0] + 1) | 0, d > 1 && (L = n(L, d, f), R = n(R, d, f), A = L.length, O = R.length), q = A, b = R.slice(0, A), x = b.length; A > x;) b[x++] = 0; D = L.slice(), D.unshift(0), F = L[0], L[1] >= f / 2 && ++F; do d = 0, a = e(L, b, A, x), 0 > a ? (E = b[0], A != x && (E = E * f + (b[1] || 0)), d = E / F | 0, d > 1 ? (d >= f && (d = f - 1), w = n(L, d, f), m = w.length, x = b.length, a = e(w, b, m, x), 1 == a && (d--, i(w, m > A ? D : L, m, f))) : (0 == d && (a = d = 1), w = L.slice()), m = w.length, x > m && w.unshift(0), i(b, w, x, f), -1 == a && (x = b.length, a = e(L, b, A, x), 1 > a && (d++, i(b, x > A ? D : L, x, f))), x = b.length) : 0 === a && (d++, b = [0]), N[l++] = d, a && b[0] ? b[x++] = R[q] || 0 : (b = [R[q]], x = 1); while ((q++ < O || void 0 !== b[0]) && M--); g = void 0 !== b[0] } N[0] || N.shift() } if (1 == p) v.e = h, hn = g; else { for (l = 1, d = N[0]; d >= 10; d /= 10) l++; v.e = l + h * p - 1, o(v, c ? s + v.e + 1 : s, u, g) } return v } }(); Nn = I(Nn), mn = new Nn(mn), vn = new Nn(vn), Bridge.$Decimal = Nn, "function" == typeof define && define.amd ? define("decimal.js", function () { return Nn }) : "undefined" != typeof module && module.exports ? module.exports = Nn["default"] = Nn.Decimal = Nn : (n || (n = "undefined" != typeof self && self && self.self == self ? self : Function("return this")()), ln = n.Decimal, Nn.noConflict = function () { return n.Decimal = ln, Nn }/*, n.Decimal = Nn*/) }(Bridge.global);

    System.Decimal = function (v, provider, T) {
        if (this.constructor !== System.Decimal) {
            return new System.Decimal(v, provider, T);
        }

        if (v == null) {
            v = 0;
        }

        if (typeof v === "string") {
            provider = provider || System.Globalization.CultureInfo.getCurrentCulture();

            var nfInfo = provider && provider.getFormat(System.Globalization.NumberFormatInfo);

            if (nfInfo && nfInfo.numberDecimalSeparator !== ".") {
                v = v.replace(nfInfo.numberDecimalSeparator, ".");
            }

            if (!/^\s*[+-]?(\d+|\d+.|\d*\.\d+)((e|E)[+-]?\d+)?\s*$/.test(v)) {
                throw new System.FormatException();
            }

            v = v.replace(/\s/g, "");
        }

        if (T && T.precision && typeof v === "number") {
            var i = Bridge.Int.trunc(v);
            var length = (i + "").length;
            var p = T.precision - length;
            if (p < 0) {
                p = 0;
            }
            v = v.toFixed(p);
        }

        this.value = System.Decimal.getValue(v);
    }

    System.Decimal.$number = true;
    System.Decimal.$$name = "System.Decimal";
    System.Decimal.prototype.$$name = "System.Decimal";
    System.Decimal.$kind = "struct";
    System.Decimal.prototype.$kind = "struct";
    System.Decimal.$$inherits = [];
    Bridge.Class.addExtend(System.Decimal, [System.IComparable, System.IFormattable, System.IComparable$1(System.Decimal), System.IEquatable$1(System.Decimal)]);

    System.Decimal.$is = function (instance) {
        return instance instanceof System.Decimal;
    };

    System.Decimal.getDefaultValue = function () {
        return new System.Decimal(0);
    };

    System.Decimal.getValue = function (d) {
        if (!Bridge.hasValue(d)) {
            return this.getDefaultValue();
        }

        if (d instanceof System.Decimal) {
            return d.value;
        }

        if (d instanceof System.Int64 || d instanceof System.UInt64) {
            return new Bridge.$Decimal(d.toString());
        }

        return new Bridge.$Decimal(d);
    };

    System.Decimal.create = function (d) {
        if (!Bridge.hasValue(d)) {
            return null;
        }

        if (d instanceof System.Decimal) {
            return d;
        }

        return new System.Decimal(d);
    };

    System.Decimal.lift = function (d) {
        return d == null ? null : System.Decimal.create(d);
    };

    System.Decimal.prototype.toString = function (format, provider) {
        return Bridge.Int.format(this, format || "G", provider);
    };

    System.Decimal.prototype.toFloat = function () {
        return this.value.toNumber();
    };

    System.Decimal.prototype.toJSON = function () {
        return this.value.toNumber();
    };

    System.Decimal.prototype.format = function (format, provider) {
        return Bridge.Int.format(this, format, provider);
    };

    System.Decimal.prototype.decimalPlaces = function () {
        return this.value.decimalPlaces();
    };

    System.Decimal.prototype.dividedToIntegerBy = function (d) {
        return new System.Decimal(this.value.dividedToIntegerBy(System.Decimal.getValue(d)));
    };

    System.Decimal.prototype.exponential = function () {
        return new System.Decimal(this.value.exponential());
    };

    System.Decimal.prototype.abs = function () {
        return new System.Decimal(this.value.abs());
    };

    System.Decimal.prototype.floor = function () {
        return new System.Decimal(this.value.floor());
    };

    System.Decimal.prototype.ceil = function () {
        return new System.Decimal(this.value.ceil());
    };

    System.Decimal.prototype.trunc = function () {
        return new System.Decimal(this.value.trunc());
    };

    System.Decimal.round = function (obj, mode) {
        obj = System.Decimal.create(obj);

        var old = Bridge.$Decimal.rounding;

        Bridge.$Decimal.rounding = mode;

        var d = new System.Decimal(obj.value.round());

        Bridge.$Decimal.rounding = old;

        return d;
    };

    System.Decimal.toDecimalPlaces = function (obj, decimals, mode) {
        obj = System.Decimal.create(obj);
        var d = new System.Decimal(obj.value.toDecimalPlaces(decimals, mode));
        return d;
    };

    System.Decimal.prototype.compareTo = function (another) {
        return this.value.comparedTo(System.Decimal.getValue(another));
    };

    System.Decimal.prototype.add = function (another) {
        return new System.Decimal(this.value.plus(System.Decimal.getValue(another)));
    };

    System.Decimal.prototype.sub = function (another) {
        return new System.Decimal(this.value.minus(System.Decimal.getValue(another)));
    };

    System.Decimal.prototype.isZero = function () {
        return this.value.isZero;
    };

    System.Decimal.prototype.mul = function (another) {
        return new System.Decimal(this.value.times(System.Decimal.getValue(another)));
    };

    System.Decimal.prototype.div = function (another) {
        return new System.Decimal(this.value.dividedBy(System.Decimal.getValue(another)));
    };

    System.Decimal.prototype.mod = function (another) {
        return new System.Decimal(this.value.modulo(System.Decimal.getValue(another)));
    };

    System.Decimal.prototype.neg = function () {
        return new System.Decimal(this.value.negated());
    };

    System.Decimal.prototype.inc = function () {
        return new System.Decimal(this.value.plus(System.Decimal.getValue(1)));
    };

    System.Decimal.prototype.dec = function () {
        return new System.Decimal(this.value.minus(System.Decimal.getValue(1)));
    };

    System.Decimal.prototype.sign = function () {
        return this.value.isZero() ? 0 : (this.value.isNegative() ? -1 : 1);
    };

    System.Decimal.prototype.clone = function () {
        return new System.Decimal(this);
    };

    System.Decimal.prototype.ne = function (v) {
        return !!this.compareTo(v);
    };

    System.Decimal.prototype.lt = function (v) {
        return this.compareTo(v) < 0;
    };

    System.Decimal.prototype.lte = function (v) {
        return this.compareTo(v) <= 0;
    };

    System.Decimal.prototype.gt = function (v) {
        return this.compareTo(v) > 0;
    };

    System.Decimal.prototype.gte = function (v) {
        return this.compareTo(v) >= 0;
    };

    System.Decimal.prototype.equals = function (v) {
        if (v instanceof System.Decimal || typeof v === "number") {
            return !this.compareTo(v);
        }

        return false;
    };

    System.Decimal.prototype.equalsT = function (v) {
        return !this.compareTo(v);
    };

    System.Decimal.prototype.getHashCode = function () {
        var n = (this.sign() * 397 + this.value.e) | 0;

        for (var i = 0; i < this.value.d.length; i++) {
            n = (n * 397 + this.value.d[i]) | 0;
        }

        return n;
    };

    System.Decimal.toInt = function (v, tp) {
        if (!v) {
            return null;
        }

        if (tp) {
            var str,
                r;

            if (tp === System.Int64) {
                str = v.value.trunc().toString();
                r = new System.Int64(str);

                if (str !== r.value.toString()) {
                    throw new System.OverflowException();
                }

                return r;
            }

            if (tp === System.UInt64) {
                if (v.value.isNegative()) {
                    throw new System.OverflowException();
                }

                str = v.value.trunc().toString();
                r = new System.UInt64(str);

                if (str !== r.value.toString()) {
                    throw new System.OverflowException();
                }

                return r;
            }

            return Bridge.Int.check(Bridge.Int.trunc(v.value.toNumber()), tp);
        }

        var i = Bridge.Int.trunc(System.Decimal.getValue(v).toNumber());

        if (!Bridge.Int.$is(i)) {
            throw new System.OverflowException();
        }

        return i;
    };

    System.Decimal.tryParse = function (s, provider, v) {
        try {
            v.v = new System.Decimal(s, provider);

            return true;
        } catch (e) {
            v.v = new System.Decimal(0);

            return false;
        }
    };

    System.Decimal.toFloat = function (v) {
        if (!v) {
            return null;
        }

        return System.Decimal.getValue(v).toNumber();
    };

    System.Decimal.setConfig = function (config) {
        Bridge.$Decimal.config(config);
    };

    System.Decimal.min = function () {
        var values = [];

        for (var i = 0, len = arguments.length; i < len; i++) {
            values.push(System.Decimal.getValue(arguments[i]));
        }

        return new System.Decimal(Bridge.$Decimal.min.apply(Bridge.$Decimal, values));
    };

    System.Decimal.max = function () {
        var values = [];

        for (var i = 0, len = arguments.length; i < len; i++) {
            values.push(System.Decimal.getValue(arguments[i]));
        }

        return new System.Decimal(Bridge.$Decimal.max.apply(Bridge.$Decimal, values));
    };

    System.Decimal.random = function (dp) {
        return new System.Decimal(Bridge.$Decimal.random(dp));
    };

    System.Decimal.exp = function (d) {
        return new System.Decimal(System.Decimal.getValue(d).exp());
    };

    System.Decimal.exp = function (d) {
        return new System.Decimal(System.Decimal.getValue(d).exp());
    };

    System.Decimal.ln = function (d) {
        return new System.Decimal(System.Decimal.getValue(d).ln());
    };

    System.Decimal.log = function (d, logBase) {
        return new System.Decimal(System.Decimal.getValue(d).log(logBase));
    };

    System.Decimal.pow = function (d, exponent) {
        return new System.Decimal(System.Decimal.getValue(d).pow(exponent));
    };

    System.Decimal.sqrt = function (d) {
        return new System.Decimal(System.Decimal.getValue(d).sqrt());
    };

    System.Decimal.prototype.isFinite = function () {
        return this.value.isFinite();
    };

    System.Decimal.prototype.isInteger = function () {
        return this.value.isInteger();
    };

    System.Decimal.prototype.isNaN = function () {
        return this.value.isNaN();
    };

    System.Decimal.prototype.isNegative = function () {
        return this.value.isNegative();
    };

    System.Decimal.prototype.isZero = function () {
        return this.value.isZero();
    };

    System.Decimal.prototype.log = function (logBase) {
        return new System.Decimal(this.value.log(logBase));
    };

    System.Decimal.prototype.ln = function () {
        return new System.Decimal(this.value.ln());
    };

    System.Decimal.prototype.precision = function () {
        return this.value.precision();
    };

    System.Decimal.prototype.round = function () {
        var old = Bridge.$Decimal.rounding,
            r;

        Bridge.$Decimal.rounding = 6;
        r = new System.Decimal(this.value.round());
        Bridge.$Decimal.rounding = old;

        return r;
    };

    System.Decimal.prototype.sqrt = function () {
        return new System.Decimal(this.value.sqrt());
    };

    System.Decimal.prototype.toDecimalPlaces = function (dp, rm) {
        return new System.Decimal(this.value.toDecimalPlaces(dp, rm));
    };

    System.Decimal.prototype.toExponential = function (dp, rm) {
        return this.value.toExponential(dp, rm);
    };

    System.Decimal.prototype.toFixed = function (dp, rm) {
        return this.value.toFixed(dp, rm);
    };

    System.Decimal.prototype.pow = function (n) {
        return new System.Decimal(this.value.pow(n));
    };

    System.Decimal.prototype.toPrecision = function (dp, rm) {
        return this.value.toPrecision(dp, rm);
    };

    System.Decimal.prototype.toSignificantDigits = function (dp, rm) {
        return new System.Decimal(this.value.toSignificantDigits(dp, rm));
    };

    System.Decimal.prototype.valueOf = function () {
        return this.value.valueOf();
    };

    System.Decimal.prototype._toFormat = function (dp, rm, f) {
        var x = this.value;

        if (!x.isFinite()) {
            return x.toString();
        }

        var i,
            isNeg = x.isNeg(),
            groupSeparator = f.groupSeparator,
            g1 = +f.groupSize,
            g2 = +f.secondaryGroupSize,
            arr = x.toFixed(dp, rm).split("."),
            intPart = arr[0],
            fractionPart = arr[1],
            intDigits = isNeg ? intPart.slice(1) : intPart,
            len = intDigits.length;

        if (g2) {
            len -= (i = g1, g1 = g2, g2 = i);
        }

        if (g1 > 0 && len > 0) {
            i = len % g1 || g1;
            intPart = intDigits.substr(0, i);

            for (; i < len; i += g1) {
                intPart += groupSeparator + intDigits.substr(i, g1);
            }

            if (g2 > 0) {
                intPart += groupSeparator + intDigits.slice(i);
            }

            if (isNeg) {
                intPart = "-" + intPart;
            }
        }

        return fractionPart
            ? intPart + f.decimalSeparator + ((g2 = +f.fractionGroupSize)
                ? fractionPart.replace(new RegExp("\\d{" + g2 + "}\\B", "g"),
                    "$&" + f.fractionGroupSeparator)
                : fractionPart)
            : intPart;
    };

    System.Decimal.prototype.toFormat = function (dp, rm, provider) {
        var config = {
                decimalSeparator : ".",
                groupSeparator : ",",
                groupSize : 3,
                secondaryGroupSize : 0,
                fractionGroupSeparator : "\xA0",
                fractionGroupSize : 0
            },
            d;

        if (provider && !provider.getFormat) {
            config = Bridge.merge(config, provider);
            d = this._toFormat(dp, rm, config);
        } else {
            provider = provider || System.Globalization.CultureInfo.getCurrentCulture();

            var nfInfo = provider && provider.getFormat(System.Globalization.NumberFormatInfo);

            if (nfInfo) {
                config.decimalSeparator = nfInfo.numberDecimalSeparator;
                config.groupSeparator = nfInfo.numberGroupSeparator;
                config.groupSize = nfInfo.numberGroupSizes[0];
            }

            d = this._toFormat(dp, rm, config);
        }

        return d;
    };

    System.Decimal.prototype.getBytes = function () {
        var s = this.value.s,
            e = this.value.e,
            d = this.value.d,
            bytes = System.Array.init(23, 0, System.Byte);

        bytes[0] = s & 255;
        bytes[1] = e;

        if (d && d.length > 0) {
            bytes[2] = d.length * 4;

            for (var i = 0; i < d.length; i++) {
                bytes[i*4 + 3] = d[i] & 255;
                bytes[i*4 + 4] = (d[i] >> 8) & 255;
                bytes[i*4 + 5] = (d[i] >> 16) & 255;
                bytes[i*4 + 6] = (d[i] >> 24) & 255;
            }
        } else {
            bytes[2] = 0;
        }

        return bytes;
    };

    System.Decimal.fromBytes = function (bytes) {
        var value = new System.Decimal(0),
            s = Bridge.Int.sxb(bytes[0] & 255),
            e = bytes[1],
            ln = bytes[2],
            d = [];

        value.value.s = s;
        value.value.e = e;

        if (ln > 0) {
            for (var i = 3; i < (ln + 3);) {
                d.push(bytes[i] | bytes[i + 1] << 8 | bytes[i + 2] << 16 | bytes[i + 3] << 24);
                i = i + 4;
            }
        }

        value.value.d = d;

        return value;
    };

    Bridge.$Decimal.config({ precision: 29 });

    System.Decimal.Zero = System.Decimal(0);
    System.Decimal.One = System.Decimal(1);
    System.Decimal.MinusOne = System.Decimal(-1);
    System.Decimal.MinValue = System.Decimal("-79228162514264337593543950335");
    System.Decimal.MaxValue = System.Decimal("79228162514264337593543950335");
    System.Decimal.precision = 29;

    // @source Date.js

    Bridge.define("System.DateTime", {
        inherits: function () { return [System.IComparable, System.IComparable$1(System.DateTime), System.IEquatable$1(System.DateTime), System.IFormattable]; },
        $kind: "struct",
        fields: {
            kind: 0
        },
        methods: {
            $clone: function (to) { return this; }
        },
        statics: {
            TicksPerDay: System.Int64("864000000000"),

            DaysTo1970: 719162,
            YearDaysByMonth: [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334],

            MinTicks: System.Int64("0"),
            MaxTicks: System.Int64("3652059").mul(System.Int64("864000000000")).sub(1),

            // Difference in Ticks from 1-Jan-0001 to 1-Jan-1970 at UTC
            $minOffset: System.Int64("621355968000000000"),

            $is: function (instance) {
                return Bridge.isDate(instance);
            },

            $default: null,

            getDefaultValue: function () {
                if (this.$default === null) {
                    this.$default = this.create(1, 1, 1, 0, 0, 0, 0, 0);
                }

                return this.$default;
            },

            $min: null,

            // UTC Min Value
            getMinValue: function () {
                if (this.$min === null) {
                    this.$min = this.create$2(0, 0);
                }

                return this.$min;
            },

            $max: null,

            // UTC Max Value
            getMaxValue: function () {
                if (this.$max === null) {
                    this.$max = this.create$2(this.MaxTicks, 0);
                    this.$max.ticks = this.MaxTicks;
                }

                return this.$max;
            },

            $getTzOffset: function (d) {
                return d.getTimezoneOffset() * 60 * 1000;
            },

            // Get the number of ticks since 0001-01-01T00:00:00.0000000 UTC
            getTicks: function (d) {
                d.kind = (d.kind !== undefined) ? d.kind : 0

                if (d.ticks === undefined) {
                    if (d.kind === 1) {
                        d.ticks = System.Int64(d.getTime()).mul(10000).add(this.$minOffset);
                    } else {
                        d.ticks = System.Int64(d.getTime() - this.$getTzOffset(d)).mul(10000).add(this.$minOffset);
                    }
                }

                return d.ticks;
            },

            toLocalTime: function (d, throwOnOverflow) {
                var d1,
                    ticks = this.getTicks(d);

                if (d.kind !== 2) {
                    ticks = d.ticks.sub(System.Int64(this.$getTzOffset(d)).mul(10000));
                }

                d1 = this.create$2(ticks, 2);

                // Check if Ticks are out of range
                if (ticks.gt(this.MaxTicks) || ticks.lt(0)) {
                    if (throwOnOverflow && throwOnOverflow === true) {
                        throw new System.ArgumentException.$ctor1("Specified argument was out of the range of valid values.");
                    } else {
                        ticks = ticks.add(System.Int64(this.$getTzOffset(d1)).mul(10000));
                        d1 = this.create$2(ticks, 2);
                    }
                }

                return d1;
            },

            toUniversalTime: function (d) {
                var ticks = this.getTicks(d),
                    d1;

                // Assuming d is Local time, so adjust to UTC
                if (d.kind !== 1) {
                    ticks = ticks.add(System.Int64(this.$getTzOffset(d)).mul(10000));
                }

                d1 = this.create$2(ticks, 1);

                // Check if Ticks are out of range
                if (ticks.gt(this.MaxTicks) || ticks.lt(0)) {
                    ticks = ticks.sub(System.Int64(this.$getTzOffset(d1)).mul(10000));
                    d1 = this.create$2(ticks, 1);
                }

                return d1;
            },

            create: function (year, month, day, hour, minute, second, millisecond, kind) {
                year = (year !== undefined) ? year : new Date().getFullYear();
                month = (month !== undefined) ? month : new Date().getMonth() + 1;
                day = (day !== undefined) ? day : 1;
                hour = (hour !== undefined) ? hour : 0;
                minute = (minute !== undefined) ? minute : 0;
                second = (second !== undefined) ? second : 0;
                millisecond = (millisecond !== undefined) ? millisecond : 0;
                kind = (kind !== undefined) ? kind : 0;

                var d,
                    ticks;

                d = new Date(year, month - 1, day, hour, minute, second, millisecond);
                d.setFullYear(year);

                ticks = this.getTicks(d);

                if (kind === 1) {
                    d = new Date(d.getTime() - this.$getTzOffset(d))
                }

                d.kind = kind;
                d.ticks = ticks;

                return d;
            },

            create$1: function (date, kind) {
                kind = (kind !== undefined) ? kind : 0;

                var d;

                if (kind === 1) {
                    d = this.create(date.getUTCFullYear(), date.getUTCMonth() + 1, date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds(), kind);
                } else {
                    d = this.create(date.getFullYear(), date.getMonth() + 1, date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds(), kind);
                }

                d.ticks = this.getTicks(d)

                return d;
            },

            create$2: function (ticks, kind) {
                ticks = System.Int64.is64Bit(ticks) ? ticks : System.Int64(ticks);
                kind = (kind !== undefined) ? kind : 0

                var d = new Date(ticks.sub(this.$minOffset).div(10000).toNumber());

                if (kind !== 1) {
                    d = new Date(d.getTime() + this.$getTzOffset(d));
                }

                d.ticks = ticks;
                d.kind = kind;

                return d;
            },

            getToday: function () {
                var d = new Date();

                return this.create(d.getFullYear(), d.getMonth() + 1, d.getDate(), 0, 0, 0, 0, 2);
            },

            getNow: function () {
                return this.create$1(new Date(), 2);
            },

            getUtcNow: function () {
                return this.create$1(new Date(), 1);
            },

            getTimeOfDay: function (d) {
                var d1 = this.getDate(d);

                return new System.TimeSpan((d - d1) * 10000);
            },

            getKind: function (d) {
                d.kind = (d.kind !== undefined) ? d.kind : 0

                return d.kind;
            },

            specifyKind: function (d, kind) {
                return this.create$2(this.getTicks(d), kind);
            },

            $FileTimeOffset: System.Int64("584388").mul(System.Int64("864000000000")),

            FromFileTime: function (fileTime) {
                return this.toLocalTime(this.FromFileTimeUtc(fileTime));
            },

            FromFileTimeUtc: function (fileTime) {
                fileTime = System.Int64.is64Bit(fileTime) ? fileTime : System.Int64(fileTime);

                return this.create$2(fileTime.add(this.$FileTimeOffset), 1);
            },

            ToFileTime: function (d) {
                return this.ToFileTimeUtc(this.toUniversalTime(d));
            },

            ToFileTimeUtc: function (d) {
                return (this.getKind(d) !== 0) ? this.getTicks(this.toUniversalTime(d)) : this.getTicks(d);
            },

            isUseGenitiveForm: function (format, index, tokenLen, patternToMatch) {
                var i,
                    repeat = 0;

                for (i = index - 1; i >= 0 && format[i] !== patternToMatch; i--) { }

                if (i >= 0) {
                    while (--i >= 0 && format[i] === patternToMatch) {
                        repeat++;
                    }

                    if (repeat <= 1) {
                        return true;
                    }
                }

                for (i = index + tokenLen; i < format.length && format[i] !== patternToMatch; i++) { }

                if (i < format.length) {
                    repeat = 0;

                    while (++i < format.length && format[i] === patternToMatch) {
                        repeat++;
                    }

                    if (repeat <= 1) {
                        return true;
                    }
                }

                return false;
            },

            format: function (d, f, p) {
                var me = this,
                    kind = d.kind || 0,
                    isUtc = (kind === 1),
                    df = (p || System.Globalization.CultureInfo.getCurrentCulture()).getFormat(System.Globalization.DateTimeFormatInfo),
                    year = isUtc ? d.getUTCFullYear() : d.getFullYear(),
                    month = isUtc ? d.getUTCMonth() : d.getMonth(),
                    dayOfMonth = isUtc ? d.getUTCDate() : d.getDate(),
                    dayOfWeek = isUtc ? d.getUTCDay() : d.getDay(),
                    hour = isUtc ? d.getUTCHours() : d.getHours(),
                    minute = isUtc ? d.getUTCMinutes() : d.getMinutes(),
                    second = isUtc ? d.getUTCSeconds() : d.getSeconds(),
                    millisecond = isUtc ? d.getUTCMilliseconds() : d.getMilliseconds(),
                    timezoneOffset = d.getTimezoneOffset(),
                    formats;

                f = f || "G";

                if (f.length === 1) {
                    formats = df.getAllDateTimePatterns(f, true);
                    f = formats ? formats[0] : f;
                } else if (f.length === 2 && f.charAt(0) === "%") {
                    f = f.charAt(1);
                }

                var removeDot = false;

                f = f.replace(/(\\.|'[^']*'|"[^"]*"|d{1,4}|M{1,4}|yyyy|yy|y|HH?|hh?|mm?|ss?|tt?|u|f{1,7}|F{1,7}|K|z{1,3}|\:|\/)/g,
                    function (match, group, index) {
                        var part = match;

                        switch (match) {
                            case "dddd":
                                part = df.dayNames[dayOfWeek];

                                break;
                            case "ddd":
                                part = df.abbreviatedDayNames[dayOfWeek];

                                break;
                            case "dd":
                                part = dayOfMonth < 10 ? "0" + dayOfMonth : dayOfMonth;

                                break;
                            case "d":
                                part = dayOfMonth;

                                break;
                            case "MMMM":
                                if (me.isUseGenitiveForm(f, index, 4, "d")) {
                                    part = df.monthGenitiveNames[month];
                                } else {
                                    part = df.monthNames[month];
                                }

                                break;
                            case "MMM":
                                if (me.isUseGenitiveForm(f, index, 3, "d")) {
                                    part = df.abbreviatedMonthGenitiveNames[month];
                                } else {
                                    part = df.abbreviatedMonthNames[month];
                                }

                                break;
                            case "MM":
                                part = (month + 1) < 10 ? "0" + (month + 1) : (month + 1);

                                break;
                            case "M":
                                part = month + 1;

                                break;
                            case "yyyy":
                                part = ("0000" + year).substring(year.toString().length);

                                break;
                            case "yy":
                                part = (year % 100).toString();

                                if (part.length === 1) {
                                    part = "0" + part;
                                }

                                break;
                            case "y":
                                part = year % 100;

                                break;
                            case "h":
                            case "hh":
                                part = hour % 12;

                                if (!part) {
                                    part = "12";
                                } else if (match === "hh" && part.length === 1) {
                                    part = "0" + part;
                                }

                                break;
                            case "HH":
                                part = hour.toString();

                                if (part.length === 1) {
                                    part = "0" + part;
                                }

                                break;
                            case "H":
                                part = hour;
                                break;
                            case "mm":
                                part = minute.toString();

                                if (part.length === 1) {
                                    part = "0" + part;
                                }

                                break;
                            case "m":
                                part = minute;

                                break;
                            case "ss":
                                part = second.toString();

                                if (part.length === 1) {
                                    part = "0" + part;
                                }

                                break;
                            case "s":
                                part = second;
                                break;
                            case "t":
                            case "tt":
                                part = (hour < 12) ? df.amDesignator : df.pmDesignator;

                                if (match === "t") {
                                    part = part.charAt(0);
                                }

                                break;
                            case "F":
                            case "FF":
                            case "FFF":
                            case "FFFF":
                            case "FFFFF":
                            case "FFFFFF":
                            case "FFFFFFF":
                                part = millisecond.toString();

                                if (part.length < 3) {
                                    part = Array(4 - part.length).join("0") + part;
                                }

                                part = part.substr(0, match.length);

                                var c = '0',
                                    i = part.length - 1;

                                for (; i >= 0 && part.charAt(i) === c; i--);
                                part = part.substring(0, i + 1);

                                removeDot = part.length == 0;

                                break;
                            case "f":
                            case "ff":
                            case "fff":
                            case "ffff":
                            case "fffff":
                            case "ffffff":
                            case "fffffff":
                                part = millisecond.toString();

                                if (part.length < 3) {
                                    part = Array(4 - part.length).join("0") + part;
                                }

                                var ln = match === "u" ? 7 : match.length;
                                if (part.length < ln) {
                                    part = part + Array(8 - part.length).join("0");
                                }

                                part = part.substr(0, ln);

                                break;
                            case "z":
                                part = timezoneOffset / 60;
                                part = ((part >= 0) ? "-" : "+") + Math.floor(Math.abs(part));

                                break;
                            case "K":
                            case "zz":
                            case "zzz":
                                if (kind === 0) {
                                    part = "";
                                } else if (kind === 1) {
                                    part = "Z";
                                } else {
                                    part = timezoneOffset / 60;
                                    part = ((part > 0) ? "-" : "+") + System.String.alignString(Math.floor(Math.abs(part)).toString(), 2, "0", 2);

                                    if (match === "zzz" || match === "K") {
                                        part += df.timeSeparator + System.String.alignString(Math.floor(Math.abs(timezoneOffset % 60)).toString(), 2, "0", 2);
                                    }
                                }

                                break;
                            case ":":
                                part = df.timeSeparator;

                                break;
                            case "/":
                                part = df.dateSeparator;

                                break;
                            default:
                                part = match.substr(1, match.length - 1 - (match.charAt(0) !== "\\"));

                                break;
                        }

                        return part;
                    });

                if (removeDot) {
                    if (System.String.endsWith(f, ".")) {
                        f = f.substring(0, f.length - 1);
                    } else if (System.String.endsWith(f, ".Z")) {
                        f = f.substring(0, f.length - 2) + "Z";
                    } else if (kind === 2 && f.match(/\.([+-])/g) !== null) {
                        f = f.replace(/\.([+-])/g, '$1');
                    }
                }

                return f;
            },

            parse: function (value, provider, utc, silent) {
                var d = this.parseExact(value, null, provider, utc, true);

                if (d !== null) {
                    return d;
                }

                d = Date.parse(value);

                if (!isNaN(d)) {
                    return new Date(d);
                } else if (!silent) {
                    throw new System.FormatException.$ctor1("String does not contain a valid string representation of a date and time.");
                }
            },

            parseExact: function (str, format, provider, utc, silent) {
                if (!format) {
                    format = ["G", "g", "F", "f", "D", "d", "R", "r", "s", "S", "U", "u", "O", "o", "Y", "y", "M", "m", "T", "t"];
                }

                if (Bridge.isArray(format)) {
                    var j = 0,
                        d;

                    for (j; j < format.length; j++) {
                        d = this.parseExact(str, format[j], provider, utc, true);

                        if (d != null) {
                            return d;
                        }
                    }

                    if (silent) {
                        return null;
                    }

                    throw new System.FormatException.$ctor1("String does not contain a valid string representation of a date and time.");
                } else {
                    // TODO: The code below assumes that there are no quotation marks around the UTC/Z format token (the format patterns
                    // used by Bridge appear to use quotation marks throughout (see universalSortableDateTimePattern), including
                    // in the recent Newtonsoft.Json.JsonConvert release).
                    // Until the above is sorted out, manually remove quotation marks to get UTC times parsed correctly.
                    format = format.replace("'Z'", "Z");
                }

                var now = new Date(),
                    df = (provider || System.Globalization.CultureInfo.getCurrentCulture()).getFormat(System.Globalization.DateTimeFormatInfo),
                    am = df.amDesignator,
                    pm = df.pmDesignator,
                    idx = 0,
                    index = 0,
                    i = 0,
                    c,
                    token,
                    year = now.getFullYear(),
                    month = now.getMonth() + 1,
                    date = now.getDate(),
                    hh = 0,
                    mm = 0,
                    ss = 0,
                    ff = 0,
                    tt = "",
                    zzh = 0,
                    zzm = 0,
                    zzi,
                    sign,
                    neg,
                    names,
                    name,
                    invalid = false,
                    inQuotes = false,
                    tokenMatched,
                    formats,
                    kind = 0,
                    adjust = false,
                    offset = 0;

                if (str == null) {
                    throw new System.ArgumentNullException.$ctor1("str");
                }

                format = format || "G";

                if (format.length === 1) {
                    formats = df.getAllDateTimePatterns(format, true);
                    format = formats ? formats[0] : format;
                } else if (format.length === 2 && format.charAt(0) === "%") {
                    format = format.charAt(1);
                }

                while (index < format.length) {
                    c = format.charAt(index);
                    token = "";

                    if (inQuotes === "\\") {
                        token += c;
                        index++;
                    } else {
                        var nextChar = format.charAt(index + 1);
                        if (c === '.' && str.charAt(idx) !== c && (nextChar === 'F' || nextChar === 'f')) {
                            index++;
                            c = nextChar;
                        }

                        while ((format.charAt(index) === c) && (index < format.length)) {
                            token += c;
                            index++;
                        }
                    }

                    tokenMatched = true;

                    if (!inQuotes) {
                        if (token === "yyyy" || token === "yy" || token === "y") {
                            if (token === "yyyy") {
                                year = this.subparseInt(str, idx, 4, 4);
                            } else if (token === "yy") {
                                year = this.subparseInt(str, idx, 2, 2);
                            } else if (token === "y") {
                                year = this.subparseInt(str, idx, 2, 4);
                            }

                            if (year == null) {
                                invalid = true;
                                break;
                            }

                            idx += year.length;

                            if (year.length === 2) {
                                year = ~~year;
                                year = (year > 30 ? 1900 : 2000) + year;
                            }
                        } else if (token === "MMM" || token === "MMMM") {
                            month = 0;

                            if (token === "MMM") {
                                if (this.isUseGenitiveForm(format, index, 3, "d")) {
                                    names = df.abbreviatedMonthGenitiveNames;
                                } else {
                                    names = df.abbreviatedMonthNames;
                                }
                            } else {
                                if (this.isUseGenitiveForm(format, index, 4, "d")) {
                                    names = df.monthGenitiveNames;
                                } else {
                                    names = df.monthNames;
                                }
                            }

                            for (i = 0; i < names.length; i++) {
                                name = names[i];

                                if (str.substring(idx, idx + name.length).toLowerCase() === name.toLowerCase()) {
                                    month = (i % 12) + 1;
                                    idx += name.length;

                                    break;
                                }
                            }

                            if ((month < 1) || (month > 12)) {
                                invalid = true;

                                break;
                            }
                        } else if (token === "MM" || token === "M") {
                            month = this.subparseInt(str, idx, token.length, 2);

                            if (month == null || month < 1 || month > 12) {
                                invalid = true;

                                break;
                            }

                            idx += month.length;
                        } else if (token === "dddd" || token === "ddd") {
                            names = token === "ddd" ? df.abbreviatedDayNames : df.dayNames;

                            for (i = 0; i < names.length; i++) {
                                name = names[i];

                                if (str.substring(idx, idx + name.length).toLowerCase() === name.toLowerCase()) {
                                    idx += name.length;

                                    break;
                                }
                            }
                        } else if (token === "dd" || token === "d") {
                            date = this.subparseInt(str, idx, token.length, 2);

                            if (date == null || date < 1 || date > 31) {
                                invalid = true;

                                break;
                            }

                            idx += date.length;
                        } else if (token === "hh" || token === "h") {
                            hh = this.subparseInt(str, idx, token.length, 2);

                            if (hh == null || hh < 1 || hh > 12) {
                                invalid = true;

                                break;
                            }

                            idx += hh.length;
                        } else if (token === "HH" || token === "H") {
                            hh = this.subparseInt(str, idx, token.length, 2);

                            if (hh == null || hh < 0 || hh > 23) {
                                invalid = true;

                                break;
                            }

                            idx += hh.length;
                        } else if (token === "mm" || token === "m") {
                            mm = this.subparseInt(str, idx, token.length, 2);

                            if (mm == null || mm < 0 || mm > 59) {
                                return null;
                            }

                            idx += mm.length;
                        } else if (token === "ss" || token === "s") {
                            ss = this.subparseInt(str, idx, token.length, 2);

                            if (ss == null || ss < 0 || ss > 59) {
                                invalid = true;

                                break;
                            }

                            idx += ss.length;
                        } else if (token === "u") {
                            ff = this.subparseInt(str, idx, 1, 7);

                            if (ff == null) {
                                invalid = true;

                                break;
                            }

                            idx += ff.length;

                            if (ff.length > 3) {
                                ff = ff.substring(0, 3);
                            }
                        } else if (token.match(/f{1,7}/) !== null) {
                            ff = this.subparseInt(str, idx, token.length, 7);

                            if (ff == null) {
                                invalid = true;

                                break;
                            }

                            idx += ff.length;

                            if (ff.length > 3) {
                                ff = ff.substring(0, 3);
                            }
                        } else if (token.match(/F{1,7}/) !== null) {
                            ff = this.subparseInt(str, idx, 0, 7);

                            if (ff !== null) {
                                idx += ff.length;

                                if (ff.length > 3) {
                                    ff = ff.substring(0, 3);
                                }
                            }
                        } else if (token === "t") {
                            if (str.substring(idx, idx + 1).toLowerCase() === am.charAt(0).toLowerCase()) {
                                tt = am;
                            } else if (str.substring(idx, idx + 1).toLowerCase() === pm.charAt(0).toLowerCase()) {
                                tt = pm;
                            } else {
                                invalid = true;

                                break;
                            }

                            idx += 1;
                        } else if (token === "tt") {
                            if (str.substring(idx, idx + 2).toLowerCase() === am.toLowerCase()) {
                                tt = am;
                            } else if (str.substring(idx, idx + 2).toLowerCase() === pm.toLowerCase()) {
                                tt = pm;
                            } else {
                                invalid = true;

                                break;
                            }

                            idx += 2;
                        } else if (token === "z" || token === "zz") {
                            sign = str.charAt(idx);

                            if (sign === "-") {
                                neg = true;
                            } else if (sign === "+") {
                                neg = false;
                            } else {
                                invalid = true;

                                break;
                            }

                            idx++;

                            zzh = this.subparseInt(str, idx, 1, 2);

                            if (zzh == null || zzh > 14) {
                                invalid = true;

                                break;
                            }

                            idx += zzh.length;

                            offset = zzh * 60 * 60 * 1000;

                            if (neg) {
                                offset = -offset;
                            }
                        } else if (token === "Z") {
                            var ch = str.substring(idx, idx + 1);
                            if (ch === "Z" || ch === "z") {
                                kind = 1;
                                idx += 1;
                            } else {
                                invalid = true;
                            }

                            break;

                        } else if (token === "zzz" || token === "K") {
                            if (str.substring(idx, idx + 1) === "Z") {
                                kind = 2;
                                adjust = true;
                                idx += 1;

                                break;
                            }

                            name = str.substring(idx, idx + 6);

                            if (name === "") {
                                kind = 0;

                                break;
                            }

                            idx += name.length;

                            if (name.length !== 6 && name.length !== 5) {
                                invalid = true;

                                break;
                            }

                            sign = name.charAt(0);

                            if (sign === "-") {
                                neg = true;
                            } else if (sign === "+") {
                                neg = false;
                            } else {
                                invalid = true;

                                break;
                            }

                            zzi = 1;
                            zzh = this.subparseInt(name, zzi, 1, name.length === 6 ? 2 : 1);

                            if (zzh == null || zzh > 14) {
                                invalid = true;

                                break;
                            }

                            zzi += zzh.length;

                            if (name.charAt(zzi) !== df.timeSeparator) {
                                invalid = true;

                                break;
                            }

                            zzi++;

                            zzm = this.subparseInt(name, zzi, 1, 2);

                            if (zzm == null || zzh > 59) {
                                invalid = true;

                                break;
                            }

                            offset = zzh * 60 * 60 * 1000 + zzm * 60 * 1000;

                            if (neg) {
                                offset = -offset;
                            }

                            kind = 2;
                        } else {
                            tokenMatched = false;
                        }
                    }

                    if (inQuotes || !tokenMatched) {
                        name = str.substring(idx, idx + token.length);

                        if (!inQuotes && name === ":" && (token === df.timeSeparator || token === ":")) {

                        } else if ((!inQuotes && ((token === ":" && name !== df.timeSeparator) || (token === "/" && name !== df.dateSeparator))) || (name !== token && token !== "'" && token !== '"' && token !== "\\")) {
                            invalid = true;

                            break;
                        }

                        if (inQuotes === "\\") {
                            inQuotes = false;
                        }

                        if (token !== "'" && token !== '"' && token !== "\\") {
                            idx += token.length;
                        } else {
                            if (inQuotes === false) {
                                inQuotes = token;
                            } else {
                                if (inQuotes !== token) {
                                    invalid = true;
                                    break;
                                }

                                inQuotes = false;
                            }
                        }
                    }
                }

                if (inQuotes) {
                    invalid = true;
                }

                if (!invalid) {
                    if (idx !== str.length) {
                        invalid = true;
                    } else if (month === 2) {
                        if (((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0)) {
                            if (date > 29) {
                                invalid = true;
                            }
                        } else if (date > 28) {
                            invalid = true;
                        }
                    } else if ((month === 4) || (month === 6) || (month === 9) || (month === 11)) {
                        if (date > 30) {
                            invalid = true;
                        }
                    }
                }

                if (invalid) {
                    if (silent) {
                        return null;
                    }

                    throw new System.FormatException.$ctor1("String does not contain a valid string representation of a date and time.");
                }

                if (tt) {
                    if (hh < 12 && tt === pm) {
                        hh = hh - 0 + 12;
                    } else if (hh > 11 && tt === am) {
                        hh -= 12;
                    }
                }

                var d = this.create(year, month, date, hh, mm, ss, ff, kind);

                if (kind === 2) {
                    if (adjust === true) {
                        d = new Date(d.getTime() - this.$getTzOffset(d));
                        d.kind = kind;
                    } else if (offset !== 0) {
                        d = new Date(d.getTime() - this.$getTzOffset(d));
                        d = this.addMilliseconds(d, -offset);
                        d.kind = kind;
                    }
                }

                return d;
            },

            subparseInt: function (str, index, min, max) {
                var x,
                    token;

                for (x = max; x >= min; x--) {
                    token = str.substring(index, index + x);

                    if (token.length < min) {
                        return null;
                    }

                    if (/^\d+$/.test(token)) {
                        return token;
                    }
                }

                return null;
            },

            tryParse: function (value, provider, result, utc) {
                result.v = this.parse(value, provider, utc, true);

                if (result.v == null) {
                    result.v = this.getMinValue();

                    return false;
                }

                return true;
            },

            tryParseExact: function (v, f, p, r, utc) {
                r.v = this.parseExact(v, f, p, utc, true);

                if (r.v == null) {
                    r.v = this.getMinValue();

                    return false;
                }

                return true;
            },

            isDaylightSavingTime: function (d) {
                if (d.kind !== undefined && d.kind === 1) {
                    return false;
                }

                var tmp = new Date(d.getTime());

                tmp.setMonth(0);
                tmp.setDate(1);

                return tmp.getTimezoneOffset() !== d.getTimezoneOffset();
            },

            dateAddSubTimeSpan: function (d, t, direction) {
                return Bridge.hasValue$1(d, t) ? this.create$2(this.getTicks(d).add(t.getTicks().mul(direction)), d.kind) : null;
            },

            subdt: function (d, t) {
                return this.dateAddSubTimeSpan(d, t, -1);
            },

            adddt: function (d, t) {
                return this.dateAddSubTimeSpan(d, t, 1);
            },

            subdd: function (a, b) {
                return Bridge.hasValue$1(a, b) ? (new System.TimeSpan((this.getTicks(a).sub(this.getTicks(b))))) : null;
            },

            addYears: function (d, v) {
                return this.addMonths(d, v * 12);
            },

            addMonths: function (d, v) {
                var dt = new Date(d.getTime()),
                    day = d.getDate();

                dt.setDate(1);
                dt.setMonth(dt.getMonth() + v * 1);
                dt.setDate(Math.min(day, this.getDaysInMonth(dt.getFullYear(), dt.getMonth() + 1)));
                dt.kind = (d.kind !== undefined) ? d.kind : 0;

                return dt;
            },

            addDays: function (d, v) {
                var d1 = new Date(d.getTime());

                d1.setDate(d1.getDate() + Math.floor(v));
                d1.kind = (d.kind !== undefined) ? d.kind : 0;

                return v % 1 !== 0 ? this.addMilliseconds(d1, Math.round((v % 1) * 864e5)) : d1;
            },

            addHours: function (d, v) {
                return this.addMilliseconds(d, Math.round(v * 36e5));
            },

            addMinutes: function (d, v) {
                return this.addMilliseconds(d, Math.round(v * 6e4));
            },

            addSeconds: function (d, v) {
                return this.addMilliseconds(d, Math.round(v * 1e3));
            },

            addMilliseconds: function (d, v) {
                v = System.Int64.is64Bit(v) ? v : System.Int64(v);

                return System.DateTime.addTicks(d, v.mul(10000));
            },

            addTicks: function (d, v) {
                v = System.Int64.is64Bit(v) ? v : System.Int64(v);

                return this.create$2(this.getTicks(d).add(v), d.kind);
            },

            add: function (d, value) {
                return this.addTicks(d, value.getTicks());
            },

            subtract: function (d, value) {
                return this.addTicks(d, value.getTicks().mul(-1));
            },

            // Replaced leap year calculation for performance:
            // https://jsperf.com/leapyear-calculation/1
            getIsLeapYear: function (year) {
                if ((year & 3) != 0) {
                    return false;
                }

                return ((year % 100) != 0 || (year % 400) == 0);
            },

            getDaysInMonth: function (year, month) {
                return [31, (this.getIsLeapYear(year) ? 29 : 28), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month - 1];
            },

            $clearTime: function (d, isUTC) {
                var dt = new Date(d.getTime());

                if (isUTC === true) {
                    dt.setUTCHours(0);
                    dt.setUTCMinutes(0);
                    dt.setUTCSeconds(0);
                    dt.setUTCMilliseconds(0);
                    dt.kind = 1;
                } else {
                    dt.setHours(0);
                    dt.setMinutes(0);
                    dt.setSeconds(0);
                    dt.setMilliseconds(0);
                    dt.kind = 2;
                }

                dt.ticks = this.getTicks(dt);

                return dt;
            },

            // Optimized as per: https://jsperf.com/get-day-of-year
            getDayOfYear: function (d) {
                var dt = this.getDate(d),
                    mn = dt.getMonth(),
                    dn = dt.getDate(),
                    dayOfYear = this.YearDaysByMonth[mn] + dn;

                if (mn > 1 && this.getIsLeapYear(dt.getFullYear())) {
                    dayOfYear++;
                }

                return dayOfYear;
            },

            getDate: function (d) {
                d.kind = (d.kind !== undefined) ? d.kind : 0

                var d1 = this.$clearTime(d, d.kind === 1);

                d1.kind = d.kind;

                return d1;
            },

            getDayOfWeek: function (d) {
                return (this.getKind(d) === 1) ? d.getUTCDay() : d.getDay();
            },

            getYear: function (d) {
                return (this.getKind(d) === 1) ? d.getUTCFullYear() : d.getFullYear();
            },

            getMonth: function (d) {
                return ((this.getKind(d) === 1) ? d.getUTCMonth() : d.getMonth()) + 1;
            },

            getDay: function (d) {
                return (this.getKind(d) === 1) ? d.getUTCDate() : d.getDate();
            },

            getHour: function (d) {
                return (this.getKind(d) === 1) ? d.getUTCHours() : d.getHours();
            },

            getMinute: function (d) {
                return (this.getKind(d) === 1) ? d.getUTCMinutes() : d.getMinutes();
            },

            getSecond: function (d) {
                return (this.getKind(d) === 1) ? d.getUTCSeconds() : d.getSeconds();
            },

            getMillisecond: function (d) {
                return (this.getKind(d) === 1) ? d.getUTCMilliseconds() : d.getMilliseconds();
            },

            gt: function (a, b) {
                return (a != null && b != null) ? (this.getTicks(a).gt(this.getTicks(b))) : false;
            },

            gte: function (a, b) {
                return (a != null && b != null) ? (this.getTicks(a).gte(this.getTicks(b))) : false;
            },

            lt: function (a, b) {
                return (a != null && b != null) ? (this.getTicks(a).lt(this.getTicks(b))) : false;
            },

            lte: function (a, b) {
                return (a != null && b != null) ? (this.getTicks(a).lte(this.getTicks(b))) : false;
            }
        }
    });

    // @source TimeSpan.js

    Bridge.define("System.TimeSpan", {
        inherits: [System.IComparable],

        config: {
            alias: [
                "compareTo", ["System$IComparable$compareTo", "System$IComparable$1$compareTo", "System$IComparable$1System$TimeSpan$compareTo"]
            ]
        },

        $kind: "struct",
        statics: {
            fromDays: function (value) {
                return new System.TimeSpan(value * 864e9);
            },

            fromHours: function (value) {
                return new System.TimeSpan(value * 36e9);
            },

            fromMilliseconds: function (value) {
                return new System.TimeSpan(value * 1e4);
            },

            fromMinutes: function (value) {
                return new System.TimeSpan(value * 6e8);
            },

            fromSeconds: function (value) {
                return new System.TimeSpan(value * 1e7);
            },

            fromTicks: function (value) {
                return new System.TimeSpan(value);
            },

            ctor: function () {
                this.zero = new System.TimeSpan(System.Int64.Zero);
                this.maxValue = new System.TimeSpan(System.Int64.MaxValue);
                this.minValue = new System.TimeSpan(System.Int64.MinValue);
            },

            getDefaultValue: function () {
                return new System.TimeSpan(System.Int64.Zero);
            },

            neg: function (t) {
                return Bridge.hasValue(t) ? (new System.TimeSpan(t.ticks.neg())) : null;
            },

            sub: function (t1, t2) {
                return Bridge.hasValue$1(t1, t2) ? (new System.TimeSpan(t1.ticks.sub(t2.ticks))) : null;
            },

            eq: function (t1, t2) {
                if (t1 === null && t2 === null) {
                    return true;
                }

                return Bridge.hasValue$1(t1, t2) ? (t1.ticks.eq(t2.ticks)) : false;
            },

            neq: function (t1, t2) {
                if (t1 === null && t2 === null) {
                    return false;
                }

                return Bridge.hasValue$1(t1, t2) ? (t1.ticks.ne(t2.ticks)) : true;
            },

            plus: function (t) {
                return Bridge.hasValue(t) ? (new System.TimeSpan(t.ticks)) : null;
            },

            add: function (t1, t2) {
                return Bridge.hasValue$1(t1, t2) ? (new System.TimeSpan(t1.ticks.add(t2.ticks))) : null;
            },

            gt: function (a, b) {
                return Bridge.hasValue$1(a, b) ? (a.ticks.gt(b.ticks)) : false;
            },

            gte: function (a, b) {
                return Bridge.hasValue$1(a, b) ? (a.ticks.gte(b.ticks)) : false;
            },

            lt: function (a, b) {
                return Bridge.hasValue$1(a, b) ? (a.ticks.lt(b.ticks)) : false;
            },

            lte: function (a, b) {
                return Bridge.hasValue$1(a, b) ? (a.ticks.lte(b.ticks)) : false;
            },

            timeSpanWithDays: /^(\-)?(\d+)[\.|:](\d+):(\d+):(\d+)(\.\d+)?/,
            timeSpanNoDays: /^(\-)?(\d+):(\d+):(\d+)(\.\d+)?/,

            parse: function(value) {
                var match,
                    milliseconds;

                function parseMilliseconds(value) {
                    return value ? parseFloat('0' + value) * 1000 : 0;
                }

                if ((match = value.match(System.TimeSpan.timeSpanWithDays))) {
                    var ts = new System.TimeSpan(match[2], match[3], match[4], match[5], parseMilliseconds(match[6]));

                    return match[1] ? new System.TimeSpan(ts.ticks.neg()) : ts;
                }

                if ((match = value.match(System.TimeSpan.timeSpanNoDays))) {
                    var ts = new System.TimeSpan(0, match[2], match[3], match[4], parseMilliseconds(match[5]));

                    return match[1] ? new System.TimeSpan(ts.ticks.neg()) : ts;
                }

                return null;
            },

            tryParse: function (value, provider, result) {
                result.v = this.parse(value);

                if (result.v == null) {
                    result.v = this.minValue;

                    return false;
                }

                return true;
            }
        },

        ctor: function () {
            this.$initialize();
            this.ticks = System.Int64.Zero;

            if (arguments.length === 1) {
                this.ticks = arguments[0] instanceof System.Int64 ? arguments[0] : new System.Int64(arguments[0]);
            } else if (arguments.length === 3) {
                this.ticks = new System.Int64(arguments[0]).mul(60).add(arguments[1]).mul(60).add(arguments[2]).mul(1e7);
            } else if (arguments.length === 4) {
                this.ticks = new System.Int64(arguments[0]).mul(24).add(arguments[1]).mul(60).add(arguments[2]).mul(60).add(arguments[3]).mul(1e7);
            } else if (arguments.length === 5) {
                this.ticks = new System.Int64(arguments[0]).mul(24).add(arguments[1]).mul(60).add(arguments[2]).mul(60).add(arguments[3]).mul(1e3).add(arguments[4]).mul(1e4);
            }
        },

        TimeToTicks: function (hour, minute, second) {
            var totalSeconds = System.Int64(hour).mul("3600").add(System.Int64(minute).mul("60")).add(System.Int64(second));
            return totalSeconds.mul("10000000");
        },

        getTicks: function () {
            return this.ticks;
        },

        getDays: function () {
            return this.ticks.div(864e9).toNumber();
        },

        getHours: function () {
            return this.ticks.div(36e9).mod(24).toNumber();
        },

        getMilliseconds: function () {
            return this.ticks.div(1e4).mod(1e3).toNumber();
        },

        getMinutes: function () {
            return this.ticks.div(6e8).mod(60).toNumber();
        },

        getSeconds: function () {
            return this.ticks.div(1e7).mod(60).toNumber();
        },

        getTotalDays: function () {
            return this.ticks.toNumberDivided(864e9);
        },

        getTotalHours: function () {
            return this.ticks.toNumberDivided(36e9);
        },

        getTotalMilliseconds: function () {
            return this.ticks.toNumberDivided(1e4);
        },

        getTotalMinutes: function () {
            return this.ticks.toNumberDivided(6e8);
        },

        getTotalSeconds: function () {
            return this.ticks.toNumberDivided(1e7);
        },

        get12HourHour: function () {
            return (this.getHours() > 12) ? this.getHours() - 12 : (this.getHours() === 0) ? 12 : this.getHours();
        },

        add: function (ts) {
            return new System.TimeSpan(this.ticks.add(ts.ticks));
        },

        subtract: function (ts) {
            return new System.TimeSpan(this.ticks.sub(ts.ticks));
        },

        duration: function () {
            return new System.TimeSpan(this.ticks.abs());
        },

        negate: function () {
            return new System.TimeSpan(this.ticks.neg());
        },

        compareTo: function (other) {
            return this.ticks.compareTo(other.ticks);
        },

        equals: function (other) {
            return Bridge.is(other, System.TimeSpan) ? other.ticks.eq(this.ticks) : false;
        },

        equalsT: function (other) {
            return other.ticks.eq(this.ticks);
        },

        format: function (formatStr, provider) {
            return this.toString(formatStr, provider);
        },

        getHashCode: function () {
            return this.ticks.getHashCode();
        },

        toString: function (formatStr, provider) {
            var ticks = this.ticks,
                result = "",
                me = this,
                dtInfo = (provider || System.Globalization.CultureInfo.getCurrentCulture()).getFormat(System.Globalization.DateTimeFormatInfo),
                format = function (t, n, dir, cut) {
                    return System.String.alignString(Math.abs(t | 0).toString(), n || 2, "0", dir || 2, cut || false);
                },
                isNeg = ticks < 0;

            if (formatStr) {
                return formatStr.replace(/(\\.|'[^']*'|"[^"]*"|dd?|HH?|hh?|mm?|ss?|tt?|f{1,7}|\:|\/)/g,
                    function (match, group, index) {
                        var part = match;

                        switch (match) {
                            case "d":
                                return me.getDays();
                            case "dd":
                                return format(me.getDays());
                            case "H":
                                return me.getHours();
                            case "HH":
                                return format(me.getHours());
                            case "h":
                                return me.get12HourHour();
                            case "hh":
                                return format(me.get12HourHour());
                            case "m":
                                return me.getMinutes();
                            case "mm":
                                return format(me.getMinutes());
                            case "s":
                                return me.getSeconds();
                            case "ss":
                                return format(me.getSeconds());
                            case "t":
                                return ((me.getHours() < 12) ? dtInfo.amDesignator : dtInfo.pmDesignator).substring(0, 1);
                            case "tt":
                                return (me.getHours() < 12) ? dtInfo.amDesignator : dtInfo.pmDesignator;
                            case "f":
                            case "ff":
                            case "fff":
                            case "ffff":
                            case "fffff":
                            case "ffffff":
                            case "fffffff":
                                return format(me.getMilliseconds(), match.length, 1, true);
                            default:
                                return match.substr(1, match.length - 1 - (match.charAt(0) !== "\\"));
                        }
                    }
                );
            }

            if (ticks.abs().gte(864e9)) {
                result += format(ticks.toNumberDivided(864e9), 1) + ".";
                ticks = ticks.mod(864e9);
            }

            result += format(ticks.toNumberDivided(36e9)) + ":";
            ticks = ticks.mod(36e9);
            result += format(ticks.toNumberDivided(6e8) | 0) + ":";
            ticks = ticks.mod(6e8);
            result += format(ticks.toNumberDivided(1e7));
            ticks = ticks.mod(1e7);

            if (ticks.gt(0)) {
                result += "." + format(ticks.toNumber(), 7);
            }

            return (isNeg ? "-" : "") + result;
        }
    });

    Bridge.Class.addExtend(System.TimeSpan, [System.IComparable$1(System.TimeSpan), System.IEquatable$1(System.TimeSpan)]);

    // @source StringBuilder.js

    Bridge.define("System.Text.StringBuilder", {
        ctor: function () {
            this.$initialize();
            this.buffer = [],
            this.capacity = 16;

            if (arguments.length === 1) {
                this.append(arguments[0]);
            } else if (arguments.length === 2) {
                this.append(arguments[0]);
                this.setCapacity(arguments[1]);
            } else if (arguments.length >= 3) {
                this.append(arguments[0], arguments[1], arguments[2]);
                if (arguments.length === 4) {
                    this.setCapacity(arguments[3]);
                }
            }
        },

        getLength: function () {
            if (this.buffer.length < 2) {
                return this.buffer[0] ? this.buffer[0].length : 0;
            }

            var s = this.getString();

            return s.length;
        },

        setLength: function (value) {
            if (value === 0) {
                this.clear();
            } else if (value < 0) {
                throw new System.ArgumentOutOfRangeException.$ctor4("value", "Length cannot be less than zero");
            } else {
                var l = this.getLength();

                if (value === l) {
                    return;
                }

                var delta = value - l;

                if (delta > 0) {
                    this.append("\0", delta);
                } else {
                    this.remove(l + delta, -delta);
                }
            }
        },

        getCapacity: function () {
            var length = this.getLength();

            return (this.capacity > length) ? this.capacity : length;
        },

        setCapacity: function (value) {
            var length = this.getLength();

            if (value > length) {
                this.capacity = value;
            }
        },

        toString: function () {
            var s = this.getString();

            if (arguments.length === 2) {
                var startIndex = arguments[0],
                    length = arguments[1];

                this.checkLimits(s, startIndex, length);

                return s.substr(startIndex, length);
            }

            return s;
        },

        append: function (value) {
            if (value == null) {
                return this;
            }

            if (arguments.length === 2) {
                // append a char repeated count times
                var count = arguments[1];

                if (count === 0) {
                    return this;
                } else if (count < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("count", "cannot be less than zero");
                }

                value = Array(count + 1).join(value).toString();
            } else if (arguments.length === 3) {
                // append a (startIndex, count) substring of value
                var startIndex = arguments[1],
                    count = arguments[2];

                if (count === 0) {
                    return this;
                }

                this.checkLimits(value, startIndex, count);
                value = value.substr(startIndex, count);
            }

            this.buffer[this.buffer.length] = value;
            this.clearString();

            return this;
        },

        appendFormat: function (format) {
            return this.append(System.String.format.apply(System.String, arguments));
        },

        clear: function () {
            this.buffer = [];
            this.clearString();

            return this;
        },

        appendLine: function () {
            if (arguments.length === 1) {
                this.append(arguments[0]);
            }

            return this.append("\r\n");
        },

        equals: function (sb) {
            if (sb == null) {
                return false;
            }

            if (sb === this) {
                return true;
            }

            return this.toString() === sb.toString();
        },

        remove: function (startIndex, length) {
            var s = this.getString();

            this.checkLimits(s, startIndex, length);

            if (s.length === length && startIndex === 0) {
                // Optimization.  If we are deleting everything
                return this.clear();
            }

            if (length > 0) {
                this.buffer = [];
                this.buffer[0] = s.substring(0, startIndex);
                this.buffer[1] = s.substring(startIndex + length, s.length);
                this.clearString();
            }

            return this;
        },

        insert: function (index, value) {
            if (value == null) {
                return this;
            }

            if (arguments.length === 3) {
                // insert value repeated count times
                var count = arguments[2];

                if (count === 0) {
                    return this;
                } else if (count < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("count", "cannot be less than zero");
                }

                value = Array(count + 1).join(value).toString();
            }

            var s = this.getString();

            this.buffer = [];

            if (index < 1) {
                this.buffer[0] = value;
                this.buffer[1] = s;
            } else if (index >= s.length) {
                this.buffer[0] = s;
                this.buffer[1] = value;
            } else {
                this.buffer[0] = s.substring(0, index);
                this.buffer[1] = value;
                this.buffer[2] = s.substring(index, s.length);
            }

            this.clearString();

            return this;
        },

        replace: function (oldValue, newValue) {
            var r = new RegExp(oldValue, "g"),
                s = this.buffer.join("");

            this.buffer = [];

            if (arguments.length === 4) {
                var startIndex = arguments[2],
                    count = arguments[3],
                    b = s.substr(startIndex, count);

                this.checkLimits(s, startIndex, count);

                this.buffer[0] = s.substring(0, startIndex);
                this.buffer[1] = b.replace(r, newValue);
                this.buffer[2] = s.substring(startIndex + count, s.length);
            } else {
                this.buffer[0] = s.replace(r, newValue);
            }

            this.clearString();
            return this;
        },

        checkLimits: function (value, startIndex, length) {
            if (length < 0) {
                throw new System.ArgumentOutOfRangeException.$ctor4("length", "must be non-negative");
            }

            if (startIndex < 0) {
                throw new System.ArgumentOutOfRangeException.$ctor4("startIndex", "startIndex cannot be less than zero");
            }

            if (length > value.length - startIndex) {
                throw new System.ArgumentOutOfRangeException.$ctor4("Index and length must refer to a location within the string");
            }
        },

        clearString: function () {
            this.$str = null;
        },

        getString: function () {
            if (!this.$str) {
                this.$str = this.buffer.join("");
                this.buffer = [];
                this.buffer[0] = this.$str;
            }

            return this.$str;
        },

        getChar: function (index) {
            var str = this.getString();

            if (index < 0 || index >= str.length) {
                throw new System.IndexOutOfRangeException();
            }

            return str.charCodeAt(index);
        },

        setChar: function (index, value) {
            var str = this.getString();

            if (index < 0 || index >= str.length) {
                throw new System.ArgumentOutOfRangeException();
            }

            value = String.fromCharCode(value);
            this.buffer = [];
            this.buffer[0] = str.substring(0, index);
            this.buffer[1] = value;
            this.buffer[2] = str.substring(index + 1, str.length);
            this.clearString();
        }
    });

    // @source BridgeRegex.js

    (function () {
        var specials = [
                // order matters for these
                  "-"
                , "["
                , "]"
                // order doesn't matter for any of these
                , "/"
                , "{"
                , "}"
                , "("
                , ")"
                , "*"
                , "+"
                , "?"
                , "."
                , "\\"
                , "^"
                , "$"
                , "|"
        ],

        regex = RegExp("[" + specials.join("\\") + "]", "g"),

        regexpEscape = function (s) {
            return s.replace(regex, "\\$&");
        };

        Bridge.regexpEscape = regexpEscape;
    })();

    // @source DebugAssertException.js

    Bridge.define("System.Diagnostics.Debug.DebugAssertException", {
        inherits: [System.Exception],
        $kind: "nested class",
        ctors: {
            ctor: function (message, detailMessage, stackTrace) {
                this.$initialize();
                System.Exception.ctor.call(this, (message || "") + ("\n" || "") + (detailMessage || "") + ("\n" || "") + (stackTrace || ""));
            }
        }
    });

    // @source Debug.js

    Bridge.define("System.Diagnostics.Debug", {
        statics: {
            fields: {
                s_lock: null,
                s_indentLevel: 0,
                s_indentSize: 0,
                s_needIndent: false,
                s_indentString: null,
                s_ShowAssertDialog: null,
                s_WriteCore: null,
                s_shouldWriteToStdErr: false
            },
            props: {
                AutoFlush: {
                    get: function () {
                        return true;
                    },
                    set: function (value) { }
                },
                IndentLevel: {
                    get: function () {
                        return System.Diagnostics.Debug.s_indentLevel;
                    },
                    set: function (value) {
                        System.Diagnostics.Debug.s_indentLevel = value < 0 ? 0 : value;
                    }
                },
                IndentSize: {
                    get: function () {
                        return System.Diagnostics.Debug.s_indentSize;
                    },
                    set: function (value) {
                        System.Diagnostics.Debug.s_indentSize = value < 0 ? 0 : value;
                    }
                }
            },
            ctors: {
                init: function () {
                    this.s_lock = { };
                    this.s_indentSize = 4;
                    this.s_ShowAssertDialog = System.Diagnostics.Debug.ShowAssertDialog;
                    this.s_WriteCore = System.Diagnostics.Debug.WriteCore;
                    this.s_shouldWriteToStdErr = Bridge.referenceEquals(System.Environment.GetEnvironmentVariable("COMPlus_DebugWriteToStdErr"), "1");
                }
            },
            methods: {
                Close: function () { },
                Flush: function () { },
                Indent: function () {
                    System.Diagnostics.Debug.IndentLevel = (System.Diagnostics.Debug.IndentLevel + 1) | 0;
                },
                Unindent: function () {
                    System.Diagnostics.Debug.IndentLevel = (System.Diagnostics.Debug.IndentLevel - 1) | 0;
                },
                Print: function (message) {
                    System.Diagnostics.Debug.Write$2(message);
                },
                Print$1: function (format, args) {
                    if (args === void 0) { args = []; }
                    System.Diagnostics.Debug.Write$2(System.String.formatProvider.apply(System.String, [null, format].concat(args)));
                },
                Assert: function (condition) {
                    System.Diagnostics.Debug.Assert$2(condition, "", "");
                },
                Assert$1: function (condition, message) {
                    System.Diagnostics.Debug.Assert$2(condition, message, "");
                },
                Assert$2: function (condition, message, detailMessage) {
                    if (!condition) {
                        var stackTrace;

                        try {
                            throw System.NotImplemented.ByDesign;
                        } catch ($e1) {
                            $e1 = System.Exception.create($e1);
                            stackTrace = "";
                        }

                        System.Diagnostics.Debug.WriteLine$2(System.Diagnostics.Debug.FormatAssert(stackTrace, message, detailMessage));
                        System.Diagnostics.Debug.s_ShowAssertDialog(stackTrace, message, detailMessage);
                    }
                },
                Assert$3: function (condition, message, detailMessageFormat, args) {
                    if (args === void 0) { args = []; }
                    System.Diagnostics.Debug.Assert$2(condition, message, System.String.format.apply(System.String, [detailMessageFormat].concat(args)));
                },
                Fail: function (message) {
                    System.Diagnostics.Debug.Assert$2(false, message, "");
                },
                Fail$1: function (message, detailMessage) {
                    System.Diagnostics.Debug.Assert$2(false, message, detailMessage);
                },
                FormatAssert: function (stackTrace, message, detailMessage) {
                    var newLine = (System.Diagnostics.Debug.GetIndentString() || "") + ("\n" || "");
                    return "---- DEBUG ASSERTION FAILED ----" + (newLine || "") + "---- Assert Short Message ----" + (newLine || "") + (message || "") + (newLine || "") + "---- Assert Long Message ----" + (newLine || "") + (detailMessage || "") + (newLine || "") + (stackTrace || "");
                },
                WriteLine$2: function (message) {
                    System.Diagnostics.Debug.Write$2((message || "") + ("\n" || ""));
                },
                WriteLine: function (value) {
                    System.Diagnostics.Debug.WriteLine$2(value != null ? Bridge.toString(value) : null);
                },
                WriteLine$1: function (value, category) {
                    System.Diagnostics.Debug.WriteLine$4(value != null ? Bridge.toString(value) : null, category);
                },
                WriteLine$3: function (format, args) {
                    if (args === void 0) { args = []; }
                    System.Diagnostics.Debug.WriteLine$2(System.String.formatProvider.apply(System.String, [null, format].concat(args)));
                },
                WriteLine$4: function (message, category) {
                    if (category == null) {
                        System.Diagnostics.Debug.WriteLine$2(message);
                    } else {
                        System.Diagnostics.Debug.WriteLine$2((category || "") + ":" + (message || ""));
                    }
                },
                Write$2: function (message) {
                    System.Diagnostics.Debug.s_lock;
                    {
                        if (message == null) {
                            System.Diagnostics.Debug.s_WriteCore("");
                            return;
                        }
                        if (System.Diagnostics.Debug.s_needIndent) {
                            message = (System.Diagnostics.Debug.GetIndentString() || "") + (message || "");
                            System.Diagnostics.Debug.s_needIndent = false;
                        }
                        System.Diagnostics.Debug.s_WriteCore(message);
                        if (System.String.endsWith(message, "\n")) {
                            System.Diagnostics.Debug.s_needIndent = true;
                        }
                    }
                },
                Write: function (value) {
                    System.Diagnostics.Debug.Write$2(value != null ? Bridge.toString(value) : null);
                },
                Write$3: function (message, category) {
                    if (category == null) {
                        System.Diagnostics.Debug.Write$2(message);
                    } else {
                        System.Diagnostics.Debug.Write$2((category || "") + ":" + (message || ""));
                    }
                },
                Write$1: function (value, category) {
                    System.Diagnostics.Debug.Write$3(value != null ? Bridge.toString(value) : null, category);
                },
                WriteIf$2: function (condition, message) {
                    if (condition) {
                        System.Diagnostics.Debug.Write$2(message);
                    }
                },
                WriteIf: function (condition, value) {
                    if (condition) {
                        System.Diagnostics.Debug.Write(value);
                    }
                },
                WriteIf$3: function (condition, message, category) {
                    if (condition) {
                        System.Diagnostics.Debug.Write$3(message, category);
                    }
                },
                WriteIf$1: function (condition, value, category) {
                    if (condition) {
                        System.Diagnostics.Debug.Write$1(value, category);
                    }
                },
                WriteLineIf: function (condition, value) {
                    if (condition) {
                        System.Diagnostics.Debug.WriteLine(value);
                    }
                },
                WriteLineIf$1: function (condition, value, category) {
                    if (condition) {
                        System.Diagnostics.Debug.WriteLine$1(value, category);
                    }
                },
                WriteLineIf$2: function (condition, message) {
                    if (condition) {
                        System.Diagnostics.Debug.WriteLine$2(message);
                    }
                },
                WriteLineIf$3: function (condition, message, category) {
                    if (condition) {
                        System.Diagnostics.Debug.WriteLine$4(message, category);
                    }
                },
                GetIndentString: function () {
                    var $t;
                    var indentCount = Bridge.Int.mul(System.Diagnostics.Debug.IndentSize, System.Diagnostics.Debug.IndentLevel);
                    if (System.Nullable.eq((System.Diagnostics.Debug.s_indentString != null ? System.Diagnostics.Debug.s_indentString.length : null), indentCount)) {
                        return System.Diagnostics.Debug.s_indentString;
                    }
                    return ($t = System.String.fromCharCount(32, indentCount), System.Diagnostics.Debug.s_indentString = $t, $t);
                },
                ShowAssertDialog: function (stackTrace, message, detailMessage) {
                    if (System.Diagnostics.Debugger.IsAttached) {
                        debugger;
                    } else {
                        var ex = new System.Diagnostics.Debug.DebugAssertException(message, detailMessage, stackTrace);
                        System.Environment.FailFast$1(ex.Message, ex);
                    }
                },
                WriteCore: function (message) {
                    System.Diagnostics.Debug.WriteToDebugger(message);

                    if (System.Diagnostics.Debug.s_shouldWriteToStdErr) {
                        System.Diagnostics.Debug.WriteToStderr(message);
                    }
                },
                WriteToDebugger: function (message) {
                    if (System.Diagnostics.Debugger.IsLogging()) {
                        System.Diagnostics.Debugger.Log(0, null, message);
                    } else {
                        System.Console.WriteLine(message);

                    }
                },
                WriteToStderr: function (message) {
                    System.Console.WriteLine(message);







                }
            }
        }
    });

    // @source Debugger.js

    Bridge.define("System.Diagnostics.Debugger", {
        statics: {
            fields: {
                DefaultCategory: null
            },
            props: {
                IsAttached: {
                    get: function () {
                        return true;
                    }
                }
            },
            methods: {
                IsLogging: function () {
                    return true;
                },
                Launch: function () {
                    return true;
                },
                Log: function (level, category, message) { },
                NotifyOfCrossThreadDependency: function () { }
            }
        }
    });

    // @source Diagnostics.js

    Bridge.define("System.Diagnostics.Stopwatch", {
        ctor: function () {
            this.$initialize();
            this.reset();
        },

        start: function () {
            if (this.isRunning) {
                return;
            }

            this._startTime = System.Diagnostics.Stopwatch.getTimestamp();
            this.isRunning = true;
        },

        stop: function () {
            if (!this.isRunning) {
                return;
            }

            var endTimeStamp = System.Diagnostics.Stopwatch.getTimestamp();
            var elapsedThisPeriod = endTimeStamp.sub(this._startTime);
            this._elapsed = this._elapsed.add(elapsedThisPeriod);
            this.isRunning = false;
        },

        reset: function () {
            this._startTime = System.Int64.Zero;
            this._elapsed = System.Int64.Zero;
            this.isRunning = false;
        },

        restart: function () {
            this.isRunning = false;
            this._elapsed = System.Int64.Zero;
            this._startTime = System.Diagnostics.Stopwatch.getTimestamp();
            this.start();
        },

        ticks: function () {
            var timeElapsed = this._elapsed;

            if (this.isRunning)
            {
                var currentTimeStamp = System.Diagnostics.Stopwatch.getTimestamp();
                var elapsedUntilNow = currentTimeStamp.sub(this._startTime);

                timeElapsed = timeElapsed.add(elapsedUntilNow);
            }

            return timeElapsed;
        },

        milliseconds: function () {
            return this.ticks().mul(1000).div(System.Diagnostics.Stopwatch.frequency);
        },

        timeSpan: function () {
            return new System.TimeSpan(this.milliseconds().mul(10000));
        },

        statics: {
            startNew: function () {
                var s = new System.Diagnostics.Stopwatch();
                s.start();

                return s;
            }
        }
    });

if (typeof window !== 'undefined' && window.performance && window.performance.now) {
        System.Diagnostics.Stopwatch.frequency = new System.Int64(1e6);
        System.Diagnostics.Stopwatch.isHighResolution = true;
        System.Diagnostics.Stopwatch.getTimestamp = function () {
            return new System.Int64(Math.round(window.performance.now() * 1000));
        };
    } else if (typeof (process) !== "undefined" && process.hrtime) {
        System.Diagnostics.Stopwatch.frequency = new System.Int64(1e9);
        System.Diagnostics.Stopwatch.isHighResolution = true;
        System.Diagnostics.Stopwatch.getTimestamp = function () {
            var hr = process.hrtime();
            return new System.Int64(hr[0]).mul(1e9).add(hr[1]);
        };
    } else {
        System.Diagnostics.Stopwatch.frequency = new System.Int64(1e3);
        System.Diagnostics.Stopwatch.isHighResolution = false;
        System.Diagnostics.Stopwatch.getTimestamp = function () {
            return new System.Int64(new Date().valueOf());
        };
    }

    System.Diagnostics.Contracts.Contract = {
        reportFailure: function (failureKind, userMessage, condition, innerException, TException) {
            var conditionText = condition.toString();

            conditionText = conditionText.substring(conditionText.indexOf("return") + 7);
            conditionText = conditionText.substr(0, conditionText.lastIndexOf(";"));

            var failureMessage = (conditionText) ? "Contract '" + conditionText + "' failed" : "Contract failed",
                displayMessage = (userMessage) ? failureMessage + ": " + userMessage : failureMessage;

            if (TException) {
                throw new TException(conditionText, userMessage);
            } else {
                throw new System.Diagnostics.Contracts.ContractException(failureKind, displayMessage, userMessage, conditionText, innerException);
            }
        },
        assert: function (failureKind, scope, condition, message) {
            if (!condition.call(scope)) {
                System.Diagnostics.Contracts.Contract.reportFailure(failureKind, message, condition, null);
            }
        },
        requires: function (TException, scope, condition, message) {
            if (!condition.call(scope)) {
                System.Diagnostics.Contracts.Contract.reportFailure(0, message, condition, null, TException);
            }
        },
        forAll: function (fromInclusive, toExclusive, predicate) {
            if (!predicate) {
                throw new System.ArgumentNullException.$ctor1("predicate");
            }

            for (; fromInclusive < toExclusive; fromInclusive++) {
                if (!predicate(fromInclusive)) {
                    return false;
                }
            }

            return true;
        },
        forAll$1: function (collection, predicate) {
            if (!collection) {
                throw new System.ArgumentNullException.$ctor1("collection");
            }

            if (!predicate) {
                throw new System.ArgumentNullException.$ctor1("predicate");
            }

            var enumerator = Bridge.getEnumerator(collection);

            try {
                while (enumerator.moveNext()) {
                    if (!predicate(enumerator.Current)) {
                        return false;
                    }
                }

                return true;
            } finally {
                enumerator.Dispose();
            }
        },
        exists: function (fromInclusive, toExclusive, predicate) {
            if (!predicate) {
                throw new System.ArgumentNullException.$ctor1("predicate");
            }

            for (; fromInclusive < toExclusive; fromInclusive++) {
                if (predicate(fromInclusive)) {
                    return true;
                }
            }

            return false;
        },
        exists$1: function (collection, predicate) {
            if (!collection) {
                throw new System.ArgumentNullException.$ctor1("collection");
            }

            if (!predicate) {
                throw new System.ArgumentNullException.$ctor1("predicate");
            }

            var enumerator = Bridge.getEnumerator(collection);

            try {
                while (enumerator.moveNext()) {
                    if (predicate(enumerator.Current)) {
                        return true;
                    }
                }

                return false;
            } finally {
                enumerator.Dispose();
            }
        }
    };

    Bridge.define("System.Diagnostics.Contracts.ContractFailureKind", {
        $kind: "enum",
        $statics: {
            precondition: 0,
            postcondition: 1,
            postconditionOnException: 2,
            invarian: 3,
            assert: 4,
            assume: 5
        }
    });

    Bridge.define("System.Diagnostics.Contracts.ContractException", {
        inherits: [System.Exception],

        config: {
            properties: {
                Kind: {
                    get: function () {
                        return this._kind;
                    }
                },

                Failure: {
                    get: function () {
                        return this._failureMessage;
                    }
                },

                UserMessage: {
                    get: function () {
                        return this._userMessage;
                    }
                },

                Condition: {
                    get: function () {
                        return this._condition;
                    }
                }
            }
        },

        ctor: function (failureKind, failureMessage, userMessage, condition, innerException) {
            this.$initialize();
            System.Exception.ctor.call(this, failureMessage, innerException);
            this._kind = failureKind;
            this._failureMessage = failureMessage || null;
            this._userMessage = userMessage || null;
            this._condition = condition || null;
        }
    });

    // @source Array.js

    var array = {
        toIndex: function (arr, indices) {
            if (indices.length !== (arr.$s ? arr.$s.length : 1)) {
                throw new System.ArgumentException.$ctor1("Invalid number of indices");
            }

            if (indices[0] < 0 || indices[0] >= (arr.$s ? arr.$s[0] : arr.length)) {
                throw new System.IndexOutOfRangeException.$ctor1("Index 0 out of range");
            }

            var idx = indices[0],
                i;

            if (arr.$s) {
                for (i = 1; i < arr.$s.length; i++) {
                    if (indices[i] < 0 || indices[i] >= arr.$s[i]) {
                        throw new System.IndexOutOfRangeException.$ctor1("Index " + i + " out of range");
                    }

                    idx = idx * arr.$s[i] + indices[i];
                }
            }

            return idx;
        },

        index: function (index, arr) {
            if (index < 0 || index >= arr.length) {
                throw new System.IndexOutOfRangeException();
            }
            return index;
        },

        $get: function (indices) {
            var r = this[System.Array.toIndex(this, indices)];

            return typeof r !== "undefined" ? r : this.$v;
        },

        get: function (arr) {
            if (arguments.length < 2) {
                throw new System.ArgumentNullException.$ctor1("indices");
            }

            var idx = Array.prototype.slice.call(arguments, 1);

            for (var i = 0; i < idx.length; i++) {
                if (!Bridge.hasValue(idx[i])) {
                    throw new System.ArgumentNullException.$ctor1("indices");
                }
            }

            var r = arr[System.Array.toIndex(arr, idx)];

            return typeof r !== "undefined" ? r : arr.$v;
        },

        $set: function (indices, value) {
            this[System.Array.toIndex(this, indices)] = value;
        },

        set: function (arr, value) {
            var indices = Array.prototype.slice.call(arguments, 2);

            arr[System.Array.toIndex(arr, indices)] = value;
        },

        getLength: function (arr, dimension) {
            if (dimension < 0 || dimension >= (arr.$s ? arr.$s.length : 1)) {
                throw new System.IndexOutOfRangeException();
            }

            return arr.$s ? arr.$s[dimension] : arr.length;
        },

        getRank: function (arr) {
            return arr.$type ? arr.$type.$rank : (arr.$s ? arr.$s.length : 1);
        },

        getLower: function (arr, d) {
            System.Array.getLength(arr, d);

            return 0;
        },

        create: function (defvalue, initValues, T, sizes) {
            if (sizes === null) {
                throw new System.ArgumentNullException.$ctor1("length");
            }

            var arr = [],
                length = arguments.length > 3 ? 1 : 0,
                i, s, v, j,
                idx,
                indices,
                flatIdx;

            arr.$v = defvalue;
            arr.$s = [];
            arr.get = System.Array.$get;
            arr.set = System.Array.$set;

            if (sizes && Bridge.isArray(sizes)) {
                for (i = 0; i < sizes.length; i++) {
                    j = sizes[i];

                    if (isNaN(j) || j < 0) {
                        throw new System.ArgumentOutOfRangeException.$ctor1("length");
                    }

                    length *= j;
                    arr.$s[i] = j;
                }
            } else {
                for (i = 3; i < arguments.length; i++) {
                    j = arguments[i];

                    if (isNaN(j) || j < 0) {
                        throw new System.ArgumentOutOfRangeException.$ctor1("length");
                    }

                    length *= j;
                    arr.$s[i - 3] = j;
                }
            }

            arr.length = length;
            var isFn = Bridge.isFunction(defvalue);

            for (var k = 0; k < length; k++) {
                arr[k] = isFn ? defvalue() : defvalue;
            }

            if (initValues) {
                for (i = 0; i < arr.length; i++) {
                    indices = [];
                    flatIdx = i;

                    for (s = arr.$s.length - 1; s >= 0; s--) {
                        idx = flatIdx % arr.$s[s];
                        indices.unshift(idx);
                        flatIdx = Bridge.Int.div(flatIdx - idx, arr.$s[s]);
                    }

                    v = initValues;

                    for (idx = 0; idx < indices.length; idx++) {
                        v = v[indices[idx]];
                    }

                    arr[i] = v;
                }
            }

            System.Array.init(arr, T, arr.$s.length);

            return arr;
        },

        init: function (length, value, T, addFn) {
            if (length == null) {
                throw new System.ArgumentNullException.$ctor1("length");
            }

            if (Bridge.isArray(length)) {
                var elementType = value,
                    rank = T || 1;

                System.Array.type(elementType, rank, length);

                return length;
            }

            if (isNaN(length) || length < 0) {
                throw new System.ArgumentOutOfRangeException.$ctor1("length");
            }

            var arr = new Array(length),
                isFn = addFn !== true && Bridge.isFunction(value);

            for (var i = 0; i < length; i++) {
                arr[i] = isFn ? value() : value;
            }

            return System.Array.init(arr, T, 1);
        },

        toEnumerable: function (array) {
            return new Bridge.ArrayEnumerable(array);
        },

        toEnumerator: function (array, T) {
            return new Bridge.ArrayEnumerator(array, T);
        },

        _typedArrays: {
            Float32Array: System.Single,
            Float64Array: System.Double,
            Int8Array: System.SByte,
            Int16Array: System.Int16,
            Int32Array: System.Int32,
            Uint8Array: System.Byte,
            Uint8ClampedArray: System.Byte,
            Uint16Array: System.UInt16,
            Uint32Array: System.UInt32
        },

        is: function (obj, type) {
            if (obj instanceof Bridge.ArrayEnumerator) {
                if ((obj.constructor === type) || (obj instanceof type) ||
                    type === Bridge.ArrayEnumerator ||
                    type.$$name && System.String.startsWith(type.$$name, "System.Collections.IEnumerator") ||
                    type.$$name && System.String.startsWith(type.$$name, "System.Collections.Generic.IEnumerator")) {
                    return true;
                }

                return false;
            }

            if (!Bridge.isArray(obj)) {
                return false;
            }

            if (type.$elementType && type.$isArray) {
                var et = Bridge.getType(obj).$elementType;

                if (et) {
                    return System.Array.getRank(obj) === type.$rank && Bridge.Reflection.isAssignableFrom(type.$elementType, et);
                }

                type = Array;
            }

            if ((obj.constructor === type) || (obj instanceof type)) {
                return true;
            }

            if (type === System.Collections.IEnumerable ||
                type === System.Collections.ICollection ||
                type === System.ICloneable ||
                type === System.Collections.IList ||
                type.$$name && System.String.startsWith(type.$$name, "System.Collections.Generic.IEnumerable$1") ||
                type.$$name && System.String.startsWith(type.$$name, "System.Collections.Generic.ICollection$1") ||
                type.$$name && System.String.startsWith(type.$$name, "System.Collections.Generic.IList$1") ||
                type.$$name && System.String.startsWith(type.$$name, "System.Collections.Generic.IReadOnlyCollection$1") ||
                type.$$name && System.String.startsWith(type.$$name, "System.Collections.Generic.IReadOnlyList$1")) {
                return true;
            }

            return !!System.Array._typedArrays[String.prototype.slice.call(Object.prototype.toString.call(obj), 8, -1)];
        },

        clone: function (arr) {
            var newArr;

            if (arr.length === 1) {
                newArr = [arr[0]];
            } else {
                newArr = arr.slice(0);
            }

            newArr.$type = arr.$type;
            newArr.$v = arr.$v;
            newArr.$s = arr.$s;
            newArr.get = System.Array.$get;
            newArr.set = System.Array.$set;

            return newArr;
        },

        getCount: function (obj, T) {
            var name,
                v;

            if (Bridge.isArray(obj)) {
                return obj.length;
            } else if (T && Bridge.isFunction(obj[name = "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$getCount"])) {
                return obj[name]();
            } else if (Bridge.isFunction(obj[name = "System$Collections$ICollection$getCount"])) {
                return obj[name]();
            } else if (T && (v = obj["System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$Count"]) !== undefined) {
                return v;
            } else if ((v = obj["System$Collections$ICollection$Count"]) !== undefined) {
                return v;
            } else if ((v = obj.Count) !== undefined) {
                return v;
            } else if (Bridge.isFunction(obj.getCount)) {
                return obj.getCount();
            }

            return 0;
        },

        getIsReadOnly: function (obj, T) {
            var name,
                v;

            if (Bridge.isArray(obj)) {
                return T ? true : false;
            } else if (T && Bridge.isFunction(obj[name = "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$getIsReadOnly"])) {
                return obj[name]();
            } else if (T && (v = obj["System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$IsReadOnly"]) !== undefined) {
                return v;
            } else if (Bridge.isFunction(obj[name = "System$Collections$IList$getIsReadOnly"])) {
                return obj[name]();
            } else if ((v = obj["System$Collections$IList$IsReadOnly"]) !== undefined) {
                return v;
            } else if ((v = obj.IsReadOnly) !== undefined) {
                return v;
            } else if (Bridge.isFunction(obj.getIsReadOnly)) {
                return obj.getIsReadOnly();
            }

            return false;
        },

        checkReadOnly: function (obj, T, msg) {
            if (Bridge.isArray(obj)) {
                if (T) {
                    throw new System.NotSupportedException.$ctor1(msg || "Collection was of a fixed size.");
                }
            } else if (System.Array.getIsReadOnly(obj, T)) {
                throw new System.NotSupportedException.$ctor1(msg || "Collection is read-only.");
            }
        },

        add: function (obj, item, T) {
            var name;

            System.Array.checkReadOnly(obj, T);

            if (T) {
                item = System.Array.checkNewElementType(item, T);
            }

            if (T && Bridge.isFunction(obj[name = "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$add"])) {
                return obj[name](item);
            } else if (Bridge.isFunction(obj[name = "System$Collections$IList$add"])) {
                return obj[name](item);
            } else if (Bridge.isFunction(obj.add)) {
                return obj.add(item);
            }

            return -1;
        },

        checkNewElementType: function (v, type) {
            var unboxed = Bridge.unbox(v, true);

            if (Bridge.isNumber(unboxed)) {
                if (type === System.Decimal) {
                    return new System.Decimal(unboxed);
                }

                if (type === System.Int64) {
                    return new System.Int64(unboxed);
                }

                if (type === System.UInt64) {
                    return new System.UInt64(unboxed);
                }
            }

            var is = Bridge.is(v, type);

            if (!is) {
                if (v == null && Bridge.getDefaultValue(type) == null) {
                    return null;
                }

                throw new System.ArgumentException.$ctor1("The value " + unboxed + "is not of type " + Bridge.getTypeName(type) + " and cannot be used in this generic collection.");
            }

            return unboxed;
        },

        clear: function (obj, T) {
            var name;

            System.Array.checkReadOnly(obj, T, "Collection is read-only.");

            if (Bridge.isArray(obj)) {
                System.Array.fill(obj, T ? (T.getDefaultValue || Bridge.getDefaultValue(T)) : null, 0, obj.length);
            } else if (T && Bridge.isFunction(obj[name = "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$clear"])) {
                obj[name]();
            } else if (Bridge.isFunction(obj[name = "System$Collections$IList$clear"])) {
                obj[name]();
            } else if (Bridge.isFunction(obj.clear)) {
                obj.clear();
            }
        },

        fill: function (dst, val, index, count) {
            if (!Bridge.hasValue(dst)) {
                throw new System.ArgumentNullException.$ctor1("dst");
            }

            if (index < 0 || count < 0 || (index + count) > dst.length) {
                throw new System.IndexOutOfRangeException();
            }

            var isFn = Bridge.isFunction(val);

            while (--count >= 0) {
                dst[index + count] = isFn ? val() : val;
            }
        },

        copy: function (src, spos, dest, dpos, len) {
            if (!dest) {
                throw new System.ArgumentNullException.$ctor3("dest", "Value cannot be null");
            }

            if (!src) {
                throw new System.ArgumentNullException.$ctor3("src", "Value cannot be null");
            }

            if (spos < 0 || dpos < 0 || len < 0) {
                throw new System.ArgumentOutOfRangeException.$ctor1("bound", "Number was less than the array's lower bound in the first dimension");
            }

            if (len > (src.length - spos) || len > (dest.length - dpos)) {
                throw new System.ArgumentException.$ctor1("Destination array was not long enough. Check destIndex and length, and the array's lower bounds");
            }

            if (spos < dpos && src === dest) {
                while (--len >= 0) {
                    dest[dpos + len] = src[spos + len];
                }
            } else {
                for (var i = 0; i < len; i++) {
                    dest[dpos + i] = src[spos + i];
                }
            }
        },

        copyTo: function (obj, dest, index, T) {
            var name;

            if (Bridge.isArray(obj)) {
                System.Array.copy(obj, 0, dest, index, obj ? obj.length : 0);
            } else if (Bridge.isFunction(obj.copyTo)) {
                obj.copyTo(dest, index);
            } else if (T && Bridge.isFunction(obj[name = "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$copyTo"])) {
                obj[name](dest, index);
            } else if (Bridge.isFunction(obj[name = "System$Collections$ICollection$copyTo"])) {
                obj[name](dest, index);
            } else {
                throw new System.NotImplementedException.$ctor1("copyTo");
            }
        },

        indexOf: function (arr, item, startIndex, count, T) {
            var name;

            if (Bridge.isArray(arr)) {
                var i,
                    el,
                    endIndex;

                startIndex = startIndex || 0;
                count = Bridge.isNumber(count) ? count : arr.length;
                endIndex = startIndex + count;

                for (i = startIndex; i < endIndex; i++) {
                    el = arr[i];

                    if (el === item || System.Collections.Generic.EqualityComparer$1.$default.equals2(el, item)) {
                        return i;
                    }
                }
            } else if (T && Bridge.isFunction(arr[name = "System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(T) + "$indexOf"])) {
                return arr[name](item);
            } else if (Bridge.isFunction(arr[name = "System$Collections$IList$indexOf"])) {
                return arr[name](item);
            } else if (Bridge.isFunction(arr.indexOf)) {
                return arr.indexOf(item);
            }

            return -1;
        },

        contains: function (obj, item, T) {
            var name;

            if (Bridge.isArray(obj)) {
                return System.Array.indexOf(obj, item) > -1;
            } else if (T && Bridge.isFunction(obj[name = "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$contains"])) {
                return obj[name](item);
            } else if (Bridge.isFunction(obj[name = "System$Collections$IList$contains"])) {
                return obj[name](item);
            } else if (Bridge.isFunction(obj.contains)) {
                return obj.contains(item);
            }

            return false;
        },

        remove: function (obj, item, T) {
            var name;

            System.Array.checkReadOnly(obj, T);

            if (Bridge.isArray(obj)) {
                var index = System.Array.indexOf(obj, item);

                if (index > -1) {
                    obj.splice(index, 1);

                    return true;
                }
            } else if (T && Bridge.isFunction(obj[name = "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$remove"])) {
                return obj[name](item);
            } else if (Bridge.isFunction(obj[name = "System$Collections$IList$remove"])) {
                return obj[name](item);
            } else if (Bridge.isFunction(obj.remove)) {
                return obj.remove(item);
            }

            return false;
        },

        insert: function (obj, index, item, T) {
            var name;

            System.Array.checkReadOnly(obj, T);

            if (T) {
                item = System.Array.checkNewElementType(item, T);
            }

            if (T && Bridge.isFunction(obj[name = "System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(T) + "$insert"])) {
                obj[name](index, item);
            } else if (Bridge.isFunction(obj[name = "System$Collections$IList$insert"])) {
                obj[name](index, item);
            } else if (Bridge.isFunction(obj.insert)) {
                obj.insert(index, item);
            }
        },

        removeAt: function (obj, index, T) {
            var name;

            System.Array.checkReadOnly(obj, T);

            if (Bridge.isArray(obj)) {
                obj.splice(index, 1);
            } else if (T && Bridge.isFunction(obj[name = "System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(T) + "$removeAt"])) {
                obj[name](index);
            } else if (Bridge.isFunction(obj[name = "System$Collections$IList$removeAt"])) {
                obj[name](index);
            } else if (Bridge.isFunction(obj.removeAt)) {
                obj.removeAt(index);
            }
        },

        getItem: function (obj, idx, T) {
            var name,
                v;

            if (Bridge.isArray(obj)) {
                v = obj[idx];
                if (T) {
                    return v;
                }

                return (obj.$type && (Bridge.isNumber(v) || Bridge.isBoolean(v) || Bridge.isDate(v))) ? Bridge.box(v, obj.$type.$elementType) : v;
            } else if (T && Bridge.isFunction(obj[name = "System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(T) + "$getItem"])) {
                v = obj[name](idx);
                return v;
            } else if (Bridge.isFunction(obj.get)) {
                v = obj.get(idx);
            } else if (Bridge.isFunction(obj.getItem)) {
                v = obj.getItem(idx);
            } else if (Bridge.isFunction(obj[name = "System$Collections$IList$$getItem"])) {
                v = obj[name](idx);
            } else if (Bridge.isFunction(obj.get_Item)) {
                v = obj.get_Item(idx);
            }

            return T && Bridge.getDefaultValue(T) != null ? Bridge.box(v, T) : v;
        },

        setItem: function (obj, idx, value, T) {
            var name;

            if (Bridge.isArray(obj)) {
                if (obj.$type) {
                    value = System.Array.checkElementType(value, obj.$type.$elementType);
                }

                obj[idx] = value;
            } else {
                if (T) {
                    value = System.Array.checkElementType(value, T);
                }

                if (Bridge.isFunction(obj.set)) {
                    obj.set(idx, value);
                } else if (Bridge.isFunction(obj.setItem)) {
                    obj.setItem(idx, value);
                } else if (T && Bridge.isFunction(obj[name = "System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(T) + "$setItem"])) {
                    return obj[name](idx, value);
                } else if (T && Bridge.isFunction(obj[name = "System$Collections$IList$setItem"])) {
                    return obj[name](idx, value);
                } else if (Bridge.isFunction(obj.set_Item)) {
                    obj.set_Item(idx, value);
                }
            }
        },

        checkElementType: function (v, type) {
            var unboxed = Bridge.unbox(v, true);

            if (Bridge.isNumber(unboxed)) {
                if (type === System.Decimal) {
                    return new System.Decimal(unboxed);
                }

                if (type === System.Int64) {
                    return new System.Int64(unboxed);
                }

                if (type === System.UInt64) {
                    return new System.UInt64(unboxed);
                }
            }

            var is = Bridge.is(v, type);

            if (!is) {
                if (v == null) {
                    return Bridge.getDefaultValue(type);
                }

                throw new System.ArgumentException.$ctor1("Cannot widen from source type to target type either because the source type is a not a primitive type or the conversion cannot be accomplished.");
            }

            return unboxed;
        },

        resize: function (arr, newSize, val) {
            if (newSize < 0) {
                throw new System.ArgumentOutOfRangeException.$ctor3("newSize", newSize, "newSize cannot be less than 0.");
            }

            var oldSize = 0,
                isFn = Bridge.isFunction(val),
                ref = arr.v;

            if (!ref) {
                ref = new Array(newSize);
            } else {
                oldSize = ref.length;
                ref.length = newSize;
            }

            for (var i = oldSize; i < newSize; i++) {
                ref[i] = isFn ? val() : val;
            }

            arr.v = ref;
        },

        reverse: function (arr, index, length) {
            if (!array) {
                throw new System.ArgumentNullException.$ctor1("arr");
            }

            if (!index && index !== 0) {
                index = 0;
                length = arr.length;
            }

            if (index < 0 || length < 0) {
                throw new System.ArgumentOutOfRangeException.$ctor4((index < 0 ? "index" : "length"), "Non-negative number required.");
            }

            if ((array.length - index) < length) {
                throw new System.ArgumentException.$ctor1("Offset and length were out of bounds for the array or count is greater than the number of elements from index to the end of the source collection.");
            }

            if (System.Array.getRank(arr) !== 1) {
                throw new System.Exception("Only single dimension arrays are supported here.");
            }

            var i = index,
                j = index + length - 1;

            while (i < j) {
                var temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
                i++;
                j--;
            }
        },

        binarySearch: function (array, index, length, value, comparer) {
            if (!array) {
                throw new System.ArgumentNullException.$ctor1("array");
            }

            var lb = 0;

            if (index < lb || length < 0) {
                throw new System.ArgumentOutOfRangeException.$ctor4(index < lb ? "index" : "length", "Non-negative number required.");
            }

            if (array.length - (index - lb) < length) {
                throw new System.ArgumentException.$ctor1("Offset and length were out of bounds for the array or count is greater than the number of elements from index to the end of the source collection.");
            }

            if (System.Array.getRank(array) !== 1) {
                throw new System.RankException.$ctor1("Only single dimensional arrays are supported for the requested action.");
            }

            if (!comparer) {
                comparer = System.Collections.Generic.Comparer$1.$default;
            }

            var lo = index,
                hi = index + length - 1,
                i,
                c;

            while (lo <= hi) {
                i = lo + ((hi - lo) >> 1);

                try {
                    c = System.Collections.Generic.Comparer$1.get(comparer)(array[i], value);
                } catch (e) {
                    throw new System.InvalidOperationException.$ctor2("Failed to compare two elements in the array.", e);
                }

                if (c === 0) {
                    return i;
                }

                if (c < 0) {
                    lo = i + 1;
                } else {
                    hi = i - 1;
                }
            }

            return ~lo;
        },

        sortDict: function (keys, values, index, length, comparer) {
            if (!comparer) {
                comparer = System.Collections.Generic.Comparer$1.$default;
            }

            var list = [],
                fn = Bridge.fn.bind(comparer, System.Collections.Generic.Comparer$1.get(comparer));

            if (length == null) {
                length = keys.length;
            }

            for (var j = 0; j < keys.length; j++) {
                list.push({ key: keys[j], value: values[j] });
            }

            if (index === 0 && length === list.length) {
                list.sort(function (x, y) {
                    return fn(x.key, y.key);
                });
            } else {
                var newarray = list.slice(index, index + length);

                newarray.sort(function (x, y) {
                    return fn(x.key, y.key);
                });

                for (var i = index; i < (index + length); i++) {
                    list[i] = newarray[i - index];
                }
            }

            for (var k = 0; k < list.length; k++) {
                keys[k] = list[k].key;
                values[k] = list[k].value;
            }
        },

        sort: function (array, index, length, comparer) {
            if (!array) {
                throw new System.ArgumentNullException.$ctor1("array");
            }

            if (arguments.length === 2 && typeof index === "function") {
                array.sort(index);
                return;
            }

            if (arguments.length === 2 && typeof index === "object") {
                comparer = index;
                index = null;
            }

            if (!Bridge.isNumber(index)) {
                index = 0;
            }

            if (!Bridge.isNumber(length)) {
                length = array.length;
            }

            if (!comparer) {
                comparer = System.Collections.Generic.Comparer$1.$default;
            }

            if (index === 0 && length === array.length) {
                array.sort(Bridge.fn.bind(comparer, System.Collections.Generic.Comparer$1.get(comparer)));
            } else {
                var newarray = array.slice(index, index + length);

                newarray.sort(Bridge.fn.bind(comparer, System.Collections.Generic.Comparer$1.get(comparer)));

                for (var i = index; i < (index + length) ; i++) {
                    array[i] = newarray[i - index];
                }
            }
        },

        min: function (arr, minValue) {
            var min = arr[0],
                len = arr.length;

            for (var i = 0; i < len; i++) {
                if ((arr[i] < min || min < minValue) && !(arr[i] < minValue)) {
                    min = arr[i];
                }
            }

            return min;
        },

        max: function (arr, maxValue) {
            var max = arr[0],
                len = arr.length;

            for (var i = 0; i < len; i++) {
                if ((arr[i] > max || max > maxValue) && !(arr[i] > maxValue)) {
                    max = arr[i];
                }
            }

            return max;
        },

        addRange: function (arr, items) {
            if (Bridge.isArray(items)) {
                arr.push.apply(arr, items);
            } else {
                var e = Bridge.getEnumerator(items);

                try {
                    while (e.moveNext()) {
                        arr.push(e.Current);
                    }
                } finally {
                    if (Bridge.is(e, System.IDisposable)) {
                        e.Dispose();
                    }
                }
            }
        },

        convertAll: function (array, converter) {
            if (!Bridge.hasValue(array)) {
                throw new System.ArgumentNullException.$ctor1("array");
            }

            if (!Bridge.hasValue(converter)) {
                throw new System.ArgumentNullException.$ctor1("converter");
            }

            var array2 = array.map(converter);

            return array2;
        },

        find: function (T, array, match) {
            if (!Bridge.hasValue(array)) {
                throw new System.ArgumentNullException.$ctor1("array");
            }

            if (!Bridge.hasValue(match)) {
                throw new System.ArgumentNullException.$ctor1("match");
            }

            for (var i = 0; i < array.length; i++) {
                if (match(array[i])) {
                    return array[i];
                }
            }

            return Bridge.getDefaultValue(T);
        },

        findAll: function (array, match) {
            if (!Bridge.hasValue(array)) {
                throw new System.ArgumentNullException.$ctor1("array");
            }

            if (!Bridge.hasValue(match)) {
                throw new System.ArgumentNullException.$ctor1("match");
            }

            var list = [];

            for (var i = 0; i < array.length; i++) {
                if (match(array[i])) {
                    list.push(array[i]);
                }
            }

            return list;
        },

        findIndex: function (array, startIndex, count, match) {
            if (!Bridge.hasValue(array)) {
                throw new System.ArgumentNullException.$ctor1("array");
            }

            if (arguments.length === 2) {
                match = startIndex;
                startIndex = 0;
                count = array.length;
            } else if (arguments.length === 3) {
                match = count;
                count = array.length - startIndex;
            }

            if (startIndex < 0 || startIndex > array.length) {
                throw new System.ArgumentOutOfRangeException.$ctor1("startIndex");
            }

            if (count < 0 || startIndex > array.length - count) {
                throw new System.ArgumentOutOfRangeException.$ctor1("count");
            }

            if (!Bridge.hasValue(match)) {
                throw new System.ArgumentNullException.$ctor1("match");
            }

            var endIndex = startIndex + count;

            for (var i = startIndex; i < endIndex; i++) {
                if (match(array[i])) {
                    return i;
                }
            }

            return -1;
        },

        findLast: function (T, array, match) {
            if (!Bridge.hasValue(array)) {
                throw new System.ArgumentNullException.$ctor1("array");
            }

            if (!Bridge.hasValue(match)) {
                throw new System.ArgumentNullException.$ctor1("match");
            }

            for (var i = array.length - 1; i >= 0; i--) {
                if (match(array[i])) {
                    return array[i];
                }
            }

            return Bridge.getDefaultValue(T);
        },

        findLastIndex: function (array, startIndex, count, match) {
            if (!Bridge.hasValue(array)) {
                throw new System.ArgumentNullException.$ctor1("array");
            }

            if (arguments.length === 2) {
                match = startIndex;
                startIndex = array.length - 1;
                count = array.length;
            } else if (arguments.length === 3) {
                match = count;
                count = startIndex + 1;
            }

            if (!Bridge.hasValue(match)) {
                throw new System.ArgumentNullException.$ctor1("match");
            }

            if (array.length === 0) {
                if (startIndex !== -1) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("startIndex");
                }
            } else {
                if (startIndex < 0 || startIndex >= array.length) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("startIndex");
                }
            }

            if (count < 0 || startIndex - count + 1 < 0) {
                throw new System.ArgumentOutOfRangeException.$ctor1("count");
            }

            var endIndex = startIndex - count;

            for (var i = startIndex; i > endIndex; i--) {
                if (match(array[i])) {
                    return i;
                }
            }

            return -1;
        },

        forEach: function (array, action) {
            if (!Bridge.hasValue(array)) {
                throw new System.ArgumentNullException.$ctor1("array");
            }

            if (!Bridge.hasValue(action)) {
                throw new System.ArgumentNullException.$ctor1("action");
            }

            for (var i = 0; i < array.length; i++) {
                action(array[i], i, array);
            }
        },

        indexOfT: function (array, value, startIndex, count) {
            if (!Bridge.hasValue(array)) {
                throw new System.ArgumentNullException.$ctor1("array");
            }

            if (arguments.length === 2) {
                startIndex = 0;
                count = array.length;
            } else if (arguments.length === 3) {
                count = array.length - startIndex;
            }

            if (startIndex < 0 || (startIndex >= array.length && array.length > 0)) {
                throw new System.ArgumentOutOfRangeException.$ctor4("startIndex", "out of range");
            }

            if (count < 0 || count > array.length - startIndex) {
                throw new System.ArgumentOutOfRangeException.$ctor4("count", "out of range");
            }

            return System.Array.indexOf(array, value, startIndex, count);
        },

        isFixedSize: function (array) {
            if (Bridge.isArray(array)) {
                return true;
            } else if (array["System$Collections$IList$isFixedSize"] != null) {
                return array["System$Collections$IList$isFixedSize"];
            } else if(array["System$Collections$IList$IsFixedSize"] != null) {
                return array["System$Collections$IList$IsFixedSize"];
            } else if (array.isFixedSize != null) {
                return array.isFixedSize;
            } else if (array.IsFixedSize != null) {
                return array.IsFixedSize;
            }

            return true;
        },

        isSynchronized: function (array) {
            return false;
        },

        lastIndexOfT: function (array, value, startIndex, count) {
            if (!Bridge.hasValue(array)) {
                throw new System.ArgumentNullException.$ctor1("array");
            }

            if (arguments.length === 2) {
                startIndex = array.length - 1;
                count = array.length;
            } else if (arguments.length === 3) {
                count = (array.length === 0) ? 0 : (startIndex + 1);
            }

            if (startIndex < 0 || (startIndex >= array.length && array.length > 0)) {
                throw new System.ArgumentOutOfRangeException.$ctor4("startIndex", "out of range");
            }

            if (count < 0 || startIndex - count + 1 < 0) {
                throw new System.ArgumentOutOfRangeException.$ctor4("count", "out of range");
            }

            var endIndex = startIndex - count + 1;

            for (var i = startIndex; i >= endIndex; i--) {
                var el = array[i];

                if (el === value || System.Collections.Generic.EqualityComparer$1.$default.equals2(el, value)) {
                    return i;
                }
            }

            return -1;
        },

        syncRoot: function (array) {
            return array;
        },

        trueForAll: function (array, match) {
            if (!Bridge.hasValue(array)) {
                throw new System.ArgumentNullException.$ctor1("array");
            }

            if (!Bridge.hasValue(match)) {
                throw new System.ArgumentNullException.$ctor1("match");
            }

            for (var i = 0; i < array.length; i++) {
                if (!match(array[i])) {
                    return false;
                }
            }

            return true;
        },

        type: function (t, rank, arr) {
            rank = rank || 1;

            var typeCache = System.Array.$cache[rank],
                result,
                name;

            if (!typeCache) {
                typeCache = [];
                System.Array.$cache[rank] = typeCache;
            }

            for (var i = 0; i < typeCache.length; i++) {
                if (typeCache[i].$elementType === t) {
                    result = typeCache[i];
                    break;
                }
            }

            if (!result) {
                name = Bridge.getTypeName(t) + "[" + System.String.fromCharCount(",".charCodeAt(0), rank - 1) + "]";

                var old = Bridge.Class.staticInitAllow;

                result = Bridge.define(name, {
                    $inherits: [System.Array, System.Collections.ICollection, System.ICloneable, System.Collections.Generic.IList$1(t), System.Collections.Generic.IReadOnlyCollection$1(t)],
                    $noRegister: true,
                    statics: {
                        $elementType: t,
                        $rank: rank,
                        $isArray: true,
                        $is: function (obj) {
                            return System.Array.is(obj, this);
                        },
                        getDefaultValue: function () {
                            return null;
                        },
                        createInstance: function () {
                            var arr;

                            if (this.$rank === 1) {
                                arr = [];
                            } else {
                                var args = [Bridge.getDefaultValue(this.$elementType), null, this.$elementType];

                                for (var j = 0; j < this.$rank; j++) {
                                    args.push(0);
                                }

                                arr = System.Array.create.apply(System.Array, args);
                            }

                            arr.$type = this;

                            return arr;
                        }
                    }
                });

                typeCache.push(result);

                Bridge.Class.staticInitAllow = true;

                if (result.$staticInit) {
                    result.$staticInit();
                }

                Bridge.Class.staticInitAllow = old;
            }

            if (arr) {
                arr.$type = result;
            }

            return arr || result;
        }
    };

    Bridge.define("System.Array", {
        statics: array
    });

    System.Array.$cache = {};

    // @source ArraySegment.js

    Bridge.define("System.ArraySegment", {
        $kind: "struct",

        statics: {
            getDefaultValue: function () {
                return new System.ArraySegment();
            }
        },

        ctor: function (array, offset, count) {
            this.$initialize();

            if (arguments.length === 0) {
                this.array = null;
                this.offset = 0;
                this.count = 0;

                return;
            }

            if (array == null) {
                throw new System.ArgumentNullException.$ctor1("array");
            }

            this.array = array;

            if (Bridge.isNumber(offset)) {
                if (offset < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("offset");
                }

                this.offset = offset;
            } else {
                this.offset = 0;
            }

            if (Bridge.isNumber(count)) {
                if (count < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("count");
                }

                this.count = count;
            } else {
                this.count = array.length;
            }

            if (array.length - this.offset < this.count) {
                throw new ArgumentException();
            }
        },

        getArray: function () {
            return this.array;
        },

        getCount: function () {
            return this.count;
        },

        getOffset: function () {
            return this.offset;
        },

        getHashCode: function () {
            var h = Bridge.addHash([5322976039, this.array, this.count, this.offset]);

            return h;
        },

        equals: function (o) {
            if (!Bridge.is(o, System.ArraySegment)) {
                return false;
            }

            return Bridge.equals(this.array, o.array) && Bridge.equals(this.count, o.count) && Bridge.equals(this.offset, o.offset);
        },

        $clone: function (to) { return this; }
    });

    // @source KeyValuePair.js

    Bridge.define("System.Collections.Generic.KeyValuePair$2", function (TKey, TValue) { return {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new (System.Collections.Generic.KeyValuePair$2(TKey,TValue))(); }
            }
        },
        fields: {
            key$1: Bridge.getDefaultValue(TKey),
            value$1: Bridge.getDefaultValue(TValue)
        },
        props: {
            key: {
                get: function () {
                    return this.key$1;
                }
            },
            value: {
                get: function () {
                    return this.value$1;
                }
            }
        },
        ctors: {
            $ctor1: function (key, value) {
                this.$initialize();
                this.key$1 = key;
                this.value$1 = value;
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            toString: function () {
                var s = System.Text.StringBuilderCache.Acquire();
                s.append(String.fromCharCode(91));
                if (this.key != null) {
                    s.append(Bridge.toString(this.key));
                }
                s.append(", ");
                if (this.value != null) {
                    s.append(Bridge.toString(this.value));
                }
                s.append(String.fromCharCode(93));
                return System.Text.StringBuilderCache.GetStringAndRelease(s);
            },
            Deconstruct: function (key, value) {
                key.v = this.key;
                value.v = this.value;
            },
            getHashCode: function () {
                var h = Bridge.addHash([5072499452, this.key$1, this.value$1]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, System.Collections.Generic.KeyValuePair$2(TKey,TValue))) {
                    return false;
                }
                return Bridge.equals(this.key$1, o.key$1) && Bridge.equals(this.value$1, o.value$1);
            },
            $clone: function (to) { return this; }
        }
    }; });

    // @source Interfaces.js

    Bridge.define("System.Collections.IEnumerable", {
        $kind: "interface"
    });
    Bridge.define("System.Collections.ICollection", {
        inherits: [System.Collections.IEnumerable],
        $kind: "interface"
    });
    Bridge.define("System.Collections.IList", {
        inherits: [System.Collections.ICollection],
        $kind: "interface"
    });
    Bridge.define("System.Collections.IDictionary", {
        inherits: [System.Collections.ICollection],
        $kind: "interface"
    });

    Bridge.define("System.Collections.Generic.IEnumerable$1", function (T) {
        return {
            inherits: [System.Collections.IEnumerable],
            $kind: "interface",
            $variance: [1]
        };
    });

    Bridge.define("System.Collections.Generic.ICollection$1", function (T) {
        return {
            inherits: [System.Collections.Generic.IEnumerable$1(T)],
            $kind: "interface"
        };
    });

    Bridge.define("System.Collections.Generic.IEqualityComparer$1", function (T) {
        return {
            $kind: "interface",
            $variance: [2]
        };
    });

    Bridge.define("System.Collections.Generic.IDictionary$2", function (TKey, TValue) {
        return {
            inherits: [System.Collections.Generic.ICollection$1(System.Collections.Generic.KeyValuePair$2(TKey, TValue))],
            $kind: "interface"
        };
    });

    Bridge.define("System.Collections.Generic.IList$1", function (T) {
        return {
            inherits: [System.Collections.Generic.ICollection$1(T)],
            $kind: "interface"
        };
    });

    Bridge.define("System.Collections.Generic.ISet$1", function (T) {
        return {
            inherits: [System.Collections.Generic.ICollection$1(T)],
            $kind: "interface"
        };
    });

    Bridge.define("System.Collections.Generic.IReadOnlyCollection$1", function (T) {
        return {
            inherits: [System.Collections.Generic.IEnumerable$1(T)],
            $kind: "interface"
        };
    });

    Bridge.define("System.Collections.Generic.IReadOnlyList$1", function (T) {
        return {
            inherits: [System.Collections.Generic.IReadOnlyCollection$1(T)],
            $kind: "interface",
            $variance: [1]
        };
    });

    Bridge.define("System.Collections.Generic.IReadOnlyDictionary$2", function (TKey, TValue) {
        return {
            inherits: [System.Collections.Generic.IReadOnlyCollection$1(System.Collections.Generic.KeyValuePair$2(TKey, TValue))],
            $kind: "interface"
        };
    });

    // @source IEnumerator.js

    Bridge.define("System.Collections.IEnumerator", {
        $kind: "interface"
    });

    // @source IComparer.js

    Bridge.define("System.Collections.IComparer", {
        $kind: "interface"
    });

    // @source IDictionaryEnumerator.js

    Bridge.define("System.Collections.IDictionaryEnumerator", {
        inherits: [System.Collections.IEnumerator],
        $kind: "interface"
    });

    // @source IEqualityComparer.js

    Bridge.define("System.Collections.IEqualityComparer", {
        $kind: "interface"
    });

    // @source IStructuralComparable.js

    Bridge.define("System.Collections.IStructuralComparable", {
        $kind: "interface"
    });

    // @source IStructuralEquatable.js

    Bridge.define("System.Collections.IStructuralEquatable", {
        $kind: "interface"
    });

    // @source IEnumerator.js

    Bridge.definei("System.Collections.Generic.IEnumerator$1", function (T) { return {
        inherits: [System.IDisposable,System.Collections.IEnumerator],
        $kind: "interface",
        $variance: [1]
    }; });

    // @source IComparer.js

    Bridge.definei("System.Collections.Generic.IComparer$1", function (T) { return {
        $kind: "interface",
        $variance: [2]
    }; });

    // @source KeyValuePairs.js

    Bridge.define("System.Collections.KeyValuePairs", {
        fields: {
            key: null,
            value: null
        },
        props: {
            Key: {
                get: function () {
                    return this.key;
                }
            },
            Value: {
                get: function () {
                    return this.value;
                }
            }
        },
        ctors: {
            ctor: function (key, value) {
                this.$initialize();
                this.value = value;
                this.key = key;
            }
        }
    });

    // @source SortedList.js

    Bridge.define("System.Collections.SortedList", {
        inherits: [System.Collections.IDictionary,System.ICloneable],
        statics: {
            fields: {
                emptyArray: null
            },
            ctors: {
                init: function () {
                    this.emptyArray = System.Array.init(0, null, System.Object);
                }
            },
            methods: {
                Synchronized: function (list) {
                    if (list == null) {
                        throw new System.ArgumentNullException.$ctor1("list");
                    }

                    return new System.Collections.SortedList.SyncSortedList(list);
                }
            }
        },
        fields: {
            keys: null,
            values: null,
            _size: 0,
            version: 0,
            comparer: null,
            keyList: null,
            valueList: null
        },
        props: {
            Capacity: {
                get: function () {
                    return this.keys.length;
                },
                set: function (value) {
                    if (value < this.Count) {
                        throw new System.ArgumentOutOfRangeException.$ctor1("value");
                    }

                    if (value !== this.keys.length) {
                        if (value > 0) {
                            var newKeys = System.Array.init(value, null, System.Object);
                            var newValues = System.Array.init(value, null, System.Object);
                            if (this._size > 0) {
                                System.Array.copy(this.keys, 0, newKeys, 0, this._size);
                                System.Array.copy(this.values, 0, newValues, 0, this._size);
                            }
                            this.keys = newKeys;
                            this.values = newValues;
                        } else {
                            this.keys = System.Collections.SortedList.emptyArray;
                            this.values = System.Collections.SortedList.emptyArray;
                        }
                    }
                }
            },
            Count: {
                get: function () {
                    return this._size;
                }
            },
            Keys: {
                get: function () {
                    return this.GetKeyList();
                }
            },
            Values: {
                get: function () {
                    return this.GetValueList();
                }
            },
            IsReadOnly: {
                get: function () {
                    return false;
                }
            },
            IsFixedSize: {
                get: function () {
                    return false;
                }
            },
            IsSynchronized: {
                get: function () {
                    return false;
                }
            },
            SyncRoot: {
                get: function () {
                    return null;
                }
            }
        },
        alias: [
            "add", "System$Collections$IDictionary$add",
            "Count", "System$Collections$ICollection$Count",
            "Keys", "System$Collections$IDictionary$Keys",
            "Values", "System$Collections$IDictionary$Values",
            "IsReadOnly", "System$Collections$IDictionary$IsReadOnly",
            "IsFixedSize", "System$Collections$IDictionary$IsFixedSize",
            "IsSynchronized", "System$Collections$ICollection$IsSynchronized",
            "SyncRoot", "System$Collections$ICollection$SyncRoot",
            "clear", "System$Collections$IDictionary$clear",
            "clone", "System$ICloneable$clone",
            "contains", "System$Collections$IDictionary$contains",
            "copyTo", "System$Collections$ICollection$copyTo",
            "GetEnumerator", "System$Collections$IDictionary$GetEnumerator",
            "getItem", "System$Collections$IDictionary$getItem",
            "setItem", "System$Collections$IDictionary$setItem",
            "remove", "System$Collections$IDictionary$remove"
        ],
        ctors: {
            ctor: function () {
                this.$initialize();
                this.Init();
            },
            $ctor5: function (initialCapacity) {
                this.$initialize();
                if (initialCapacity < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("initialCapacity");
                }

                this.keys = System.Array.init(initialCapacity, null, System.Object);
                this.values = System.Array.init(initialCapacity, null, System.Object);
                this.comparer = new (System.Collections.Generic.Comparer$1(Object))(System.Collections.Generic.Comparer$1.$default.fn);
            },
            $ctor1: function (comparer) {
                System.Collections.SortedList.ctor.call(this);
                if (comparer != null) {
                    this.comparer = comparer;
                }
            },
            $ctor2: function (comparer, capacity) {
                System.Collections.SortedList.$ctor1.call(this, comparer);
                this.Capacity = capacity;
            },
            $ctor3: function (d) {
                System.Collections.SortedList.$ctor4.call(this, d, null);
            },
            $ctor4: function (d, comparer) {
                System.Collections.SortedList.$ctor2.call(this, comparer, (d != null ? System.Array.getCount(d) : 0));
                if (d == null) {
                    throw new System.ArgumentNullException.$ctor1("d");
                }

                System.Array.copyTo(d.System$Collections$IDictionary$Keys, this.keys, 0);
                System.Array.copyTo(d.System$Collections$IDictionary$Values, this.values, 0);
                System.Array.sortDict(this.keys, this.values, 0, null, comparer);
                this._size = System.Array.getCount(d);
            }
        },
        methods: {
            getItem: function (key) {
                var i = this.IndexOfKey(key);
                if (i >= 0) {
                    return this.values[System.Array.index(i, this.values)];
                }
                return null;
            },
            setItem: function (key, value) {
                if (key == null) {
                    throw new System.ArgumentNullException.$ctor1("key");
                }

                var i = System.Array.binarySearch(this.keys, 0, this._size, key, this.comparer);
                if (i >= 0) {
                    this.values[System.Array.index(i, this.values)] = value;
                    this.version = (this.version + 1) | 0;
                    return;
                }
                this.Insert(~i, key, value);
            },
            Init: function () {
                this.keys = System.Collections.SortedList.emptyArray;
                this.values = System.Collections.SortedList.emptyArray;
                this._size = 0;
                this.comparer = new (System.Collections.Generic.Comparer$1(Object))(System.Collections.Generic.Comparer$1.$default.fn);
            },
            add: function (key, value) {
                if (key == null) {
                    throw new System.ArgumentNullException.$ctor1("key");
                }

                var i = System.Array.binarySearch(this.keys, 0, this._size, key, this.comparer);
                if (i >= 0) {
                    throw new System.ArgumentException.ctor();
                }
                this.Insert(~i, key, value);
            },
            clear: function () {
                this.version = (this.version + 1) | 0;
                System.Array.fill(this.keys, null, 0, this._size);
                System.Array.fill(this.values, null, 0, this._size);
                this._size = 0;

            },
            clone: function () {
                var sl = new System.Collections.SortedList.$ctor5(this._size);
                System.Array.copy(this.keys, 0, sl.keys, 0, this._size);
                System.Array.copy(this.values, 0, sl.values, 0, this._size);
                sl._size = this._size;
                sl.version = this.version;
                sl.comparer = this.comparer;
                return sl;
            },
            contains: function (key) {
                return this.IndexOfKey(key) >= 0;
            },
            ContainsKey: function (key) {
                return this.IndexOfKey(key) >= 0;
            },
            ContainsValue: function (value) {
                return this.IndexOfValue(value) >= 0;
            },
            copyTo: function (array, arrayIndex) {
                if (array == null) {
                    throw new System.ArgumentNullException.$ctor1("array");
                }
                if (System.Array.getRank(array) !== 1) {
                    throw new System.ArgumentException.ctor();
                }
                if (arrayIndex < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("arrayIndex");
                }
                if (((array.length - arrayIndex) | 0) < this.Count) {
                    throw new System.ArgumentException.ctor();
                }
                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    var entry = new System.Collections.DictionaryEntry.$ctor1(this.keys[System.Array.index(i, this.keys)], this.values[System.Array.index(i, this.values)]);
                    System.Array.set(array, entry.$clone(), ((i + arrayIndex) | 0));
                }
            },
            ToKeyValuePairsArray: function () {
                var array = System.Array.init(this.Count, null, System.Collections.KeyValuePairs);
                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    array[System.Array.index(i, array)] = new System.Collections.KeyValuePairs(this.keys[System.Array.index(i, this.keys)], this.values[System.Array.index(i, this.values)]);
                }
                return array;
            },
            EnsureCapacity: function (min) {
                var newCapacity = this.keys.length === 0 ? 16 : Bridge.Int.mul(this.keys.length, 2);

                if ((newCapacity >>> 0) > 2146435071) {
                    newCapacity = 2146435071;
                }
                if (newCapacity < min) {
                    newCapacity = min;
                }
                this.Capacity = newCapacity;
            },
            GetByIndex: function (index) {
                if (index < 0 || index >= this.Count) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("index");
                }

                return this.values[System.Array.index(index, this.values)];
            },
            System$Collections$IEnumerable$GetEnumerator: function () {
                return new System.Collections.SortedList.SortedListEnumerator(this, 0, this._size, System.Collections.SortedList.SortedListEnumerator.DictEntry);
            },
            GetEnumerator: function () {
                return new System.Collections.SortedList.SortedListEnumerator(this, 0, this._size, System.Collections.SortedList.SortedListEnumerator.DictEntry);
            },
            GetKey: function (index) {
                if (index < 0 || index >= this.Count) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("index");
                }
                return this.keys[System.Array.index(index, this.keys)];
            },
            GetKeyList: function () {
                if (this.keyList == null) {
                    this.keyList = new System.Collections.SortedList.KeyList(this);
                }
                return this.keyList;
            },
            GetValueList: function () {
                if (this.valueList == null) {
                    this.valueList = new System.Collections.SortedList.ValueList(this);
                }
                return this.valueList;
            },
            IndexOfKey: function (key) {
                if (key == null) {
                    throw new System.ArgumentNullException.$ctor1("key");
                }

                var ret = System.Array.binarySearch(this.keys, 0, this._size, key, this.comparer);
                return ret >= 0 ? ret : -1;
            },
            IndexOfValue: function (value) {
                return System.Array.indexOfT(this.values, value, 0, this._size);
            },
            Insert: function (index, key, value) {
                if (this._size === this.keys.length) {
                    this.EnsureCapacity(((this._size + 1) | 0));
                }
                if (index < this._size) {
                    System.Array.copy(this.keys, index, this.keys, ((index + 1) | 0), ((this._size - index) | 0));
                    System.Array.copy(this.values, index, this.values, ((index + 1) | 0), ((this._size - index) | 0));
                }
                this.keys[System.Array.index(index, this.keys)] = key;
                this.values[System.Array.index(index, this.values)] = value;
                this._size = (this._size + 1) | 0;
                this.version = (this.version + 1) | 0;
            },
            RemoveAt: function (index) {
                if (index < 0 || index >= this.Count) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("index");
                }

                this._size = (this._size - 1) | 0;
                if (index < this._size) {
                    System.Array.copy(this.keys, ((index + 1) | 0), this.keys, index, ((this._size - index) | 0));
                    System.Array.copy(this.values, ((index + 1) | 0), this.values, index, ((this._size - index) | 0));
                }
                this.keys[System.Array.index(this._size, this.keys)] = null;
                this.values[System.Array.index(this._size, this.values)] = null;
                this.version = (this.version + 1) | 0;
            },
            remove: function (key) {
                var i = this.IndexOfKey(key);
                if (i >= 0) {
                    this.RemoveAt(i);
                }
            },
            SetByIndex: function (index, value) {
                if (index < 0 || index >= this.Count) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("index");
                }

                this.values[System.Array.index(index, this.values)] = value;
                this.version = (this.version + 1) | 0;
            },
            TrimToSize: function () {
                this.Capacity = this._size;
            }
        }
    });

    // @source KeyList.js

    Bridge.define("System.Collections.SortedList.KeyList", {
        inherits: [System.Collections.IList],
        $kind: "nested class",
        fields: {
            sortedList: null
        },
        props: {
            Count: {
                get: function () {
                    return this.sortedList._size;
                }
            },
            IsReadOnly: {
                get: function () {
                    return true;
                }
            },
            IsFixedSize: {
                get: function () {
                    return true;
                }
            },
            IsSynchronized: {
                get: function () {
                    return this.sortedList.IsSynchronized;
                }
            },
            SyncRoot: {
                get: function () {
                    return this.sortedList.SyncRoot;
                }
            }
        },
        alias: [
            "Count", "System$Collections$ICollection$Count",
            "IsReadOnly", "System$Collections$IList$IsReadOnly",
            "IsFixedSize", "System$Collections$IList$IsFixedSize",
            "IsSynchronized", "System$Collections$ICollection$IsSynchronized",
            "SyncRoot", "System$Collections$ICollection$SyncRoot",
            "add", "System$Collections$IList$add",
            "clear", "System$Collections$IList$clear",
            "contains", "System$Collections$IList$contains",
            "copyTo", "System$Collections$ICollection$copyTo",
            "insert", "System$Collections$IList$insert",
            "getItem", "System$Collections$IList$getItem",
            "setItem", "System$Collections$IList$setItem",
            "GetEnumerator", "System$Collections$IEnumerable$GetEnumerator",
            "indexOf", "System$Collections$IList$indexOf",
            "remove", "System$Collections$IList$remove",
            "removeAt", "System$Collections$IList$removeAt"
        ],
        ctors: {
            ctor: function (sortedList) {
                this.$initialize();
                this.sortedList = sortedList;
            }
        },
        methods: {
            getItem: function (index) {
                return this.sortedList.GetKey(index);
            },
            setItem: function (index, value) {
                throw new System.NotSupportedException.ctor();
            },
            add: function (key) {
                throw new System.NotSupportedException.ctor();
            },
            clear: function () {
                throw new System.NotSupportedException.ctor();
            },
            contains: function (key) {
                return this.sortedList.contains(key);
            },
            copyTo: function (array, arrayIndex) {
                if (array != null && System.Array.getRank(array) !== 1) {
                    throw new System.ArgumentException.ctor();
                }

                System.Array.copy(this.sortedList.keys, 0, array, arrayIndex, this.sortedList.Count);
            },
            insert: function (index, value) {
                throw new System.NotSupportedException.ctor();
            },
            GetEnumerator: function () {
                return new System.Collections.SortedList.SortedListEnumerator(this.sortedList, 0, this.sortedList.Count, System.Collections.SortedList.SortedListEnumerator.Keys);
            },
            indexOf: function (key) {
                if (key == null) {
                    throw new System.ArgumentNullException.$ctor1("key");
                }

                var i = System.Array.binarySearch(this.sortedList.keys, 0, this.sortedList.Count, key, this.sortedList.comparer);
                if (i >= 0) {
                    return i;
                }
                return -1;
            },
            remove: function (key) {
                throw new System.NotSupportedException.ctor();
            },
            removeAt: function (index) {
                throw new System.NotSupportedException.ctor();
            }
        }
    });

    // @source SortedListDebugView.js

    Bridge.define("System.Collections.SortedList.SortedListDebugView", {
        $kind: "nested class",
        fields: {
            sortedList: null
        },
        props: {
            Items: {
                get: function () {
                    return this.sortedList.ToKeyValuePairsArray();
                }
            }
        },
        ctors: {
            ctor: function (sortedList) {
                this.$initialize();
                if (sortedList == null) {
                    throw new System.ArgumentNullException.$ctor1("sortedList");
                }

                this.sortedList = sortedList;
            }
        }
    });

    // @source SortedListEnumerator.js

    Bridge.define("System.Collections.SortedList.SortedListEnumerator", {
        inherits: [System.Collections.IDictionaryEnumerator,System.ICloneable],
        $kind: "nested class",
        statics: {
            fields: {
                Keys: 0,
                Values: 0,
                DictEntry: 0
            },
            ctors: {
                init: function () {
                    this.Keys = 1;
                    this.Values = 2;
                    this.DictEntry = 3;
                }
            }
        },
        fields: {
            sortedList: null,
            key: null,
            value: null,
            index: 0,
            startIndex: 0,
            endIndex: 0,
            version: 0,
            current: false,
            getObjectRetType: 0
        },
        props: {
            Key: {
                get: function () {
                    if (this.version !== this.sortedList.version) {
                        throw new System.InvalidOperationException.ctor();
                    }
                    if (this.current === false) {
                        throw new System.InvalidOperationException.ctor();
                    }
                    return this.key;
                }
            },
            Entry: {
                get: function () {
                    if (this.version !== this.sortedList.version) {
                        throw new System.InvalidOperationException.ctor();
                    }
                    if (this.current === false) {
                        throw new System.InvalidOperationException.ctor();
                    }
                    return new System.Collections.DictionaryEntry.$ctor1(this.key, this.value);
                }
            },
            Current: {
                get: function () {
                    if (this.current === false) {
                        throw new System.InvalidOperationException.ctor();
                    }

                    if (this.getObjectRetType === System.Collections.SortedList.SortedListEnumerator.Keys) {
                        return this.key;
                    } else {
                        if (this.getObjectRetType === System.Collections.SortedList.SortedListEnumerator.Values) {
                            return this.value;
                        } else {
                            return new System.Collections.DictionaryEntry.$ctor1(this.key, this.value).$clone();
                        }
                    }
                }
            },
            Value: {
                get: function () {
                    if (this.version !== this.sortedList.version) {
                        throw new System.InvalidOperationException.ctor();
                    }
                    if (this.current === false) {
                        throw new System.InvalidOperationException.ctor();
                    }
                    return this.value;
                }
            }
        },
        alias: [
            "clone", "System$ICloneable$clone",
            "Key", "System$Collections$IDictionaryEnumerator$Key",
            "moveNext", "System$Collections$IEnumerator$moveNext",
            "Entry", "System$Collections$IDictionaryEnumerator$Entry",
            "Current", "System$Collections$IEnumerator$Current",
            "Value", "System$Collections$IDictionaryEnumerator$Value",
            "reset", "System$Collections$IEnumerator$reset"
        ],
        ctors: {
            ctor: function (sortedList, index, count, getObjRetType) {
                this.$initialize();
                this.sortedList = sortedList;
                this.index = index;
                this.startIndex = index;
                this.endIndex = (index + count) | 0;
                this.version = sortedList.version;
                this.getObjectRetType = getObjRetType;
                this.current = false;
            }
        },
        methods: {
            clone: function () {
                return Bridge.clone(this);
            },
            moveNext: function () {
                var $t, $t1;
                if (this.version !== this.sortedList.version) {
                    throw new System.InvalidOperationException.ctor();
                }
                if (this.index < this.endIndex) {
                    this.key = ($t = this.sortedList.keys)[System.Array.index(this.index, $t)];
                    this.value = ($t1 = this.sortedList.values)[System.Array.index(this.index, $t1)];
                    this.index = (this.index + 1) | 0;
                    this.current = true;
                    return true;
                }
                this.key = null;
                this.value = null;
                this.current = false;
                return false;
            },
            reset: function () {
                if (this.version !== this.sortedList.version) {
                    throw new System.InvalidOperationException.ctor();
                }
                this.index = this.startIndex;
                this.current = false;
                this.key = null;
                this.value = null;
            }
        }
    });

    // @source SyncSortedList.js

    Bridge.define("System.Collections.SortedList.SyncSortedList", {
        inherits: [System.Collections.SortedList],
        $kind: "nested class",
        fields: {
            _list: null,
            _root: null
        },
        props: {
            Count: {
                get: function () {
                    this._root;
                    {
                        return this._list.Count;
                    }
                }
            },
            SyncRoot: {
                get: function () {
                    return this._root;
                }
            },
            IsReadOnly: {
                get: function () {
                    return this._list.IsReadOnly;
                }
            },
            IsFixedSize: {
                get: function () {
                    return this._list.IsFixedSize;
                }
            },
            IsSynchronized: {
                get: function () {
                    return true;
                }
            },
            Capacity: {
                get: function () {
                    this._root;
                    {
                        return this._list.Capacity;
                    }
                }
            }
        },
        alias: [
            "Count", "System$Collections$ICollection$Count",
            "SyncRoot", "System$Collections$ICollection$SyncRoot",
            "IsReadOnly", "System$Collections$IDictionary$IsReadOnly",
            "IsFixedSize", "System$Collections$IDictionary$IsFixedSize",
            "IsSynchronized", "System$Collections$ICollection$IsSynchronized",
            "getItem", "System$Collections$IDictionary$getItem",
            "setItem", "System$Collections$IDictionary$setItem",
            "add", "System$Collections$IDictionary$add",
            "clear", "System$Collections$IDictionary$clear",
            "clone", "System$ICloneable$clone",
            "contains", "System$Collections$IDictionary$contains",
            "copyTo", "System$Collections$ICollection$copyTo",
            "GetEnumerator", "System$Collections$IDictionary$GetEnumerator",
            "GetEnumerator", "System$Collections$IEnumerable$GetEnumerator",
            "remove", "System$Collections$IDictionary$remove"
        ],
        ctors: {
            ctor: function (list) {
                this.$initialize();
                System.Collections.SortedList.ctor.call(this);
                this._list = list;
                this._root = list.SyncRoot;
            }
        },
        methods: {
            getItem: function (key) {
                this._root;
                {
                    return this._list.getItem(key);
                }
            },
            setItem: function (key, value) {
                this._root;
                {
                    this._list.setItem(key, value);
                }
            },
            add: function (key, value) {
                this._root;
                {
                    this._list.add(key, value);
                }
            },
            clear: function () {
                this._root;
                {
                    this._list.clear();
                }
            },
            clone: function () {
                this._root;
                {
                    return this._list.clone();
                }
            },
            contains: function (key) {
                this._root;
                {
                    return this._list.contains(key);
                }
            },
            ContainsKey: function (key) {
                this._root;
                {
                    return this._list.ContainsKey(key);
                }
            },
            ContainsValue: function (key) {
                this._root;
                {
                    return this._list.ContainsValue(key);
                }
            },
            copyTo: function (array, index) {
                this._root;
                {
                    this._list.copyTo(array, index);
                }
            },
            GetByIndex: function (index) {
                this._root;
                {
                    return this._list.GetByIndex(index);
                }
            },
            GetEnumerator: function () {
                this._root;
                {
                    return this._list.GetEnumerator();
                }
            },
            GetKey: function (index) {
                this._root;
                {
                    return this._list.GetKey(index);
                }
            },
            GetKeyList: function () {
                this._root;
                {
                    return this._list.GetKeyList();
                }
            },
            GetValueList: function () {
                this._root;
                {
                    return this._list.GetValueList();
                }
            },
            IndexOfKey: function (key) {
                if (key == null) {
                    throw new System.ArgumentNullException.$ctor1("key");
                }

                return this._list.IndexOfKey(key);
            },
            IndexOfValue: function (value) {
                this._root;
                {
                    return this._list.IndexOfValue(value);
                }
            },
            RemoveAt: function (index) {
                this._root;
                {
                    this._list.RemoveAt(index);
                }
            },
            remove: function (key) {
                this._root;
                {
                    this._list.remove(key);
                }
            },
            SetByIndex: function (index, value) {
                this._root;
                {
                    this._list.SetByIndex(index, value);
                }
            },
            ToKeyValuePairsArray: function () {
                return this._list.ToKeyValuePairsArray();
            },
            TrimToSize: function () {
                this._root;
                {
                    this._list.TrimToSize();
                }
            }
        }
    });

    // @source ValueList.js

    Bridge.define("System.Collections.SortedList.ValueList", {
        inherits: [System.Collections.IList],
        $kind: "nested class",
        fields: {
            sortedList: null
        },
        props: {
            Count: {
                get: function () {
                    return this.sortedList._size;
                }
            },
            IsReadOnly: {
                get: function () {
                    return true;
                }
            },
            IsFixedSize: {
                get: function () {
                    return true;
                }
            },
            IsSynchronized: {
                get: function () {
                    return this.sortedList.IsSynchronized;
                }
            },
            SyncRoot: {
                get: function () {
                    return this.sortedList.SyncRoot;
                }
            }
        },
        alias: [
            "Count", "System$Collections$ICollection$Count",
            "IsReadOnly", "System$Collections$IList$IsReadOnly",
            "IsFixedSize", "System$Collections$IList$IsFixedSize",
            "IsSynchronized", "System$Collections$ICollection$IsSynchronized",
            "SyncRoot", "System$Collections$ICollection$SyncRoot",
            "add", "System$Collections$IList$add",
            "clear", "System$Collections$IList$clear",
            "contains", "System$Collections$IList$contains",
            "copyTo", "System$Collections$ICollection$copyTo",
            "insert", "System$Collections$IList$insert",
            "getItem", "System$Collections$IList$getItem",
            "setItem", "System$Collections$IList$setItem",
            "GetEnumerator", "System$Collections$IEnumerable$GetEnumerator",
            "indexOf", "System$Collections$IList$indexOf",
            "remove", "System$Collections$IList$remove",
            "removeAt", "System$Collections$IList$removeAt"
        ],
        ctors: {
            ctor: function (sortedList) {
                this.$initialize();
                this.sortedList = sortedList;
            }
        },
        methods: {
            getItem: function (index) {
                return this.sortedList.GetByIndex(index);
            },
            setItem: function (index, value) {
                throw new System.NotSupportedException.ctor();
            },
            add: function (key) {
                throw new System.NotSupportedException.ctor();
            },
            clear: function () {
                throw new System.NotSupportedException.ctor();
            },
            contains: function (value) {
                return this.sortedList.ContainsValue(value);
            },
            copyTo: function (array, arrayIndex) {
                if (array != null && System.Array.getRank(array) !== 1) {
                    throw new System.ArgumentException.ctor();
                }

                System.Array.copy(this.sortedList.values, 0, array, arrayIndex, this.sortedList.Count);
            },
            insert: function (index, value) {
                throw new System.NotSupportedException.ctor();
            },
            GetEnumerator: function () {
                return new System.Collections.SortedList.SortedListEnumerator(this.sortedList, 0, this.sortedList.Count, System.Collections.SortedList.SortedListEnumerator.Values);
            },
            indexOf: function (value) {
                return System.Array.indexOfT(this.sortedList.values, value, 0, this.sortedList.Count);
            },
            remove: function (value) {
                throw new System.NotSupportedException.ctor();
            },
            removeAt: function (index) {
                throw new System.NotSupportedException.ctor();
            }
        }
    });

    // @source SortedList.js

    Bridge.define("System.Collections.Generic.SortedList$2", function (TKey, TValue) { return {
        inherits: [System.Collections.Generic.IDictionary$2(TKey,TValue),System.Collections.IDictionary,System.Collections.Generic.IReadOnlyDictionary$2(TKey,TValue)],
        statics: {
            fields: {
                emptyKeys: null,
                emptyValues: null,
                _defaultCapacity: 0,
                MaxArrayLength: 0
            },
            ctors: {
                init: function () {
                    this.emptyKeys = System.Array.init(0, function (){
                        return Bridge.getDefaultValue(TKey);
                    }, TKey);
                    this.emptyValues = System.Array.init(0, function (){
                        return Bridge.getDefaultValue(TValue);
                    }, TValue);
                    this._defaultCapacity = 4;
                    this.MaxArrayLength = 2146435071;
                }
            },
            methods: {
                IsCompatibleKey: function (key) {
                    if (key == null) {
                        System.ThrowHelper.ThrowArgumentNullException(System.ExceptionArgument.key);
                    }

                    return (Bridge.is(key, TKey));
                }
            }
        },
        fields: {
            keys: null,
            values: null,
            _size: 0,
            version: 0,
            comparer: null,
            keyList: null,
            valueList: null
        },
        props: {
            Capacity: {
                get: function () {
                    return this.keys.length;
                },
                set: function (value) {
                    if (value !== this.keys.length) {
                        if (value < this._size) {
                            System.ThrowHelper.ThrowArgumentOutOfRangeException$2(System.ExceptionArgument.value, System.ExceptionResource.ArgumentOutOfRange_SmallCapacity);
                        }

                        if (value > 0) {
                            var newKeys = System.Array.init(value, function (){
                                return Bridge.getDefaultValue(TKey);
                            }, TKey);
                            var newValues = System.Array.init(value, function (){
                                return Bridge.getDefaultValue(TValue);
                            }, TValue);
                            if (this._size > 0) {
                                System.Array.copy(this.keys, 0, newKeys, 0, this._size);
                                System.Array.copy(this.values, 0, newValues, 0, this._size);
                            }
                            this.keys = newKeys;
                            this.values = newValues;
                        } else {
                            this.keys = System.Collections.Generic.SortedList$2(TKey,TValue).emptyKeys;
                            this.values = System.Collections.Generic.SortedList$2(TKey,TValue).emptyValues;
                        }
                    }
                }
            },
            Comparer: {
                get: function () {
                    return this.comparer;
                }
            },
            Count: {
                get: function () {
                    return this._size;
                }
            },
            Keys: {
                get: function () {
                    return this.GetKeyListHelper();
                }
            },
            System$Collections$Generic$IDictionary$2$Keys: {
                get: function () {
                    return this.GetKeyListHelper();
                }
            },
            System$Collections$IDictionary$Keys: {
                get: function () {
                    return this.GetKeyListHelper();
                }
            },
            System$Collections$Generic$IReadOnlyDictionary$2$Keys: {
                get: function () {
                    return this.GetKeyListHelper();
                }
            },
            Values: {
                get: function () {
                    return this.GetValueListHelper();
                }
            },
            System$Collections$Generic$IDictionary$2$Values: {
                get: function () {
                    return this.GetValueListHelper();
                }
            },
            System$Collections$IDictionary$Values: {
                get: function () {
                    return this.GetValueListHelper();
                }
            },
            System$Collections$Generic$IReadOnlyDictionary$2$Values: {
                get: function () {
                    return this.GetValueListHelper();
                }
            },
            System$Collections$Generic$ICollection$1$IsReadOnly: {
                get: function () {
                    return false;
                }
            },
            System$Collections$IDictionary$IsReadOnly: {
                get: function () {
                    return false;
                }
            },
            System$Collections$IDictionary$IsFixedSize: {
                get: function () {
                    return false;
                }
            },
            System$Collections$ICollection$IsSynchronized: {
                get: function () {
                    return false;
                }
            },
            System$Collections$ICollection$SyncRoot: {
                get: function () {
                    return null;
                }
            }
        },
        alias: [
            "add", "System$Collections$Generic$IDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$add",
            "System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$add", "System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$add",
            "System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$contains", "System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$contains",
            "System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$remove", "System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$remove",
            "Count", ["System$Collections$Generic$IReadOnlyCollection$1$System$Collections$Generic$KeyValuePair$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$Count", "System$Collections$Generic$IReadOnlyCollection$1$Count"],
            "Count", "System$Collections$ICollection$Count",
            "Count", "System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$Count",
            "System$Collections$Generic$IDictionary$2$Keys", "System$Collections$Generic$IDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$Keys",
            "System$Collections$Generic$IReadOnlyDictionary$2$Keys", "System$Collections$Generic$IReadOnlyDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$Keys",
            "System$Collections$Generic$IDictionary$2$Values", "System$Collections$Generic$IDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$Values",
            "System$Collections$Generic$IReadOnlyDictionary$2$Values", "System$Collections$Generic$IReadOnlyDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$Values",
            "System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$IsReadOnly", "System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$IsReadOnly",
            "clear", "System$Collections$IDictionary$clear",
            "clear", "System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$clear",
            "containsKey", "System$Collections$Generic$IReadOnlyDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$containsKey",
            "containsKey", "System$Collections$Generic$IDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$containsKey",
            "System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$copyTo", "System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$copyTo",
            "System$Collections$Generic$IEnumerable$1$System$Collections$Generic$KeyValuePair$2$GetEnumerator", "System$Collections$Generic$IEnumerable$1$System$Collections$Generic$KeyValuePair$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$GetEnumerator",
            "getItem", "System$Collections$Generic$IReadOnlyDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$getItem",
            "setItem", "System$Collections$Generic$IReadOnlyDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$setItem",
            "getItem", "System$Collections$Generic$IDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$getItem",
            "setItem", "System$Collections$Generic$IDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$setItem",
            "getItem", "System$Collections$IDictionary$getItem",
            "setItem", "System$Collections$IDictionary$setItem",
            "tryGetValue", "System$Collections$Generic$IReadOnlyDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$tryGetValue",
            "tryGetValue", "System$Collections$Generic$IDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$tryGetValue",
            "remove", "System$Collections$Generic$IDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$remove"
        ],
        ctors: {
            ctor: function () {
                this.$initialize();
                this.keys = System.Collections.Generic.SortedList$2(TKey,TValue).emptyKeys;
                this.values = System.Collections.Generic.SortedList$2(TKey,TValue).emptyValues;
                this._size = 0;
                this.comparer = new (System.Collections.Generic.Comparer$1(TKey))(System.Collections.Generic.Comparer$1.$default.fn);
            },
            $ctor4: function (capacity) {
                this.$initialize();
                if (capacity < 0) {
                    System.ThrowHelper.ThrowArgumentOutOfRangeException$1(System.ExceptionArgument.capacity);
                }
                this.keys = System.Array.init(capacity, function (){
                    return Bridge.getDefaultValue(TKey);
                }, TKey);
                this.values = System.Array.init(capacity, function (){
                    return Bridge.getDefaultValue(TValue);
                }, TValue);
                this.comparer = new (System.Collections.Generic.Comparer$1(TKey))(System.Collections.Generic.Comparer$1.$default.fn);
            },
            $ctor1: function (comparer) {
                System.Collections.Generic.SortedList$2(TKey,TValue).ctor.call(this);
                if (comparer != null) {
                    this.comparer = comparer;
                }
            },
            $ctor5: function (capacity, comparer) {
                System.Collections.Generic.SortedList$2(TKey,TValue).$ctor1.call(this, comparer);
                this.Capacity = capacity;
            },
            $ctor2: function (dictionary) {
                System.Collections.Generic.SortedList$2(TKey,TValue).$ctor3.call(this, dictionary, null);
            },
            $ctor3: function (dictionary, comparer) {
                System.Collections.Generic.SortedList$2(TKey,TValue).$ctor5.call(this, (dictionary != null ? System.Array.getCount(dictionary, System.Collections.Generic.KeyValuePair$2(TKey,TValue)) : 0), comparer);
                if (dictionary == null) {
                    System.ThrowHelper.ThrowArgumentNullException(System.ExceptionArgument.dictionary);
                }

                System.Array.copyTo(dictionary["System$Collections$Generic$IDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$Keys"], this.keys, 0, TKey);
                System.Array.copyTo(dictionary["System$Collections$Generic$IDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$Values"], this.values, 0, TValue);
                System.Array.sortDict(this.keys, this.values, 0, null, this.comparer);
                this._size = System.Array.getCount(dictionary, System.Collections.Generic.KeyValuePair$2(TKey,TValue));
            }
        },
        methods: {
            getItem: function (key) {
                var i = this.IndexOfKey(key);
                if (i >= 0) {
                    return this.values[System.Array.index(i, this.values)];
                }

                throw new System.Collections.Generic.KeyNotFoundException.ctor();
            },
            setItem: function (key, value) {
                if (key == null) {
                    System.ThrowHelper.ThrowArgumentNullException(System.ExceptionArgument.key);
                }
                var i = System.Array.binarySearch(this.keys, 0, this._size, key, this.comparer);
                if (i >= 0) {
                    this.values[System.Array.index(i, this.values)] = value;
                    this.version = (this.version + 1) | 0;
                    return;
                }
                this.Insert(~i, key, value);
            },
            getItem: function (key) {
                if (System.Collections.Generic.SortedList$2(TKey,TValue).IsCompatibleKey(key)) {
                    var i = this.IndexOfKey(Bridge.cast(Bridge.unbox(key, TKey), TKey));
                    if (i >= 0) {
                        return this.values[System.Array.index(i, this.values)];
                    }
                }

                return null;
            },
            setItem: function (key, value) {
                if (!System.Collections.Generic.SortedList$2(TKey,TValue).IsCompatibleKey(key)) {
                    System.ThrowHelper.ThrowArgumentNullException(System.ExceptionArgument.key);
                }

                System.ThrowHelper.IfNullAndNullsAreIllegalThenThrow(TValue, value, System.ExceptionArgument.value);

                try {
                    var tempKey = Bridge.cast(Bridge.unbox(key, TKey), TKey);
                    try {
                        this.setItem(tempKey, Bridge.cast(Bridge.unbox(value, TValue), TValue));
                    } catch ($e1) {
                        $e1 = System.Exception.create($e1);
                        if (Bridge.is($e1, System.InvalidCastException)) {
                            System.ThrowHelper.ThrowWrongValueTypeArgumentException(System.Object, value, TValue);
                        } else {
                            throw $e1;
                        }
                    }
                } catch ($e2) {
                    $e2 = System.Exception.create($e2);
                    if (Bridge.is($e2, System.InvalidCastException)) {
                        System.ThrowHelper.ThrowWrongKeyTypeArgumentException(System.Object, key, TKey);
                    } else {
                        throw $e2;
                    }
                }
            },
            add: function (key, value) {
                if (key == null) {
                    System.ThrowHelper.ThrowArgumentNullException(System.ExceptionArgument.key);
                }
                var i = System.Array.binarySearch(this.keys, 0, this._size, key, this.comparer);
                if (i >= 0) {
                    System.ThrowHelper.ThrowArgumentException(System.ExceptionResource.Argument_AddingDuplicate);
                }
                this.Insert(~i, key, value);
            },
            System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$add: function (keyValuePair) {
                this.add(keyValuePair.key, keyValuePair.value);
            },
            System$Collections$IDictionary$add: function (key, value) {
                if (key == null) {
                    System.ThrowHelper.ThrowArgumentNullException(System.ExceptionArgument.key);
                }

                System.ThrowHelper.IfNullAndNullsAreIllegalThenThrow(TValue, value, System.ExceptionArgument.value);

                try {
                    var tempKey = Bridge.cast(Bridge.unbox(key, TKey), TKey);

                    try {
                        this.add(tempKey, Bridge.cast(Bridge.unbox(value, TValue), TValue));
                    } catch ($e1) {
                        $e1 = System.Exception.create($e1);
                        if (Bridge.is($e1, System.InvalidCastException)) {
                            System.ThrowHelper.ThrowWrongValueTypeArgumentException(System.Object, value, TValue);
                        } else {
                            throw $e1;
                        }
                    }
                } catch ($e2) {
                    $e2 = System.Exception.create($e2);
                    if (Bridge.is($e2, System.InvalidCastException)) {
                        System.ThrowHelper.ThrowWrongKeyTypeArgumentException(System.Object, key, TKey);
                    } else {
                        throw $e2;
                    }
                }
            },
            System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$contains: function (keyValuePair) {
                var index = this.IndexOfKey(keyValuePair.key);
                if (index >= 0 && System.Collections.Generic.EqualityComparer$1(TValue).def.equals2(this.values[System.Array.index(index, this.values)], keyValuePair.value)) {
                    return true;
                }
                return false;
            },
            System$Collections$IDictionary$contains: function (key) {
                if (System.Collections.Generic.SortedList$2(TKey,TValue).IsCompatibleKey(key)) {
                    return this.containsKey(Bridge.cast(Bridge.unbox(key, TKey), TKey));
                }
                return false;
            },
            System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$remove: function (keyValuePair) {
                var index = this.IndexOfKey(keyValuePair.key);
                if (index >= 0 && System.Collections.Generic.EqualityComparer$1(TValue).def.equals2(this.values[System.Array.index(index, this.values)], keyValuePair.value)) {
                    this.RemoveAt(index);
                    return true;
                }
                return false;
            },
            remove: function (key) {
                var i = this.IndexOfKey(key);
                if (i >= 0) {
                    this.RemoveAt(i);
                }
                return i >= 0;
            },
            System$Collections$IDictionary$remove: function (key) {
                if (System.Collections.Generic.SortedList$2(TKey,TValue).IsCompatibleKey(key)) {
                    this.remove(Bridge.cast(Bridge.unbox(key, TKey), TKey));
                }
            },
            GetKeyListHelper: function () {
                if (this.keyList == null) {
                    this.keyList = new (System.Collections.Generic.SortedList$2.KeyList(TKey,TValue))(this);
                }
                return this.keyList;
            },
            GetValueListHelper: function () {
                if (this.valueList == null) {
                    this.valueList = new (System.Collections.Generic.SortedList$2.ValueList(TKey,TValue))(this);
                }
                return this.valueList;
            },
            clear: function () {
                this.version = (this.version + 1) | 0;
                System.Array.fill(this.keys, Bridge.getDefaultValue(TKey), 0, this._size);
                System.Array.fill(this.values, Bridge.getDefaultValue(TValue), 0, this._size);
                this._size = 0;
            },
            containsKey: function (key) {
                return this.IndexOfKey(key) >= 0;
            },
            ContainsValue: function (value) {
                return this.IndexOfValue(value) >= 0;
            },
            System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$copyTo: function (array, arrayIndex) {
                if (array == null) {
                    System.ThrowHelper.ThrowArgumentNullException(System.ExceptionArgument.array);
                }

                if (arrayIndex < 0 || arrayIndex > array.length) {
                    System.ThrowHelper.ThrowArgumentOutOfRangeException$2(System.ExceptionArgument.arrayIndex, System.ExceptionResource.ArgumentOutOfRange_NeedNonNegNum);
                }

                if (((array.length - arrayIndex) | 0) < this.Count) {
                    System.ThrowHelper.ThrowArgumentException(System.ExceptionResource.Arg_ArrayPlusOffTooSmall);
                }

                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    var entry = new (System.Collections.Generic.KeyValuePair$2(TKey,TValue)).$ctor1(this.keys[System.Array.index(i, this.keys)], this.values[System.Array.index(i, this.values)]);
                    array[System.Array.index(((arrayIndex + i) | 0), array)] = entry;
                }
            },
            System$Collections$ICollection$copyTo: function (array, arrayIndex) {
                if (array == null) {
                    System.ThrowHelper.ThrowArgumentNullException(System.ExceptionArgument.array);
                }

                if (System.Array.getRank(array) !== 1) {
                    System.ThrowHelper.ThrowArgumentException(System.ExceptionResource.Arg_RankMultiDimNotSupported);
                }

                if (System.Array.getLower(array, 0) !== 0) {
                    System.ThrowHelper.ThrowArgumentException(System.ExceptionResource.Arg_NonZeroLowerBound);
                }

                if (arrayIndex < 0 || arrayIndex > array.length) {
                    System.ThrowHelper.ThrowArgumentOutOfRangeException$2(System.ExceptionArgument.arrayIndex, System.ExceptionResource.ArgumentOutOfRange_NeedNonNegNum);
                }

                if (((array.length - arrayIndex) | 0) < this.Count) {
                    System.ThrowHelper.ThrowArgumentException(System.ExceptionResource.Arg_ArrayPlusOffTooSmall);
                }

                var keyValuePairArray = Bridge.as(array, System.Array.type(System.Collections.Generic.KeyValuePair$2(TKey,TValue)));
                if (keyValuePairArray != null) {
                    for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                        keyValuePairArray[System.Array.index(((i + arrayIndex) | 0), keyValuePairArray)] = new (System.Collections.Generic.KeyValuePair$2(TKey,TValue)).$ctor1(this.keys[System.Array.index(i, this.keys)], this.values[System.Array.index(i, this.values)]);
                    }
                } else {
                    var objects = Bridge.as(array, System.Array.type(System.Object));
                    if (objects == null) {
                        System.ThrowHelper.ThrowArgumentException(System.ExceptionResource.Argument_InvalidArrayType);
                    }

                    try {
                        for (var i1 = 0; i1 < this.Count; i1 = (i1 + 1) | 0) {
                            objects[System.Array.index(((i1 + arrayIndex) | 0), objects)] = new (System.Collections.Generic.KeyValuePair$2(TKey,TValue)).$ctor1(this.keys[System.Array.index(i1, this.keys)], this.values[System.Array.index(i1, this.values)]);
                        }
                    } catch ($e1) {
                        $e1 = System.Exception.create($e1);
                        if (Bridge.is($e1, System.ArrayTypeMismatchException)) {
                            System.ThrowHelper.ThrowArgumentException(System.ExceptionResource.Argument_InvalidArrayType);
                        } else {
                            throw $e1;
                        }
                    }

                }
            },
            EnsureCapacity: function (min) {
                var newCapacity = this.keys.length === 0 ? System.Collections.Generic.SortedList$2(TKey,TValue)._defaultCapacity : Bridge.Int.mul(this.keys.length, 2);
                if ((newCapacity >>> 0) > System.Collections.Generic.SortedList$2(TKey,TValue).MaxArrayLength) {
                    newCapacity = System.Collections.Generic.SortedList$2(TKey,TValue).MaxArrayLength;
                }
                if (newCapacity < min) {
                    newCapacity = min;
                }
                this.Capacity = newCapacity;
            },
            GetByIndex: function (index) {
                if (index < 0 || index >= this._size) {
                    System.ThrowHelper.ThrowArgumentOutOfRangeException$2(System.ExceptionArgument.index, System.ExceptionResource.ArgumentOutOfRange_Index);
                }
                return this.values[System.Array.index(index, this.values)];
            },
            GetEnumerator: function () {
                return new (System.Collections.Generic.SortedList$2.Enumerator(TKey,TValue)).$ctor1(this, System.Collections.Generic.SortedList$2.Enumerator(TKey,TValue).KeyValuePair).$clone();
            },
            System$Collections$Generic$IEnumerable$1$System$Collections$Generic$KeyValuePair$2$GetEnumerator: function () {
                return new (System.Collections.Generic.SortedList$2.Enumerator(TKey,TValue)).$ctor1(this, System.Collections.Generic.SortedList$2.Enumerator(TKey,TValue).KeyValuePair).$clone();
            },
            System$Collections$IDictionary$GetEnumerator: function () {
                return new (System.Collections.Generic.SortedList$2.Enumerator(TKey,TValue)).$ctor1(this, System.Collections.Generic.SortedList$2.Enumerator(TKey,TValue).DictEntry).$clone();
            },
            System$Collections$IEnumerable$GetEnumerator: function () {
                return new (System.Collections.Generic.SortedList$2.Enumerator(TKey,TValue)).$ctor1(this, System.Collections.Generic.SortedList$2.Enumerator(TKey,TValue).KeyValuePair).$clone();
            },
            GetKey: function (index) {
                if (index < 0 || index >= this._size) {
                    System.ThrowHelper.ThrowArgumentOutOfRangeException$2(System.ExceptionArgument.index, System.ExceptionResource.ArgumentOutOfRange_Index);
                }
                return this.keys[System.Array.index(index, this.keys)];
            },
            IndexOfKey: function (key) {
                if (key == null) {
                    System.ThrowHelper.ThrowArgumentNullException(System.ExceptionArgument.key);
                }
                var ret = System.Array.binarySearch(this.keys, 0, this._size, key, this.comparer);
                return ret >= 0 ? ret : -1;
            },
            IndexOfValue: function (value) {
                return System.Array.indexOfT(this.values, value, 0, this._size);
            },
            Insert: function (index, key, value) {
                if (this._size === this.keys.length) {
                    this.EnsureCapacity(((this._size + 1) | 0));
                }
                if (index < this._size) {
                    System.Array.copy(this.keys, index, this.keys, ((index + 1) | 0), ((this._size - index) | 0));
                    System.Array.copy(this.values, index, this.values, ((index + 1) | 0), ((this._size - index) | 0));
                }
                this.keys[System.Array.index(index, this.keys)] = key;
                this.values[System.Array.index(index, this.values)] = value;
                this._size = (this._size + 1) | 0;
                this.version = (this.version + 1) | 0;
            },
            tryGetValue: function (key, value) {
                var i = this.IndexOfKey(key);
                if (i >= 0) {
                    value.v = this.values[System.Array.index(i, this.values)];
                    return true;
                }

                value.v = Bridge.getDefaultValue(TValue);
                return false;
            },
            RemoveAt: function (index) {
                if (index < 0 || index >= this._size) {
                    System.ThrowHelper.ThrowArgumentOutOfRangeException$2(System.ExceptionArgument.index, System.ExceptionResource.ArgumentOutOfRange_Index);
                }
                this._size = (this._size - 1) | 0;
                if (index < this._size) {
                    System.Array.copy(this.keys, ((index + 1) | 0), this.keys, index, ((this._size - index) | 0));
                    System.Array.copy(this.values, ((index + 1) | 0), this.values, index, ((this._size - index) | 0));
                }
                this.keys[System.Array.index(this._size, this.keys)] = Bridge.getDefaultValue(TKey);
                this.values[System.Array.index(this._size, this.values)] = Bridge.getDefaultValue(TValue);
                this.version = (this.version + 1) | 0;
            },
            TrimExcess: function () {
                var threshold = Bridge.Int.clip32(this.keys.length * 0.9);
                if (this._size < threshold) {
                    this.Capacity = this._size;
                }
            }
        }
    }; });

    // @source Enumerator.js

    Bridge.define("System.Collections.Generic.SortedList$2.Enumerator", function (TKey, TValue) { return {
        inherits: [System.Collections.Generic.IEnumerator$1(System.Collections.Generic.KeyValuePair$2(TKey,TValue)),System.Collections.IDictionaryEnumerator],
        $kind: "nested struct",
        statics: {
            fields: {
                KeyValuePair: 0,
                DictEntry: 0
            },
            ctors: {
                init: function () {
                    this.KeyValuePair = 1;
                    this.DictEntry = 2;
                }
            },
            methods: {
                getDefaultValue: function () { return new (System.Collections.Generic.SortedList$2.Enumerator(TKey,TValue))(); }
            }
        },
        fields: {
            _sortedList: null,
            key: Bridge.getDefaultValue(TKey),
            value: Bridge.getDefaultValue(TValue),
            index: 0,
            version: 0,
            getEnumeratorRetType: 0
        },
        props: {
            System$Collections$IDictionaryEnumerator$Key: {
                get: function () {
                    if (this.index === 0 || (this.index === ((this._sortedList.Count + 1) | 0))) {
                        System.ThrowHelper.ThrowInvalidOperationException(System.ExceptionResource.InvalidOperation_EnumOpCantHappen);
                    }

                    return this.key;
                }
            },
            System$Collections$IDictionaryEnumerator$Entry: {
                get: function () {
                    if (this.index === 0 || (this.index === ((this._sortedList.Count + 1) | 0))) {
                        System.ThrowHelper.ThrowInvalidOperationException(System.ExceptionResource.InvalidOperation_EnumOpCantHappen);
                    }

                    return new System.Collections.DictionaryEntry.$ctor1(this.key, this.value);
                }
            },
            Current: {
                get: function () {
                    return new (System.Collections.Generic.KeyValuePair$2(TKey,TValue)).$ctor1(this.key, this.value);
                }
            },
            System$Collections$IEnumerator$Current: {
                get: function () {
                    if (this.index === 0 || (this.index === ((this._sortedList.Count + 1) | 0))) {
                        System.ThrowHelper.ThrowInvalidOperationException(System.ExceptionResource.InvalidOperation_EnumOpCantHappen);
                    }

                    if (this.getEnumeratorRetType === System.Collections.Generic.SortedList$2.Enumerator(TKey,TValue).DictEntry) {
                        return new System.Collections.DictionaryEntry.$ctor1(this.key, this.value).$clone();
                    } else {
                        return new (System.Collections.Generic.KeyValuePair$2(TKey,TValue)).$ctor1(this.key, this.value);
                    }
                }
            },
            System$Collections$IDictionaryEnumerator$Value: {
                get: function () {
                    if (this.index === 0 || (this.index === ((this._sortedList.Count + 1) | 0))) {
                        System.ThrowHelper.ThrowInvalidOperationException(System.ExceptionResource.InvalidOperation_EnumOpCantHappen);
                    }

                    return this.value;
                }
            }
        },
        alias: [
            "Dispose", "System$IDisposable$Dispose",
            "moveNext", "System$Collections$IEnumerator$moveNext",
            "Current", ["System$Collections$Generic$IEnumerator$1$System$Collections$Generic$KeyValuePair$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$Current$1", "System$Collections$Generic$IEnumerator$1$Current$1"]
        ],
        ctors: {
            $ctor1: function (sortedList, getEnumeratorRetType) {
                this.$initialize();
                this._sortedList = sortedList;
                this.index = 0;
                this.version = this._sortedList.version;
                this.getEnumeratorRetType = getEnumeratorRetType;
                this.key = Bridge.getDefaultValue(TKey);
                this.value = Bridge.getDefaultValue(TValue);
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            Dispose: function () {
                this.index = 0;
                this.key = Bridge.getDefaultValue(TKey);
                this.value = Bridge.getDefaultValue(TValue);
            },
            moveNext: function () {
                var $t, $t1;
                if (this.version !== this._sortedList.version) {
                    System.ThrowHelper.ThrowInvalidOperationException(System.ExceptionResource.InvalidOperation_EnumFailedVersion);
                }

                if ((this.index >>> 0) < ((this._sortedList.Count) >>> 0)) {
                    this.key = ($t = this._sortedList.keys)[System.Array.index(this.index, $t)];
                    this.value = ($t1 = this._sortedList.values)[System.Array.index(this.index, $t1)];
                    this.index = (this.index + 1) | 0;
                    return true;
                }

                this.index = (this._sortedList.Count + 1) | 0;
                this.key = Bridge.getDefaultValue(TKey);
                this.value = Bridge.getDefaultValue(TValue);
                return false;
            },
            System$Collections$IEnumerator$reset: function () {
                if (this.version !== this._sortedList.version) {
                    System.ThrowHelper.ThrowInvalidOperationException(System.ExceptionResource.InvalidOperation_EnumFailedVersion);
                }

                this.index = 0;
                this.key = Bridge.getDefaultValue(TKey);
                this.value = Bridge.getDefaultValue(TValue);
            },
            getHashCode: function () {
                var h = Bridge.addHash([3788985113, this._sortedList, this.key, this.value, this.index, this.version, this.getEnumeratorRetType]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, System.Collections.Generic.SortedList$2.Enumerator(TKey,TValue))) {
                    return false;
                }
                return Bridge.equals(this._sortedList, o._sortedList) && Bridge.equals(this.key, o.key) && Bridge.equals(this.value, o.value) && Bridge.equals(this.index, o.index) && Bridge.equals(this.version, o.version) && Bridge.equals(this.getEnumeratorRetType, o.getEnumeratorRetType);
            },
            $clone: function (to) {
                var s = to || new (System.Collections.Generic.SortedList$2.Enumerator(TKey,TValue))();
                s._sortedList = this._sortedList;
                s.key = this.key;
                s.value = this.value;
                s.index = this.index;
                s.version = this.version;
                s.getEnumeratorRetType = this.getEnumeratorRetType;
                return s;
            }
        }
    }; });

    // @source KeyList.js

    Bridge.define("System.Collections.Generic.SortedList$2.KeyList", function (TKey, TValue) { return {
        inherits: [System.Collections.Generic.IList$1(TKey),System.Collections.ICollection],
        $kind: "nested class",
        fields: {
            _dict: null
        },
        props: {
            Count: {
                get: function () {
                    return this._dict._size;
                }
            },
            IsReadOnly: {
                get: function () {
                    return true;
                }
            },
            System$Collections$ICollection$IsSynchronized: {
                get: function () {
                    return false;
                }
            },
            System$Collections$ICollection$SyncRoot: {
                get: function () {
                    return Bridge.cast(this._dict, System.Collections.ICollection).System$Collections$ICollection$SyncRoot;
                }
            }
        },
        alias: [
            "Count", "System$Collections$ICollection$Count",
            "Count", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(TKey) + "$Count",
            "IsReadOnly", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(TKey) + "$IsReadOnly",
            "add", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(TKey) + "$add",
            "clear", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(TKey) + "$clear",
            "contains", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(TKey) + "$contains",
            "copyTo", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(TKey) + "$copyTo",
            "insert", "System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TKey) + "$insert",
            "getItem", "System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TKey) + "$getItem",
            "setItem", "System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TKey) + "$setItem",
            "GetEnumerator", ["System$Collections$Generic$IEnumerable$1$" + Bridge.getTypeAlias(TKey) + "$GetEnumerator", "System$Collections$Generic$IEnumerable$1$GetEnumerator"],
            "indexOf", "System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TKey) + "$indexOf",
            "remove", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(TKey) + "$remove",
            "removeAt", "System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TKey) + "$removeAt"
        ],
        ctors: {
            ctor: function (dictionary) {
                this.$initialize();
                this._dict = dictionary;
            }
        },
        methods: {
            getItem: function (index) {
                return this._dict.GetKey(index);
            },
            setItem: function (index, value) {
                System.ThrowHelper.ThrowNotSupportedException$1(System.ExceptionResource.NotSupported_KeyCollectionSet);
            },
            add: function (key) {
                System.ThrowHelper.ThrowNotSupportedException$1(System.ExceptionResource.NotSupported_SortedListNestedWrite);
            },
            clear: function () {
                System.ThrowHelper.ThrowNotSupportedException$1(System.ExceptionResource.NotSupported_SortedListNestedWrite);
            },
            contains: function (key) {
                return this._dict.containsKey(key);
            },
            copyTo: function (array, arrayIndex) {
                System.Array.copy(this._dict.keys, 0, array, arrayIndex, this._dict.Count);
            },
            System$Collections$ICollection$copyTo: function (array, arrayIndex) {
                if (array != null && System.Array.getRank(array) !== 1) {
                    System.ThrowHelper.ThrowArgumentException(System.ExceptionResource.Arg_RankMultiDimNotSupported);
                }

                try {
                    System.Array.copy(this._dict.keys, 0, array, arrayIndex, this._dict.Count);
                } catch ($e1) {
                    $e1 = System.Exception.create($e1);
                    if (Bridge.is($e1, System.ArrayTypeMismatchException)) {
                        System.ThrowHelper.ThrowArgumentException(System.ExceptionResource.Argument_InvalidArrayType);
                    } else {
                        throw $e1;
                    }
                }
            },
            insert: function (index, value) {
                System.ThrowHelper.ThrowNotSupportedException$1(System.ExceptionResource.NotSupported_SortedListNestedWrite);
            },
            GetEnumerator: function () {
                return new (System.Collections.Generic.SortedList$2.SortedListKeyEnumerator(TKey,TValue))(this._dict);
            },
            System$Collections$IEnumerable$GetEnumerator: function () {
                return new (System.Collections.Generic.SortedList$2.SortedListKeyEnumerator(TKey,TValue))(this._dict);
            },
            indexOf: function (key) {
                if (key == null) {
                    System.ThrowHelper.ThrowArgumentNullException(System.ExceptionArgument.key);
                }

                var i = System.Array.binarySearch(this._dict.keys, 0, this._dict.Count, key, this._dict.comparer);
                if (i >= 0) {
                    return i;
                }
                return -1;
            },
            remove: function (key) {
                System.ThrowHelper.ThrowNotSupportedException$1(System.ExceptionResource.NotSupported_SortedListNestedWrite);
                return false;
            },
            removeAt: function (index) {
                System.ThrowHelper.ThrowNotSupportedException$1(System.ExceptionResource.NotSupported_SortedListNestedWrite);
            }
        }
    }; });

    // @source SortedListKeyEnumerator.js

    Bridge.define("System.Collections.Generic.SortedList$2.SortedListKeyEnumerator", function (TKey, TValue) { return {
        inherits: [System.Collections.Generic.IEnumerator$1(TKey),System.Collections.IEnumerator],
        $kind: "nested class",
        fields: {
            _sortedList: null,
            index: 0,
            version: 0,
            currentKey: Bridge.getDefaultValue(TKey)
        },
        props: {
            Current: {
                get: function () {
                    return this.currentKey;
                }
            },
            System$Collections$IEnumerator$Current: {
                get: function () {
                    if (this.index === 0 || (this.index === ((this._sortedList.Count + 1) | 0))) {
                        System.ThrowHelper.ThrowInvalidOperationException(System.ExceptionResource.InvalidOperation_EnumOpCantHappen);
                    }

                    return this.currentKey;
                }
            }
        },
        alias: [
            "Dispose", "System$IDisposable$Dispose",
            "moveNext", "System$Collections$IEnumerator$moveNext",
            "Current", ["System$Collections$Generic$IEnumerator$1$" + Bridge.getTypeAlias(TKey) + "$Current$1", "System$Collections$Generic$IEnumerator$1$Current$1"]
        ],
        ctors: {
            ctor: function (sortedList) {
                this.$initialize();
                this._sortedList = sortedList;
                this.version = sortedList.version;
            }
        },
        methods: {
            Dispose: function () {
                this.index = 0;
                this.currentKey = Bridge.getDefaultValue(TKey);
            },
            moveNext: function () {
                var $t;
                if (this.version !== this._sortedList.version) {
                    System.ThrowHelper.ThrowInvalidOperationException(System.ExceptionResource.InvalidOperation_EnumFailedVersion);
                }

                if ((this.index >>> 0) < ((this._sortedList.Count) >>> 0)) {
                    this.currentKey = ($t = this._sortedList.keys)[System.Array.index(this.index, $t)];
                    this.index = (this.index + 1) | 0;
                    return true;
                }

                this.index = (this._sortedList.Count + 1) | 0;
                this.currentKey = Bridge.getDefaultValue(TKey);
                return false;
            },
            System$Collections$IEnumerator$reset: function () {
                if (this.version !== this._sortedList.version) {
                    System.ThrowHelper.ThrowInvalidOperationException(System.ExceptionResource.InvalidOperation_EnumFailedVersion);
                }
                this.index = 0;
                this.currentKey = Bridge.getDefaultValue(TKey);
            }
        }
    }; });

    // @source SortedListValueEnumerator.js

    Bridge.define("System.Collections.Generic.SortedList$2.SortedListValueEnumerator", function (TKey, TValue) { return {
        inherits: [System.Collections.Generic.IEnumerator$1(TValue),System.Collections.IEnumerator],
        $kind: "nested class",
        fields: {
            _sortedList: null,
            index: 0,
            version: 0,
            currentValue: Bridge.getDefaultValue(TValue)
        },
        props: {
            Current: {
                get: function () {
                    return this.currentValue;
                }
            },
            System$Collections$IEnumerator$Current: {
                get: function () {
                    if (this.index === 0 || (this.index === ((this._sortedList.Count + 1) | 0))) {
                        System.ThrowHelper.ThrowInvalidOperationException(System.ExceptionResource.InvalidOperation_EnumOpCantHappen);
                    }

                    return this.currentValue;
                }
            }
        },
        alias: [
            "Dispose", "System$IDisposable$Dispose",
            "moveNext", "System$Collections$IEnumerator$moveNext",
            "Current", ["System$Collections$Generic$IEnumerator$1$" + Bridge.getTypeAlias(TValue) + "$Current$1", "System$Collections$Generic$IEnumerator$1$Current$1"]
        ],
        ctors: {
            ctor: function (sortedList) {
                this.$initialize();
                this._sortedList = sortedList;
                this.version = sortedList.version;
            }
        },
        methods: {
            Dispose: function () {
                this.index = 0;
                this.currentValue = Bridge.getDefaultValue(TValue);
            },
            moveNext: function () {
                var $t;
                if (this.version !== this._sortedList.version) {
                    System.ThrowHelper.ThrowInvalidOperationException(System.ExceptionResource.InvalidOperation_EnumFailedVersion);
                }

                if ((this.index >>> 0) < ((this._sortedList.Count) >>> 0)) {
                    this.currentValue = ($t = this._sortedList.values)[System.Array.index(this.index, $t)];
                    this.index = (this.index + 1) | 0;
                    return true;
                }

                this.index = (this._sortedList.Count + 1) | 0;
                this.currentValue = Bridge.getDefaultValue(TValue);
                return false;
            },
            System$Collections$IEnumerator$reset: function () {
                if (this.version !== this._sortedList.version) {
                    System.ThrowHelper.ThrowInvalidOperationException(System.ExceptionResource.InvalidOperation_EnumFailedVersion);
                }
                this.index = 0;
                this.currentValue = Bridge.getDefaultValue(TValue);
            }
        }
    }; });

    // @source ValueList.js

    Bridge.define("System.Collections.Generic.SortedList$2.ValueList", function (TKey, TValue) { return {
        inherits: [System.Collections.Generic.IList$1(TValue),System.Collections.ICollection],
        $kind: "nested class",
        fields: {
            _dict: null
        },
        props: {
            Count: {
                get: function () {
                    return this._dict._size;
                }
            },
            IsReadOnly: {
                get: function () {
                    return true;
                }
            },
            System$Collections$ICollection$IsSynchronized: {
                get: function () {
                    return false;
                }
            },
            System$Collections$ICollection$SyncRoot: {
                get: function () {
                    return Bridge.cast(this._dict, System.Collections.ICollection).System$Collections$ICollection$SyncRoot;
                }
            }
        },
        alias: [
            "Count", "System$Collections$ICollection$Count",
            "Count", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(TValue) + "$Count",
            "IsReadOnly", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(TValue) + "$IsReadOnly",
            "add", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(TValue) + "$add",
            "clear", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(TValue) + "$clear",
            "contains", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(TValue) + "$contains",
            "copyTo", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(TValue) + "$copyTo",
            "insert", "System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TValue) + "$insert",
            "getItem", "System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TValue) + "$getItem",
            "setItem", "System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TValue) + "$setItem",
            "GetEnumerator", ["System$Collections$Generic$IEnumerable$1$" + Bridge.getTypeAlias(TValue) + "$GetEnumerator", "System$Collections$Generic$IEnumerable$1$GetEnumerator"],
            "indexOf", "System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TValue) + "$indexOf",
            "remove", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(TValue) + "$remove",
            "removeAt", "System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TValue) + "$removeAt"
        ],
        ctors: {
            ctor: function (dictionary) {
                this.$initialize();
                this._dict = dictionary;
            }
        },
        methods: {
            getItem: function (index) {
                return this._dict.GetByIndex(index);
            },
            setItem: function (index, value) {
                System.ThrowHelper.ThrowNotSupportedException$1(System.ExceptionResource.NotSupported_SortedListNestedWrite);
            },
            add: function (key) {
                System.ThrowHelper.ThrowNotSupportedException$1(System.ExceptionResource.NotSupported_SortedListNestedWrite);
            },
            clear: function () {
                System.ThrowHelper.ThrowNotSupportedException$1(System.ExceptionResource.NotSupported_SortedListNestedWrite);
            },
            contains: function (value) {
                return this._dict.ContainsValue(value);
            },
            copyTo: function (array, arrayIndex) {
                System.Array.copy(this._dict.values, 0, array, arrayIndex, this._dict.Count);
            },
            System$Collections$ICollection$copyTo: function (array, arrayIndex) {
                if (array != null && System.Array.getRank(array) !== 1) {
                    System.ThrowHelper.ThrowArgumentException(System.ExceptionResource.Arg_RankMultiDimNotSupported);
                }

                try {
                    System.Array.copy(this._dict.values, 0, array, arrayIndex, this._dict.Count);
                } catch ($e1) {
                    $e1 = System.Exception.create($e1);
                    if (Bridge.is($e1, System.ArrayTypeMismatchException)) {
                        System.ThrowHelper.ThrowArgumentException(System.ExceptionResource.Argument_InvalidArrayType);
                    } else {
                        throw $e1;
                    }
                }
            },
            insert: function (index, value) {
                System.ThrowHelper.ThrowNotSupportedException$1(System.ExceptionResource.NotSupported_SortedListNestedWrite);
            },
            GetEnumerator: function () {
                return new (System.Collections.Generic.SortedList$2.SortedListValueEnumerator(TKey,TValue))(this._dict);
            },
            System$Collections$IEnumerable$GetEnumerator: function () {
                return new (System.Collections.Generic.SortedList$2.SortedListValueEnumerator(TKey,TValue))(this._dict);
            },
            indexOf: function (value) {
                return System.Array.indexOfT(this._dict.values, value, 0, this._dict.Count);
            },
            remove: function (value) {
                System.ThrowHelper.ThrowNotSupportedException$1(System.ExceptionResource.NotSupported_SortedListNestedWrite);
                return false;
            },
            removeAt: function (index) {
                System.ThrowHelper.ThrowNotSupportedException$1(System.ExceptionResource.NotSupported_SortedListNestedWrite);
            }
        }
    }; });

    // @source SortedSet.js

    Bridge.define("System.Collections.Generic.SortedSet$1", function (T) { return {
        inherits: [System.Collections.Generic.ISet$1(T),System.Collections.Generic.ICollection$1(T),System.Collections.ICollection,System.Collections.Generic.IReadOnlyCollection$1(T)],
        statics: {
            fields: {
                ComparerName: null,
                CountName: null,
                ItemsName: null,
                VersionName: null,
                TreeName: null,
                NodeValueName: null,
                EnumStartName: null,
                ReverseName: null,
                EnumVersionName: null,
                minName: null,
                maxName: null,
                lBoundActiveName: null,
                uBoundActiveName: null,
                StackAllocThreshold: 0
            },
            ctors: {
                init: function () {
                    this.ComparerName = "Comparer";
                    this.CountName = "Count";
                    this.ItemsName = "Items";
                    this.VersionName = "Version";
                    this.TreeName = "Tree";
                    this.NodeValueName = "Item";
                    this.EnumStartName = "EnumStarted";
                    this.ReverseName = "Reverse";
                    this.EnumVersionName = "EnumVersion";
                    this.minName = "Min";
                    this.maxName = "Max";
                    this.lBoundActiveName = "lBoundActive";
                    this.uBoundActiveName = "uBoundActive";
                    this.StackAllocThreshold = 100;
                }
            },
            methods: {
                GetSibling: function (node, parent) {
                    if (Bridge.referenceEquals(parent.Left, node)) {
                        return parent.Right;
                    }
                    return parent.Left;
                },
                Is2Node: function (node) {
                    return System.Collections.Generic.SortedSet$1(T).IsBlack(node) && System.Collections.Generic.SortedSet$1(T).IsNullOrBlack(node.Left) && System.Collections.Generic.SortedSet$1(T).IsNullOrBlack(node.Right);
                },
                Is4Node: function (node) {
                    return System.Collections.Generic.SortedSet$1(T).IsRed(node.Left) && System.Collections.Generic.SortedSet$1(T).IsRed(node.Right);
                },
                IsBlack: function (node) {
                    return (node != null && !node.IsRed);
                },
                IsNullOrBlack: function (node) {
                    return (node == null || !node.IsRed);
                },
                IsRed: function (node) {
                    return (node != null && node.IsRed);
                },
                Merge2Nodes: function (parent, child1, child2) {
                    parent.IsRed = false;
                    child1.IsRed = true;
                    child2.IsRed = true;
                },
                RotateLeft: function (node) {
                    var x = node.Right;
                    node.Right = x.Left;
                    x.Left = node;
                    return x;
                },
                RotateLeftRight: function (node) {
                    var child = node.Left;
                    var grandChild = child.Right;

                    node.Left = grandChild.Right;
                    grandChild.Right = node;
                    child.Right = grandChild.Left;
                    grandChild.Left = child;
                    return grandChild;
                },
                RotateRight: function (node) {
                    var x = node.Left;
                    node.Left = x.Right;
                    x.Right = node;
                    return x;
                },
                RotateRightLeft: function (node) {
                    var child = node.Right;
                    var grandChild = child.Left;

                    node.Right = grandChild.Left;
                    grandChild.Left = node;
                    child.Left = grandChild.Right;
                    grandChild.Right = child;
                    return grandChild;
                },
                RotationNeeded: function (parent, current, sibling) {
                    if (System.Collections.Generic.SortedSet$1(T).IsRed(sibling.Left)) {
                        if (Bridge.referenceEquals(parent.Left, current)) {
                            return System.Collections.Generic.TreeRotation.RightLeftRotation;
                        }
                        return System.Collections.Generic.TreeRotation.RightRotation;
                    } else {
                        if (Bridge.referenceEquals(parent.Left, current)) {
                            return System.Collections.Generic.TreeRotation.LeftRotation;
                        }
                        return System.Collections.Generic.TreeRotation.LeftRightRotation;
                    }
                },
                CreateSetComparer: function () {
                    return new (System.Collections.Generic.SortedSetEqualityComparer$1(T)).ctor();
                },
                CreateSetComparer$1: function (memberEqualityComparer) {
                    return new (System.Collections.Generic.SortedSetEqualityComparer$1(T)).$ctor3(memberEqualityComparer);
                },
                SortedSetEquals: function (set1, set2, comparer) {
                    var $t, $t1;
                    if (set1 == null) {
                        return (set2 == null);
                    } else if (set2 == null) {
                        return false;
                    }

                    if (System.Collections.Generic.SortedSet$1(T).AreComparersEqual(set1, set2)) {
                        if (set1.Count !== set2.Count) {
                            return false;
                        }

                        return set1.setEquals(set2);
                    } else {
                        var found = false;
                        $t = Bridge.getEnumerator(set1);
                        try {
                            while ($t.moveNext()) {
                                var item1 = $t.Current;
                                found = false;
                                $t1 = Bridge.getEnumerator(set2);
                                try {
                                    while ($t1.moveNext()) {
                                        var item2 = $t1.Current;
                                        if (comparer[Bridge.geti(comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare", "System$Collections$Generic$IComparer$1$compare")](item1, item2) === 0) {
                                            found = true;
                                            break;
                                        }
                                    }
                                } finally {
                                    if (Bridge.is($t1, System.IDisposable)) {
                                        $t1.System$IDisposable$Dispose();
                                    }
                                }
                                if (!found) {
                                    return false;
                                }
                            }
                        } finally {
                            if (Bridge.is($t, System.IDisposable)) {
                                $t.System$IDisposable$Dispose();
                            }
                        }
                        return true;
                    }

                },
                AreComparersEqual: function (set1, set2) {
                    return Bridge.equals(set1.Comparer, set2.Comparer);
                },
                Split4Node: function (node) {
                    node.IsRed = true;
                    node.Left.IsRed = false;
                    node.Right.IsRed = false;
                },
                ConstructRootFromSortedArray: function (arr, startIndex, endIndex, redNode) {





                    var size = (((endIndex - startIndex) | 0) + 1) | 0;
                    if (size === 0) {
                        return null;
                    }
                    var root = null;
                    if (size === 1) {
                        root = new (System.Collections.Generic.SortedSet$1.Node(T)).$ctor1(arr[System.Array.index(startIndex, arr)], false);
                        if (redNode != null) {
                            root.Left = redNode;
                        }
                    } else if (size === 2) {
                        root = new (System.Collections.Generic.SortedSet$1.Node(T)).$ctor1(arr[System.Array.index(startIndex, arr)], false);
                        root.Right = new (System.Collections.Generic.SortedSet$1.Node(T)).$ctor1(arr[System.Array.index(endIndex, arr)], false);
                        root.Right.IsRed = true;
                        if (redNode != null) {
                            root.Left = redNode;
                        }
                    } else if (size === 3) {
                        root = new (System.Collections.Generic.SortedSet$1.Node(T)).$ctor1(arr[System.Array.index(((startIndex + 1) | 0), arr)], false);
                        root.Left = new (System.Collections.Generic.SortedSet$1.Node(T)).$ctor1(arr[System.Array.index(startIndex, arr)], false);
                        root.Right = new (System.Collections.Generic.SortedSet$1.Node(T)).$ctor1(arr[System.Array.index(endIndex, arr)], false);
                        if (redNode != null) {
                            root.Left.Left = redNode;

                        }
                    } else {
                        var midpt = (((Bridge.Int.div((((startIndex + endIndex) | 0)), 2)) | 0));
                        root = new (System.Collections.Generic.SortedSet$1.Node(T)).$ctor1(arr[System.Array.index(midpt, arr)], false);
                        root.Left = System.Collections.Generic.SortedSet$1(T).ConstructRootFromSortedArray(arr, startIndex, ((midpt - 1) | 0), redNode);
                        if (size % 2 === 0) {
                            root.Right = System.Collections.Generic.SortedSet$1(T).ConstructRootFromSortedArray(arr, ((midpt + 2) | 0), endIndex, new (System.Collections.Generic.SortedSet$1.Node(T)).$ctor1(arr[System.Array.index(((midpt + 1) | 0), arr)], true));
                        } else {
                            root.Right = System.Collections.Generic.SortedSet$1(T).ConstructRootFromSortedArray(arr, ((midpt + 1) | 0), endIndex, null);
                        }
                    }
                    return root;

                },
                log2: function (value) {
                    var c = 0;
                    while (value > 0) {
                        c = (c + 1) | 0;
                        value = value >> 1;
                    }
                    return c;
                }
            }
        },
        fields: {
            root: null,
            comparer: null,
            count: 0,
            version: 0
        },
        props: {
            Count: {
                get: function () {
                    this.VersionCheck();
                    return this.count;
                }
            },
            Comparer: {
                get: function () {
                    return this.comparer;
                }
            },
            System$Collections$Generic$ICollection$1$IsReadOnly: {
                get: function () {
                    return false;
                }
            },
            System$Collections$ICollection$IsSynchronized: {
                get: function () {
                    return false;
                }
            },
            System$Collections$ICollection$SyncRoot: {
                get: function () {
                    return null;
                }
            },
            Min: {
                get: function () {
                    var ret = Bridge.getDefaultValue(T);
                    this.InOrderTreeWalk(function (n) {
                        ret = n.Item;
                        return false;
                    });
                    return ret;
                }
            },
            Max: {
                get: function () {
                    var ret = Bridge.getDefaultValue(T);
                    this.InOrderTreeWalk$1(function (n) {
                        ret = n.Item;
                        return false;
                    }, true);
                    return ret;
                }
            }
        },
        alias: [
            "Count", ["System$Collections$Generic$IReadOnlyCollection$1$" + Bridge.getTypeAlias(T) + "$Count", "System$Collections$Generic$IReadOnlyCollection$1$Count"],
            "Count", "System$Collections$ICollection$Count",
            "Count", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$Count",
            "System$Collections$Generic$ICollection$1$IsReadOnly", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$IsReadOnly",
            "add", "System$Collections$Generic$ISet$1$" + Bridge.getTypeAlias(T) + "$add",
            "System$Collections$Generic$ICollection$1$add", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$add",
            "remove", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$remove",
            "clear", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$clear",
            "contains", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$contains",
            "copyTo", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$copyTo",
            "System$Collections$Generic$IEnumerable$1$GetEnumerator", "System$Collections$Generic$IEnumerable$1$" + Bridge.getTypeAlias(T) + "$GetEnumerator",
            "unionWith", "System$Collections$Generic$ISet$1$" + Bridge.getTypeAlias(T) + "$unionWith",
            "intersectWith", "System$Collections$Generic$ISet$1$" + Bridge.getTypeAlias(T) + "$intersectWith",
            "exceptWith", "System$Collections$Generic$ISet$1$" + Bridge.getTypeAlias(T) + "$exceptWith",
            "symmetricExceptWith", "System$Collections$Generic$ISet$1$" + Bridge.getTypeAlias(T) + "$symmetricExceptWith",
            "isSubsetOf", "System$Collections$Generic$ISet$1$" + Bridge.getTypeAlias(T) + "$isSubsetOf",
            "isProperSubsetOf", "System$Collections$Generic$ISet$1$" + Bridge.getTypeAlias(T) + "$isProperSubsetOf",
            "isSupersetOf", "System$Collections$Generic$ISet$1$" + Bridge.getTypeAlias(T) + "$isSupersetOf",
            "isProperSupersetOf", "System$Collections$Generic$ISet$1$" + Bridge.getTypeAlias(T) + "$isProperSupersetOf",
            "setEquals", "System$Collections$Generic$ISet$1$" + Bridge.getTypeAlias(T) + "$setEquals",
            "overlaps", "System$Collections$Generic$ISet$1$" + Bridge.getTypeAlias(T) + "$overlaps"
        ],
        ctors: {
            ctor: function () {
                this.$initialize();
                this.comparer = new (System.Collections.Generic.Comparer$1(T))(System.Collections.Generic.Comparer$1.$default.fn);

            },
            $ctor1: function (comparer) {
                this.$initialize();
                if (comparer == null) {
                    this.comparer = new (System.Collections.Generic.Comparer$1(T))(System.Collections.Generic.Comparer$1.$default.fn);
                } else {
                    this.comparer = comparer;
                }
            },
            $ctor2: function (collection) {
                System.Collections.Generic.SortedSet$1(T).$ctor3.call(this, collection, new (System.Collections.Generic.Comparer$1(T))(System.Collections.Generic.Comparer$1.$default.fn));
            },
            $ctor3: function (collection, comparer) {
                System.Collections.Generic.SortedSet$1(T).$ctor1.call(this, comparer);

                if (collection == null) {
                    throw new System.ArgumentNullException.$ctor1("collection");
                }

                var baseSortedSet = Bridge.as(collection, System.Collections.Generic.SortedSet$1(T));
                var baseTreeSubSet = Bridge.as(collection, System.Collections.Generic.SortedSet$1.TreeSubSet(T));
                if (baseSortedSet != null && baseTreeSubSet == null && System.Collections.Generic.SortedSet$1(T).AreComparersEqual(this, baseSortedSet)) {
                    if (baseSortedSet.Count === 0) {
                        this.count = 0;
                        this.version = 0;
                        this.root = null;
                        return;
                    }


                    var theirStack = new (System.Collections.Generic.Stack$1(System.Collections.Generic.SortedSet$1.Node(T))).$ctor2(((Bridge.Int.mul(2, System.Collections.Generic.SortedSet$1(T).log2(baseSortedSet.Count)) + 2) | 0));
                    var myStack = new (System.Collections.Generic.Stack$1(System.Collections.Generic.SortedSet$1.Node(T))).$ctor2(((Bridge.Int.mul(2, System.Collections.Generic.SortedSet$1(T).log2(baseSortedSet.Count)) + 2) | 0));
                    var theirCurrent = baseSortedSet.root;
                    var myCurrent = (theirCurrent != null ? new (System.Collections.Generic.SortedSet$1.Node(T)).$ctor1(theirCurrent.Item, theirCurrent.IsRed) : null);
                    this.root = myCurrent;
                    while (theirCurrent != null) {
                        theirStack.Push(theirCurrent);
                        myStack.Push(myCurrent);
                        myCurrent.Left = (theirCurrent.Left != null ? new (System.Collections.Generic.SortedSet$1.Node(T)).$ctor1(theirCurrent.Left.Item, theirCurrent.Left.IsRed) : null);
                        theirCurrent = theirCurrent.Left;
                        myCurrent = myCurrent.Left;
                    }
                    while (theirStack.Count !== 0) {
                        theirCurrent = theirStack.Pop();
                        myCurrent = myStack.Pop();
                        var theirRight = theirCurrent.Right;
                        var myRight = null;
                        if (theirRight != null) {
                            myRight = new (System.Collections.Generic.SortedSet$1.Node(T)).$ctor1(theirRight.Item, theirRight.IsRed);
                        }
                        myCurrent.Right = myRight;

                        while (theirRight != null) {
                            theirStack.Push(theirRight);
                            myStack.Push(myRight);
                            myRight.Left = (theirRight.Left != null ? new (System.Collections.Generic.SortedSet$1.Node(T)).$ctor1(theirRight.Left.Item, theirRight.Left.IsRed) : null);
                            theirRight = theirRight.Left;
                            myRight = myRight.Left;
                        }
                    }
                    this.count = baseSortedSet.count;
                    this.version = 0;
                } else {

                    var els = new (System.Collections.Generic.List$1(T)).$ctor1(collection);
                    els.Sort$1(this.comparer);
                    for (var i = 1; i < els.Count; i = (i + 1) | 0) {
                        if (this.comparer[Bridge.geti(this.comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare", "System$Collections$Generic$IComparer$1$compare")](els.getItem(i), els.getItem(((i - 1) | 0))) === 0) {
                            els.removeAt(i);
                            i = (i - 1) | 0;
                        }
                    }
                    this.root = System.Collections.Generic.SortedSet$1(T).ConstructRootFromSortedArray(els.ToArray(), 0, ((els.Count - 1) | 0), null);
                    this.count = els.Count;
                    this.version = 0;
                }
            }
        },
        methods: {
            AddAllElements: function (collection) {
                var $t;

                $t = Bridge.getEnumerator(collection, T);
                try {
                    while ($t.moveNext()) {
                        var item = $t.Current;
                        if (!this.contains(item)) {
                            this.add(item);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            RemoveAllElements: function (collection) {
                var $t;
                var min = this.Min;
                var max = this.Max;
                $t = Bridge.getEnumerator(collection, T);
                try {
                    while ($t.moveNext()) {
                        var item = $t.Current;
                        if (!(this.comparer[Bridge.geti(this.comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare", "System$Collections$Generic$IComparer$1$compare")](item, min) < 0 || this.comparer[Bridge.geti(this.comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare", "System$Collections$Generic$IComparer$1$compare")](item, max) > 0) && this.contains(item)) {
                            this.remove(item);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            ContainsAllElements: function (collection) {
                var $t;
                $t = Bridge.getEnumerator(collection, T);
                try {
                    while ($t.moveNext()) {
                        var item = $t.Current;
                        if (!this.contains(item)) {
                            return false;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return true;
            },
            InOrderTreeWalk: function (action) {
                return this.InOrderTreeWalk$1(action, false);
            },
            InOrderTreeWalk$1: function (action, reverse) {
                if (this.root == null) {
                    return true;
                }

                var stack = new (System.Collections.Generic.Stack$1(System.Collections.Generic.SortedSet$1.Node(T))).$ctor2(Bridge.Int.mul(2, (System.Collections.Generic.SortedSet$1(T).log2(((this.Count + 1) | 0)))));
                var current = this.root;
                while (current != null) {
                    stack.Push(current);
                    current = (reverse ? current.Right : current.Left);
                }
                while (stack.Count !== 0) {
                    current = stack.Pop();
                    if (!action(current)) {
                        return false;
                    }

                    var node = (reverse ? current.Left : current.Right);
                    while (node != null) {
                        stack.Push(node);
                        node = (reverse ? node.Right : node.Left);
                    }
                }
                return true;
            },
            BreadthFirstTreeWalk: function (action) {
                if (this.root == null) {
                    return true;
                }

                var processQueue = new (System.Collections.Generic.List$1(System.Collections.Generic.SortedSet$1.Node(T))).ctor();
                processQueue.add(this.root);
                var current;

                while (processQueue.Count !== 0) {
                    current = processQueue.getItem(0);
                    processQueue.removeAt(0);
                    if (!action(current)) {
                        return false;
                    }
                    if (current.Left != null) {
                        processQueue.add(current.Left);
                    }
                    if (current.Right != null) {
                        processQueue.add(current.Right);
                    }
                }
                return true;
            },
            VersionCheck: function () { },
            IsWithinRange: function (item) {
                return true;

            },
            add: function (item) {
                return this.AddIfNotPresent(item);
            },
            System$Collections$Generic$ICollection$1$add: function (item) {
                this.AddIfNotPresent(item);
            },
            AddIfNotPresent: function (item) {
                if (this.root == null) {
                    this.root = new (System.Collections.Generic.SortedSet$1.Node(T)).$ctor1(item, false);
                    this.count = 1;
                    this.version = (this.version + 1) | 0;
                    return true;
                }

                var current = this.root;
                var parent = { v : null };
                var grandParent = null;
                var greatGrandParent = null;

                this.version = (this.version + 1) | 0;


                var order = 0;
                while (current != null) {
                    order = this.comparer[Bridge.geti(this.comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare", "System$Collections$Generic$IComparer$1$compare")](item, current.Item);
                    if (order === 0) {
                        this.root.IsRed = false;
                        return false;
                    }

                    if (System.Collections.Generic.SortedSet$1(T).Is4Node(current)) {
                        System.Collections.Generic.SortedSet$1(T).Split4Node(current);
                        if (System.Collections.Generic.SortedSet$1(T).IsRed(parent.v)) {
                            this.InsertionBalance(current, parent, grandParent, greatGrandParent);
                        }
                    }
                    greatGrandParent = grandParent;
                    grandParent = parent.v;
                    parent.v = current;
                    current = (order < 0) ? current.Left : current.Right;
                }

                var node = new (System.Collections.Generic.SortedSet$1.Node(T)).ctor(item);
                if (order > 0) {
                    parent.v.Right = node;
                } else {
                    parent.v.Left = node;
                }

                if (parent.v.IsRed) {
                    this.InsertionBalance(node, parent, grandParent, greatGrandParent);
                }

                this.root.IsRed = false;
                this.count = (this.count + 1) | 0;
                return true;
            },
            remove: function (item) {
                return this.DoRemove(item);
            },
            DoRemove: function (item) {

                if (this.root == null) {
                    return false;
                }



                this.version = (this.version + 1) | 0;

                var current = this.root;
                var parent = null;
                var grandParent = null;
                var match = null;
                var parentOfMatch = null;
                var foundMatch = false;
                while (current != null) {
                    if (System.Collections.Generic.SortedSet$1(T).Is2Node(current)) {
                        if (parent == null) {
                            current.IsRed = true;
                        } else {
                            var sibling = System.Collections.Generic.SortedSet$1(T).GetSibling(current, parent);
                            if (sibling.IsRed) {
                                if (Bridge.referenceEquals(parent.Right, sibling)) {
                                    System.Collections.Generic.SortedSet$1(T).RotateLeft(parent);
                                } else {
                                    System.Collections.Generic.SortedSet$1(T).RotateRight(parent);
                                }

                                parent.IsRed = true;
                                sibling.IsRed = false;
                                this.ReplaceChildOfNodeOrRoot(grandParent, parent, sibling);
                                grandParent = sibling;
                                if (Bridge.referenceEquals(parent, match)) {
                                    parentOfMatch = sibling;
                                }

                                sibling = (Bridge.referenceEquals(parent.Left, current)) ? parent.Right : parent.Left;
                            }

                            if (System.Collections.Generic.SortedSet$1(T).Is2Node(sibling)) {
                                System.Collections.Generic.SortedSet$1(T).Merge2Nodes(parent, current, sibling);
                            } else {
                                var rotation = System.Collections.Generic.SortedSet$1(T).RotationNeeded(parent, current, sibling);
                                var newGrandParent = null;
                                switch (rotation) {
                                    case System.Collections.Generic.TreeRotation.RightRotation: 
                                        sibling.Left.IsRed = false;
                                        newGrandParent = System.Collections.Generic.SortedSet$1(T).RotateRight(parent);
                                        break;
                                    case System.Collections.Generic.TreeRotation.LeftRotation: 
                                        sibling.Right.IsRed = false;
                                        newGrandParent = System.Collections.Generic.SortedSet$1(T).RotateLeft(parent);
                                        break;
                                    case System.Collections.Generic.TreeRotation.RightLeftRotation: 
                                        newGrandParent = System.Collections.Generic.SortedSet$1(T).RotateRightLeft(parent);
                                        break;
                                    case System.Collections.Generic.TreeRotation.LeftRightRotation: 
                                        newGrandParent = System.Collections.Generic.SortedSet$1(T).RotateLeftRight(parent);
                                        break;
                                }

                                newGrandParent.IsRed = parent.IsRed;
                                parent.IsRed = false;
                                current.IsRed = true;
                                this.ReplaceChildOfNodeOrRoot(grandParent, parent, newGrandParent);
                                if (Bridge.referenceEquals(parent, match)) {
                                    parentOfMatch = newGrandParent;
                                }
                                grandParent = newGrandParent;
                            }
                        }
                    }

                    var order = foundMatch ? -1 : this.comparer[Bridge.geti(this.comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare", "System$Collections$Generic$IComparer$1$compare")](item, current.Item);
                    if (order === 0) {
                        foundMatch = true;
                        match = current;
                        parentOfMatch = parent;
                    }

                    grandParent = parent;
                    parent = current;

                    if (order < 0) {
                        current = current.Left;
                    } else {
                        current = current.Right;
                    }
                }

                if (match != null) {
                    this.ReplaceNode(match, parentOfMatch, parent, grandParent);
                    this.count = (this.count - 1) | 0;
                }

                if (this.root != null) {
                    this.root.IsRed = false;
                }
                return foundMatch;
            },
            clear: function () {
                this.root = null;
                this.count = 0;
                this.version = (this.version + 1) | 0;
            },
            contains: function (item) {

                return this.FindNode(item) != null;
            },
            CopyTo: function (array) {
                this.CopyTo$1(array, 0, this.Count);
            },
            copyTo: function (array, index) {
                this.CopyTo$1(array, index, this.Count);
            },
            CopyTo$1: function (array, index, count) {
                if (array == null) {
                    System.ThrowHelper.ThrowArgumentNullException(System.ExceptionArgument.array);
                }

                if (index < 0) {
                    System.ThrowHelper.ThrowArgumentOutOfRangeException$1(System.ExceptionArgument.index);
                }

                if (count < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("count");
                }

                if (index > array.length || count > ((array.length - index) | 0)) {
                    throw new System.ArgumentException.ctor();
                }
                count = (count + index) | 0;

                this.InOrderTreeWalk(function (node) {
                    if (index >= count) {
                        return false;
                    } else {
                        array[System.Array.index(Bridge.identity(index, (index = (index + 1) | 0)), array)] = node.Item;
                        return true;
                    }
                });
            },
            System$Collections$ICollection$copyTo: function (array, index) {
                if (array == null) {
                    System.ThrowHelper.ThrowArgumentNullException(System.ExceptionArgument.array);
                }

                if (System.Array.getRank(array) !== 1) {
                    System.ThrowHelper.ThrowArgumentException(System.ExceptionResource.Arg_RankMultiDimNotSupported);
                }

                if (System.Array.getLower(array, 0) !== 0) {
                    System.ThrowHelper.ThrowArgumentException(System.ExceptionResource.Arg_NonZeroLowerBound);
                }

                if (index < 0) {
                    System.ThrowHelper.ThrowArgumentOutOfRangeException$2(System.ExceptionArgument.arrayIndex, System.ExceptionResource.ArgumentOutOfRange_NeedNonNegNum);
                }

                if (((array.length - index) | 0) < this.Count) {
                    System.ThrowHelper.ThrowArgumentException(System.ExceptionResource.Arg_ArrayPlusOffTooSmall);
                }

                var tarray = Bridge.as(array, System.Array.type(T));
                if (tarray != null) {
                    this.copyTo(tarray, index);
                } else {
                    var objects = Bridge.as(array, System.Array.type(System.Object));
                    if (objects == null) {
                        System.ThrowHelper.ThrowArgumentException(System.ExceptionResource.Argument_InvalidArrayType);
                    }

                    try {
                        this.InOrderTreeWalk(function (node) {
                            objects[System.Array.index(Bridge.identity(index, (index = (index + 1) | 0)), objects)] = node.Item;
                            return true;
                        });
                    } catch ($e1) {
                        $e1 = System.Exception.create($e1);
                        if (Bridge.is($e1, System.ArrayTypeMismatchException)) {
                            System.ThrowHelper.ThrowArgumentException(System.ExceptionResource.Argument_InvalidArrayType);
                        } else {
                            throw $e1;
                        }
                    }
                }
            },
            GetEnumerator: function () {
                return new (System.Collections.Generic.SortedSet$1.Enumerator(T)).$ctor1(this);
            },
            System$Collections$Generic$IEnumerable$1$GetEnumerator: function () {
                return new (System.Collections.Generic.SortedSet$1.Enumerator(T)).$ctor1(this).$clone();
            },
            System$Collections$IEnumerable$GetEnumerator: function () {
                return new (System.Collections.Generic.SortedSet$1.Enumerator(T)).$ctor1(this).$clone();
            },
            InsertionBalance: function (current, parent, grandParent, greatGrandParent) {
                var parentIsOnRight = (Bridge.referenceEquals(grandParent.Right, parent.v));
                var currentIsOnRight = (Bridge.referenceEquals(parent.v.Right, current));

                var newChildOfGreatGrandParent;
                if (parentIsOnRight === currentIsOnRight) {
                    newChildOfGreatGrandParent = currentIsOnRight ? System.Collections.Generic.SortedSet$1(T).RotateLeft(grandParent) : System.Collections.Generic.SortedSet$1(T).RotateRight(grandParent);
                } else {
                    newChildOfGreatGrandParent = currentIsOnRight ? System.Collections.Generic.SortedSet$1(T).RotateLeftRight(grandParent) : System.Collections.Generic.SortedSet$1(T).RotateRightLeft(grandParent);
                    parent.v = greatGrandParent;
                }
                grandParent.IsRed = true;
                newChildOfGreatGrandParent.IsRed = false;

                this.ReplaceChildOfNodeOrRoot(greatGrandParent, grandParent, newChildOfGreatGrandParent);
            },
            ReplaceChildOfNodeOrRoot: function (parent, child, newChild) {
                if (parent != null) {
                    if (Bridge.referenceEquals(parent.Left, child)) {
                        parent.Left = newChild;
                    } else {
                        parent.Right = newChild;
                    }
                } else {
                    this.root = newChild;
                }
            },
            ReplaceNode: function (match, parentOfMatch, succesor, parentOfSuccesor) {
                if (Bridge.referenceEquals(succesor, match)) {
                    succesor = match.Left;
                } else {
                    if (succesor.Right != null) {
                        succesor.Right.IsRed = false;
                    }

                    if (!Bridge.referenceEquals(parentOfSuccesor, match)) {
                        parentOfSuccesor.Left = succesor.Right;
                        succesor.Right = match.Right;
                    }

                    succesor.Left = match.Left;
                }

                if (succesor != null) {
                    succesor.IsRed = match.IsRed;
                }

                this.ReplaceChildOfNodeOrRoot(parentOfMatch, match, succesor);

            },
            FindNode: function (item) {
                var current = this.root;
                while (current != null) {
                    var order = this.comparer[Bridge.geti(this.comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare", "System$Collections$Generic$IComparer$1$compare")](item, current.Item);
                    if (order === 0) {
                        return current;
                    } else {
                        current = (order < 0) ? current.Left : current.Right;
                    }
                }

                return null;
            },
            InternalIndexOf: function (item) {
                var current = this.root;
                var count = 0;
                while (current != null) {
                    var order = this.comparer[Bridge.geti(this.comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare", "System$Collections$Generic$IComparer$1$compare")](item, current.Item);
                    if (order === 0) {
                        return count;
                    } else {
                        current = (order < 0) ? current.Left : current.Right;
                        count = (order < 0) ? (((Bridge.Int.mul(2, count) + 1) | 0)) : (((Bridge.Int.mul(2, count) + 2) | 0));
                    }
                }
                return -1;
            },
            FindRange: function (from, to) {
                return this.FindRange$1(from, to, true, true);
            },
            FindRange$1: function (from, to, lowerBoundActive, upperBoundActive) {
                var current = this.root;
                while (current != null) {
                    if (lowerBoundActive && this.comparer[Bridge.geti(this.comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare", "System$Collections$Generic$IComparer$1$compare")](from, current.Item) > 0) {
                        current = current.Right;
                    } else {
                        if (upperBoundActive && this.comparer[Bridge.geti(this.comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare", "System$Collections$Generic$IComparer$1$compare")](to, current.Item) < 0) {
                            current = current.Left;
                        } else {
                            return current;
                        }
                    }
                }

                return null;
            },
            UpdateVersion: function () {
                this.version = (this.version + 1) | 0;
            },
            ToArray: function () {
                var newArray = System.Array.init(this.Count, function (){
                    return Bridge.getDefaultValue(T);
                }, T);
                this.CopyTo(newArray);
                return newArray;
            },
            unionWith: function (other) {
                if (other == null) {
                    throw new System.ArgumentNullException.$ctor1("other");
                }

                var s = Bridge.as(other, System.Collections.Generic.SortedSet$1(T));
                var t = Bridge.as(this, System.Collections.Generic.SortedSet$1.TreeSubSet(T));

                if (t != null) {
                    this.VersionCheck();
                }

                if (s != null && t == null && this.count === 0) {
                    var dummy = new (System.Collections.Generic.SortedSet$1(T)).$ctor3(s, this.comparer);
                    this.root = dummy.root;
                    this.count = dummy.count;
                    this.version = (this.version + 1) | 0;
                    return;
                }


                if (s != null && t == null && System.Collections.Generic.SortedSet$1(T).AreComparersEqual(this, s) && (s.Count > ((Bridge.Int.div(this.Count, 2)) | 0))) {
                    var merged = System.Array.init(((s.Count + this.Count) | 0), function (){
                        return Bridge.getDefaultValue(T);
                    }, T);
                    var c = 0;
                    var mine = this.GetEnumerator();
                    var theirs = s.GetEnumerator();
                    var mineEnded = !mine.moveNext(), theirsEnded = !theirs.moveNext();
                    while (!mineEnded && !theirsEnded) {
                        var comp = this.Comparer[Bridge.geti(this.Comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare", "System$Collections$Generic$IComparer$1$compare")](mine.Current, theirs.Current);
                        if (comp < 0) {
                            merged[System.Array.index(Bridge.identity(c, (c = (c + 1) | 0)), merged)] = mine.Current;
                            mineEnded = !mine.moveNext();
                        } else if (comp === 0) {
                            merged[System.Array.index(Bridge.identity(c, (c = (c + 1) | 0)), merged)] = theirs.Current;
                            mineEnded = !mine.moveNext();
                            theirsEnded = !theirs.moveNext();
                        } else {
                            merged[System.Array.index(Bridge.identity(c, (c = (c + 1) | 0)), merged)] = theirs.Current;
                            theirsEnded = !theirs.moveNext();
                        }
                    }

                    if (!mineEnded || !theirsEnded) {
                        var remaining = (mineEnded ? theirs : mine);
                        do {
                            merged[System.Array.index(Bridge.identity(c, (c = (c + 1) | 0)), merged)] = remaining.Current;
                        } while (remaining.moveNext());
                    }


                    this.root = null;


                    this.root = System.Collections.Generic.SortedSet$1(T).ConstructRootFromSortedArray(merged, 0, ((c - 1) | 0), null);
                    this.count = c;
                    this.version = (this.version + 1) | 0;
                } else {
                    this.AddAllElements(other);
                }
            },
            intersectWith: function (other) {
                if (other == null) {
                    throw new System.ArgumentNullException.$ctor1("other");
                }

                if (this.Count === 0) {
                    return;
                }


                var s = Bridge.as(other, System.Collections.Generic.SortedSet$1(T));
                var t = Bridge.as(this, System.Collections.Generic.SortedSet$1.TreeSubSet(T));
                if (t != null) {
                    this.VersionCheck();
                }
                if (s != null && t == null && System.Collections.Generic.SortedSet$1(T).AreComparersEqual(this, s)) {


                    var merged = System.Array.init(this.Count, function (){
                        return Bridge.getDefaultValue(T);
                    }, T);
                    var c = 0;
                    var mine = this.GetEnumerator();
                    var theirs = s.GetEnumerator();
                    var mineEnded = !mine.moveNext(), theirsEnded = !theirs.moveNext();
                    var max = this.Max;
                    var min = this.Min;

                    while (!mineEnded && !theirsEnded && this.Comparer[Bridge.geti(this.Comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare", "System$Collections$Generic$IComparer$1$compare")](theirs.Current, max) <= 0) {
                        var comp = this.Comparer[Bridge.geti(this.Comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare", "System$Collections$Generic$IComparer$1$compare")](mine.Current, theirs.Current);
                        if (comp < 0) {
                            mineEnded = !mine.moveNext();
                        } else if (comp === 0) {
                            merged[System.Array.index(Bridge.identity(c, (c = (c + 1) | 0)), merged)] = theirs.Current;
                            mineEnded = !mine.moveNext();
                            theirsEnded = !theirs.moveNext();
                        } else {
                            theirsEnded = !theirs.moveNext();
                        }
                    }


                    this.root = null;

                    this.root = System.Collections.Generic.SortedSet$1(T).ConstructRootFromSortedArray(merged, 0, ((c - 1) | 0), null);
                    this.count = c;
                    this.version = (this.version + 1) | 0;
                } else {
                    this.IntersectWithEnumerable(other);
                }
            },
            IntersectWithEnumerable: function (other) {
                var $t;
                var toSave = new (System.Collections.Generic.List$1(T)).$ctor2(this.Count);
                $t = Bridge.getEnumerator(other, T);
                try {
                    while ($t.moveNext()) {
                        var item = $t.Current;
                        if (this.contains(item)) {
                            toSave.add(item);
                            this.remove(item);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.clear();
                this.AddAllElements(toSave);

            },
            exceptWith: function (other) {
                var $t;
                if (other == null) {
                    throw new System.ArgumentNullException.$ctor1("other");
                }

                if (this.count === 0) {
                    return;
                }

                if (Bridge.referenceEquals(other, this)) {
                    this.clear();
                    return;
                }

                var asSorted = Bridge.as(other, System.Collections.Generic.SortedSet$1(T));

                if (asSorted != null && System.Collections.Generic.SortedSet$1(T).AreComparersEqual(this, asSorted)) {
                    if (!(this.comparer[Bridge.geti(this.comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare", "System$Collections$Generic$IComparer$1$compare")](asSorted.Max, this.Min) < 0 || this.comparer[Bridge.geti(this.comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare", "System$Collections$Generic$IComparer$1$compare")](asSorted.Min, this.Max) > 0)) {
                        var min = this.Min;
                        var max = this.Max;
                        $t = Bridge.getEnumerator(other, T);
                        try {
                            while ($t.moveNext()) {
                                var item = $t.Current;
                                if (this.comparer[Bridge.geti(this.comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare", "System$Collections$Generic$IComparer$1$compare")](item, min) < 0) {
                                    continue;
                                }
                                if (this.comparer[Bridge.geti(this.comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare", "System$Collections$Generic$IComparer$1$compare")](item, max) > 0) {
                                    break;
                                }
                                this.remove(item);
                            }
                        } finally {
                            if (Bridge.is($t, System.IDisposable)) {
                                $t.System$IDisposable$Dispose();
                            }
                        }
                    }

                } else {
                    this.RemoveAllElements(other);
                }
            },
            symmetricExceptWith: function (other) {
                if (other == null) {
                    throw new System.ArgumentNullException.$ctor1("other");
                }

                if (this.Count === 0) {
                    this.unionWith(other);
                    return;
                }

                if (Bridge.referenceEquals(other, this)) {
                    this.clear();
                    return;
                }


                var asSorted = Bridge.as(other, System.Collections.Generic.SortedSet$1(T));
                var asHash = Bridge.as(other, System.Collections.Generic.HashSet$1(T));

                if (asSorted != null && System.Collections.Generic.SortedSet$1(T).AreComparersEqual(this, asSorted)) {
                    this.SymmetricExceptWithSameEC$1(asSorted);
                } else if (asHash != null && Bridge.equals(this.comparer, new (System.Collections.Generic.Comparer$1(T))(System.Collections.Generic.Comparer$1.$default.fn)) && Bridge.equals(asHash.Comparer, System.Collections.Generic.EqualityComparer$1(T).def)) {
                    this.SymmetricExceptWithSameEC$1(asHash);
                } else {
                    var elements = (new (System.Collections.Generic.List$1(T)).$ctor1(other)).ToArray();
                    System.Array.sort(elements, this.Comparer);
                    this.SymmetricExceptWithSameEC(elements);
                }
            },
            SymmetricExceptWithSameEC$1: function (other) {
                var $t;
                $t = Bridge.getEnumerator(other, T);
                try {
                    while ($t.moveNext()) {
                        var item = $t.Current;
                        if (this.contains(item)) {
                            this.remove(item);
                        } else {
                            this.add(item);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            SymmetricExceptWithSameEC: function (other) {
                if (other.length === 0) {
                    return;
                }
                var last = other[System.Array.index(0, other)];
                for (var i = 0; i < other.length; i = (i + 1) | 0) {
                    while (i < other.length && i !== 0 && this.comparer[Bridge.geti(this.comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare", "System$Collections$Generic$IComparer$1$compare")](other[System.Array.index(i, other)], last) === 0) {
                        i = (i + 1) | 0;
                    }
                    if (i >= other.length) {
                        break;
                    }
                    if (this.contains(other[System.Array.index(i, other)])) {
                        this.remove(other[System.Array.index(i, other)]);
                    } else {
                        this.add(other[System.Array.index(i, other)]);
                    }
                    last = other[System.Array.index(i, other)];
                }
            },
            isSubsetOf: function (other) {
                if (other == null) {
                    throw new System.ArgumentNullException.$ctor1("other");
                }

                if (this.Count === 0) {
                    return true;
                }


                var asSorted = Bridge.as(other, System.Collections.Generic.SortedSet$1(T));
                if (asSorted != null && System.Collections.Generic.SortedSet$1(T).AreComparersEqual(this, asSorted)) {
                    if (this.Count > asSorted.Count) {
                        return false;
                    }
                    return this.IsSubsetOfSortedSetWithSameEC(asSorted);
                } else {

                    var result = this.CheckUniqueAndUnfoundElements(other, false);
                    return (result.uniqueCount === this.Count && result.unfoundCount >= 0);
                }
            },
            IsSubsetOfSortedSetWithSameEC: function (asSorted) {
                var $t;
                var prunedOther = asSorted.GetViewBetween(this.Min, this.Max);
                $t = Bridge.getEnumerator(this);
                try {
                    while ($t.moveNext()) {
                        var item = $t.Current;
                        if (!prunedOther.contains(item)) {
                            return false;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return true;

            },
            isProperSubsetOf: function (other) {
                if (other == null) {
                    throw new System.ArgumentNullException.$ctor1("other");
                }

                if ((Bridge.as(other, System.Collections.ICollection)) != null) {
                    if (this.Count === 0) {
                        return System.Array.getCount((Bridge.as(other, System.Collections.ICollection))) > 0;
                    }
                }



                var asHash = Bridge.as(other, System.Collections.Generic.HashSet$1(T));
                if (asHash != null && Bridge.equals(this.comparer, new (System.Collections.Generic.Comparer$1(T))(System.Collections.Generic.Comparer$1.$default.fn)) && Bridge.equals(asHash.Comparer, System.Collections.Generic.EqualityComparer$1(T).def)) {
                    return asHash.isProperSupersetOf(this);
                }

                var asSorted = Bridge.as(other, System.Collections.Generic.SortedSet$1(T));
                if (asSorted != null && System.Collections.Generic.SortedSet$1(T).AreComparersEqual(this, asSorted)) {
                    if (this.Count >= asSorted.Count) {
                        return false;
                    }
                    return this.IsSubsetOfSortedSetWithSameEC(asSorted);
                }


                var result = this.CheckUniqueAndUnfoundElements(other, false);
                return (result.uniqueCount === this.Count && result.unfoundCount > 0);
            },
            isSupersetOf: function (other) {
                var $t;
                if (other == null) {
                    throw new System.ArgumentNullException.$ctor1("other");
                }

                if ((Bridge.as(other, System.Collections.ICollection)) != null && System.Array.getCount((Bridge.as(other, System.Collections.ICollection))) === 0) {
                    return true;
                }


                var asHash = Bridge.as(other, System.Collections.Generic.HashSet$1(T));
                if (asHash != null && Bridge.equals(this.comparer, new (System.Collections.Generic.Comparer$1(T))(System.Collections.Generic.Comparer$1.$default.fn)) && Bridge.equals(asHash.Comparer, System.Collections.Generic.EqualityComparer$1(T).def)) {
                    return asHash.isSubsetOf(this);
                }

                var asSorted = Bridge.as(other, System.Collections.Generic.SortedSet$1(T));
                if (asSorted != null && System.Collections.Generic.SortedSet$1(T).AreComparersEqual(this, asSorted)) {
                    if (this.Count < asSorted.Count) {
                        return false;
                    }
                    var pruned = this.GetViewBetween(asSorted.Min, asSorted.Max);
                    $t = Bridge.getEnumerator(asSorted);
                    try {
                        while ($t.moveNext()) {
                            var item = $t.Current;
                            if (!pruned.contains(item)) {
                                return false;
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return true;
                }
                return this.ContainsAllElements(other);
            },
            isProperSupersetOf: function (other) {
                var $t;
                if (other == null) {
                    throw new System.ArgumentNullException.$ctor1("other");
                }

                if (this.Count === 0) {
                    return false;
                }

                if ((Bridge.as(other, System.Collections.ICollection)) != null && System.Array.getCount((Bridge.as(other, System.Collections.ICollection))) === 0) {
                    return true;
                }



                var asHash = Bridge.as(other, System.Collections.Generic.HashSet$1(T));
                if (asHash != null && Bridge.equals(this.comparer, new (System.Collections.Generic.Comparer$1(T))(System.Collections.Generic.Comparer$1.$default.fn)) && Bridge.equals(asHash.Comparer, System.Collections.Generic.EqualityComparer$1(T).def)) {
                    return asHash.isProperSubsetOf(this);
                }

                var asSorted = Bridge.as(other, System.Collections.Generic.SortedSet$1(T));
                if (asSorted != null && System.Collections.Generic.SortedSet$1(T).AreComparersEqual(asSorted, this)) {
                    if (asSorted.Count >= this.Count) {
                        return false;
                    }
                    var pruned = this.GetViewBetween(asSorted.Min, asSorted.Max);
                    $t = Bridge.getEnumerator(asSorted);
                    try {
                        while ($t.moveNext()) {
                            var item = $t.Current;
                            if (!pruned.contains(item)) {
                                return false;
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return true;
                }


                var result = this.CheckUniqueAndUnfoundElements(other, true);
                return (result.uniqueCount < this.Count && result.unfoundCount === 0);
            },
            setEquals: function (other) {
                if (other == null) {
                    throw new System.ArgumentNullException.$ctor1("other");
                }

                var asHash = Bridge.as(other, System.Collections.Generic.HashSet$1(T));
                if (asHash != null && Bridge.equals(this.comparer, new (System.Collections.Generic.Comparer$1(T))(System.Collections.Generic.Comparer$1.$default.fn)) && Bridge.equals(asHash.Comparer, System.Collections.Generic.EqualityComparer$1(T).def)) {
                    return asHash.setEquals(this);
                }

                var asSorted = Bridge.as(other, System.Collections.Generic.SortedSet$1(T));
                if (asSorted != null && System.Collections.Generic.SortedSet$1(T).AreComparersEqual(this, asSorted)) {
                    var mine = this.GetEnumerator().$clone();
                    var theirs = asSorted.GetEnumerator().$clone();
                    var mineEnded = !mine.System$Collections$IEnumerator$moveNext();
                    var theirsEnded = !theirs.System$Collections$IEnumerator$moveNext();
                    while (!mineEnded && !theirsEnded) {
                        if (this.Comparer[Bridge.geti(this.Comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare", "System$Collections$Generic$IComparer$1$compare")](mine[Bridge.geti(mine, "System$Collections$Generic$IEnumerator$1$" + Bridge.getTypeAlias(T) + "$Current$1", "System$Collections$Generic$IEnumerator$1$Current$1")], theirs[Bridge.geti(theirs, "System$Collections$Generic$IEnumerator$1$" + Bridge.getTypeAlias(T) + "$Current$1", "System$Collections$Generic$IEnumerator$1$Current$1")]) !== 0) {
                            return false;
                        }
                        mineEnded = !mine.System$Collections$IEnumerator$moveNext();
                        theirsEnded = !theirs.System$Collections$IEnumerator$moveNext();
                    }
                    return mineEnded && theirsEnded;
                }

                var result = this.CheckUniqueAndUnfoundElements(other, true);
                return (result.uniqueCount === this.Count && result.unfoundCount === 0);
            },
            overlaps: function (other) {
                var $t;
                if (other == null) {
                    throw new System.ArgumentNullException.$ctor1("other");
                }

                if (this.Count === 0) {
                    return false;
                }

                if ((Bridge.as(other, System.Collections.Generic.ICollection$1(T)) != null) && System.Array.getCount((Bridge.as(other, System.Collections.Generic.ICollection$1(T))), T) === 0) {
                    return false;
                }

                var asSorted = Bridge.as(other, System.Collections.Generic.SortedSet$1(T));
                if (asSorted != null && System.Collections.Generic.SortedSet$1(T).AreComparersEqual(this, asSorted) && (this.comparer[Bridge.geti(this.comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare", "System$Collections$Generic$IComparer$1$compare")](this.Min, asSorted.Max) > 0 || this.comparer[Bridge.geti(this.comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare", "System$Collections$Generic$IComparer$1$compare")](this.Max, asSorted.Min) < 0)) {
                    return false;
                }

                var asHash = Bridge.as(other, System.Collections.Generic.HashSet$1(T));
                if (asHash != null && Bridge.equals(this.comparer, new (System.Collections.Generic.Comparer$1(T))(System.Collections.Generic.Comparer$1.$default.fn)) && Bridge.equals(asHash.Comparer, System.Collections.Generic.EqualityComparer$1(T).def)) {
                    return asHash.overlaps(this);
                }

                $t = Bridge.getEnumerator(other, T);
                try {
                    while ($t.moveNext()) {
                        var item = $t.Current;
                        if (this.contains(item)) {
                            return true;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return false;
            },
            CheckUniqueAndUnfoundElements: function (other, returnIfUnfound) {
                var $t, $t1;
                var result = new (System.Collections.Generic.SortedSet$1.ElementCount(T))();

                if (this.Count === 0) {
                    var numElementsInOther = 0;
                    $t = Bridge.getEnumerator(other, T);
                    try {
                        while ($t.moveNext()) {
                            var item = $t.Current;
                            numElementsInOther = (numElementsInOther + 1) | 0;
                            break;
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    result.uniqueCount = 0;
                    result.unfoundCount = numElementsInOther;
                    return result.$clone();
                }


                var originalLastIndex = this.Count;
                var intArrayLength = System.Collections.Generic.BitHelper.ToIntArrayLength(originalLastIndex);

                var bitHelper;
                var bitArray = System.Array.init(intArrayLength, 0, System.Int32);
                bitHelper = new System.Collections.Generic.BitHelper(bitArray, intArrayLength);

                var unfoundCount = 0;
                var uniqueFoundCount = 0;

                $t1 = Bridge.getEnumerator(other, T);
                try {
                    while ($t1.moveNext()) {
                        var item1 = $t1.Current;
                        var index = this.InternalIndexOf(item1);
                        if (index >= 0) {
                            if (!bitHelper.IsMarked(index)) {
                                bitHelper.MarkBit(index);
                                uniqueFoundCount = (uniqueFoundCount + 1) | 0;
                            }
                        } else {
                            unfoundCount = (unfoundCount + 1) | 0;
                            if (returnIfUnfound) {
                                break;
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }

                result.uniqueCount = uniqueFoundCount;
                result.unfoundCount = unfoundCount;
                return result.$clone();
            },
            RemoveWhere: function (match) {
                if (Bridge.staticEquals(match, null)) {
                    throw new System.ArgumentNullException.$ctor1("match");
                }
                var matches = new (System.Collections.Generic.List$1(T)).$ctor2(this.Count);

                this.BreadthFirstTreeWalk(function (n) {
                    if (match(n.Item)) {
                        matches.add(n.Item);
                    }
                    return true;
                });
                var actuallyRemoved = 0;
                for (var i = (matches.Count - 1) | 0; i >= 0; i = (i - 1) | 0) {
                    if (this.remove(matches.getItem(i))) {
                        actuallyRemoved = (actuallyRemoved + 1) | 0;
                    }
                }

                return actuallyRemoved;

            },
            Reverse: function () {
                return new (Bridge.GeneratorEnumerable$1(T))(Bridge.fn.bind(this, function ()  {
                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        e,
                        $async_e;

                    var $enumerator = new (Bridge.GeneratorEnumerator$1(T))(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        e = new (System.Collections.Generic.SortedSet$1.Enumerator(T)).$ctor2(this, true);
                                        $step = 1;
                                        continue;
                                    }
                                    case 1: {
                                        if ( e.moveNext() ) {
                                                $step = 2;
                                                continue;
                                            } 
                                            $step = 4;
                                            continue;
                                    }
                                    case 2: {
                                        $enumerator.current = e.Current;
                                            $step = 3;
                                            return true;
                                    }
                                    case 3: {
                                        
                                            $step = 1;
                                            continue;
                                    }
                                    case 4: {

                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                }));
            },
            GetViewBetween: function (lowerValue, upperValue) {
                if (this.Comparer[Bridge.geti(this.Comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare", "System$Collections$Generic$IComparer$1$compare")](lowerValue, upperValue) > 0) {
                    throw new System.ArgumentException.$ctor1("lowerBound is greater than upperBound");
                }
                return new (System.Collections.Generic.SortedSet$1.TreeSubSet(T)).$ctor1(this, lowerValue, upperValue, true, true);
            },
            TryGetValue: function (equalValue, actualValue) {
                var node = this.FindNode(equalValue);
                if (node != null) {
                    actualValue.v = node.Item;
                    return true;
                }
                actualValue.v = Bridge.getDefaultValue(T);
                return false;
            }
        }
    }; });

    // @source SortedSetEqualityComparer.js

    Bridge.define("System.Collections.Generic.SortedSetEqualityComparer$1", function (T) { return {
        inherits: [System.Collections.Generic.IEqualityComparer$1(System.Collections.Generic.SortedSet$1(T))],
        fields: {
            comparer: null,
            e_comparer: null
        },
        alias: [
            "equals2", ["System$Collections$Generic$IEqualityComparer$1$System$Collections$Generic$SortedSet$1$" + Bridge.getTypeAlias(T) + "$equals2", "System$Collections$Generic$IEqualityComparer$1$equals2"],
            "getHashCode2", ["System$Collections$Generic$IEqualityComparer$1$System$Collections$Generic$SortedSet$1$" + Bridge.getTypeAlias(T) + "$getHashCode2", "System$Collections$Generic$IEqualityComparer$1$getHashCode2"]
        ],
        ctors: {
            ctor: function () {
                System.Collections.Generic.SortedSetEqualityComparer$1(T).$ctor2.call(this, null, null);
            },
            $ctor1: function (comparer) {
                System.Collections.Generic.SortedSetEqualityComparer$1(T).$ctor2.call(this, comparer, null);
            },
            $ctor3: function (memberEqualityComparer) {
                System.Collections.Generic.SortedSetEqualityComparer$1(T).$ctor2.call(this, null, memberEqualityComparer);
            },
            $ctor2: function (comparer, memberEqualityComparer) {
                this.$initialize();
                if (comparer == null) {
                    this.comparer = new (System.Collections.Generic.Comparer$1(T))(System.Collections.Generic.Comparer$1.$default.fn);
                } else {
                    this.comparer = comparer;
                }
                if (memberEqualityComparer == null) {
                    this.e_comparer = System.Collections.Generic.EqualityComparer$1(T).def;
                } else {
                    this.e_comparer = memberEqualityComparer;
                }
            }
        },
        methods: {
            equals2: function (x, y) {
                return System.Collections.Generic.SortedSet$1(T).SortedSetEquals(x, y, this.comparer);
            },
            equals: function (obj) {
                var comparer = Bridge.as(obj, System.Collections.Generic.SortedSetEqualityComparer$1(T));
                if (comparer == null) {
                    return false;
                }
                return (Bridge.referenceEquals(this.comparer, comparer.comparer));
            },
            getHashCode2: function (obj) {
                var $t;
                var hashCode = 0;
                if (obj != null) {
                    $t = Bridge.getEnumerator(obj);
                    try {
                        while ($t.moveNext()) {
                            var t = $t.Current;
                            hashCode = hashCode ^ (this.e_comparer[Bridge.geti(this.e_comparer, "System$Collections$Generic$IEqualityComparer$1$" + Bridge.getTypeAlias(T) + "$getHashCode2", "System$Collections$Generic$IEqualityComparer$1$getHashCode2")](t) & 2147483647);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }
                return hashCode;
            },
            getHashCode: function () {
                return Bridge.getHashCode(this.comparer) ^ Bridge.getHashCode(this.e_comparer);
            }
        }
    }; });

    // @source ElementCount.js

    Bridge.define("System.Collections.Generic.SortedSet$1.ElementCount", function (T) { return {
        $kind: "nested struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new (System.Collections.Generic.SortedSet$1.ElementCount(T))(); }
            }
        },
        fields: {
            uniqueCount: 0,
            unfoundCount: 0
        },
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
                var h = Bridge.addHash([4920463385, this.uniqueCount, this.unfoundCount]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, System.Collections.Generic.SortedSet$1.ElementCount(T))) {
                    return false;
                }
                return Bridge.equals(this.uniqueCount, o.uniqueCount) && Bridge.equals(this.unfoundCount, o.unfoundCount);
            },
            $clone: function (to) {
                var s = to || new (System.Collections.Generic.SortedSet$1.ElementCount(T))();
                s.uniqueCount = this.uniqueCount;
                s.unfoundCount = this.unfoundCount;
                return s;
            }
        }
    }; });

    // @source Enumerator.js

    Bridge.define("System.Collections.Generic.SortedSet$1.Enumerator", function (T) { return {
        inherits: [System.Collections.Generic.IEnumerator$1(T),System.Collections.IEnumerator],
        $kind: "nested struct",
        statics: {
            fields: {
                dummyNode: null
            },
            ctors: {
                init: function () {
                    this.dummyNode = new (System.Collections.Generic.SortedSet$1.Node(T)).ctor(Bridge.getDefaultValue(T));
                }
            },
            methods: {
                getDefaultValue: function () { return new (System.Collections.Generic.SortedSet$1.Enumerator(T))(); }
            }
        },
        fields: {
            tree: null,
            version: 0,
            stack: null,
            current: null,
            reverse: false
        },
        props: {
            Current: {
                get: function () {
                    if (this.current != null) {
                        return this.current.Item;
                    }
                    return Bridge.getDefaultValue(T);
                }
            },
            System$Collections$IEnumerator$Current: {
                get: function () {
                    if (this.current == null) {
                        System.ThrowHelper.ThrowInvalidOperationException(System.ExceptionResource.InvalidOperation_EnumOpCantHappen);
                    }

                    return this.current.Item;
                }
            },
            NotStartedOrEnded: {
                get: function () {
                    return this.current == null;
                }
            }
        },
        alias: [
            "moveNext", "System$Collections$IEnumerator$moveNext",
            "Dispose", "System$IDisposable$Dispose",
            "Current", ["System$Collections$Generic$IEnumerator$1$" + Bridge.getTypeAlias(T) + "$Current$1", "System$Collections$Generic$IEnumerator$1$Current$1"]
        ],
        ctors: {
            $ctor1: function (set) {
                this.$initialize();
                this.tree = set;
                this.tree.VersionCheck();

                this.version = this.tree.version;

                this.stack = new (System.Collections.Generic.Stack$1(System.Collections.Generic.SortedSet$1.Node(T))).$ctor2(Bridge.Int.mul(2, System.Collections.Generic.SortedSet$1(T).log2(((set.Count + 1) | 0))));
                this.current = null;
                this.reverse = false;

                this.Intialize();
            },
            $ctor2: function (set, reverse) {
                this.$initialize();
                this.tree = set;
                this.tree.VersionCheck();
                this.version = this.tree.version;

                this.stack = new (System.Collections.Generic.Stack$1(System.Collections.Generic.SortedSet$1.Node(T))).$ctor2(Bridge.Int.mul(2, System.Collections.Generic.SortedSet$1(T).log2(((set.Count + 1) | 0))));
                this.current = null;
                this.reverse = reverse;

                this.Intialize();

            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            Intialize: function () {

                this.current = null;
                var node = this.tree.root;
                var next = null, other = null;
                while (node != null) {
                    next = (this.reverse ? node.Right : node.Left);
                    other = (this.reverse ? node.Left : node.Right);
                    if (this.tree.IsWithinRange(node.Item)) {
                        this.stack.Push(node);
                        node = next;
                    } else if (next == null || !this.tree.IsWithinRange(next.Item)) {
                        node = other;
                    } else {
                        node = next;
                    }
                }
            },
            moveNext: function () {

                this.tree.VersionCheck();

                if (this.version !== this.tree.version) {
                    System.ThrowHelper.ThrowInvalidOperationException(System.ExceptionResource.InvalidOperation_EnumFailedVersion);
                }

                if (this.stack.Count === 0) {
                    this.current = null;
                    return false;
                }

                this.current = this.stack.Pop();
                var node = (this.reverse ? this.current.Left : this.current.Right);
                var next = null, other = null;
                while (node != null) {
                    next = (this.reverse ? node.Right : node.Left);
                    other = (this.reverse ? node.Left : node.Right);
                    if (this.tree.IsWithinRange(node.Item)) {
                        this.stack.Push(node);
                        node = next;
                    } else if (other == null || !this.tree.IsWithinRange(other.Item)) {
                        node = next;
                    } else {
                        node = other;
                    }
                }
                return true;
            },
            Dispose: function () { },
            Reset: function () {
                if (this.version !== this.tree.version) {
                    System.ThrowHelper.ThrowInvalidOperationException(System.ExceptionResource.InvalidOperation_EnumFailedVersion);
                }

                this.stack.Clear();
                this.Intialize();
            },
            System$Collections$IEnumerator$reset: function () {
                this.Reset();
            },
            getHashCode: function () {
                var h = Bridge.addHash([3788985113, this.tree, this.version, this.stack, this.current, this.reverse]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, System.Collections.Generic.SortedSet$1.Enumerator(T))) {
                    return false;
                }
                return Bridge.equals(this.tree, o.tree) && Bridge.equals(this.version, o.version) && Bridge.equals(this.stack, o.stack) && Bridge.equals(this.current, o.current) && Bridge.equals(this.reverse, o.reverse);
            },
            $clone: function (to) {
                var s = to || new (System.Collections.Generic.SortedSet$1.Enumerator(T))();
                s.tree = this.tree;
                s.version = this.version;
                s.stack = this.stack;
                s.current = this.current;
                s.reverse = this.reverse;
                return s;
            }
        }
    }; });

    // @source Node.js

    Bridge.define("System.Collections.Generic.SortedSet$1.Node", function (T) { return {
        $kind: "nested class",
        fields: {
            IsRed: false,
            Item: Bridge.getDefaultValue(T),
            Left: null,
            Right: null
        },
        ctors: {
            ctor: function (item) {
                this.$initialize();
                this.Item = item;
                this.IsRed = true;
            },
            $ctor1: function (item, isRed) {
                this.$initialize();
                this.Item = item;
                this.IsRed = isRed;
            }
        }
    }; });

    // @source TreeSubSet.js

    Bridge.define("System.Collections.Generic.SortedSet$1.TreeSubSet", function (T) { return {
        inherits: [System.Collections.Generic.SortedSet$1(T)],
        $kind: "nested class",
        fields: {
            underlying: null,
            min: Bridge.getDefaultValue(T),
            max: Bridge.getDefaultValue(T),
            lBoundActive: false,
            uBoundActive: false
        },
        alias: [
            "contains", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$contains",
            "clear", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$clear"
        ],
        ctors: {
            $ctor1: function (Underlying, Min, Max, lowerBoundActive, upperBoundActive) {
                this.$initialize();
                System.Collections.Generic.SortedSet$1(T).$ctor1.call(this, Underlying.Comparer);
                this.underlying = Underlying;
                this.min = Min;
                this.max = Max;
                this.lBoundActive = lowerBoundActive;
                this.uBoundActive = upperBoundActive;
                this.root = this.underlying.FindRange$1(this.min, this.max, this.lBoundActive, this.uBoundActive);
                this.count = 0;
                this.version = -1;
                this.VersionCheckImpl();
            },
            ctor: function () {
                this.$initialize();
                System.Collections.Generic.SortedSet$1(T).ctor.call(this);
                this.comparer = null;
            }
        },
        methods: {
            AddIfNotPresent: function (item) {

                if (!this.IsWithinRange(item)) {
                    System.ThrowHelper.ThrowArgumentOutOfRangeException$1(System.ExceptionArgument.collection);
                }

                var ret = this.underlying.AddIfNotPresent(item);
                this.VersionCheck();

                return ret;
            },
            contains: function (item) {
                this.VersionCheck();
                return System.Collections.Generic.SortedSet$1(T).prototype.contains.call(this, item);
            },
            DoRemove: function (item) {

                if (!this.IsWithinRange(item)) {
                    return false;
                }

                var ret = this.underlying.remove(item);
                this.VersionCheck();
                return ret;
            },
            clear: function () {


                if (this.count === 0) {
                    return;
                }

                var toRemove = new (System.Collections.Generic.List$1(T)).ctor();
                this.BreadthFirstTreeWalk(function (n) {
                    toRemove.add(n.Item);
                    return true;
                });
                while (toRemove.Count !== 0) {
                    this.underlying.remove(toRemove.getItem(((toRemove.Count - 1) | 0)));
                    toRemove.removeAt(((toRemove.Count - 1) | 0));
                }
                this.root = null;
                this.count = 0;
                this.version = this.underlying.version;
            },
            IsWithinRange: function (item) {

                var comp = (this.lBoundActive ? this.Comparer[Bridge.geti(this.Comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare", "System$Collections$Generic$IComparer$1$compare")](this.min, item) : -1);
                if (comp > 0) {
                    return false;
                }
                comp = (this.uBoundActive ? this.Comparer[Bridge.geti(this.Comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare", "System$Collections$Generic$IComparer$1$compare")](this.max, item) : 1);
                if (comp < 0) {
                    return false;
                }
                return true;
            },
            InOrderTreeWalk$1: function (action, reverse) {
                this.VersionCheck();

                if (this.root == null) {
                    return true;
                }

                var stack = new (System.Collections.Generic.Stack$1(System.Collections.Generic.SortedSet$1.Node(T))).$ctor2(Bridge.Int.mul(2, System.Collections.Generic.SortedSet$1(T).log2(((this.count + 1) | 0))));
                var current = this.root;
                while (current != null) {
                    if (this.IsWithinRange(current.Item)) {
                        stack.Push(current);
                        current = (reverse ? current.Right : current.Left);
                    } else if (this.lBoundActive && this.Comparer[Bridge.geti(this.Comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare", "System$Collections$Generic$IComparer$1$compare")](this.min, current.Item) > 0) {
                        current = current.Right;
                    } else {
                        current = current.Left;
                    }
                }

                while (stack.Count !== 0) {
                    current = stack.Pop();
                    if (!action(current)) {
                        return false;
                    }

                    var node = (reverse ? current.Left : current.Right);
                    while (node != null) {
                        if (this.IsWithinRange(node.Item)) {
                            stack.Push(node);
                            node = (reverse ? node.Right : node.Left);
                        } else if (this.lBoundActive && this.Comparer[Bridge.geti(this.Comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare", "System$Collections$Generic$IComparer$1$compare")](this.min, node.Item) > 0) {
                            node = node.Right;
                        } else {
                            node = node.Left;
                        }
                    }
                }
                return true;
            },
            BreadthFirstTreeWalk: function (action) {
                this.VersionCheck();

                if (this.root == null) {
                    return true;
                }

                var processQueue = new (System.Collections.Generic.List$1(System.Collections.Generic.SortedSet$1.Node(T))).ctor();
                processQueue.add(this.root);
                var current;

                while (processQueue.Count !== 0) {
                    current = processQueue.getItem(0);
                    processQueue.removeAt(0);
                    if (this.IsWithinRange(current.Item) && !action(current)) {
                        return false;
                    }
                    if (current.Left != null && (!this.lBoundActive || this.Comparer[Bridge.geti(this.Comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare", "System$Collections$Generic$IComparer$1$compare")](this.min, current.Item) < 0)) {
                        processQueue.add(current.Left);
                    }
                    if (current.Right != null && (!this.uBoundActive || this.Comparer[Bridge.geti(this.Comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare", "System$Collections$Generic$IComparer$1$compare")](this.max, current.Item) > 0)) {
                        processQueue.add(current.Right);
                    }

                }
                return true;
            },
            FindNode: function (item) {

                if (!this.IsWithinRange(item)) {
                    return null;
                }
                this.VersionCheck();
                return System.Collections.Generic.SortedSet$1(T).prototype.FindNode.call(this, item);
            },
            InternalIndexOf: function (item) {
                var $t;
                var count = -1;
                $t = Bridge.getEnumerator(this);
                try {
                    while ($t.moveNext()) {
                        var i = $t.Current;
                        count = (count + 1) | 0;
                        if (this.Comparer[Bridge.geti(this.Comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare", "System$Collections$Generic$IComparer$1$compare")](item, i) === 0) {
                            return count;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return -1;
            },
            VersionCheck: function () {
                this.VersionCheckImpl();
            },
            VersionCheckImpl: function () {
                if (this.version !== this.underlying.version) {
                    this.root = this.underlying.FindRange$1(this.min, this.max, this.lBoundActive, this.uBoundActive);
                    this.version = this.underlying.version;
                    this.count = 0;
                    this.InOrderTreeWalk(Bridge.fn.bind(this, $asm.$.System.Collections.Generic.SortedSet$1.TreeSubSet.f1));
                }
            },
            GetViewBetween: function (lowerValue, upperValue) {

                if (this.lBoundActive && this.Comparer[Bridge.geti(this.Comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare", "System$Collections$Generic$IComparer$1$compare")](this.min, lowerValue) > 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("lowerValue");
                }
                if (this.uBoundActive && this.Comparer[Bridge.geti(this.Comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare", "System$Collections$Generic$IComparer$1$compare")](this.max, upperValue) < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("upperValue");
                }
                var ret = Bridge.cast(this.underlying.GetViewBetween(lowerValue, upperValue), System.Collections.Generic.SortedSet$1.TreeSubSet(T));
                return ret;
            },
            IntersectWithEnumerable: function (other) {
                var $t;

                var toSave = new (System.Collections.Generic.List$1(T)).$ctor2(this.Count);
                $t = Bridge.getEnumerator(other, T);
                try {
                    while ($t.moveNext()) {
                        var item = $t.Current;
                        if (this.contains(item)) {
                            toSave.add(item);
                            this.remove(item);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.clear();
                this.AddAllElements(toSave);
            }
        }
    }; });

    Bridge.ns("System.Collections.Generic.SortedSet$1.TreeSubSet", $asm.$);

    Bridge.apply($asm.$.System.Collections.Generic.SortedSet$1.TreeSubSet, {
        f1: function (n) {
            this.count = (this.count + 1) | 0;
            return true;
        }
    });

    // @source LinkedList.js

    Bridge.define("System.Collections.Generic.LinkedList$1", function (T) { return {
        inherits: [System.Collections.Generic.ICollection$1(T),System.Collections.ICollection,System.Collections.Generic.IReadOnlyCollection$1(T)],
        statics: {
            fields: {
                VersionName: null,
                CountName: null,
                ValuesName: null
            },
            ctors: {
                init: function () {
                    this.VersionName = "Version";
                    this.CountName = "Count";
                    this.ValuesName = "Data";
                }
            }
        },
        fields: {
            head: null,
            count: 0,
            version: 0
        },
        props: {
            Count: {
                get: function () {
                    return this.count;
                }
            },
            First: {
                get: function () {
                    return this.head;
                }
            },
            Last: {
                get: function () {
                    return this.head == null ? null : this.head.prev;
                }
            },
            System$Collections$Generic$ICollection$1$IsReadOnly: {
                get: function () {
                    return false;
                }
            },
            System$Collections$ICollection$IsSynchronized: {
                get: function () {
                    return false;
                }
            },
            System$Collections$ICollection$SyncRoot: {
                get: function () {
                    return null;
                }
            }
        },
        alias: [
            "Count", ["System$Collections$Generic$IReadOnlyCollection$1$" + Bridge.getTypeAlias(T) + "$Count", "System$Collections$Generic$IReadOnlyCollection$1$Count"],
            "Count", "System$Collections$ICollection$Count",
            "Count", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$Count",
            "System$Collections$Generic$ICollection$1$IsReadOnly", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$IsReadOnly",
            "System$Collections$Generic$ICollection$1$add", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$add",
            "clear", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$clear",
            "contains", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$contains",
            "copyTo", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$copyTo",
            "System$Collections$Generic$IEnumerable$1$GetEnumerator", "System$Collections$Generic$IEnumerable$1$" + Bridge.getTypeAlias(T) + "$GetEnumerator",
            "remove", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$remove"
        ],
        ctors: {
            ctor: function () {
                this.$initialize();
            },
            $ctor1: function (collection) {
                var $t;
                this.$initialize();
                if (collection == null) {
                    throw new System.ArgumentNullException.$ctor1("collection");
                }

                $t = Bridge.getEnumerator(collection, T);
                try {
                    while ($t.moveNext()) {
                        var item = $t.Current;
                        this.AddLast(item);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            }
        },
        methods: {
            System$Collections$Generic$ICollection$1$add: function (value) {
                this.AddLast(value);
            },
            AddAfter: function (node, value) {
                this.ValidateNode(node);
                var result = new (System.Collections.Generic.LinkedListNode$1(T)).$ctor1(node.list, value);
                this.InternalInsertNodeBefore(node.next, result);
                return result;
            },
            AddAfter$1: function (node, newNode) {
                this.ValidateNode(node);
                this.ValidateNewNode(newNode);
                this.InternalInsertNodeBefore(node.next, newNode);
                newNode.list = this;
            },
            AddBefore: function (node, value) {
                this.ValidateNode(node);
                var result = new (System.Collections.Generic.LinkedListNode$1(T)).$ctor1(node.list, value);
                this.InternalInsertNodeBefore(node, result);
                if (Bridge.referenceEquals(node, this.head)) {
                    this.head = result;
                }
                return result;
            },
            AddBefore$1: function (node, newNode) {
                this.ValidateNode(node);
                this.ValidateNewNode(newNode);
                this.InternalInsertNodeBefore(node, newNode);
                newNode.list = this;
                if (Bridge.referenceEquals(node, this.head)) {
                    this.head = newNode;
                }
            },
            AddFirst: function (value) {
                var result = new (System.Collections.Generic.LinkedListNode$1(T)).$ctor1(this, value);
                if (this.head == null) {
                    this.InternalInsertNodeToEmptyList(result);
                } else {
                    this.InternalInsertNodeBefore(this.head, result);
                    this.head = result;
                }
                return result;
            },
            AddFirst$1: function (node) {
                this.ValidateNewNode(node);

                if (this.head == null) {
                    this.InternalInsertNodeToEmptyList(node);
                } else {
                    this.InternalInsertNodeBefore(this.head, node);
                    this.head = node;
                }
                node.list = this;
            },
            AddLast: function (value) {
                var result = new (System.Collections.Generic.LinkedListNode$1(T)).$ctor1(this, value);
                if (this.head == null) {
                    this.InternalInsertNodeToEmptyList(result);
                } else {
                    this.InternalInsertNodeBefore(this.head, result);
                }
                return result;
            },
            AddLast$1: function (node) {
                this.ValidateNewNode(node);

                if (this.head == null) {
                    this.InternalInsertNodeToEmptyList(node);
                } else {
                    this.InternalInsertNodeBefore(this.head, node);
                }
                node.list = this;
            },
            clear: function () {
                var current = this.head;
                while (current != null) {
                    var temp = current;
                    current = current.Next;
                    temp.Invalidate();
                }

                this.head = null;
                this.count = 0;
                this.version = (this.version + 1) | 0;
            },
            contains: function (value) {
                return this.Find(value) != null;
            },
            copyTo: function (array, index) {
                if (array == null) {
                    throw new System.ArgumentNullException.$ctor1("array");
                }

                if (index < 0 || index > array.length) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("index");
                }

                if (((array.length - index) | 0) < this.Count) {
                    throw new System.ArgumentException.ctor();
                }

                var node = this.head;
                if (node != null) {
                    do {
                        array[System.Array.index(Bridge.identity(index, (index = (index + 1) | 0)), array)] = node.item;
                        node = node.next;
                    } while (!Bridge.referenceEquals(node, this.head));
                }
            },
            System$Collections$ICollection$copyTo: function (array, index) {
                if (array == null) {
                    throw new System.ArgumentNullException.$ctor1("array");
                }

                if (System.Array.getRank(array) !== 1) {
                    throw new System.ArgumentException.ctor();
                }

                if (System.Array.getLower(array, 0) !== 0) {
                    throw new System.ArgumentException.ctor();
                }

                if (index < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("index");
                }

                if (((array.length - index) | 0) < this.Count) {
                    throw new System.ArgumentException.ctor();
                }

                var tArray = Bridge.as(array, System.Array.type(T));
                if (tArray != null) {
                    this.copyTo(tArray, index);
                } else {
                    var targetType = (Bridge.getType(array).$elementType || null);
                    var sourceType = T;
                    if (!(Bridge.Reflection.isAssignableFrom(targetType, sourceType) || Bridge.Reflection.isAssignableFrom(sourceType, targetType))) {
                        throw new System.ArgumentException.ctor();
                    }

                    var objects = Bridge.as(array, System.Array.type(System.Object));
                    if (objects == null) {
                        throw new System.ArgumentException.ctor();
                    }
                    var node = this.head;
                    try {
                        if (node != null) {
                            do {
                                objects[System.Array.index(Bridge.identity(index, (index = (index + 1) | 0)), objects)] = node.item;
                                node = node.next;
                            } while (!Bridge.referenceEquals(node, this.head));
                        }
                    } catch ($e1) {
                        $e1 = System.Exception.create($e1);
                        if (Bridge.is($e1, System.ArrayTypeMismatchException)) {
                            throw new System.ArgumentException.ctor();
                        } else {
                            throw $e1;
                        }
                    }
                }
            },
            Find: function (value) {
                var node = this.head;
                var c = System.Collections.Generic.EqualityComparer$1(T).def;
                if (node != null) {
                    if (value != null) {
                        do {
                            if (c.equals2(node.item, value)) {
                                return node;
                            }
                            node = node.next;
                        } while (!Bridge.referenceEquals(node, this.head));
                    } else {
                        do {
                            if (node.item == null) {
                                return node;
                            }
                            node = node.next;
                        } while (!Bridge.referenceEquals(node, this.head));
                    }
                }
                return null;
            },
            FindLast: function (value) {
                if (this.head == null) {
                    return null;
                }

                var last = this.head.prev;
                var node = last;
                var c = System.Collections.Generic.EqualityComparer$1(T).def;
                if (node != null) {
                    if (value != null) {
                        do {
                            if (c.equals2(node.item, value)) {
                                return node;
                            }

                            node = node.prev;
                        } while (!Bridge.referenceEquals(node, last));
                    } else {
                        do {
                            if (node.item == null) {
                                return node;
                            }
                            node = node.prev;
                        } while (!Bridge.referenceEquals(node, last));
                    }
                }
                return null;
            },
            GetEnumerator: function () {
                return new (System.Collections.Generic.LinkedList$1.Enumerator(T)).$ctor1(this);
            },
            System$Collections$Generic$IEnumerable$1$GetEnumerator: function () {
                return this.GetEnumerator().$clone();
            },
            System$Collections$IEnumerable$GetEnumerator: function () {
                return this.GetEnumerator().$clone();
            },
            remove: function (value) {
                var node = this.Find(value);
                if (node != null) {
                    this.InternalRemoveNode(node);
                    return true;
                }
                return false;
            },
            Remove: function (node) {
                this.ValidateNode(node);
                this.InternalRemoveNode(node);
            },
            RemoveFirst: function () {
                if (this.head == null) {
                    throw new System.InvalidOperationException.ctor();
                }
                this.InternalRemoveNode(this.head);
            },
            RemoveLast: function () {
                if (this.head == null) {
                    throw new System.InvalidOperationException.ctor();
                }
                this.InternalRemoveNode(this.head.prev);
            },
            InternalInsertNodeBefore: function (node, newNode) {
                newNode.next = node;
                newNode.prev = node.prev;
                node.prev.next = newNode;
                node.prev = newNode;
                this.version = (this.version + 1) | 0;
                this.count = (this.count + 1) | 0;
            },
            InternalInsertNodeToEmptyList: function (newNode) {
                newNode.next = newNode;
                newNode.prev = newNode;
                this.head = newNode;
                this.version = (this.version + 1) | 0;
                this.count = (this.count + 1) | 0;
            },
            InternalRemoveNode: function (node) {
                if (Bridge.referenceEquals(node.next, node)) {
                    this.head = null;
                } else {
                    node.next.prev = node.prev;
                    node.prev.next = node.next;
                    if (Bridge.referenceEquals(this.head, node)) {
                        this.head = node.next;
                    }
                }
                node.Invalidate();
                this.count = (this.count - 1) | 0;
                this.version = (this.version + 1) | 0;
            },
            ValidateNewNode: function (node) {
                if (node == null) {
                    throw new System.ArgumentNullException.$ctor1("node");
                }

                if (node.list != null) {
                    throw new System.InvalidOperationException.ctor();
                }
            },
            ValidateNode: function (node) {
                if (node == null) {
                    throw new System.ArgumentNullException.$ctor1("node");
                }

                if (!Bridge.referenceEquals(node.list, this)) {
                    throw new System.InvalidOperationException.ctor();
                }
            }
        }
    }; });

    // @source LinkedListNode.js

    Bridge.define("System.Collections.Generic.LinkedListNode$1", function (T) { return {
        fields: {
            list: null,
            next: null,
            prev: null,
            item: Bridge.getDefaultValue(T)
        },
        props: {
            List: {
                get: function () {
                    return this.list;
                }
            },
            Next: {
                get: function () {
                    return this.next == null || Bridge.referenceEquals(this.next, this.list.head) ? null : this.next;
                }
            },
            Previous: {
                get: function () {
                    return this.prev == null || Bridge.referenceEquals(this, this.list.head) ? null : this.prev;
                }
            },
            Value: {
                get: function () {
                    return this.item;
                },
                set: function (value) {
                    this.item = value;
                }
            }
        },
        ctors: {
            ctor: function (value) {
                this.$initialize();
                this.item = value;
            },
            $ctor1: function (list, value) {
                this.$initialize();
                this.list = list;
                this.item = value;
            }
        },
        methods: {
            Invalidate: function () {
                this.list = null;
                this.next = null;
                this.prev = null;
            }
        }
    }; });

    // @source Enumerator.js

    Bridge.define("System.Collections.Generic.LinkedList$1.Enumerator", function (T) { return {
        inherits: [System.Collections.Generic.IEnumerator$1(T),System.Collections.IEnumerator],
        $kind: "nested struct",
        statics: {
            fields: {
                LinkedListName: null,
                CurrentValueName: null,
                VersionName: null,
                IndexName: null
            },
            ctors: {
                init: function () {
                    this.LinkedListName = "LinkedList";
                    this.CurrentValueName = "Current";
                    this.VersionName = "Version";
                    this.IndexName = "Index";
                }
            },
            methods: {
                getDefaultValue: function () { return new (System.Collections.Generic.LinkedList$1.Enumerator(T))(); }
            }
        },
        fields: {
            list: null,
            node: null,
            version: 0,
            current: Bridge.getDefaultValue(T),
            index: 0
        },
        props: {
            Current: {
                get: function () {
                    return this.current;
                }
            },
            System$Collections$IEnumerator$Current: {
                get: function () {
                    if (this.index === 0 || (this.index === ((this.list.Count + 1) | 0))) {
                        System.ThrowHelper.ThrowInvalidOperationException(System.ExceptionResource.InvalidOperation_EnumOpCantHappen);
                    }

                    return this.current;
                }
            }
        },
        alias: [
            "Current", ["System$Collections$Generic$IEnumerator$1$" + Bridge.getTypeAlias(T) + "$Current$1", "System$Collections$Generic$IEnumerator$1$Current$1"],
            "moveNext", "System$Collections$IEnumerator$moveNext",
            "Dispose", "System$IDisposable$Dispose"
        ],
        ctors: {
            $ctor1: function (list) {
                this.$initialize();
                this.list = list;
                this.version = list.version;
                this.node = list.head;
                this.current = Bridge.getDefaultValue(T);
                this.index = 0;
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            moveNext: function () {
                if (this.version !== this.list.version) {
                    throw new System.InvalidOperationException.ctor();
                }

                if (this.node == null) {
                    this.index = (this.list.Count + 1) | 0;
                    return false;
                }

                this.index = (this.index + 1) | 0;
                this.current = this.node.item;
                this.node = this.node.next;
                if (Bridge.referenceEquals(this.node, this.list.head)) {
                    this.node = null;
                }
                return true;
            },
            System$Collections$IEnumerator$reset: function () {
                if (this.version !== this.list.version) {
                    throw new System.InvalidOperationException.ctor();
                }

                this.current = Bridge.getDefaultValue(T);
                this.node = this.list.head;
                this.index = 0;
            },
            Dispose: function () { },
            getHashCode: function () {
                var h = Bridge.addHash([3788985113, this.list, this.node, this.version, this.current, this.index]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, System.Collections.Generic.LinkedList$1.Enumerator(T))) {
                    return false;
                }
                return Bridge.equals(this.list, o.list) && Bridge.equals(this.node, o.node) && Bridge.equals(this.version, o.version) && Bridge.equals(this.current, o.current) && Bridge.equals(this.index, o.index);
            },
            $clone: function (to) {
                var s = to || new (System.Collections.Generic.LinkedList$1.Enumerator(T))();
                s.list = this.list;
                s.node = this.node;
                s.version = this.version;
                s.current = this.current;
                s.index = this.index;
                return s;
            }
        }
    }; });

    // @source TreeRotation.js

    Bridge.define("System.Collections.Generic.TreeRotation", {
        $kind: "enum",
        statics: {
            fields: {
                LeftRotation: 1,
                RightRotation: 2,
                RightLeftRotation: 3,
                LeftRightRotation: 4
            }
        }
    });

    // @source CustomEnumerator.js

    Bridge.define("Bridge.CustomEnumerator", {
        inherits: [System.Collections.IEnumerator, System.IDisposable],

        config: {
            properties: {
                Current: {
                    get: function () {
                        return this.getCurrent();
                    }
                },

                Current$1: {
                    get: function () {
                        return this.getCurrent();
                    }
                }
            },

            alias: [
                "getCurrent", "System$Collections$IEnumerator$getCurrent",
                "moveNext", "System$Collections$IEnumerator$moveNext",
                "reset", "System$Collections$IEnumerator$reset",
                "Dispose", "System$IDisposable$Dispose",
                "Current", "System$Collections$IEnumerator$Current"
            ]
        },

        ctor: function (moveNext, getCurrent, reset, dispose, scope, T) {
            this.$initialize();
            this.$moveNext = moveNext;
            this.$getCurrent = getCurrent;
            this.$Dispose = dispose;
            this.$reset = reset;
            this.scope = scope;

            if (T) {
                this["System$Collections$Generic$IEnumerator$1$" + Bridge.getTypeAlias(T) + "$getCurrent$1"] = this.getCurrent;
                this["System$Collections$Generic$IEnumerator$1$getCurrent$1"] = this.getCurrent;

                Object.defineProperty(this, "System$Collections$Generic$IEnumerator$1$" + Bridge.getTypeAlias(T) + "$Current$1", {
                    get: this.getCurrent,
                    enumerable: true
                });

                Object.defineProperty(this, "System$Collections$Generic$IEnumerator$1$Current$1", {
                    get: this.getCurrent,
                    enumerable: true
                });
            }
        },

        moveNext: function () {
            try {
                return this.$moveNext.call(this.scope);
            }
            catch (ex) {
                this.Dispose.call(this.scope);

                throw ex;
            }
        },

        getCurrent: function () {
            return this.$getCurrent.call(this.scope);
        },

        getCurrent$1: function () {
            return this.$getCurrent.call(this.scope);
        },

        reset: function () {
            if (this.$reset) {
                this.$reset.call(this.scope);
            }
        },

        Dispose: function () {
            if (this.$Dispose) {
                this.$Dispose.call(this.scope);
            }
        }
    });

    // @source ArrayEnumerator.js

    Bridge.define("Bridge.ArrayEnumerator", {
        inherits: [System.Collections.IEnumerator, System.IDisposable],

        statics: {
            $isArrayEnumerator: true
        },

        config: {
            properties: {
                Current: {
                    get: function () {
                        return this.getCurrent();
                    }
                },

                Current$1: {
                    get: function () {
                        return this.getCurrent();
                    }
                }
            },

            alias: [
                "getCurrent", "System$Collections$IEnumerator$getCurrent",
                "moveNext", "System$Collections$IEnumerator$moveNext",
                "reset", "System$Collections$IEnumerator$reset",
                "Dispose", "System$IDisposable$Dispose",
                "Current", "System$Collections$IEnumerator$Current"
            ]
        },

        ctor: function (array, T) {
            this.$initialize();
            this.array = array;
            this.reset();

            if (T) {
                this["System$Collections$Generic$IEnumerator$1$" + Bridge.getTypeAlias(T) + "$getCurrent$1"] = this.getCurrent;
                this["System$Collections$Generic$IEnumerator$1$getCurrent$1"] = this.getCurrent;

                Object.defineProperty(this, "System$Collections$Generic$IEnumerator$1$" + Bridge.getTypeAlias(T) + "$Current$1", {
                    get: this.getCurrent,
                    enumerable: true
                });

                Object.defineProperty(this, "System$Collections$Generic$IEnumerator$1$Current$1", {
                    get: this.getCurrent,
                    enumerable: true
                });
            }
        },

        moveNext: function () {
            this.index++;

            return this.index < this.array.length;
        },

        getCurrent: function () {
            return this.array[this.index];
        },

        getCurrent$1: function () {
            return this.array[this.index];
        },

        reset: function () {
            this.index = -1;
        },

        Dispose: Bridge.emptyFn
    });

    Bridge.define("Bridge.ArrayEnumerable", {
        inherits: [System.Collections.IEnumerable],

        config: {
            alias: [
                "GetEnumerator", "System$Collections$IEnumerable$GetEnumerator"
            ]
        },

        ctor: function (array) {
            this.$initialize();
            this.array = array;
        },

        GetEnumerator: function () {
            return new Bridge.ArrayEnumerator(this.array);
        }
    });

    // @source EqualityComparer.js

    Bridge.define("System.Collections.Generic.EqualityComparer$1", function (T) {
        return {
            inherits: [System.Collections.Generic.IEqualityComparer$1(T)],

            statics: {
                config: {
                    init: function () {
                        this.def = new (System.Collections.Generic.EqualityComparer$1(T))();
                    }
                }
            },

            config: {
                alias: [
                    "equals2", ["System$Collections$Generic$IEqualityComparer$1$" + Bridge.getTypeAlias(T) + "$equals2", "System$Collections$Generic$IEqualityComparer$1$equals2"],
                    "getHashCode2", ["System$Collections$Generic$IEqualityComparer$1$" + Bridge.getTypeAlias(T) + "$getHashCode2", "System$Collections$Generic$IEqualityComparer$1$getHashCode2"]
                ]
            },

            equals2: function (x, y) {
                if (!Bridge.isDefined(x, true)) {
                    return !Bridge.isDefined(y, true);
                } else if (Bridge.isDefined(y, true)) {
                    var isBridge = x && x.$$name;

                    if (Bridge.isFunction(x) && Bridge.isFunction(y)) {
                        return Bridge.fn.equals.call(x, y);
                    } else if (!isBridge || x && x.$boxed || y && y.$boxed) {
                        return Bridge.equals(x, y);
                    } else if (Bridge.isFunction(x.equalsT)) {
                        return Bridge.equalsT(x, y);
                    } else if (Bridge.isFunction(x.equals)) {
                        return Bridge.equals(x, y);
                    }

                    return x === y;
                }

                return false;
            },

            getHashCode2: function (obj) {
                return Bridge.isDefined(obj, true) ? Bridge.getHashCode(obj) : 0;
            }
        };
    });

    System.Collections.Generic.EqualityComparer$1.$default = new (System.Collections.Generic.EqualityComparer$1(System.Object))();

    // @source Comparer.js

    Bridge.define("System.Collections.Generic.Comparer$1", function (T) {
        return {
            inherits: [System.Collections.Generic.IComparer$1(T)],

            ctor: function (fn) {
                this.$initialize();
                this.fn = fn;
                this.compare = fn;
                this["System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare"] = fn;
                this["System$Collections$Generic$IComparer$1$compare"] = fn;
            }
        }
    });

    System.Collections.Generic.Comparer$1.$default = new (System.Collections.Generic.Comparer$1(System.Object))(function (x, y) {
        if (!Bridge.hasValue(x)) {
            return !Bridge.hasValue(y) ? 0 : -1;
        } else if (!Bridge.hasValue(y)) {
            return 1;
        }

        return Bridge.compare(x, y);
    });

    System.Collections.Generic.Comparer$1.get = function (obj, T) {
        var m;

        if (T && (m = obj["System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare"])) {
            return m.bind(obj);
        }

        if (m = obj["System$Collections$Generic$IComparer$1$compare"]) {
            return m.bind(obj);
        }

        return obj.compare.bind(obj);
    };

    // @source Dictionary.js

    Bridge.define("System.Collections.Generic.Dictionary$2", function (TKey, TValue) {
        return {
            inherits: [System.Collections.Generic.IDictionary$2(TKey, TValue),
                System.Collections.IDictionary,
                System.Collections.Generic.IReadOnlyDictionary$2(TKey, TValue)],

            config: {
                properties: {
                    Keys: {
                        get: function () {
                            return this.getKeys();
                        }
                    },

                    Values: {
                        get: function () {
                            return this.getValues();
                        }
                    },

                    IsReadOnly: {
                        get: function () {
                            return this.getIsReadOnly();
                        }
                    }
                },
                alias: [
                    "getCount", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(System.Collections.Generic.KeyValuePair$2(TKey, TValue)) + "$getCount",
                    "getKeys", "System$Collections$Generic$IDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$getKeys",
                    "getValues", "System$Collections$Generic$IDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$getValues",
                    "Keys", "System$Collections$Generic$IDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$Keys",
                    "Values", "System$Collections$Generic$IDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$Values",
                    "get", "System$Collections$Generic$IDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$getItem",
                    "set", "System$Collections$Generic$IDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$setItem",
                    "add", "System$Collections$Generic$IDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$add",
                    "containsKey", "System$Collections$Generic$IDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$containsKey",
                    "GetEnumerator", ["System$Collections$Generic$IEnumerable$1$System$Collections$Generic$KeyValuePair$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$GetEnumerator", "System$Collections$Generic$IEnumerable$1$GetEnumerator"],
                    "remove", "System$Collections$Generic$IDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$remove",
                    "tryGetValue", "System$Collections$Generic$IDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$tryGetValue",
                    "getIsReadOnly", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(System.Collections.Generic.KeyValuePair$2(TKey, TValue)) + "$getIsReadOnly",
                    "IsReadOnly", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(System.Collections.Generic.KeyValuePair$2(TKey, TValue)) + "$IsReadOnly",
                    "addPair", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(System.Collections.Generic.KeyValuePair$2(TKey, TValue)) + "$add",
                    "copyTo", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(System.Collections.Generic.KeyValuePair$2(TKey, TValue)) + "$copyTo",
                    "clear", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(System.Collections.Generic.KeyValuePair$2(TKey, TValue)) + "$clear",
                    "containsPair", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(System.Collections.Generic.KeyValuePair$2(TKey, TValue)) + "$contains",
                    "removePair", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(System.Collections.Generic.KeyValuePair$2(TKey, TValue)) + "$remove",
                    "copyTo", "System$Collections$ICollection$copyTo",
                    "get", "System$Collections$IDictionary$getItem",
                    "set", "System$Collections$IDictionary$setItem",
                    "containsKey", "System$Collections$IDictionary$containsKey",
                    "add", "System$Collections$IDictionary$add",
                    "remove", "System$Collections$IDictionary$remove",
                    "getIsReadOnly", "System$Collections$IDictionary$getIsReadOnly",
                    "getKeys", "System$Collections$IDictionary$getKeys",
                    "getValues", "System$Collections$IDictionary$getValues",
                    "IsReadOnly", "System$Collections$IDictionary$IsReadOnly",
                    "Keys", "System$Collections$IDictionary$Keys",
                    "Values", "System$Collections$IDictionary$Values",
                    "get", "System$Collections$Generic$IReadOnlyDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$getItem",
                    "Keys", "System$Collections$Generic$IReadOnlyDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$Keys",
                    "getKeys", "System$Collections$Generic$IReadOnlyDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$getKeys",
                    "getValues", "System$Collections$Generic$IReadOnlyDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$getValues",
                    "Values", "System$Collections$Generic$IReadOnlyDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$Values",
                    "containsKey", "System$Collections$Generic$IReadOnlyDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$containsKey",
                    "tryGetValue", "System$Collections$Generic$IReadOnlyDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$tryGetValue"
                ]
            },

            noKeyCheck: false,

            ctor: function (obj, comparer) {
                this.$initialize();
                this.comparer = comparer || System.Collections.Generic.EqualityComparer$1(TKey).def;
                this.clear();
                this.isSimpleKey = ((TKey === System.String) || (TKey.$number === true && TKey !== System.Int64 && TKey !== System.UInt64) || (TKey === System.Char)) && (this.comparer === System.Collections.Generic.EqualityComparer$1(TKey).def);

                if (Bridge.is(obj, System.Collections.Generic.Dictionary$2(TKey, TValue))) {
                    var e = Bridge.getEnumerator(obj),
                        c;

                    while (e.moveNext()) {
                        c = e.Current;
                        this.add(c.key, c.value);
                    }
                } else if (Object.prototype.toString.call(obj) === "[object Object]") {
                    var names = Object.keys(obj),
                        name;

                    for (var i = 0; i < names.length; i++) {
                        name = names[i];
                        this.add(name, obj[name]);
                    }
                }
            },

            containsPair: function (pair) {
                var entry = this.findEntry(pair.key);

                return entry && this.comparer.equals2(entry.value, pair.value);
            },

            removePair: function (pair) {
                var entry = this.findEntry(pair.key);

                if (entry && this.comparer.equals2(entry.value, pair.value)) {
                    return this.remove(pair.key);
                }

                return false;
            },

            copyTo: function (array, arrayIndex) {
                var items = System.Linq.Enumerable.from(this).ToArray();

                System.Array.copy(items, 0, array, arrayIndex, items.length);
            },

            getIsReadOnly: function () {
                return !!this.readOnly;
            },

            getKeys: function () {
                var keys = [];
                var entry;

                if (this.isSimpleKey) {
                    keys = this.keys
                } else {
                    for (var i = 0; i < this.keys.length; i++) {
                        entry = this.entries[this.keys[i]];

                        for (var j = 0; j < entry.length; j++) {
                            keys.push(entry[j].key);
                        }
                    }
                }

                return System.Array.init(keys, TKey);
            },

            getValues: function () {
                var values = [];
                var entry;

                if (this.isSimpleKey) {
                    for (var i = 0; i < this.keys.length; i++) {
                        values.push(this.entries[this.keys[i]].value);
                    }
                } else {
                    for (var i = 0; i < this.keys.length; i++) {
                        entry = this.entries[this.keys[i]];

                        for (var j = 0; j < entry.length; j++) {
                            values.push(entry[j].value);
                        }
                    }
                }

                return System.Array.init(values, TValue);
            },

            clear: function () {
                this.entries = {};
                this.keys = [];
                this.count = 0;
            },

            findEntry: function (key) {
                var hash, entries, i;

                if (this.isSimpleKey) {
                    if (this.entries.hasOwnProperty(key)) {
                        return this.entries[key];
                    }

                    return;
                }

                hash = this.comparer.getHashCode2(key);

                if (Bridge.isDefined(this.entries[hash])) {
                    entries = this.entries[hash];

                    for (i = 0; i < entries.length; i++) {
                        if (this.comparer.equals2(entries[i].key, key)) {
                            return entries[i];
                        }
                    }
                }
            },

            containsKey: function (key) {
                return !!this.findEntry(key);
            },

            containsValue: function (value) {
                var e, i;

                for (e in this.entries) {
                    if (this.entries.hasOwnProperty(e)) {
                        var entries = this.isSimpleKey ? [this.entries[e]] : this.entries[e];

                        for (i = 0; i < entries.length; i++) {
                            if (this.comparer.equals2(entries[i].value, value)) {
                                return true;
                            }
                        }
                    }
                }

                return false;
            },

            get: function (key) {
                var entry = this.findEntry(key);

                if (!entry) {
                    if (this.noKeyCheck) {
                        return Bridge.getDefaultValue(TValue);
                    }

                    throw new System.Collections.Generic.KeyNotFoundException.$ctor1("Key " + key + " does not exist.");
                }

                return entry.value;
            },

            getItem: function (key) {
                return this.get(key);
            },

            set: function (key, value, add) {
                var entry = this.findEntry(key),
                    hash;

                if (entry) {
                    if (add) {
                        throw new System.ArgumentException.$ctor1("Key " + key + " already exists.");
                    }

                    entry.value$1 = value;
                    return;
                }

                entry = new (System.Collections.Generic.KeyValuePair$2(TKey, TValue)).$ctor1(key, value);

                if (this.isSimpleKey) {
                    this.entries[key] = entry;
                    this.keys.push(key);
                } else {
                    hash = this.comparer.getHashCode2(key);

                    if (this.entries[hash]) {
                        this.entries[hash].push(entry);
                    } else {
                        this.entries[hash] = [entry];
                        this.keys.push(hash);
                    }
                }

                this.count++;
            },

            setItem: function (key, value, add) {
                this.set(key, value, add);
            },

            add: function (key, value) {
                this.set(key, value, true);
            },

            addPair: function (pair) {
                this.set(pair.key, pair.value, true);
            },

            remove: function (key) {
                var hash, entries, i;

                if (this.isSimpleKey) {
                    if (this.entries.hasOwnProperty(key)) {
                        delete this.entries[key];
                        this.keys.splice(this.keys.indexOf(key), 1);
                        this.count--;
                        return true;
                    }

                    return false;
                }

                hash = this.comparer.getHashCode2(key);

                if (!this.entries[hash]) {
                    return false;
                }

                entries = this.entries[hash];

                for (i = 0; i < entries.length; i++) {
                    if (this.comparer.equals2(entries[i].key, key)) {
                        entries.splice(i, 1);

                        if (entries.length == 0) {
                            delete this.entries[hash];
                            this.keys.splice(this.keys.indexOf(hash), 1);
                        }

                        this.count--;

                        return true;
                    }
                }

                return false;
            },

            getCount: function () {
                return this.count;
            },

            getComparer: function () {
                return this.comparer;
            },

            tryGetValue: function (key, value) {
                var entry = this.findEntry(key);

                value.v = entry ? entry.value : Bridge.getDefaultValue(TValue);

                return !!entry;
            },

            getCustomEnumerator: function (fn) {
                var hashes = this.keys,
                    hashIndex = -1,
                    keyIndex;

                return new Bridge.CustomEnumerator(function () {
                    if (hashIndex < 0 || this.isSimpleKey || keyIndex >= (this.entries[hashes[hashIndex]].length - 1)) {
                        keyIndex = -1;
                        hashIndex++;
                    }

                    if (hashIndex >= hashes.length) {
                        return false;
                    }

                    keyIndex++;

                    return true;
                }, function () {
                    if (hashIndex < 0 || hashIndex >= hashes.length) {
                        return new (System.Collections.Generic.KeyValuePair$2(TKey, TValue))()
                    }

                    return fn(this.isSimpleKey ? this.entries[hashes[hashIndex]] : this.entries[hashes[hashIndex]][keyIndex]);
                }, function () {
                    hashIndex = -1;
                }, null, this, System.Collections.Generic.KeyValuePair$2(TKey, TValue));
            },

            GetEnumerator: function () {
                return this.getCustomEnumerator(function (e) {
                    return e;
                });
            }
        };
    });

    System.Collections.Generic.Dictionary$2.getTypeParameters = function (type) {
        var interfaceType;

        if (System.String.startsWith(type.$$name, "System.Collections.Generic.IDictionary")) {
            interfaceType = type;
        } else {
            var interfaces = Bridge.Reflection.getInterfaces(type);

            for (var j = 0; j < interfaces.length; j++) {
                if (System.String.startsWith(interfaces[j].$$name, "System.Collections.Generic.IDictionary")) {
                    interfaceType = interfaces[j];

                    break;
                }
            }
        }

        var typesGeneric = interfaceType ? Bridge.Reflection.getGenericArguments(interfaceType) : null;
        var typeKey = typesGeneric ? typesGeneric[0] : null;
        var typeValue = typesGeneric ? typesGeneric[1] : null;

        return [typeKey, typeValue];
    };

    Bridge.define("System.Collections.Generic.DictionaryCollection$1", function (T) {
        return {
            inherits: [System.Collections.Generic.ICollection$1(T)],

            config: {
                alias: [
                  "GetEnumerator", ["System$Collections$Generic$IEnumerable$1$" + Bridge.getTypeAlias(T) + "$GetEnumerator", "System$Collections$Generic$IEnumerable$1$GetEnumerator"],
                  "getCount", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$getCount",
                  "add", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$add",
                  "clear", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$clear",
                  "contains", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$contains",
                  "remove", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$remove"
                ]
            },

            ctor: function (dictionary, keys) {
                this.$initialize();
                this.dictionary = dictionary;
                this.keys = keys;
            },

            getCount: function () {
                return this.dictionary.getCount();
            },

            GetEnumerator: function () {
                return this.dictionary.getCustomEnumerator(this.keys ? function (e) {
                    return e.key;
                } : function (e) {
                    return e.value;
                });
            },

            contains: function (value) {
                return this.keys ? this.dictionary.containsKey(value) : this.dictionary.containsValue(value);
            },

            add: function (v) {
                throw new System.NotSupportedException();
            },

            clear: function () {
                throw new System.NotSupportedException();
            },

            remove: function () {
                throw new System.NotSupportedException();
            }
        };
    });

    // @source List.js

    Bridge.define("System.Collections.Generic.List$1", function (T) { return {
        inherits: [System.Collections.Generic.IList$1(T),System.Collections.IList,System.Collections.Generic.IReadOnlyList$1(T)],
        statics: {
            fields: {
                _defaultCapacity: 0,
                _emptyArray: null
            },
            ctors: {
                init: function () {
                    this._defaultCapacity = 4;
                    this._emptyArray = System.Array.init(0, function (){
                        return Bridge.getDefaultValue(T);
                    }, T);
                }
            },
            methods: {
                IsCompatibleObject: function (value) {
                    return ((Bridge.is(value, T)) || (value == null && Bridge.getDefaultValue(T) == null));
                }
            }
        },
        fields: {
            _items: null,
            _size: 0,
            _version: 0
        },
        props: {
            Capacity: {
                get: function () {
                    return this._items.length;
                },
                set: function (value) {
                    if (value < this._size) {
                        throw new System.ArgumentOutOfRangeException.$ctor1("value");
                    }

                    if (value !== this._items.length) {
                        if (value > 0) {
                            var newItems = System.Array.init(value, function (){
                                return Bridge.getDefaultValue(T);
                            }, T);
                            if (this._size > 0) {
                                System.Array.copy(this._items, 0, newItems, 0, this._size);
                            }
                            this._items = newItems;
                        } else {
                            this._items = System.Collections.Generic.List$1(T)._emptyArray;
                        }
                    }
                }
            },
            Count: {
                get: function () {
                    return this._size;
                }
            },
            System$Collections$IList$IsFixedSize: {
                get: function () {
                    return false;
                }
            },
            System$Collections$Generic$ICollection$1$IsReadOnly: {
                get: function () {
                    return false;
                }
            },
            System$Collections$IList$IsReadOnly: {
                get: function () {
                    return false;
                }
            },
            System$Collections$ICollection$IsSynchronized: {
                get: function () {
                    return false;
                }
            },
            System$Collections$ICollection$SyncRoot: {
                get: function () {
                    return this;
                }
            }
        },
        alias: [
            "Count", ["System$Collections$Generic$IReadOnlyCollection$1$" + Bridge.getTypeAlias(T) + "$Count", "System$Collections$Generic$IReadOnlyCollection$1$Count"],
            "Count", "System$Collections$ICollection$Count",
            "Count", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$Count",
            "System$Collections$Generic$ICollection$1$IsReadOnly", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$IsReadOnly",
            "getItem", ["System$Collections$Generic$IReadOnlyList$1$" + Bridge.getTypeAlias(T) + "$getItem", "System$Collections$Generic$IReadOnlyList$1$getItem"],
            "setItem", ["System$Collections$Generic$IReadOnlyList$1$" + Bridge.getTypeAlias(T) + "$setItem", "System$Collections$Generic$IReadOnlyList$1$setItem"],
            "getItem", "System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(T) + "$getItem",
            "setItem", "System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(T) + "$setItem",
            "add", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$add",
            "clear", "System$Collections$IList$clear",
            "clear", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$clear",
            "contains", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$contains",
            "copyTo", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$copyTo",
            "System$Collections$Generic$IEnumerable$1$GetEnumerator", "System$Collections$Generic$IEnumerable$1$" + Bridge.getTypeAlias(T) + "$GetEnumerator",
            "indexOf", "System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(T) + "$indexOf",
            "insert", "System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(T) + "$insert",
            "remove", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$remove",
            "removeAt", "System$Collections$IList$removeAt",
            "removeAt", "System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(T) + "$removeAt"
        ],
        ctors: {
            ctor: function () {
                this.$initialize();
                this._items = System.Collections.Generic.List$1(T)._emptyArray;
            },
            $ctor2: function (capacity) {
                this.$initialize();
                if (capacity < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("capacity");
                }

                if (capacity === 0) {
                    this._items = System.Collections.Generic.List$1(T)._emptyArray;
                } else {
                    this._items = System.Array.init(capacity, function (){
                        return Bridge.getDefaultValue(T);
                    }, T);
                }
            },
            $ctor1: function (collection) {
                this.$initialize();
                if (collection == null) {
                    throw new System.ArgumentNullException.$ctor1("collection");
                }

                var c = Bridge.as(collection, System.Collections.Generic.ICollection$1(T));
                if (c != null) {
                    var count = System.Array.getCount(c, T);
                    if (count === 0) {
                        this._items = System.Collections.Generic.List$1(T)._emptyArray;
                    } else {
                        this._items = System.Array.init(count, function (){
                            return Bridge.getDefaultValue(T);
                        }, T);
                        System.Array.copyTo(c, this._items, 0, T);
                        this._size = count;
                    }
                } else {
                    this._size = 0;
                    this._items = System.Collections.Generic.List$1(T)._emptyArray;

                    var en = Bridge.getEnumerator(collection, T);
                    try {
                        while (en.System$Collections$IEnumerator$moveNext()) {
                            this.add(en[Bridge.geti(en, "System$Collections$Generic$IEnumerator$1$" + Bridge.getTypeAlias(T) + "$Current$1", "System$Collections$Generic$IEnumerator$1$Current$1")]);
                        }
                    }
                    finally {
                        if (Bridge.hasValue(en)) {
                            en.System$IDisposable$Dispose();
                        }
                    }
                }
            }
        },
        methods: {
            getItem: function (index) {
                if ((index >>> 0) >= (this._size >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.ctor();
                }
                return this._items[System.Array.index(index, this._items)];
            },
            setItem: function (index, value) {
                if ((index >>> 0) >= (this._size >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.ctor();
                }
                this._items[System.Array.index(index, this._items)] = value;
                this._version = (this._version + 1) | 0;
            },
            System$Collections$IList$getItem: function (index) {
                return this.getItem(index);
            },
            System$Collections$IList$setItem: function (index, value) {
                if (value == null && !(Bridge.getDefaultValue(T) == null)) {
                    throw new System.ArgumentNullException.$ctor1("value");
                }

                try {
                    this.setItem(index, Bridge.cast(Bridge.unbox(value, T), T));
                } catch ($e1) {
                    $e1 = System.Exception.create($e1);
                    if (Bridge.is($e1, System.InvalidCastException)) {
                        throw new System.ArgumentException.$ctor1("value");
                    } else {
                        throw $e1;
                    }
                }
            },
            add: function (item) {
                if (this._size === this._items.length) {
                    this.EnsureCapacity(((this._size + 1) | 0));
                }
                this._items[System.Array.index(Bridge.identity(this._size, (this._size = (this._size + 1) | 0)), this._items)] = item;
                this._version = (this._version + 1) | 0;
            },
            System$Collections$IList$add: function (item) {
                if (item == null && !(Bridge.getDefaultValue(T) == null)) {
                    throw new System.ArgumentNullException.$ctor1("item");
                }

                try {
                    this.add(Bridge.cast(Bridge.unbox(item, T), T));
                } catch ($e1) {
                    $e1 = System.Exception.create($e1);
                    if (Bridge.is($e1, System.InvalidCastException)) {
                        throw new System.ArgumentException.$ctor1("item");
                    } else {
                        throw $e1;
                    }
                }

                return ((this.Count - 1) | 0);
            },
            AddRange: function (collection) {
                this.InsertRange(this._size, collection);
            },
            AsReadOnly: function () {
                return new (System.Collections.ObjectModel.ReadOnlyCollection$1(T))(this);
            },
            BinarySearch$2: function (index, count, item, comparer) {
                if (index < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("index");
                }
                if (count < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("count");
                }
                if (((this._size - index) | 0) < count) {
                    throw new System.ArgumentException.ctor();
                }

                return System.Array.binarySearch(this._items, index, count, item, comparer);
            },
            BinarySearch: function (item) {
                return this.BinarySearch$2(0, this.Count, item, null);
            },
            BinarySearch$1: function (item, comparer) {
                return this.BinarySearch$2(0, this.Count, item, comparer);
            },
            clear: function () {
                if (this._size > 0) {
                    System.Array.fill(this._items, Bridge.getDefaultValue(T), 0, this._size);
                    this._size = 0;
                }
                this._version = (this._version + 1) | 0;
            },
            contains: function (item) {
                if (item == null) {
                    for (var i = 0; i < this._size; i = (i + 1) | 0) {
                        if (this._items[System.Array.index(i, this._items)] == null) {
                            return true;
                        }
                    }
                    return false;
                } else {
                    var c = System.Collections.Generic.EqualityComparer$1(T).def;
                    for (var i1 = 0; i1 < this._size; i1 = (i1 + 1) | 0) {
                        if (c.equals2(this._items[System.Array.index(i1, this._items)], item)) {
                            return true;
                        }
                    }
                    return false;
                }
            },
            System$Collections$IList$contains: function (item) {
                if (System.Collections.Generic.List$1(T).IsCompatibleObject(item)) {
                    return this.contains(Bridge.cast(Bridge.unbox(item, T), T));
                }
                return false;
            },
            ConvertAll: function (TOutput, converter) {
                if (Bridge.staticEquals(converter, null)) {
                    throw new System.ArgumentNullException.$ctor1("converter");
                }

                var list = new (System.Collections.Generic.List$1(TOutput)).$ctor2(this._size);
                for (var i = 0; i < this._size; i = (i + 1) | 0) {
                    list._items[System.Array.index(i, list._items)] = converter(this._items[System.Array.index(i, this._items)]);
                }
                list._size = this._size;
                return list;
            },
            CopyTo: function (array) {
                this.copyTo(array, 0);
            },
            System$Collections$ICollection$copyTo: function (array, arrayIndex) {
                if ((array != null) && (System.Array.getRank(array) !== 1)) {
                    throw new System.ArgumentException.$ctor1("array");
                }

                System.Array.copy(this._items, 0, array, arrayIndex, this._size);
            },
            CopyTo$1: function (index, array, arrayIndex, count) {
                if (((this._size - index) | 0) < count) {
                    throw new System.ArgumentException.ctor();
                }

                System.Array.copy(this._items, index, array, arrayIndex, count);
            },
            copyTo: function (array, arrayIndex) {
                System.Array.copy(this._items, 0, array, arrayIndex, this._size);
            },
            EnsureCapacity: function (min) {
                if (this._items.length < min) {
                    var newCapacity = this._items.length === 0 ? System.Collections.Generic.List$1(T)._defaultCapacity : Bridge.Int.mul(this._items.length, 2);
                    if ((newCapacity >>> 0) > 2146435071) {
                        newCapacity = 2146435071;
                    }
                    if (newCapacity < min) {
                        newCapacity = min;
                    }
                    this.Capacity = newCapacity;
                }
            },
            Exists: function (match) {
                return this.FindIndex$2(match) !== -1;
            },
            Find: function (match) {
                if (Bridge.staticEquals(match, null)) {
                    throw new System.ArgumentNullException.$ctor1("match");
                }

                for (var i = 0; i < this._size; i = (i + 1) | 0) {
                    if (match(this._items[System.Array.index(i, this._items)])) {
                        return this._items[System.Array.index(i, this._items)];
                    }
                }
                return Bridge.getDefaultValue(T);
            },
            FindAll: function (match) {
                if (Bridge.staticEquals(match, null)) {
                    throw new System.ArgumentNullException.$ctor1("match");
                }

                var list = new (System.Collections.Generic.List$1(T)).ctor();
                for (var i = 0; i < this._size; i = (i + 1) | 0) {
                    if (match(this._items[System.Array.index(i, this._items)])) {
                        list.add(this._items[System.Array.index(i, this._items)]);
                    }
                }
                return list;
            },
            FindIndex$2: function (match) {
                return this.FindIndex(0, this._size, match);
            },
            FindIndex$1: function (startIndex, match) {
                return this.FindIndex(startIndex, ((this._size - startIndex) | 0), match);
            },
            FindIndex: function (startIndex, count, match) {
                if ((startIndex >>> 0) > (this._size >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("startIndex");
                }

                if (count < 0 || startIndex > ((this._size - count) | 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("count");
                }

                if (Bridge.staticEquals(match, null)) {
                    throw new System.ArgumentNullException.$ctor1("match");
                }

                var endIndex = (startIndex + count) | 0;
                for (var i = startIndex; i < endIndex; i = (i + 1) | 0) {
                    if (match(this._items[System.Array.index(i, this._items)])) {
                        return i;
                    }
                }
                return -1;
            },
            FindLast: function (match) {
                if (Bridge.staticEquals(match, null)) {
                    throw new System.ArgumentNullException.$ctor1("match");
                }

                for (var i = (this._size - 1) | 0; i >= 0; i = (i - 1) | 0) {
                    if (match(this._items[System.Array.index(i, this._items)])) {
                        return this._items[System.Array.index(i, this._items)];
                    }
                }
                return Bridge.getDefaultValue(T);
            },
            FindLastIndex$2: function (match) {
                return this.FindLastIndex(((this._size - 1) | 0), this._size, match);
            },
            FindLastIndex$1: function (startIndex, match) {
                return this.FindLastIndex(startIndex, ((startIndex + 1) | 0), match);
            },
            FindLastIndex: function (startIndex, count, match) {
                if (Bridge.staticEquals(match, null)) {
                    throw new System.ArgumentNullException.$ctor1("match");
                }

                if (this._size === 0) {
                    if (startIndex !== -1) {
                        throw new System.ArgumentOutOfRangeException.$ctor1("startIndex");
                    }
                } else {
                    if ((startIndex >>> 0) >= (this._size >>> 0)) {
                        throw new System.ArgumentOutOfRangeException.$ctor1("startIndex");
                    }
                }

                if (count < 0 || ((((startIndex - count) | 0) + 1) | 0) < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("count");
                }

                var endIndex = (startIndex - count) | 0;
                for (var i = startIndex; i > endIndex; i = (i - 1) | 0) {
                    if (match(this._items[System.Array.index(i, this._items)])) {
                        return i;
                    }
                }
                return -1;
            },
            ForEach: function (action) {
                if (Bridge.staticEquals(action, null)) {
                    throw new System.ArgumentNullException.$ctor1("match");
                }

                var version = this._version;

                for (var i = 0; i < this._size; i = (i + 1) | 0) {
                    if (version !== this._version) {
                        break;
                    }
                    action(this._items[System.Array.index(i, this._items)]);
                }

                if (version !== this._version) {
                    throw new System.InvalidOperationException.ctor();
                }
            },
            GetEnumerator: function () {
                return new (System.Collections.Generic.List$1.Enumerator(T)).$ctor1(this);
            },
            System$Collections$Generic$IEnumerable$1$GetEnumerator: function () {
                return new (System.Collections.Generic.List$1.Enumerator(T)).$ctor1(this).$clone();
            },
            System$Collections$IEnumerable$GetEnumerator: function () {
                return new (System.Collections.Generic.List$1.Enumerator(T)).$ctor1(this).$clone();
            },
            GetRange: function (index, count) {
                if (index < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("index");
                }

                if (count < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("count");
                }

                if (((this._size - index) | 0) < count) {
                    throw new System.ArgumentException.ctor();
                }

                var list = new (System.Collections.Generic.List$1(T)).$ctor2(count);
                System.Array.copy(this._items, index, list._items, 0, count);
                list._size = count;
                return list;
            },
            indexOf: function (item) {
                return System.Array.indexOfT(this._items, item, 0, this._size);
            },
            System$Collections$IList$indexOf: function (item) {
                if (System.Collections.Generic.List$1(T).IsCompatibleObject(item)) {
                    return this.indexOf(Bridge.cast(Bridge.unbox(item, T), T));
                }
                return -1;
            },
            IndexOf: function (item, index) {
                if (index > this._size) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("index");
                }
                return System.Array.indexOfT(this._items, item, index, ((this._size - index) | 0));
            },
            IndexOf$1: function (item, index, count) {
                if (index > this._size) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("index");
                }

                if (count < 0 || index > ((this._size - count) | 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("count");
                }

                return System.Array.indexOfT(this._items, item, index, count);
            },
            insert: function (index, item) {
                if ((index >>> 0) > (this._size >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("index");
                }
                if (this._size === this._items.length) {
                    this.EnsureCapacity(((this._size + 1) | 0));
                }
                if (index < this._size) {
                    System.Array.copy(this._items, index, this._items, ((index + 1) | 0), ((this._size - index) | 0));
                }
                this._items[System.Array.index(index, this._items)] = item;
                this._size = (this._size + 1) | 0;
                this._version = (this._version + 1) | 0;
            },
            System$Collections$IList$insert: function (index, item) {
                if (item == null && !(Bridge.getDefaultValue(T) == null)) {
                    throw new System.ArgumentNullException.$ctor1("item");
                }

                try {
                    this.insert(index, Bridge.cast(Bridge.unbox(item, T), T));
                } catch ($e1) {
                    $e1 = System.Exception.create($e1);
                    if (Bridge.is($e1, System.InvalidCastException)) {
                        throw new System.ArgumentException.$ctor1("item");
                    } else {
                        throw $e1;
                    }
                }
            },
            InsertRange: function (index, collection) {
                if (collection == null) {
                    throw new System.ArgumentNullException.$ctor1("collection");
                }

                if ((index >>> 0) > (this._size >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("index");
                }

                var c = Bridge.as(collection, System.Collections.Generic.ICollection$1(T));
                if (c != null) {
                    var count = System.Array.getCount(c, T);
                    if (count > 0) {
                        this.EnsureCapacity(((this._size + count) | 0));
                        if (index < this._size) {
                            System.Array.copy(this._items, index, this._items, ((index + count) | 0), ((this._size - index) | 0));
                        }

                        if (Bridge.referenceEquals(this, c)) {
                            System.Array.copy(this._items, 0, this._items, index, index);
                            System.Array.copy(this._items, ((index + count) | 0), this._items, Bridge.Int.mul(index, 2), ((this._size - index) | 0));
                        } else {
                            var itemsToInsert = System.Array.init(count, function (){
                                return Bridge.getDefaultValue(T);
                            }, T);
                            System.Array.copyTo(c, itemsToInsert, 0, T);
                            System.Array.copy(itemsToInsert, 0, this._items, index, itemsToInsert.length);
                        }
                        this._size = (this._size + count) | 0;
                    }
                } else {
                    var en = Bridge.getEnumerator(collection, T);
                    try {
                        while (en.System$Collections$IEnumerator$moveNext()) {
                            this.insert(Bridge.identity(index, (index = (index + 1) | 0)), en[Bridge.geti(en, "System$Collections$Generic$IEnumerator$1$" + Bridge.getTypeAlias(T) + "$Current$1", "System$Collections$Generic$IEnumerator$1$Current$1")]);
                        }
                    }
                    finally {
                        if (Bridge.hasValue(en)) {
                            en.System$IDisposable$Dispose();
                        }
                    }
                }
                this._version = (this._version + 1) | 0;
            },
            LastIndexOf: function (item) {
                if (this._size === 0) {
                    return -1;
                } else {
                    return this.LastIndexOf$2(item, ((this._size - 1) | 0), this._size);
                }
            },
            LastIndexOf$1: function (item, index) {
                if (index >= this._size) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("index");
                }
                return this.LastIndexOf$2(item, index, ((index + 1) | 0));
            },
            LastIndexOf$2: function (item, index, count) {
                if ((this.Count !== 0) && (index < 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("index");
                }

                if ((this.Count !== 0) && (count < 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("count");
                }

                if (this._size === 0) {
                    return -1;
                }

                if (index >= this._size) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("index");
                }

                if (count > ((index + 1) | 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("count");
                }

                return System.Array.lastIndexOfT(this._items, item, index, count);
            },
            remove: function (item) {
                var index = this.indexOf(item);
                if (index >= 0) {
                    this.removeAt(index);
                    return true;
                }

                return false;
            },
            System$Collections$IList$remove: function (item) {
                if (System.Collections.Generic.List$1(T).IsCompatibleObject(item)) {
                    this.remove(Bridge.cast(Bridge.unbox(item, T), T));
                }
            },
            RemoveAll: function (match) {
                if (Bridge.staticEquals(match, null)) {
                    throw new System.ArgumentNullException.$ctor1("match");
                }

                var freeIndex = 0;

                while (freeIndex < this._size && !match(this._items[System.Array.index(freeIndex, this._items)])) {
                    freeIndex = (freeIndex + 1) | 0;
                }
                if (freeIndex >= this._size) {
                    return 0;
                }

                var current = (freeIndex + 1) | 0;
                while (current < this._size) {
                    while (current < this._size && match(this._items[System.Array.index(current, this._items)])) {
                        current = (current + 1) | 0;
                    }

                    if (current < this._size) {
                        this._items[System.Array.index(Bridge.identity(freeIndex, (freeIndex = (freeIndex + 1) | 0)), this._items)] = this._items[System.Array.index(Bridge.identity(current, (current = (current + 1) | 0)), this._items)];
                    }
                }

                System.Array.fill(this._items, Bridge.getDefaultValue(T), freeIndex, ((this._size - freeIndex) | 0));
                var result = (this._size - freeIndex) | 0;
                this._size = freeIndex;
                this._version = (this._version + 1) | 0;
                return result;
            },
            removeAt: function (index) {
                if ((index >>> 0) >= (this._size >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.ctor();
                }
                this._size = (this._size - 1) | 0;
                if (index < this._size) {
                    System.Array.copy(this._items, ((index + 1) | 0), this._items, index, ((this._size - index) | 0));
                }
                this._items[System.Array.index(this._size, this._items)] = Bridge.getDefaultValue(T);
                this._version = (this._version + 1) | 0;
            },
            RemoveRange: function (index, count) {
                if (index < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("index");
                }

                if (count < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("count");
                }

                if (((this._size - index) | 0) < count) {
                    throw new System.ArgumentException.ctor();
                }

                if (count > 0) {
                    var i = this._size;
                    this._size = (this._size - count) | 0;
                    if (index < this._size) {
                        System.Array.copy(this._items, ((index + count) | 0), this._items, index, ((this._size - index) | 0));
                    }
                    System.Array.fill(this._items, Bridge.getDefaultValue(T), this._size, count);
                    this._version = (this._version + 1) | 0;
                }
            },
            Reverse: function () {
                this.Reverse$1(0, this.Count);
            },
            Reverse$1: function (index, count) {
                if (index < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("index");
                }

                if (count < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("count");
                }

                if (((this._size - index) | 0) < count) {
                    throw new System.ArgumentException.ctor();
                }
                System.Array.reverse(this._items, index, count);
                this._version = (this._version + 1) | 0;
            },
            Sort: function () {
                this.Sort$3(0, this.Count, null);
            },
            Sort$1: function (comparer) {
                this.Sort$3(0, this.Count, comparer);
            },
            Sort$3: function (index, count, comparer) {
                if (index < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("index");
                }

                if (count < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("count");
                }

                if (((this._size - index) | 0) < count) {
                    throw new System.ArgumentException.ctor();
                }

                System.Array.sort(this._items, index, count, comparer);
                this._version = (this._version + 1) | 0;
            },
            Sort$2: function (comparison) {
                if (Bridge.staticEquals(comparison, null)) {
                    throw new System.ArgumentNullException.$ctor1("comparison");
                }

                if (this._size > 0) {
                    if (this._items.length === this._size) {
                        System.Array.sort(this._items, comparison);
                    } else {
                        var newItems = System.Array.init(this._size, function (){
                            return Bridge.getDefaultValue(T);
                        }, T);
                        System.Array.copy(this._items, 0, newItems, 0, this._size);
                        System.Array.sort(newItems, comparison);
                        System.Array.copy(newItems, 0, this._items, 0, this._size);
                    }
                }
            },
            ToArray: function () {

                var array = System.Array.init(this._size, function (){
                    return Bridge.getDefaultValue(T);
                }, T);
                System.Array.copy(this._items, 0, array, 0, this._size);
                return array;
            },
            TrimExcess: function () {
                var threshold = Bridge.Int.clip32(this._items.length * 0.9);
                if (this._size < threshold) {
                    this.Capacity = this._size;
                }
            },
            TrueForAll: function (match) {
                if (Bridge.staticEquals(match, null)) {
                    throw new System.ArgumentNullException.$ctor1("match");
                }

                for (var i = 0; i < this._size; i = (i + 1) | 0) {
                    if (!match(this._items[System.Array.index(i, this._items)])) {
                        return false;
                    }
                }
                return true;
            },
            toJSON: function () {
                var newItems = System.Array.init(this._size, function (){
                    return Bridge.getDefaultValue(T);
                }, T);
                if (this._size > 0) {
                    System.Array.copy(this._items, 0, newItems, 0, this._size);
                }

                return newItems;
            }
        }
    }; });

    // @source KeyNotFoundException.js

    Bridge.define("System.Collections.Generic.KeyNotFoundException", {
        inherits: [System.SystemException],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.SystemException.$ctor1.call(this, "The given key was not present in the dictionary.");
                this.HResult = -2146232969;
            },
            $ctor1: function (message) {
                this.$initialize();
                System.SystemException.$ctor1.call(this, message);
                this.HResult = -2146232969;
            },
            $ctor2: function (message, innerException) {
                this.$initialize();
                System.SystemException.$ctor2.call(this, message, innerException);
                this.HResult = -2146232969;
            }
        }
    });

    // @source List.js

    System.Collections.Generic.List$1.getElementType = function (type) {
        var interfaceType;

        if (System.String.startsWith(type.$$name, "System.Collections.Generic.IList")) {
            interfaceType = type;
        } else {
            var interfaces = Bridge.Reflection.getInterfaces(type);

            for (var j = 0; j < interfaces.length; j++) {
                if (System.String.startsWith(interfaces[j].$$name, "System.Collections.Generic.IList")) {
                    interfaceType = interfaces[j];

                    break;
                }
            }
        }

        return interfaceType ? Bridge.Reflection.getGenericArguments(interfaceType)[0] : null;
    };

    // @source CharEnumerator.js

    Bridge.define("System.CharEnumerator", {
        inherits: [System.Collections.IEnumerator,System.Collections.Generic.IEnumerator$1(System.Char),System.IDisposable,System.ICloneable],
        fields: {
            _str: null,
            _index: 0,
            _currentElement: 0
        },
        props: {
            System$Collections$IEnumerator$Current: {
                get: function () {
                    return Bridge.box(this.Current, System.Char, String.fromCharCode, System.Char.getHashCode);
                }
            },
            Current: {
                get: function () {
                    if (this._index === -1) {
                        throw new System.InvalidOperationException.$ctor1("Enumeration has not started. Call MoveNext.");
                    }
                    if (this._index >= this._str.length) {
                        throw new System.InvalidOperationException.$ctor1("Enumeration already finished.");
                    }
                    return this._currentElement;
                }
            }
        },
        alias: [
            "clone", "System$ICloneable$clone",
            "moveNext", "System$Collections$IEnumerator$moveNext",
            "Dispose", "System$IDisposable$Dispose",
            "Current", ["System$Collections$Generic$IEnumerator$1$System$Char$Current$1", "System$Collections$Generic$IEnumerator$1$Current$1"],
            "reset", "System$Collections$IEnumerator$reset"
        ],
        ctors: {
            ctor: function (str) {
                this.$initialize();
                this._str = str;
                this._index = -1;
            }
        },
        methods: {
            clone: function () {
                return Bridge.clone(this);
            },
            moveNext: function () {
                if (this._index < (((this._str.length - 1) | 0))) {
                    this._index = (this._index + 1) | 0;
                    this._currentElement = this._str.charCodeAt(this._index);
                    return true;
                } else {
                    this._index = this._str.length;
                }
                return false;
            },
            Dispose: function () {
                if (this._str != null) {
                    this._index = this._str.length;
                }
                this._str = null;
            },
            reset: function () {
                this._currentElement = 0;
                this._index = -1;
            }
        }
    });

    // @source String.js

    Bridge.define("System.String", {
        inherits: [System.IComparable, System.ICloneable, System.Collections.IEnumerable, System.Collections.Generic.IEnumerable$1(System.Char)],

        statics: {
            $is: function (instance) {
                return typeof (instance) === "string";
            },

            charCodeAt: function (str, idx) {
                idx = idx || 0;

                var code = str.charCodeAt(idx),
                    hi,
                    low;

                if (0xD800 <= code && code <= 0xDBFF) {
                    hi = code;
                    low = str.charCodeAt(idx + 1);

                    if (isNaN(low)) {
                        throw new System.Exception("High surrogate not followed by low surrogate");
                    }

                    return ((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000;
                }

                if (0xDC00 <= code && code <= 0xDFFF) {
                    return false;
                }

                return code;
            },

            fromCharCode: function (codePt) {
                if (codePt > 0xFFFF) {
                    codePt -= 0x10000;

                    return String.fromCharCode(0xD800 + (codePt >> 10), 0xDC00 + (codePt & 0x3FF));
                }

                return String.fromCharCode(codePt);
            },

            fromCharArray: function (chars, startIndex, length) {
                if (chars == null) {
                    throw new System.ArgumentNullException.$ctor1("chars");
                }

                if (startIndex < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("startIndex");
                }

                if (length < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("length");
                }

                if (chars.length - startIndex < length) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("startIndex");
                }

                var result = "";

                startIndex = startIndex || 0;
                length = Bridge.isNumber(length) ? length : chars.length;

                if ((startIndex + length) > chars.length) {
                    length = chars.length - startIndex;
                }

                for (var i = 0; i < length; i++) {
                    var ch = chars[i + startIndex] | 0;

                    result += String.fromCharCode(ch);
                }

                return result;
            },

            lastIndexOf: function (s, search, startIndex, count) {
                var index = s.lastIndexOf(search, startIndex);

                return (index < (startIndex - count + 1)) ? -1 : index;
            },

            lastIndexOfAny: function (s, chars, startIndex, count) {
                var length = s.length;

                if (!length) {
                    return -1;
                }

                chars = String.fromCharCode.apply(null, chars);
                startIndex = startIndex || length - 1;
                count = count || length;

                var endIndex = startIndex - count + 1;

                if (endIndex < 0) {
                    endIndex = 0;
                }

                for (var i = startIndex; i >= endIndex; i--) {
                    if (chars.indexOf(s.charAt(i)) >= 0) {
                        return i;
                    }
                }

                return -1;
            },

            isNullOrWhiteSpace: function (s) {
                if (!s) {
                    return true;
                }

                return System.Char.isWhiteSpace(s);
            },

            isNullOrEmpty: function (s) {
                return !s;
            },

            fromCharCount: function (c, count) {
                if (count >= 0) {
                    return String(Array(count + 1).join(String.fromCharCode(c)));
                } else {
                    throw new System.ArgumentOutOfRangeException.$ctor4("count", "cannot be less than zero");
                }
            },

            format: function (format, args) {
                return System.String._format(System.Globalization.CultureInfo.getCurrentCulture(), format, Array.isArray(args) && arguments.length == 2 ? args : Array.prototype.slice.call(arguments, 1));
            },

            formatProvider: function (provider, format, args) {
                return System.String._format(provider, format, Array.isArray(args) && arguments.length == 3 ? args : Array.prototype.slice.call(arguments, 2));
            },

            _format: function (provider, format, args) {
                if (format == null) {
                    throw new System.ArgumentNullException.$ctor1("format");
                }

                var reverse = function (s) {
                    return s.split("").reverse().join("");
                };

                format = reverse(reverse(format.replace(/\{\{/g, function (m) {
                    return String.fromCharCode(1, 1);
                })).replace(/\}\}/g, function (m) {
                    return String.fromCharCode(2, 2);
                }));

                var me = this,
                    _formatRe = /(\{+)((\d+|[a-zA-Z_$]\w+(?:\.[a-zA-Z_$]\w+|\[\d+\])*)(?:\,(-?\d*))?(?:\:([^\}]*))?)(\}+)|(\{+)|(\}+)/g,
                    fn = this.decodeBraceSequence;

                format = format.replace(_formatRe, function (m, openBrace, elementContent, index, align, format, closeBrace, repeatOpenBrace, repeatCloseBrace) {
                    if (repeatOpenBrace) {
                        return fn(repeatOpenBrace);
                    }

                    if (repeatCloseBrace) {
                        return fn(repeatCloseBrace);
                    }

                    if (openBrace.length % 2 === 0 || closeBrace.length % 2 === 0) {
                        return fn(openBrace) + elementContent + fn(closeBrace);
                    }

                    return fn(openBrace, true) + me.handleElement(provider, index, align, format, args) + fn(closeBrace, true);
                });

                return format.replace(/(\x01\x01)|(\x02\x02)/g, function (m) {
                    if (m == String.fromCharCode(1, 1)) {
                        return "{";
                    }

                    if (m == String.fromCharCode(2, 2)) {
                        return "}";
                    }
                });
            },

            handleElement: function (provider, index, alignment, formatStr, args) {
                var value;

                index = parseInt(index, 10);

                if (index > args.length - 1) {
                    throw new System.FormatException.$ctor1("Input string was not in a correct format.");
                }

                value = args[index];

                if (value == null) {
                    value = "";
                }

                if (formatStr && value.$boxed && value.type.$kind === "enum") {
                    value = System.Enum.format(value.type, value.v, formatStr);
                } else if (formatStr && value.$boxed && value.type.format) {
                    value = value.type.format(Bridge.unbox(value, true), formatStr, provider);
                } else if (formatStr && Bridge.is(value, System.IFormattable)) {
                    value = Bridge.format(Bridge.unbox(value, true), formatStr, provider);
                } if (Bridge.isNumber(value)) {
                    value = Bridge.Int.format(value, formatStr, provider);
                } else if (Bridge.isDate(value)) {
                    value = System.DateTime.format(value, formatStr, provider);
                } else {
                    value = "" + Bridge.toString(value);
                }

                if (alignment) {
                    alignment = parseInt(alignment, 10);

                    if (!Bridge.isNumber(alignment)) {
                        alignment = null;
                    }
                }

                return System.String.alignString(Bridge.toString(value), alignment);
            },

            decodeBraceSequence: function (braces, remove) {
                return braces.substr(0, (braces.length + (remove ? 0 : 1)) / 2);
            },

            alignString: function (str, alignment, pad, dir, cut) {
                if (str == null || !alignment) {
                    return str;
                }

                if (!pad) {
                    pad = " ";
                }

                if (Bridge.isNumber(pad)) {
                    pad = String.fromCharCode(pad);
                }

                if (!dir) {
                    dir = alignment < 0 ? 1 : 2;
                }

                alignment = Math.abs(alignment);

                if (cut && (str.length > alignment)) {
                    str = str.substring(0, alignment);
                }

                if (alignment + 1 >= str.length) {
                    switch (dir) {
                        case 2:
                            str = Array(alignment + 1 - str.length).join(pad) + str;
                            break;

                        case 3:
                            var padlen = alignment - str.length,
                                right = Math.ceil(padlen / 2),
                                left = padlen - right;

                            str = Array(left + 1).join(pad) + str + Array(right + 1).join(pad);
                            break;

                        case 1:
                        default:
                            str = str + Array(alignment + 1 - str.length).join(pad);
                            break;
                    }
                }

                return str;
            },

            startsWith: function (str, prefix) {
                if (!prefix.length) {
                    return true;
                }

                if (prefix.length > str.length) {
                    return false;
                }

                return System.String.equals(str.slice(0, prefix.length), prefix, arguments[2]);
            },

            endsWith: function (str, suffix) {
                if (!suffix.length) {
                    return true;
                }

                if (suffix.length > str.length) {
                    return false;
                }

                return System.String.equals(str.slice(str.length - suffix.length, str.length), suffix, arguments[2]);
            },

            contains: function (str, value) {
                if (value == null) {
                    throw new System.ArgumentNullException();
                }

                if (str == null) {
                    return false;
                }

                return str.indexOf(value) > -1;
            },

            indexOfAny: function (str, anyOf) {
                if (anyOf == null) {
                    throw new System.ArgumentNullException();
                }

                if (str == null || str === "") {
                    return -1;
                }

                var startIndex = (arguments.length > 2) ? arguments[2] : 0;

                if (startIndex < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("startIndex", "startIndex cannot be less than zero");
                }

                var length = str.length - startIndex;

                if (arguments.length > 3 && arguments[3] != null) {
                    length = arguments[3];
                }

                if (length < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("length", "must be non-negative");
                }

                if (length > str.length - startIndex) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("length", "Index and length must refer to a location within the string");
                }

                var s = str.substr(startIndex, length);

                for (var i = 0; i < anyOf.length; i++) {
                    var c = String.fromCharCode(anyOf[i]),
                        index = s.indexOf(c);

                    if (index > -1) {
                        return index + startIndex;
                    }
                }

                return -1;
            },

            indexOf: function (str, value) {
                if (value == null) {
                    throw new System.ArgumentNullException();
                }

                if (str == null || str === "") {
                    return -1;
                }

                var startIndex = (arguments.length > 2) ? arguments[2] : 0;

                if (startIndex < 0 || startIndex > str.length) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("startIndex", "startIndex cannot be less than zero and must refer to a location within the string");
                }

                if (value === "") {
                    return (arguments.length > 2) ? startIndex : 0;
                }

                var length = str.length - startIndex;

                if (arguments.length > 3 && arguments[3] != null) {
                    length = arguments[3];
                }

                if (length < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("length", "must be non-negative");
                }

                if (length > str.length - startIndex) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("length", "Index and length must refer to a location within the string");
                }

                var s = str.substr(startIndex, length),
                    index = (arguments.length === 5 && arguments[4] % 2 !== 0) ? s.toLocaleUpperCase().indexOf(value.toLocaleUpperCase()) : s.indexOf(value);

                if (index > -1) {
                    if (arguments.length === 5) {
                        // StringComparison
                        return (System.String.compare(value, s.substr(index, value.length), arguments[4]) === 0) ? index + startIndex : -1;
                    } else {
                        return index + startIndex;
                    }
                }

                return -1;
            },

            equals: function () {
                return System.String.compare.apply(this, arguments) === 0;
            },

            swapCase: function (letters) {
                return letters.replace(/\w/g, function (c) {
                    if (c === c.toLowerCase()) {
                        return c.toUpperCase();
                    } else {
                        return c.toLowerCase();
                    }
                });
            },

            compare: function (strA, strB) {
                if (strA == null) {
                    return (strB == null) ? 0 : -1;
                }

                if (strB == null) {
                    return 1;
                }

                if (arguments.length >= 3) {
                    if (!Bridge.isBoolean(arguments[2])) {
                        // StringComparison
                        switch (arguments[2]) {
                            case 1: // CurrentCultureIgnoreCase
                                return strA.localeCompare(strB, System.Globalization.CultureInfo.getCurrentCulture().name, {
                                    sensitivity: "accent"
                                });
                            case 2: // InvariantCulture
                                return strA.localeCompare(strB, System.Globalization.CultureInfo.invariantCulture.name);
                            case 3: // InvariantCultureIgnoreCase
                                return strA.localeCompare(strB, System.Globalization.CultureInfo.invariantCulture.name, {
                                    sensitivity: "accent"
                                });
                            case 4: // Ordinal
                                return (strA === strB) ? 0 : ((strA > strB) ? 1 : -1);
                            case 5: // OrdinalIgnoreCase
                                return (strA.toUpperCase() === strB.toUpperCase()) ? 0 : ((strA.toUpperCase() > strB.toUpperCase()) ? 1 : -1);
                            case 0: // CurrentCulture
                            default:
                                break;
                        }
                    } else {
                        // ignoreCase
                        if (arguments[2]) {
                            strA = strA.toLocaleUpperCase();
                            strB = strB.toLocaleUpperCase();
                        }

                        if (arguments.length === 4) {
                            // CultureInfo
                            return strA.localeCompare(strB, arguments[3].name);
                        }
                    }
                }

                return strA.localeCompare(strB);
            },

            toCharArray: function (str, startIndex, length) {
                if (startIndex < 0 || startIndex > str.length || startIndex > str.length - length) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("startIndex", "startIndex cannot be less than zero and must refer to a location within the string");
                }

                if (length < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("length", "must be non-negative");
                }

                if (!Bridge.hasValue(startIndex)) {
                    startIndex = 0;
                }

                if (!Bridge.hasValue(length)) {
                    length = str.length;
                }

                var arr = [];

                for (var i = startIndex; i < startIndex + length; i++) {
                    arr.push(str.charCodeAt(i));
                }

                return arr;
            },

            escape: function (str) {
                return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
            },

            replaceAll: function (str, a, b) {
                var reg = new RegExp(System.String.escape(a), "g");

                return str.replace(reg, b);
            },

            insert: function (index, strA, strB) {
                return index > 0 ? (strA.substring(0, index) + strB + strA.substring(index, strA.length)) : (strB + strA);
            },

            remove: function (s, index, count) {
                if (s == null) {
                    throw new System.NullReferenceException();
                }

                if (index < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("startIndex", "StartIndex cannot be less than zero");
                }

                if (count != null) {
                    if (count < 0) {
                        throw new System.ArgumentOutOfRangeException.$ctor4("count", "Count cannot be less than zero");
                    }

                    if (count > s.length - index) {
                        throw new System.ArgumentOutOfRangeException.$ctor4("count", "Index and count must refer to a location within the string");
                    }
                } else {
                    if (index >= s.length) {
                        throw new System.ArgumentOutOfRangeException.$ctor4("startIndex", "startIndex must be less than length of string");
                    }
                }

                if (count == null || ((index + count) > s.length)) {
                    return s.substr(0, index);
                }

                return s.substr(0, index) + s.substr(index + count);
            },

            split: function (s, strings, limit, options) {
                var re = (!Bridge.hasValue(strings) || strings.length === 0) ? new RegExp("\\s", "g") : new RegExp(strings.map(System.String.escape).join("|"), "g"),
                    res = [],
                    m,
                    i;

                for (i = 0; ; i = re.lastIndex) {
                    if (m = re.exec(s)) {
                        if (options !== 1 || m.index > i) {
                            if (res.length === limit - 1) {
                                res.push(s.substr(i));

                                return res;
                            } else {
                                res.push(s.substring(i, m.index));
                            }
                        }
                    } else {
                        if (options !== 1 || i !== s.length) {
                            res.push(s.substr(i));
                        }

                        return res;
                    }
                }
            },

            trimEnd: function (str, chars) {
                return str.replace(chars ? new RegExp("[" + System.String.escape(String.fromCharCode.apply(null, chars)) + "]+$") : /\s*$/, "");
            },

            trimStart: function (str, chars) {
                return str.replace(chars ? new RegExp("^[" + System.String.escape(String.fromCharCode.apply(null, chars)) + "]+") : /^\s*/, "");
            },

            trim: function (str, chars) {
                return System.String.trimStart(System.String.trimEnd(str, chars), chars);
            },

            trimStartZeros: function (str) {
                return str.replace(new RegExp("^[ 0+]+(?=.)"), "");
            },

            concat: function (values) {
                var list = (arguments.length == 1 && Array.isArray(values)) ? values : [].slice.call(arguments),
                    s = "";

                for (var i = 0; i < list.length; i++) {
                    s += list[i] == null ? "" : Bridge.toString(list[i]);
                }

                return s;
            },

            copyTo: function (str, sourceIndex, destination, destinationIndex, count) {
                if (destination == null) {
                    throw new System.ArgumentNullException.$ctor1("destination");
                }

                if (str == null) {
                    throw new System.ArgumentNullException.$ctor1("str");
                }

                if (count < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("count");
                }

                if (sourceIndex < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("sourceIndex");
                }

                if (count > str.length - sourceIndex) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("sourceIndex");
                }

                if (destinationIndex > destination.length - count || destinationIndex < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("destinationIndex");
                }

                if (count > 0) {
                    for (var i = 0; i < count; i++) {
                        destination[destinationIndex + i] = str.charCodeAt(sourceIndex + i);
                    }
                }
            }
        }
    });

    Bridge.Class.addExtend(System.String, [System.IComparable$1(System.String), System.IEquatable$1(System.String)]);

    // @source Task.js

    Bridge.define("System.Threading.Tasks.Task", {
        inherits: [System.IDisposable],

        config: {
            alias: [
                "dispose", "System$IDisposable$Dispose"
            ]
        },

        ctor: function (action, state) {
            this.$initialize();
            this.action = action;
            this.state = state;
            this.exception = null;
            this.status = System.Threading.Tasks.TaskStatus.created;
            this.callbacks = [];
            this.result = null;
        },

        statics: {
            queue: [],

            runQueue: function () {
                var queue = System.Threading.Tasks.Task.queue.slice(0);
                System.Threading.Tasks.Task.queue = [];

                for (var i = 0; i < queue.length; i++) {
                    queue[i]();
                }
            },

            schedule: function (fn) {
                System.Threading.Tasks.Task.queue.push(fn);
                Bridge.setImmediate(System.Threading.Tasks.Task.runQueue);
            },

            delay: function (delay, state) {
                var tcs = new System.Threading.Tasks.TaskCompletionSource();

                setTimeout(function () {
                    tcs.setResult(state);
                }, delay);

                return tcs.task;
            },

            fromResult: function (result, T) {
                var t = new (System.Threading.Tasks.Task$1(T || System.Object))();

                t.status = System.Threading.Tasks.TaskStatus.ranToCompletion;
                t.result = result;

                return t;
            },

            run: function (fn) {
                var tcs = new System.Threading.Tasks.TaskCompletionSource();

                System.Threading.Tasks.Task.schedule(function () {
                    try {
                        tcs.setResult(fn());
                    } catch (e) {
                        tcs.setException(System.Exception.create(e));
                    }
                });

                return tcs.task;
            },

            whenAll: function (tasks) {
                var tcs = new System.Threading.Tasks.TaskCompletionSource(),
                    result,
                    executing,
                    cancelled = false,
                    exceptions = [],
                    i;

                if (Bridge.is(tasks, System.Collections.IEnumerable)) {
                    tasks = Bridge.toArray(tasks);
                } else if (!Bridge.isArray(tasks)) {
                    tasks = Array.prototype.slice.call(arguments, 0);
                }

                if (tasks.length === 0) {
                    tcs.setResult([]);

                    return tcs.task;
                }

                executing = tasks.length;
                result = new Array(tasks.length);

                for (i = 0; i < tasks.length; i++) {
                    (function (i) {
                        tasks[i].continueWith(function (t) {
                            switch (t.status) {
                                case System.Threading.Tasks.TaskStatus.ranToCompletion:
                                    result[i] = t.getResult();
                                    break;
                                case System.Threading.Tasks.TaskStatus.canceled:
                                    cancelled = true;
                                    break;
                                case System.Threading.Tasks.TaskStatus.faulted:
                                    System.Array.addRange(exceptions, t.exception.innerExceptions);
                                    break;
                                default:
                                    throw new System.InvalidOperationException.$ctor1("Invalid task status: " + t.status);
                            }

                            if (--executing === 0) {
                                if (exceptions.length > 0) {
                                    tcs.setException(exceptions);
                                } else if (cancelled) {
                                    tcs.setCanceled();
                                } else {
                                    tcs.setResult(result);
                                }
                            }
                        });
                    })(i);
                }

                return tcs.task;
            },

            whenAny: function (tasks) {
                if (Bridge.is(tasks, System.Collections.IEnumerable)) {
                    tasks = Bridge.toArray(tasks);
                } else if (!Bridge.isArray(tasks)) {
                    tasks = Array.prototype.slice.call(arguments, 0);
                }

                if (!tasks.length) {
                    throw new System.ArgumentException.$ctor1("At least one task is required");
                }

                var tcs = new System.Threading.Tasks.TaskCompletionSource(),
                    i;

                for (i = 0; i < tasks.length; i++) {
                    tasks[i].continueWith(function (t) {
                        switch (t.status) {
                            case System.Threading.Tasks.TaskStatus.ranToCompletion:
                                tcs.trySetResult(t);
                                break;
                            case System.Threading.Tasks.TaskStatus.canceled:
                                tcs.trySetCanceled();
                                break;
                            case System.Threading.Tasks.TaskStatus.faulted:
                                tcs.trySetException(t.exception.innerExceptions);
                                break;
                            default:
                                throw new System.InvalidOperationException.$ctor1("Invalid task status: " + t.status);
                        }
                    });
                }

                return tcs.task;
            },

            fromCallback: function (target, method) {
                var tcs = new System.Threading.Tasks.TaskCompletionSource(),
                    args = Array.prototype.slice.call(arguments, 2),
                    callback;

                callback = function (value) {
                    tcs.setResult(value);
                };

                args.push(callback);

                target[method].apply(target, args);

                return tcs.task;
            },

            fromCallbackResult: function (target, method, resultHandler) {
                var tcs = new System.Threading.Tasks.TaskCompletionSource(),
                    args = Array.prototype.slice.call(arguments, 3),
                    callback;

                callback = function (value) {
                    tcs.setResult(value);
                };

                resultHandler(args, callback);

                target[method].apply(target, args);

                return tcs.task;
            },

            fromCallbackOptions: function (target, method, name) {
                var tcs = new System.Threading.Tasks.TaskCompletionSource(),
                    args = Array.prototype.slice.call(arguments, 3),
                    callback;

                callback = function (value) {
                    tcs.setResult(value);
                };

                args[0] = args[0] || {};
                args[0][name] = callback;

                target[method].apply(target, args);

                return tcs.task;
            },

            fromPromise: function (promise, handler, errorHandler, progressHandler) {
                var tcs = new System.Threading.Tasks.TaskCompletionSource();

                if (!promise.then) {
                    promise = promise.promise();
                }

                if (typeof (handler) === 'number') {
                    handler = (function (i) {
                        return function () {
                            return arguments[i >= 0 ? i : (arguments.length + i)];
                        };
                    })(handler);
                } else if (typeof (handler) !== 'function') {
                    handler = function () {
                        return Array.prototype.slice.call(arguments, 0);
                    };
                }

                promise.then(function () {
                    tcs.setResult(handler ? handler.apply(null, arguments) : Array.prototype.slice.call(arguments, 0));
                }, function () {
                    tcs.setException(errorHandler ? errorHandler.apply(null, arguments) : new Bridge.PromiseException(Array.prototype.slice.call(arguments, 0)));
                }, progressHandler);

                return tcs.task;
            }
        },

        continueWith: function (continuationAction, raise) {
            var tcs = new System.Threading.Tasks.TaskCompletionSource(),
                me = this,
                fn = raise ? function () {
                    tcs.setResult(continuationAction(me));
                } : function () {
                    try {
                        tcs.setResult(continuationAction(me));
                    } catch (e) {
                        tcs.setException(System.Exception.create(e));
                    }
                };

            if (this.isCompleted()) {
                //System.Threading.Tasks.Task.schedule(fn);
                System.Threading.Tasks.Task.queue.push(fn);
                System.Threading.Tasks.Task.runQueue();
            } else {
                this.callbacks.push(fn);
            }

            return tcs.task;
        },

        start: function () {
            if (this.status !== System.Threading.Tasks.TaskStatus.created) {
                throw new System.InvalidOperationException.$ctor1("Task was already started.");
            }

            var me = this;

            this.status = System.Threading.Tasks.TaskStatus.running;

            System.Threading.Tasks.Task.schedule(function () {
                try {
                    var result = me.action(me.state);

                    delete me.action;
                    delete me.state;

                    me.complete(result);
                } catch (e) {
                    me.fail(new System.AggregateException(null, [System.Exception.create(e)]));
                }
            });
        },

        runCallbacks: function () {
            var me = this;

            for (var i = 0; i < me.callbacks.length; i++) {
                me.callbacks[i](me);
            }

            delete me.callbacks;
        },

        complete: function (result) {
            if (this.isCompleted()) {
                return false;
            }

            this.result = result;
            this.status = System.Threading.Tasks.TaskStatus.ranToCompletion;
            this.runCallbacks();

            return true;
        },

        fail: function (error) {
            if (this.isCompleted()) {
                return false;
            }

            this.exception = error;
            this.status = System.Threading.Tasks.TaskStatus.faulted;
            this.runCallbacks();

            return true;
        },

        cancel: function () {
            if (this.isCompleted()) {
                return false;
            }

            this.status = System.Threading.Tasks.TaskStatus.canceled;
            this.runCallbacks();

            return true;
        },

        isCanceled: function () {
            return this.status === System.Threading.Tasks.TaskStatus.canceled;
        },

        isCompleted: function () {
            return this.status === System.Threading.Tasks.TaskStatus.ranToCompletion || this.status === System.Threading.Tasks.TaskStatus.canceled || this.status === System.Threading.Tasks.TaskStatus.faulted;
        },

        isFaulted: function () {
            return this.status === System.Threading.Tasks.TaskStatus.faulted;
        },

        _getResult: function (awaiting) {
            switch (this.status) {
                case System.Threading.Tasks.TaskStatus.ranToCompletion:
                    return this.result;
                case System.Threading.Tasks.TaskStatus.canceled:
                    var ex = new System.Threading.Tasks.TaskCanceledException.$ctor3(this);

                    throw awaiting ? ex : new System.AggregateException(null, [ex]);
                case System.Threading.Tasks.TaskStatus.faulted:
                    throw awaiting ? (this.exception.innerExceptions.Count > 0 ? this.exception.innerExceptions.getItem(0) : null) : this.exception;
                default:
                    throw new System.InvalidOperationException.$ctor1("Task is not yet completed.");
            }
        },

        getResult: function () {
            return this._getResult(false);
        },

        dispose: function () {},

        getAwaiter: function () {
            return this;
        },

        getAwaitedResult: function () {
            return this._getResult(true);
        }
    });

    Bridge.define("System.Threading.Tasks.Task$1", function (T) {
        return {
            inherits: [System.Threading.Tasks.Task],
            ctor: function (action, state) {
                this.$initialize();
                System.Threading.Tasks.Task.ctor.call(this, action, state);
            }
        };
    });

    Bridge.define("System.Threading.Tasks.TaskStatus", {
        $kind: "enum",
        $statics: {
            created: 0,
            waitingForActivation: 1,
            waitingToRun: 2,
            running: 3,
            waitingForChildrenToComplete: 4,
            ranToCompletion: 5,
            canceled: 6,
            faulted: 7
        }
    });

    Bridge.define("System.Threading.Tasks.TaskCompletionSource", {
        ctor: function () {
            this.$initialize();
            this.task = new System.Threading.Tasks.Task();
            this.task.status = System.Threading.Tasks.TaskStatus.running;
        },

        setCanceled: function () {
            if (!this.task.cancel()) {
                throw new System.InvalidOperationException.$ctor1("Task was already completed.");
            }
        },

        setResult: function (result) {
            if (!this.task.complete(result)) {
                throw new System.InvalidOperationException.$ctor1("Task was already completed.");
            }
        },

        setException: function (exception) {
            if (!this.trySetException(exception)) {
                throw new System.InvalidOperationException.$ctor1("Task was already completed.");
            }
        },

        trySetCanceled: function () {
            return this.task.cancel();
        },

        trySetResult: function (result) {
            return this.task.complete(result);
        },

        trySetException: function (exception) {
            if (Bridge.is(exception, System.Exception)) {
                exception = [exception];
            }

            return this.task.fail(new System.AggregateException(null, exception));
        }
    });

    Bridge.define("System.Threading.CancellationTokenSource", {
        inherits: [System.IDisposable],

        config: {
            alias: [
                "dispose", "System$IDisposable$Dispose"
            ]
        },

        ctor: function (delay) {
            this.$initialize();
            this.timeout = typeof delay === "number" && delay >= 0 ? setTimeout(Bridge.fn.bind(this, this.cancel), delay, -1) : null;
            this.isCancellationRequested = false;
            this.token = new System.Threading.CancellationToken(this);
            this.handlers = [];
        },

        cancel: function (throwFirst) {
            if (this.isCancellationRequested) {
                return;
            }

            this.isCancellationRequested = true;

            var x = [],
                h = this.handlers;

            this.clean();

            for (var i = 0; i < h.length; i++) {
                try {
                    h[i].f(h[i].s);
                } catch (ex) {
                    if (throwFirst && throwFirst !== -1) {
                        throw ex;
                    }

                    x.push(ex);
                }
            }

            if (x.length > 0 && throwFirst !== -1) {
                throw new System.AggregateException(null, x);
            }
        },

        cancelAfter: function (delay) {
            if (this.isCancellationRequested) {
                return;
            }

            if (this.timeout) {
                clearTimeout(this.timeout);
            }

            this.timeout = setTimeout(Bridge.fn.bind(this, this.cancel), delay, -1);
        },

        register: function (f, s) {
            if (this.isCancellationRequested) {
                f(s);

                return new System.Threading.CancellationTokenRegistration();
            } else {
                var o = {
                    f: f,
                    s: s
                };

                this.handlers.push(o);

                return new System.Threading.CancellationTokenRegistration(this, o);
            }
        },

        deregister: function (o) {
            var ix = this.handlers.indexOf(o);

            if (ix >= 0) {
                this.handlers.splice(ix, 1);
            }
        },

        dispose: function () {
            this.clean();
        },

        clean: function () {
            if (this.timeout) {
                clearTimeout(this.timeout);
            }

            this.timeout = null;
            this.handlers = [];

            if (this.links) {
                for (var i = 0; i < this.links.length; i++) {
                    this.links[i].dispose();
                }

                this.links = null;
            }
        },

        statics: {
            createLinked: function () {
                var cts = new System.Threading.CancellationTokenSource();

                cts.links = [];

                var d = Bridge.fn.bind(cts, cts.cancel);

                for (var i = 0; i < arguments.length; i++) {
                    cts.links.push(arguments[i].register(d));
                }

                return cts;
            }
        }
    });

    Bridge.define("System.Threading.CancellationToken", {
         $kind: "struct",

        ctor: function (source) {
            this.$initialize();

            if (!Bridge.is(source, System.Threading.CancellationTokenSource)) {
                source = source ? System.Threading.CancellationToken.sourceTrue : System.Threading.CancellationToken.sourceFalse;
            }

            this.source = source;
        },

        getCanBeCanceled: function () {
            return !this.source.uncancellable;
        },

        getIsCancellationRequested: function () {
            return this.source.isCancellationRequested;
        },

        throwIfCancellationRequested: function () {
            if (this.source.isCancellationRequested) {
                throw new System.OperationCanceledException.$ctor1(this);
            }
        },

        register: function (cb, s) {
            return this.source.register(cb, s);
        },

        getHashCode: function () {
            return Bridge.getHashCode(this.source);
        },

        equals: function (other) {
            return other.source === this.source;
        },

        equalsT: function (other) {
            return other.source === this.source;
        },

        statics: {
            sourceTrue: {
                isCancellationRequested: true,
                register: function (f, s) {
                    f(s);

                    return new System.Threading.CancellationTokenRegistration();
                }
            },
            sourceFalse: {
                uncancellable: true,
                isCancellationRequested: false,
                register: function () {
                    return new System.Threading.CancellationTokenRegistration();
                }
            },
            getDefaultValue: function () {
                return new System.Threading.CancellationToken();
            }
        }
    });

    System.Threading.CancellationToken.none = new System.Threading.CancellationToken();

    Bridge.define("System.Threading.CancellationTokenRegistration", {
        inherits: function () {
            return [System.IDisposable, System.IEquatable$1(System.Threading.CancellationTokenRegistration)];
        },

        $kind: "struct",

        config: {
            alias: [
                "dispose", "System$IDisposable$Dispose"
            ]
        },

        ctor: function (cts, o) {
            this.$initialize();
            this.cts = cts;
            this.o = o;
        },

        dispose: function () {
            if (this.cts) {
                this.cts.deregister(this.o);
                this.cts = this.o = null;
            }
        },

        equalsT: function (o) {
            return this === o;
        },

        equals: function (o) {
            return this === o;
        },

        statics: {
            getDefaultValue: function () {
                return new System.Threading.CancellationTokenRegistration();
            }
        }
    });

    // @source Validation.js

    var validation = {
        isNull: function (value) {
            return !Bridge.isDefined(value, true);
        },

        isEmpty: function (value) {
            return value == null || value.length === 0 || Bridge.is(value, System.Collections.ICollection) ? value.getCount() === 0 : false;
        },

        isNotEmptyOrWhitespace: function (value) {
            return Bridge.isDefined(value, true) && !(/^$|\s+/.test(value));
        },

        isNotNull: function (value) {
            return Bridge.isDefined(value, true);
        },

        isNotEmpty: function (value) {
            return !Bridge.Validation.isEmpty(value);
        },

        email: function (value) {
            var re = /^(")?(?:[^\."])(?:(?:[\.])?(?:[\w\-!#$%&'*+/=?^_`{|}~]))*\1@(\w[\-\w]*\.){1,5}([A-Za-z]){2,6}$/;

            return re.test(value);
        },

        url: function (value) {
            var re = /(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:\.\d{1,3}){3})(?!(?:\.\d{1,3}){2})(?!\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,}))\.?)(?::\d{2,5})?(?:[/?#]\S*)?$/;

            return re.test(value);
        },

        alpha: function (value) {
            var re = /^[a-zA-Z_]+$/;

            return re.test(value);
        },

        alphaNum: function (value) {
            var re = /^[a-zA-Z_]+$/;

            return re.test(value);
        },

        creditCard: function (value, type) {
            var re,
                checksum,
                i,
                digit,
                notype = false;

            if (type === "Visa") {
                // Visa: length 16, prefix 4, dashes optional.
                re = /^4\d{3}[- ]?\d{4}[- ]?\d{4}[- ]?\d{4}$/;
            } else if (type === "MasterCard") {
                // Mastercard: length 16, prefix 51-55, dashes optional.
                re = /^5[1-5]\d{2}[- ]?\d{4}[- ]?\d{4}[- ]?\d{4}$/;
            } else if (type === "Discover") {
                // Discover: length 16, prefix 6011, dashes optional.
                re = /^6011[- ]?\d{4}[- ]?\d{4}[- ]?\d{4}$/;
            } else if (type === "AmericanExpress") {
                // American Express: length 15, prefix 34 or 37.
                re = /^3[4,7]\d{13}$/;
            } else if (type === "DinersClub") {
                // Diners: length 14, prefix 30, 36, or 38.
                re = /^(3[0,6,8]\d{12})|(5[45]\d{14})$/;
            } else {
                // Basing min and max length on
                // http://developer.ean.com/general_info/Valid_Credit_Card_Types
                if (!value || value.length < 13 || value.length > 19) {
                    return false;
                }

                re = /[^0-9 \-]+/;
                notype = true;
            }

            if (!re.test(value)) {
                return false;
            }

            // Remove all dashes for the checksum checks to eliminate negative numbers
            value = value.split(notype ? "-" : /[- ]/).join("");

            // Checksum ("Mod 10")
            // Add even digits in even length strings or odd digits in odd length strings.
            checksum = 0;

            for (i = (2 - (value.length % 2)); i <= value.length; i += 2) {
                checksum += parseInt(value.charAt(i - 1));
            }

            // Analyze odd digits in even length strings or even digits in odd length strings.
            for (i = (value.length % 2) + 1; i < value.length; i += 2) {
                digit = parseInt(value.charAt(i - 1)) * 2;

                if (digit < 10) {
                    checksum += digit;
                } else {
                    checksum += (digit - 9);
                }
            }

            return (checksum % 10) === 0;
        }
    };

    Bridge.Validation = validation;

    // @source Attribute.js

    Bridge.define("System.Attribute", {
        statics: {
            getCustomAttributes: function (o, t, b) {
                if (o == null) {
                    throw new System.ArgumentNullException.$ctor1("element");
                }

                if (t == null) {
                    throw new System.ArgumentNullException.$ctor1("attributeType");
                }

                var r = o.at || [];

                if (o.ov === true) {
                    var baseType = Bridge.Reflection.getBaseType(o.td),
                        baseAttrs = [],
                        baseMember = null;

                    while (baseType != null && baseMember == null) {
                        baseMember = Bridge.Reflection.getMembers(baseType, 31, 28, o.n);

                        if (baseMember.length == 0) {
                            var newBaseType = Bridge.Reflection.getBaseType(baseType);

                            if (newBaseType != baseType) {
                                baseType = newBaseType;
                            }

                            baseMember = null;
                        } else {
                            baseMember = baseMember[0];
                        }
                    }

                    if (baseMember != null) {
                        baseAttrs = System.Attribute.getCustomAttributes(baseMember, t);
                    }

                    for (var i = 0; i < baseAttrs.length; i++) {
                        var baseAttr = baseAttrs[i],
                            attrType = Bridge.getType(baseAttr),
                            meta = Bridge.getMetadata(attrType);

                        if (meta && meta.am || !r.some(function (a) { return Bridge.is(a, t); })) {
                            r.push(baseAttr);
                        }
                    }
                }

                if (!t) {
                    return r;
                }

                return r.filter(function (a) { return Bridge.is(a, t); });
            },

            getCustomAttributes$1: function (a, t, b) {
                if (a == null) {
                    throw new System.ArgumentNullException.$ctor1("element");
                }

                if (t == null) {
                    throw new System.ArgumentNullException.$ctor1("attributeType");
                }

                return a.getCustomAttributes(t || b);
            },

            isDefined: function (o, t, b) {
                var attrs = System.Attribute.getCustomAttributes(o, t, b);

                return attrs.length > 0;
            }
        }
    });

    // @source SerializableAttribute.js

    Bridge.define("System.SerializableAttribute", {
        inherits: [System.Attribute],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Attribute.ctor.call(this);
            }
        }
    });

    // @source INotifyPropertyChanged.js

    Bridge.define("System.ComponentModel.INotifyPropertyChanged", {
        $kind: "interface"
    });

    Bridge.define("System.ComponentModel.PropertyChangedEventArgs", {
        ctor: function (propertyName, newValue, oldValue) {
            this.$initialize();
            this.propertyName = propertyName;
            this.newValue = newValue;
            this.oldValue = oldValue;
        }
    });

    // @source Convert.js

    var scope = {};

    scope.convert = {
        typeCodes: {
            Empty: 0,
            Object: 1,
            DBNull: 2,
            Boolean: 3,
            Char: 4,
            SByte: 5,
            Byte: 6,
            Int16: 7,
            UInt16: 8,
            Int32: 9,
            UInt32: 10,
            Int64: 11,
            UInt64: 12,
            Single: 13,
            Double: 14,
            Decimal: 15,
            DateTime: 16,
            String: 18
        },

        toBoolean: function (value, formatProvider) {
            value = Bridge.unbox(value, true);

            switch (typeof (value)) {
                case "boolean":
                    return value;

                case "number":
                    return value !== 0; // non-zero int/float value is always converted to True;

                case "string":
                    var lowCaseVal = value.toLowerCase().trim();

                    if (lowCaseVal === "true") {
                        return true;
                    } else if (lowCaseVal === "false") {
                        return false;
                    } else {
                        throw new System.FormatException.$ctor1("String was not recognized as a valid Boolean.");
                    }

                case "object":
                    if (value == null) {
                        return false;
                    }

                    if (value instanceof System.Decimal) {
                        return !value.isZero();
                    }

                    if (System.Int64.is64Bit(value)) {
                        return value.ne(0);
                    }

                    break;
            }

            // TODO: #822 When IConvertible is implemented, try it before throwing InvalidCastEx
            var typeCode = scope.internal.suggestTypeCode(value);
            scope.internal.throwInvalidCastEx(typeCode, scope.convert.typeCodes.Boolean);

            // try converting using IConvertible
            return scope.convert.convertToType(scope.convert.typeCodes.Boolean, value, formatProvider || null);
        },

        toChar: function (value, formatProvider, valueTypeCode) {
            var typeCodes = scope.convert.typeCodes,
                isChar = Bridge.is(value, System.Char);

            value = Bridge.unbox(value, true);

            if (value instanceof System.Decimal) {
                value = value.toFloat();
            }

            if (value instanceof System.Int64 || value instanceof System.UInt64) {
                value = value.toNumber();
            }

            var type = typeof (value);

            valueTypeCode = valueTypeCode || scope.internal.suggestTypeCode(value);

            if (valueTypeCode === typeCodes.String && value == null) {
                type = "string";
            }

            if (valueTypeCode !== typeCodes.Object || isChar) {
                switch (type) {
                    case "boolean":
                        scope.internal.throwInvalidCastEx(typeCodes.Boolean, typeCodes.Char);

                    case "number":
                        var isFloatingType = scope.internal.isFloatingType(valueTypeCode);

                        if (isFloatingType || value % 1 !== 0) {
                            scope.internal.throwInvalidCastEx(valueTypeCode, typeCodes.Char);
                        }

                        scope.internal.validateNumberRange(value, typeCodes.Char, true);

                        return value;

                    case "string":
                        if (value == null) {
                            throw new System.ArgumentNullException.$ctor1("value");
                        }

                        if (value.length !== 1) {
                            throw new System.FormatException.$ctor1("String must be exactly one character long.");
                        }

                        return value.charCodeAt(0);
                }
            }

            if (valueTypeCode === typeCodes.Object || type === "object") {
                if (value == null) {
                    return 0;
                }

                if (Bridge.isDate(value)) {
                    scope.internal.throwInvalidCastEx(typeCodes.DateTime, typeCodes.Char);
                }
            }

            // TODO: #822 When IConvertible is implemented, try it before throwing InvalidCastEx
            scope.internal.throwInvalidCastEx(valueTypeCode, scope.convert.typeCodes.Char);

            // try converting using IConvertible
            return scope.convert.convertToType(typeCodes.Char, value, formatProvider || null);
        },

        toSByte: function (value, formatProvider, valueTypeCode) {
            return scope.internal.toNumber(value, formatProvider || null, scope.convert.typeCodes.SByte, valueTypeCode || null);
        },

        toByte: function (value, formatProvider) {
            return scope.internal.toNumber(value, formatProvider || null, scope.convert.typeCodes.Byte);
        },

        toInt16: function (value, formatProvider) {
            return scope.internal.toNumber(value, formatProvider || null, scope.convert.typeCodes.Int16);
        },

        toUInt16: function (value, formatProvider) {
            return scope.internal.toNumber(value, formatProvider || null, scope.convert.typeCodes.UInt16);
        },

        toInt32: function (value, formatProvider) {
            return scope.internal.toNumber(value, formatProvider || null, scope.convert.typeCodes.Int32);
        },

        toUInt32: function (value, formatProvider) {
            return scope.internal.toNumber(value, formatProvider || null, scope.convert.typeCodes.UInt32);
        },

        toInt64: function (value, formatProvider) {
            var result = scope.internal.toNumber(value, formatProvider || null, scope.convert.typeCodes.Int64);
            return new System.Int64(result);
        },

        toUInt64: function (value, formatProvider) {
            var result = scope.internal.toNumber(value, formatProvider || null, scope.convert.typeCodes.UInt64);
            return new System.UInt64(result);
        },

        toSingle: function (value, formatProvider) {
            return scope.internal.toNumber(value, formatProvider || null, scope.convert.typeCodes.Single);
        },

        toDouble: function (value, formatProvider) {
            return scope.internal.toNumber(value, formatProvider || null, scope.convert.typeCodes.Double);
        },

        toDecimal: function (value, formatProvider) {
            if (value instanceof System.Decimal) {
                return value;
            }

            return new System.Decimal(scope.internal.toNumber(value, formatProvider || null, scope.convert.typeCodes.Decimal));
        },

        toDateTime: function (value, formatProvider) {
            var typeCodes = scope.convert.typeCodes;

            value = Bridge.unbox(value, true);

            switch (typeof (value)) {
                case "boolean":
                    scope.internal.throwInvalidCastEx(typeCodes.Boolean, typeCodes.DateTime);

                case "number":
                    var fromType = scope.internal.suggestTypeCode(value);
                    scope.internal.throwInvalidCastEx(fromType, typeCodes.DateTime);

                case "string":
                    value = System.DateTime.parse(value, formatProvider || null);

                    return value;

                case "object":
                    if (value == null) {
                        return scope.internal.getMinValue(typeCodes.DateTime);
                    }

                    if (Bridge.isDate(value)) {
                        return value;
                    }

                    if (value instanceof System.Decimal) {
                        scope.internal.throwInvalidCastEx(typeCodes.Decimal, typeCodes.DateTime);
                    }

                    if (value instanceof System.Int64) {
                        scope.internal.throwInvalidCastEx(typeCodes.Int64, typeCodes.DateTime);
                    }

                    if (value instanceof System.UInt64) {
                        scope.internal.throwInvalidCastEx(typeCodes.UInt64, typeCodes.DateTime);
                    }

                    break;
            }

            // TODO: #822 When IConvertible is implemented, try it before throwing InvalidCastEx
            var valueTypeCode = scope.internal.suggestTypeCode(value);

            scope.internal.throwInvalidCastEx(valueTypeCode, scope.convert.typeCodes.DateTime);

            // try converting using IConvertible
            return scope.convert.convertToType(typeCodes.DateTime, value, formatProvider || null);
        },

        toString: function (value, formatProvider, valueTypeCode) {
            if (value && value.$boxed) {
                return value.toString();
            }

            var typeCodes = scope.convert.typeCodes,
                type = typeof (value);

            switch (type) {
                case "boolean":
                    return value ? "True" : "False";

                case "number":
                    if ((valueTypeCode || null) === typeCodes.Char) {
                        return String.fromCharCode(value);
                    }

                    if (isNaN(value)) {
                        return "NaN";
                    }

                    if (value % 1 !== 0) {
                        value = parseFloat(value.toPrecision(15));
                    }

                    return value.toString();

                case "string":
                    return value;

                case "object":
                    if (value == null) {
                        return "";
                    }

                    // If the object has an override to the toString() method,
                    // then just return its result
                    if (value.toString !== Object.prototype.toString) {
                        return value.toString();
                    }

                    if (Bridge.isDate(value)) {
                        return System.DateTime.format(value, null, formatProvider || null);
                    }

                    if (value instanceof System.Decimal) {
                        if (value.isInteger()) {
                            return value.toFixed(0, 4);
                        }
                        return value.toPrecision(value.precision());
                    }

                    if (System.Int64.is64Bit(value)) {
                        return value.toString();
                    }

                    if (value.format) {
                        return value.format(null, formatProvider || null);
                    }

                    var typeName = Bridge.getTypeName(value);

                    return typeName;
            }

            // try converting using IConvertible
            return scope.convert.convertToType(scope.convert.typeCodes.String, value, formatProvider || null);
        },

        toNumberInBase: function (str, fromBase, typeCode) {
            if (fromBase !== 2 && fromBase !== 8 && fromBase !== 10 && fromBase !== 16) {
                throw new System.ArgumentException.$ctor1("Invalid Base.");
            }

            var typeCodes = scope.convert.typeCodes;

            if (str == null) {
                if (typeCode === typeCodes.Int64) {
                    return System.Int64.Zero;
                }

                if (typeCode === typeCodes.UInt64) {
                    return System.UInt64.Zero;
                }

                return 0;
            }

            if (str.length === 0) {
                throw new System.ArgumentOutOfRangeException.$ctor4("length", "Index was out of range. Must be non-negative and less than the size of the collection.");
            }

            // Let's process the string in lower case.
            str = str.toLowerCase();

            var minValue = scope.internal.getMinValue(typeCode),
                maxValue = scope.internal.getMaxValue(typeCode);

            // Calculate offset (start index)
            var isNegative = false,
                startIndex = 0;

            if (str[startIndex] === "-") {
                if (fromBase !== 10) {
                    throw new System.ArgumentException.$ctor1("String cannot contain a minus sign if the base is not 10.");
                }

                if (minValue >= 0) {
                    throw new System.OverflowException.$ctor1("The string was being parsed as an unsigned number and could not have a negative sign.");
                }

                isNegative = true;
                ++startIndex;
            } else if (str[startIndex] === "+") {
                ++startIndex;
            }

            if (fromBase === 16 && str.length >= 2 && str[startIndex] === "0" && str[startIndex + 1] === "x") {
                startIndex += 2;
            }

            // Fill allowed codes for the specified base:
            var allowedCodes;

            if (fromBase === 2) {
                allowedCodes = scope.internal.charsToCodes("01");
            } else if (fromBase === 8) {
                allowedCodes = scope.internal.charsToCodes("01234567");
            } else if (fromBase === 10) {
                allowedCodes = scope.internal.charsToCodes("0123456789");
            } else if (fromBase === 16) {
                allowedCodes = scope.internal.charsToCodes("0123456789abcdef");
            } else {
                throw new System.ArgumentException.$ctor1("Invalid Base.");
            }

            // Create charCode-to-Value map
            var codeValues = {};

            for (var i = 0; i < allowedCodes.length; i++) {
                var allowedCode = allowedCodes[i];

                codeValues[allowedCode] = i;
            }

            var firstAllowed = allowedCodes[0],
                lastAllowed = allowedCodes[allowedCodes.length - 1],
                res,
                totalMax,
                code,
                j;

            if (typeCode === typeCodes.Int64 || typeCode === typeCodes.UInt64) {
                for (j = startIndex; j < str.length; j++) {
                    code = str[j].charCodeAt(0);

                    if (!(code >= firstAllowed && code <= lastAllowed)) {
                        if (j === startIndex) {
                            throw new System.FormatException.$ctor1("Could not find any recognizable digits.");
                        } else {
                            throw new System.FormatException.$ctor1("Additional non-parsable characters are at the end of the string.");
                        }
                    }
                }

                var isSign = typeCode === typeCodes.Int64;

                if (isSign) {
                    res = new System.Int64(Bridge.$Long.fromString(str, false, fromBase));
                } else {
                    res = new System.UInt64(Bridge.$Long.fromString(str, true, fromBase));
                }

                if (res.toString(fromBase) !== System.String.trimStartZeros(str)) {
                    throw new System.OverflowException.$ctor1("Value was either too large or too small.");
                }

                return res;
            } else {
                // Parse the number:
                res = 0;
                totalMax = maxValue - minValue + 1;

                for (j = startIndex; j < str.length; j++) {
                    code = str[j].charCodeAt(0);

                    if (code >= firstAllowed && code <= lastAllowed) {
                        res *= fromBase;
                        res += codeValues[code];

                        if (res > scope.internal.typeRanges.Int64_MaxValue) {
                            throw new System.OverflowException.$ctor1("Value was either too large or too small.");
                        }
                    } else {
                        if (j === startIndex) {
                            throw new System.FormatException.$ctor1("Could not find any recognizable digits.");
                        } else {
                            throw new System.FormatException.$ctor1("Additional non-parsable characters are at the end of the string.");
                        }
                    }
                }

                if (isNegative) {
                    res *= -1;
                }

                if (res > maxValue && fromBase !== 10 && minValue < 0) {
                    // Assume that the value is negative, transform it:
                    res = res - totalMax;
                }

                if (res < minValue || res > maxValue) {
                    throw new System.OverflowException.$ctor1("Value was either too large or too small.");
                }

                return res;
            }
        },

        toStringInBase: function (value, toBase, typeCode) {
            var typeCodes = scope.convert.typeCodes;

            value = Bridge.unbox(value, true);

            if (toBase !== 2 && toBase !== 8 && toBase !== 10 && toBase !== 16) {
                throw new System.ArgumentException.$ctor1("Invalid Base.");
            }

            var minValue = scope.internal.getMinValue(typeCode),
                maxValue = scope.internal.getMaxValue(typeCode),
                special = System.Int64.is64Bit(value);

            if (special) {
                if (value.lt(minValue) || value.gt(maxValue)) {
                    throw new System.OverflowException.$ctor1("Value was either too large or too small for an unsigned byte.");
                }
            } else if (value < minValue || value > maxValue) {
                throw new System.OverflowException.$ctor1("Value was either too large or too small for an unsigned byte.");
            }

            // Handle negative numbers:
            var isNegative = false;

            if (special) {
                if (toBase === 10) {
                    return value.toString();
                } else {
                    return value.value.toUnsigned().toString(toBase);
                }
            } else if (value < 0) {
                if (toBase === 10) {
                    isNegative = true;
                    value *= -1;
                } else {
                    value = (maxValue + 1 - minValue) + value;
                }
            }

            // Fill allowed codes for the specified base:
            var allowedChars;

            if (toBase === 2) {
                allowedChars = "01";
            } else if (toBase === 8) {
                allowedChars = "01234567";
            } else if (toBase === 10) {
                allowedChars = "0123456789";
            } else if (toBase === 16) {
                allowedChars = "0123456789abcdef";
            } else {
                throw new System.ArgumentException.$ctor1("Invalid Base.");
            }

            // Fill Value-To-Char map:
            var charByValues = {},
                allowedCharArr = allowedChars.split(""),
                allowedChar;

            for (var i = 0; i < allowedCharArr.length; i++) {
                allowedChar = allowedCharArr[i];

                charByValues[i] = allowedChar;
            }

            // Parse the number:
            var res = "";

            if (value === 0 || (special && value.eq(0))) {
                res = "0";
            } else {
                var mod, char;

                if (special) {
                    while (value.gt(0)) {
                        mod = value.mod(toBase);
                        value = value.sub(mod).div(toBase);

                        char = charByValues[mod.toNumber()];
                        res += char;
                    }
                } else {
                    while (value > 0) {
                        mod = value % toBase;
                        value = (value - mod) / toBase;

                        char = charByValues[mod];
                        res += char;
                    }
                }
            }

            if (isNegative) {
                res += "-";
            }

            res = res.split("").reverse().join("");

            return res;
        },

        toBase64String: function (inArray, offset, length, options) {
            if (inArray == null) {
                throw new System.ArgumentNullException.$ctor1("inArray");
            }

            offset = offset || 0;
            length = length != null ? length : inArray.length;
            options = options || 0; // 0 - means "None", 1 - stands for "InsertLineBreaks"

            if (length < 0) {
                throw new System.ArgumentOutOfRangeException.$ctor4("length", "Index was out of range. Must be non-negative and less than the size of the collection.");
            }

            if (offset < 0) {
                throw new System.ArgumentOutOfRangeException.$ctor4("offset", "Value must be positive.");
            }

            if (options < 0 || options > 1) {
                throw new System.ArgumentException.$ctor1("Illegal enum value.");
            }

            var inArrayLength = inArray.length;

            if (offset > (inArrayLength - length)) {
                throw new System.ArgumentOutOfRangeException.$ctor4("offset", "Offset and length must refer to a position in the string.");
            }

            if (inArrayLength === 0) {
                return "";
            }

            var insertLineBreaks = (options === 1),
                strArrayLen = scope.internal.toBase64_CalculateAndValidateOutputLength(length, insertLineBreaks);

            var strArray = [];
            strArray.length = strArrayLen;

            scope.internal.convertToBase64Array(strArray, inArray, offset, length, insertLineBreaks);

            var str = strArray.join("");

            return str;
        },

        toBase64CharArray: function (inArray, offsetIn, length, outArray, offsetOut, options) {
            if (inArray == null) {
                throw new System.ArgumentNullException.$ctor1("inArray");
            }

            if (outArray == null) {
                throw new System.ArgumentNullException.$ctor1("outArray");
            }

            if (length < 0) {
                throw new System.ArgumentOutOfRangeException.$ctor4("length", "Index was out of range. Must be non-negative and less than the size of the collection.");
            }

            if (offsetIn < 0) {
                throw new System.ArgumentOutOfRangeException.$ctor4("offsetIn", "Value must be positive.");
            }

            if (offsetOut < 0) {
                throw new System.ArgumentOutOfRangeException.$ctor4("offsetOut", "Value must be positive.");
            }

            options = options || 0; // 0 - means "None", 1 - stands for "InsertLineBreaks"

            if (options < 0 || options > 1) {
                throw new System.ArgumentException.$ctor1("Illegal enum value.");
            }

            var inArrayLength = inArray.length;

            if (offsetIn > inArrayLength - length) {
                throw new System.ArgumentOutOfRangeException.$ctor4("offsetIn", "Offset and length must refer to a position in the string.");
            }

            if (inArrayLength === 0) {
                return 0;
            }

            var insertLineBreaks = options === 1,
                outArrayLength = outArray.length; //This is the maximally required length that must be available in the char array

            // Length of the char buffer required
            var numElementsToCopy = scope.internal.toBase64_CalculateAndValidateOutputLength(length, insertLineBreaks);

            if (offsetOut > (outArrayLength - numElementsToCopy)) {
                throw new System.ArgumentOutOfRangeException.$ctor4("offsetOut", "Either offset did not refer to a position in the string, or there is an insufficient length of destination character array.");
            }

            var charsArr = [],
                charsArrLength = scope.internal.convertToBase64Array(charsArr, inArray, offsetIn, length, insertLineBreaks);

            scope.internal.charsToCodes(charsArr, outArray, offsetOut);

            return charsArrLength;
        },

        fromBase64String: function (s) {
            // "s" is an unfortunate parameter name, but we need to keep it for backward compat.

            if (s == null) {
                throw new System.ArgumentNullException.$ctor1("s");
            }

            var sChars = s.split(""),
                bytes = scope.internal.fromBase64CharPtr(sChars, 0, sChars.length);

            return bytes;
        },

        fromBase64CharArray: function (inArray, offset, length) {
            if (inArray == null) {
                throw new System.ArgumentNullException.$ctor1("inArray");
            }

            if (length < 0) {
                throw new System.ArgumentOutOfRangeException.$ctor4("length", "Index was out of range. Must be non-negative and less than the size of the collection.");
            }

            if (offset < 0) {
                throw new System.ArgumentOutOfRangeException.$ctor4("offset", "Value must be positive.");
            }

            if (offset > (inArray.length - length)) {
                throw new System.ArgumentOutOfRangeException.$ctor4("offset", "Offset and length must refer to a position in the string.");
            }

            var chars = scope.internal.codesToChars(inArray),
                bytes = scope.internal.fromBase64CharPtr(chars, offset, length);

            return bytes;
        },

        convertToType: function (typeCode, value, formatProvider) {
            //TODO: #822 IConvertible
            throw new System.NotSupportedException.$ctor1("IConvertible interface is not supported.");
        }
    };

    scope.internal = {
        base64Table: [
            "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O",
            "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d",
            "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s",
            "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7",
            "8", "9", "+", "/", "="
        ],

        typeRanges: {
            Char_MinValue: 0,
            Char_MaxValue: 65535,

            Byte_MinValue: 0,
            Byte_MaxValue: 255,

            SByte_MinValue: -128,
            SByte_MaxValue: 127,

            Int16_MinValue: -32768,
            Int16_MaxValue: 32767,

            UInt16_MinValue: 0,
            UInt16_MaxValue: 65535,

            Int32_MinValue: -2147483648,
            Int32_MaxValue: 2147483647,

            UInt32_MinValue: 0,
            UInt32_MaxValue: 4294967295,

            Int64_MinValue: System.Int64.MinValue,
            Int64_MaxValue: System.Int64.MaxValue,

            UInt64_MinValue: System.UInt64.MinValue,
            UInt64_MaxValue: System.UInt64.MaxValue,

            Single_MinValue: -3.40282347e+38,
            Single_MaxValue: 3.40282347e+38,

            Double_MinValue: -1.7976931348623157e+308,
            Double_MaxValue: 1.7976931348623157e+308,

            Decimal_MinValue: System.Decimal.MinValue,
            Decimal_MaxValue: System.Decimal.MaxValue
        },

        base64LineBreakPosition: 76,

        getTypeCodeName: function (typeCode) {
            var typeCodes = scope.convert.typeCodes;

            if (scope.internal.typeCodeNames == null) {
                var names = {};

                for (var codeName in typeCodes) {
                    if (!typeCodes.hasOwnProperty(codeName)) {
                        continue;
                    }

                    var codeValue = typeCodes[codeName];

                    names[codeValue] = codeName;
                }
                scope.internal.typeCodeNames = names;
            }

            var name = scope.internal.typeCodeNames[typeCode];

            if (name == null) {
                throw System.ArgumentOutOfRangeException("typeCode", "The specified typeCode is undefined.");
            }

            return name;
        },

        suggestTypeCode: function (value) {
            var typeCodes = scope.convert.typeCodes,
                type = typeof (value);

            switch (type) {
                case "boolean":
                    return typeCodes.Boolean;

                case "number":
                    if (value % 1 !== 0) {
                        return typeCodes.Double;
                    }

                    return typeCodes.Int32;

                case "string":
                    return typeCodes.String;

                case "object":
                    if (Bridge.isDate(value)) {
                        return typeCodes.DateTime;
                    }

                    if (value != null) {
                        return typeCodes.Object;
                    }

                    break;
            }
            return null;
        },

        getMinValue: function (typeCode) {
            var typeCodes = scope.convert.typeCodes;

            switch (typeCode) {
                case typeCodes.Char:
                    return scope.internal.typeRanges.Char_MinValue;
                case typeCodes.SByte:
                    return scope.internal.typeRanges.SByte_MinValue;
                case typeCodes.Byte:
                    return scope.internal.typeRanges.Byte_MinValue;
                case typeCodes.Int16:
                    return scope.internal.typeRanges.Int16_MinValue;
                case typeCodes.UInt16:
                    return scope.internal.typeRanges.UInt16_MinValue;
                case typeCodes.Int32:
                    return scope.internal.typeRanges.Int32_MinValue;
                case typeCodes.UInt32:
                    return scope.internal.typeRanges.UInt32_MinValue;
                case typeCodes.Int64:
                    return scope.internal.typeRanges.Int64_MinValue;
                case typeCodes.UInt64:
                    return scope.internal.typeRanges.UInt64_MinValue;
                case typeCodes.Single:
                    return scope.internal.typeRanges.Single_MinValue;
                case typeCodes.Double:
                    return scope.internal.typeRanges.Double_MinValue;
                case typeCodes.Decimal:
                    return scope.internal.typeRanges.Decimal_MinValue;
                case typeCodes.DateTime:
                    return System.DateTime.getMinValue();

                default:
                    return null;
            }
        },

        getMaxValue: function (typeCode) {
            var typeCodes = scope.convert.typeCodes;

            switch (typeCode) {
                case typeCodes.Char:
                    return scope.internal.typeRanges.Char_MaxValue;
                case typeCodes.SByte:
                    return scope.internal.typeRanges.SByte_MaxValue;
                case typeCodes.Byte:
                    return scope.internal.typeRanges.Byte_MaxValue;
                case typeCodes.Int16:
                    return scope.internal.typeRanges.Int16_MaxValue;
                case typeCodes.UInt16:
                    return scope.internal.typeRanges.UInt16_MaxValue;
                case typeCodes.Int32:
                    return scope.internal.typeRanges.Int32_MaxValue;
                case typeCodes.UInt32:
                    return scope.internal.typeRanges.UInt32_MaxValue;
                case typeCodes.Int64:
                    return scope.internal.typeRanges.Int64_MaxValue;
                case typeCodes.UInt64:
                    return scope.internal.typeRanges.UInt64_MaxValue;
                case typeCodes.Single:
                    return scope.internal.typeRanges.Single_MaxValue;
                case typeCodes.Double:
                    return scope.internal.typeRanges.Double_MaxValue;
                case typeCodes.Decimal:
                    return scope.internal.typeRanges.Decimal_MaxValue;
                case typeCodes.DateTime:
                    return System.DateTime.getMaxValue();
                default:
                    throw new System.ArgumentOutOfRangeException.$ctor4("typeCode", "The specified typeCode is undefined.");
            }
        },

        isFloatingType: function (typeCode) {
            var typeCodes = scope.convert.typeCodes,
                isFloatingType =
                    typeCode === typeCodes.Single ||
                    typeCode === typeCodes.Double ||
                    typeCode === typeCodes.Decimal;

            return isFloatingType;
        },

        toNumber: function (value, formatProvider, typeCode, valueTypeCode) {
            value = Bridge.unbox(value, true);

            var typeCodes = scope.convert.typeCodes,
                type = typeof (value),
                isFloating = scope.internal.isFloatingType(typeCode);

            if (valueTypeCode === typeCodes.String) {
                type = "string";
            }

            if (System.Int64.is64Bit(value) || value instanceof System.Decimal) {
                type = "number";
            }

            switch (type) {
                case "boolean":
                    return value ? 1 : 0;

                case "number":
                    if (typeCode === typeCodes.Decimal) {
                        scope.internal.validateNumberRange(value, typeCode, true);

                        return new System.Decimal(value, formatProvider);
                    }

                    if (typeCode === typeCodes.Int64) {
                        scope.internal.validateNumberRange(value, typeCode, true);

                        return new System.Int64(value);
                    }

                    if (typeCode === typeCodes.UInt64) {
                        scope.internal.validateNumberRange(value, typeCode, true);

                        return new System.UInt64(value);
                    }

                    if (System.Int64.is64Bit(value)) {
                        value = value.toNumber();
                    } else if (value instanceof System.Decimal) {
                        value = value.toFloat();
                    }

                    if (!isFloating && (value % 1 !== 0)) {
                        value = scope.internal.roundToInt(value, typeCode);
                    }

                    if (isFloating) {
                        var minValue = scope.internal.getMinValue(typeCode),
                            maxValue = scope.internal.getMaxValue(typeCode);

                        if (value > maxValue) {
                            value = Infinity;
                        } else if (value < minValue) {
                            value = -Infinity;
                        }
                    }

                    scope.internal.validateNumberRange(value, typeCode, false);
                    return value;

                case "string":
                    if (value == null) {
                        if (formatProvider != null) {
                            throw new System.ArgumentNullException.$ctor3("String", "Value cannot be null.");
                        }

                        return 0;
                    }

                    if (isFloating) {
                        if (typeCode === typeCodes.Decimal) {
                            if (!/^[+-]?(\d+|\d+.|\d*\.\d+)$/.test(value)) {
                                if (!/^[+-]?[0-9]+$/.test(value)) {
                                    throw new System.FormatException.$ctor1("Input string was not in a correct format.");
                                }
                            }

                            value = System.Decimal(value, formatProvider);
                        } else {
                            if (!/^[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?$/.test(value)) {
                                throw new System.FormatException.$ctor1("Input string was not in a correct format.");
                            }

                            value = parseFloat(value);
                        }
                    } else {
                        if (!/^[+-]?[0-9]+$/.test(value)) {
                            throw new System.FormatException.$ctor1("Input string was not in a correct format.");
                        }

                        var str = value;

                        if (typeCode === typeCodes.Int64) {
                            value = new System.Int64(value);

                            if (System.String.trimStartZeros(str) !== value.toString()) {
                                this.throwOverflow(scope.internal.getTypeCodeName(typeCode));
                            }
                        } else if (typeCode === typeCodes.UInt64) {
                            value = new System.UInt64(value);

                            if (System.String.trimStartZeros(str) !== value.toString()) {
                                this.throwOverflow(scope.internal.getTypeCodeName(typeCode));
                            }
                        } else {
                            value = parseInt(value, 10);
                        }
                    }

                    if (isNaN(value)) {
                        throw new System.FormatException.$ctor1("Input string was not in a correct format.");
                    }

                    scope.internal.validateNumberRange(value, typeCode, true);

                    return value;

                case "object":
                    if (value == null) {
                        return 0;
                    }

                    if (Bridge.isDate(value)) {
                        scope.internal.throwInvalidCastEx(scope.convert.typeCodes.DateTime, typeCode);
                    }

                    break;
            }

            // TODO: #822 When IConvertible is implemented, try it before throwing InvalidCastEx
            valueTypeCode = valueTypeCode || scope.internal.suggestTypeCode(value);
            scope.internal.throwInvalidCastEx(valueTypeCode, typeCode);

            // try converting using IConvertible
            return scope.convert.convertToType(typeCode, value, formatProvider);
        },

        validateNumberRange: function (value, typeCode, denyInfinity) {
            var typeCodes = scope.convert.typeCodes,
                minValue = scope.internal.getMinValue(typeCode),
                maxValue = scope.internal.getMaxValue(typeCode),
                typeName = scope.internal.getTypeCodeName(typeCode);

            if (typeCode === typeCodes.Single ||
                typeCode === typeCodes.Double) {
                if (!denyInfinity && (value === Infinity || value === -Infinity)) {
                    return;
                }
            }

            if (typeCode === typeCodes.Decimal || typeCode === typeCodes.Int64 || typeCode === typeCodes.UInt64) {
                if (typeCode === typeCodes.Decimal) {
                    if (!System.Int64.is64Bit(value)) {
                        if (minValue.gt(value) || maxValue.lt(value)) {
                            this.throwOverflow(typeName);
                        }
                    }

                    value = new System.Decimal(value);
                } else if (typeCode === typeCodes.Int64) {
                    if (value instanceof System.UInt64) {
                        if (value.gt(System.Int64.MaxValue)) {
                            this.throwOverflow(typeName);
                        }
                    } else if (value instanceof System.Decimal) {
                        if ((value.gt(new System.Decimal(maxValue)) || value.lt(new System.Decimal(minValue)))) {
                            this.throwOverflow(typeName);
                        }
                    } else if (!(value instanceof System.Int64)) {
                        if (minValue.toNumber() > value || maxValue.toNumber() < value) {
                            this.throwOverflow(typeName);
                        }
                    }

                    value = new System.Int64(value);
                } else if (typeCode === typeCodes.UInt64) {
                    if (value instanceof System.Int64) {
                        if (value.isNegative()) {
                            this.throwOverflow(typeName);
                        }
                    } else if (value instanceof System.Decimal) {
                        if ((value.gt(new System.Decimal(maxValue)) || value.lt(new System.Decimal(minValue)))) {
                            this.throwOverflow(typeName);
                        }
                    } else if (!(value instanceof System.UInt64)) {
                        if (minValue.toNumber() > value || maxValue.toNumber() < value) {
                            this.throwOverflow(typeName);
                        }
                    }

                    value = new System.UInt64(value);
                }
            } else if (value < minValue || value > maxValue) {
                this.throwOverflow(typeName);
            }
        },

        throwOverflow: function (typeName) {
            throw new System.OverflowException.$ctor1("Value was either too large or too small for '" + typeName + "'.");
        },

        roundToInt: function (value, typeCode) {
            if (value % 1 === 0) {
                return value;
            }

            var intPart;

            if (value >= 0) {
                intPart = Math.floor(value);
            } else {
                intPart = -1 * Math.floor(-value);
            }

            var floatPart = value - intPart,
                minValue = scope.internal.getMinValue(typeCode),
                maxValue = scope.internal.getMaxValue(typeCode);

            if (value >= 0.0) {
                if (value < (maxValue + 0.5)) {
                    if (floatPart > 0.5 || floatPart === 0.5 && (intPart & 1) !== 0) {
                        ++intPart;
                    }

                    return intPart;
                }
            } else if (value >= (minValue - 0.5)) {
                if (floatPart < -0.5 || floatPart === -0.5 && (intPart & 1) !== 0) {
                    --intPart;
                }

                return intPart;
            }

            var typeName = scope.internal.getTypeCodeName(typeCode);

            throw new System.OverflowException.$ctor1("Value was either too large or too small for an '" + typeName + "'.");
        },

        toBase64_CalculateAndValidateOutputLength: function (inputLength, insertLineBreaks) {
            var base64LineBreakPosition = scope.internal.base64LineBreakPosition,
                outlen = ~~(inputLength / 3) * 4; // the base length - we want integer division here.

            outlen += ((inputLength % 3) !== 0) ? 4 : 0; // at most 4 more chars for the remainder

            if (outlen === 0) {
                return 0;
            }

            if (insertLineBreaks) {
                var newLines = ~~(outlen / base64LineBreakPosition);

                if ((outlen % base64LineBreakPosition) === 0) {
                    --newLines;
                }

                outlen += newLines * 2; // the number of line break chars we'll add, "\r\n"
            }

            // If we overflow an int then we cannot allocate enough
            // memory to output the value so throw
            if (outlen > 2147483647) {
                throw new System.OutOfMemoryException();
            }

            return outlen;
        },

        convertToBase64Array: function (outChars, inData, offset, length, insertLineBreaks) {
            var base64Table = scope.internal.base64Table,
                base64LineBreakPosition = scope.internal.base64LineBreakPosition,
                lengthmod3 = length % 3,
                calcLength = offset + (length - lengthmod3),
                charCount = 0,
                j = 0;

            // Convert three bytes at a time to base64 notation.  This will consume 4 chars.
            var i;

            for (i = offset; i < calcLength; i += 3) {
                if (insertLineBreaks) {
                    if (charCount === base64LineBreakPosition) {
                        outChars[j++] = "\r";
                        outChars[j++] = "\n";
                        charCount = 0;
                    }

                    charCount += 4;
                }

                outChars[j] = base64Table[(inData[i] & 0xfc) >> 2];
                outChars[j + 1] = base64Table[((inData[i] & 0x03) << 4) | ((inData[i + 1] & 0xf0) >> 4)];
                outChars[j + 2] = base64Table[((inData[i + 1] & 0x0f) << 2) | ((inData[i + 2] & 0xc0) >> 6)];
                outChars[j + 3] = base64Table[(inData[i + 2] & 0x3f)];
                j += 4;
            }

            //Where we left off before
            i = calcLength;

            if (insertLineBreaks && (lengthmod3 !== 0) && (charCount === scope.internal.base64LineBreakPosition)) {
                outChars[j++] = "\r";
                outChars[j++] = "\n";
            }

            switch (lengthmod3) {
                case 2: //One character padding needed
                    outChars[j] = base64Table[(inData[i] & 0xfc) >> 2];
                    outChars[j + 1] = base64Table[((inData[i] & 0x03) << 4) | ((inData[i + 1] & 0xf0) >> 4)];
                    outChars[j + 2] = base64Table[(inData[i + 1] & 0x0f) << 2];
                    outChars[j + 3] = base64Table[64]; //Pad
                    j += 4;

                    break;

                case 1: // Two character padding needed
                    outChars[j] = base64Table[(inData[i] & 0xfc) >> 2];
                    outChars[j + 1] = base64Table[(inData[i] & 0x03) << 4];
                    outChars[j + 2] = base64Table[64]; //Pad
                    outChars[j + 3] = base64Table[64]; //Pad
                    j += 4;

                    break;
            }

            return j;
        },

        fromBase64CharPtr: function (input, offset, inputLength) {
            if (inputLength < 0) {
                throw new System.ArgumentOutOfRangeException.$ctor4("inputLength", "Index was out of range. Must be non-negative and less than the size of the collection.");
            }

            if (offset < 0) {
                throw new System.ArgumentOutOfRangeException.$ctor4("offset", "Value must be positive.");
            }

            // We need to get rid of any trailing white spaces.
            // Otherwise we would be rejecting input such as "abc= ":
            while (inputLength > 0) {
                var lastChar = input[offset + inputLength - 1];

                if (lastChar !== " " && lastChar !== "\n" && lastChar !== "\r" && lastChar !== "\t") {
                    break;
                }

                inputLength--;
            }

            // Compute the output length:
            var resultLength = scope.internal.fromBase64_ComputeResultLength(input, offset, inputLength);

            if (0 > resultLength) {
                throw new System.InvalidOperationException.$ctor1("Contract voilation: 0 <= resultLength.");
            }

            // resultLength can be zero. We will still enter FromBase64_Decode and process the input.
            // It may either simply write no bytes (e.g. input = " ") or throw (e.g. input = "ab").

            // Create result byte blob:
            var decodedBytes = [];
            decodedBytes.length = resultLength;

            // Convert Base64 chars into bytes:
            scope.internal.fromBase64_Decode(input, offset, inputLength, decodedBytes, 0, resultLength);

            // We are done:
            return decodedBytes;
        },

        fromBase64_Decode: function (input, inputIndex, inputLength, dest, destIndex, destLength) {
            var startDestIndex = destIndex;

            // You may find this method weird to look at. Its written for performance, not aesthetics.
            // You will find unrolled loops label jumps and bit manipulations.

            var intA = "A".charCodeAt(0),
                inta = "a".charCodeAt(0),
                int0 = "0".charCodeAt(0),
                intEq = "=".charCodeAt(0),
                intPlus = "+".charCodeAt(0),
                intSlash = "/".charCodeAt(0),
                intSpace = " ".charCodeAt(0),
                intTab = "\t".charCodeAt(0),
                intNLn = "\n".charCodeAt(0),
                intCRt = "\r".charCodeAt(0),
                intAtoZ = ("Z".charCodeAt(0) - "A".charCodeAt(0)),
                int0To9 = ("9".charCodeAt(0) - "0".charCodeAt(0));

            var endInputIndex = inputIndex + inputLength,
                endDestIndex = destIndex + destLength;

            // Current char code/value:
            var currCode;

            // This 4-byte integer will contain the 4 codes of the current 4-char group.
            // Eeach char codes for 6 bits = 24 bits.
            // The remaining byte will be FF, we use it as a marker when 4 chars have been processed.
            var currBlockCodes = 0x000000FF;

            var allInputConsumed = false,
                equalityCharEncountered = false;

            while (true) {
                // break when done:
                if (inputIndex >= endInputIndex) {
                    allInputConsumed = true;

                    break;
                }

                // Get current char:
                currCode = input[inputIndex].charCodeAt(0);
                inputIndex++;

                // Determine current char code (unsigned Int comparison):
                if (((currCode - intA) >>> 0) <= intAtoZ) {
                    currCode -= intA;
                } else if (((currCode - inta) >>> 0) <= intAtoZ) {
                    currCode -= (inta - 26);
                } else if (((currCode - int0) >>> 0) <= int0To9) {
                    currCode -= (int0 - 52);
                } else {
                    // Use the slower switch for less common cases:
                    switch (currCode) {
                        // Significant chars:
                        case intPlus:
                            currCode = 62;

                            break;

                        case intSlash:
                            currCode = 63;

                            break;

                            // Legal no-value chars (we ignore these):
                        case intCRt:
                        case intNLn:
                        case intSpace:
                        case intTab:
                            continue;

                            // The equality char is only legal at the end of the input.
                            // Jump after the loop to make it easier for the JIT register predictor to do a good job for the loop itself:
                        case intEq:
                            equalityCharEncountered = true;

                            break;

                            // Other chars are illegal:
                        default:
                            throw new System.FormatException.$ctor1("The input is not a valid Base-64 string as it contains a non-base 64 character, more than two padding characters, or an illegal character among the padding characters.");
                    }
                }

                if (equalityCharEncountered) {
                    break;
                }

                // Ok, we got the code. Save it:
                currBlockCodes = (currBlockCodes << 6) | currCode;

                // Last bit in currBlockCodes will be on after in shifted right 4 times:
                if ((currBlockCodes & 0x80000000) !== 0) {
                    if ((endDestIndex - destIndex) < 3) {
                        return -1;
                    }

                    dest[destIndex] = 0xFF & (currBlockCodes >> 16);
                    dest[destIndex + 1] = 0xFF & (currBlockCodes >> 8);
                    dest[destIndex + 2] = 0xFF & (currBlockCodes);
                    destIndex += 3;

                    currBlockCodes = 0x000000FF;
                }
            } // end of while

            if (!allInputConsumed && !equalityCharEncountered) {
                throw new System.InvalidOperationException.$ctor1("Contract violation: should never get here.");
            }

            if (equalityCharEncountered) {
                if (currCode !== intEq) {
                    throw new System.InvalidOperationException.$ctor1("Contract violation: currCode == intEq.");
                }

                // Recall that inputIndex is now one position past where '=' was read.
                // '=' can only be at the last input pos:
                if (inputIndex === endInputIndex) {
                    // Code is zero for trailing '=':
                    currBlockCodes <<= 6;

                    // The '=' did not complete a 4-group. The input must be bad:
                    if ((currBlockCodes & 0x80000000) === 0) {
                        throw new System.FormatException.$ctor1("Invalid length for a Base-64 char array or string.");
                    }

                    if ((endDestIndex - destIndex) < 2) {
                        // Autch! We underestimated the output length!
                        return -1;
                    }

                    // We are good, store bytes form this past group. We had a single "=", so we take two bytes:
                    dest[destIndex] = 0xFF & (currBlockCodes >> 16);
                    dest[destIndex + 1] = 0xFF & (currBlockCodes >> 8);
                    destIndex += 2;

                    currBlockCodes = 0x000000FF;
                } else { // '=' can also be at the pre-last position iff the last is also a '=' excluding the white spaces:
                    // We need to get rid of any intermediate white spaces.
                    // Otherwise we would be rejecting input such as "abc= =":
                    while (inputIndex < (endInputIndex - 1)) {
                        var lastChar = input[inputIndex];

                        if (lastChar !== " " && lastChar !== "\n" && lastChar !== "\r" && lastChar !== "\t") {
                            break;
                        }

                        inputIndex++;
                    }

                    if (inputIndex === (endInputIndex - 1) && input[inputIndex] === "=") {
                        // Code is zero for each of the two '=':
                        currBlockCodes <<= 12;

                        // The '=' did not complete a 4-group. The input must be bad:
                        if ((currBlockCodes & 0x80000000) === 0) {
                            throw new System.FormatException.$ctor1("Invalid length for a Base-64 char array or string.");
                        }

                        if ((endDestIndex - destIndex) < 1) {
                            // Autch! We underestimated the output length!
                            return -1;
                        }

                        // We are good, store bytes form this past group. We had a "==", so we take only one byte:
                        dest[destIndex] = 0xFF & (currBlockCodes >> 16);
                        destIndex++;

                        currBlockCodes = 0x000000FF;
                    } else {
                        // '=' is not ok at places other than the end:
                        throw new System.FormatException.$ctor1("The input is not a valid Base-64 string as it contains a non-base 64 character, more than two padding characters, or an illegal character among the padding characters.");
                    }
                }
            }

            // We get here either from above or by jumping out of the loop:
            // The last block of chars has less than 4 items
            if (currBlockCodes !== 0x000000FF) {
                throw new System.FormatException.$ctor1("Invalid length for a Base-64 char array or string.");
            }

            // Return how many bytes were actually recovered:
            return (destIndex - startDestIndex);
        },

        fromBase64_ComputeResultLength: function (input, startIndex, inputLength) {
            var intEq = "=",
                intSpace = " ";

            if (inputLength < 0) {
                throw new System.ArgumentOutOfRangeException.$ctor4("inputLength", "Index was out of range. Must be non-negative and less than the size of the collection.");
            }

            var endIndex = startIndex + inputLength,
                usefulInputLength = inputLength,
                padding = 0;

            while (startIndex < endIndex) {
                var c = input[startIndex];

                startIndex++;

                // We want to be as fast as possible and filter out spaces with as few comparisons as possible.
                // We end up accepting a number of illegal chars as legal white-space chars.
                // This is ok: as soon as we hit them during actual decode we will recognise them as illegal and throw.
                if (c <= intSpace) {
                    usefulInputLength--;
                } else if (c === intEq) {
                    usefulInputLength--;
                    padding++;
                }
            }

            if (0 > usefulInputLength) {
                throw new System.InvalidOperationException.$ctor1("Contract violation: 0 <= usefulInputLength.");
            }

            if (0 > padding) {
                // For legal input, we can assume that 0 <= padding < 3. But it may be more for illegal input.
                // We will notice it at decode when we see a '=' at the wrong place.
                throw new System.InvalidOperationException.$ctor1("Contract violation: 0 <= padding.");
            }

            // Perf: reuse the variable that stored the number of '=' to store the number of bytes encoded by the
            // last group that contains the '=':
            if (padding !== 0) {
                if (padding === 1) {
                    padding = 2;
                } else if (padding === 2) {
                    padding = 1;
                } else {
                    throw new System.FormatException.$ctor1("The input is not a valid Base-64 string as it contains a non-base 64 character, more than two padding characters, or an illegal character among the padding characters.");
                }
            }

            // Done:
            return ~~(usefulInputLength / 4) * 3 + padding;
        },

        charsToCodes: function (chars, codes, codesOffset) {
            if (chars == null) {
                return null;
            }

            codesOffset = codesOffset || 0;

            if (codes == null) {
                codes = [];
                codes.length = chars.length;
            }

            for (var i = 0; i < chars.length; i++) {
                codes[i + codesOffset] = chars[i].charCodeAt(0);
            }

            return codes;
        },

        codesToChars: function (codes, chars) {
            if (codes == null) {
                return null;
            }

            chars = chars || [];

            for (var i = 0; i < codes.length; i++) {
                var code = codes[i];

                chars[i] = String.fromCharCode(code);
            }

            return chars;
        },

        throwInvalidCastEx: function (fromTypeCode, toTypeCode) {
            var fromType = scope.internal.getTypeCodeName(fromTypeCode),                toType = scope.internal.getTypeCodeName(toTypeCode);

            throw new System.InvalidCastException.$ctor1("Invalid cast from '" + fromType + "' to '" + toType + "'.");
        }
    };

    System.Convert = scope.convert;

    // @source ClientWebSocket.js

    Bridge.define("System.Net.WebSockets.ClientWebSocket", {
        inherits: [System.IDisposable],

        ctor: function () {
            this.$initialize();
            this.messageBuffer = [];
            this.state = "none";
            this.options = new System.Net.WebSockets.ClientWebSocketOptions();
            this.disposed = false;
            this.closeStatus = null;
            this.closeStatusDescription = null;
        },

        getCloseStatus: function () {
            return this.closeStatus;
        },

        getState: function () {
            return this.state;
        },

        getCloseStatusDescription: function () {
            return this.closeStatusDescription;
        },

        getSubProtocol: function () {
            return this.socket ? this.socket.protocol : null;
        },

        connectAsync: function (uri, cancellationToken) {
            if (this.state !== "none") {
                throw new System.InvalidOperationException.$ctor1("Socket is not in initial state");
            }

            this.options.setToReadOnly();
            this.state = "connecting";

            var tcs = new System.Threading.Tasks.TaskCompletionSource(),
                self = this;

            try {
                this.socket = new WebSocket(uri.getAbsoluteUri(), this.options.requestedSubProtocols);
                this.socket.binaryType = "arraybuffer";
                this.socket.onopen = function () {
                    self.state = "open";
                    tcs.setResult(null);
                };

                this.socket.onmessage = function (e) {
                    var data = e.data,
                        message = {},
                        i;

                    message.bytes = [];

                    if (typeof (data) === "string") {
                        for (i = 0; i < data.length; ++i) {
                            message.bytes.push(data.charCodeAt(i));
                        }

                        message.messageType = "text";
                        self.messageBuffer.push(message);

                        return;
                    }

                    if (data instanceof ArrayBuffer) {
                        var dataView = new Uint8Array(data);

                        for (i = 0; i < dataView.length; i++) {
                            message.bytes.push(dataView[i]);
                        }

                        message.messageType = "binary";
                        self.messageBuffer.push(message);

                        return;
                    }

                    throw new System.ArgumentException.$ctor1("Invalid message type.");
                };

                this.socket.onclose = function (e) {
                    self.state = "closed";
                    self.closeStatus = e.code;
                    self.closeStatusDescription = e.reason;
                }
            } catch (e) {
                tcs.setException(System.Exception.create(e));
            }

            return tcs.task;
        },

        sendAsync: function (buffer, messageType, endOfMessage, cancellationToken) {
            this.throwIfNotConnected();

            var tcs = new System.Threading.Tasks.TaskCompletionSource();

            try {
                if (messageType === "close") {
                    this.socket.close();
                } else {
                    var array = buffer.getArray(),
                        count = buffer.getCount(),
                        offset = buffer.getOffset();

                    var data = new Uint8Array(count);

                    for (var i = 0; i < count; i++) {
                        data[i] = array[i + offset];
                    }

                    if (messageType === "text") {
                        data = String.fromCharCode.apply(null, data);
                    }

                    this.socket.send(data);
                }

                tcs.setResult(null);
            } catch (e) {
                tcs.setException(System.Exception.create(e));
            }

            return tcs.task;
        },

        receiveAsync: function (buffer, cancellationToken) {
            this.throwIfNotConnected();

            var task,
                tcs = new System.Threading.Tasks.TaskCompletionSource(),
                self = this,
                asyncBody = Bridge.fn.bind(this, function () {
                    try {
                        if (cancellationToken.getIsCancellationRequested()) {
                            tcs.setException(new System.Threading.Tasks.TaskCanceledException("Receive has been cancelled.", tcs.task));

                            return;
                        }

                        if (self.messageBuffer.length === 0) {
                            task = System.Threading.Tasks.Task.delay(0);
                            task.continueWith(asyncBody);

                            return;
                        }

                        var message = self.messageBuffer[0],
                            array = buffer.getArray(),
                            resultBytes,
                            endOfMessage;

                        if (message.bytes.length <= array.length) {
                            self.messageBuffer.shift();
                            resultBytes = message.bytes;
                            endOfMessage = true;
                        } else {
                            resultBytes = message.bytes.slice(0, array.length);
                            message.bytes = message.bytes.slice(array.length, message.bytes.length);
                            endOfMessage = false;
                        }

                        for (var i = 0; i < resultBytes.length; i++) {
                            array[i] = resultBytes[i];
                        }

                        tcs.setResult(new System.Net.WebSockets.WebSocketReceiveResult(
                            resultBytes.length, message.messageType, endOfMessage));
                    } catch (e) {
                        tcs.setException(System.Exception.create(e));
                    }
                }, arguments);

            asyncBody();

            return tcs.task;
        },

        closeAsync: function (closeStatus, statusDescription, cancellationToken) {
            this.throwIfNotConnected();

            if (this.state !== "open") {
                throw new System.InvalidOperationException.$ctor1("Socket is not in connected state");
            }

            var tcs = new System.Threading.Tasks.TaskCompletionSource(),
                self = this,
                task,
                asyncBody = function () {
                    if (self.state === "closed") {
                        tcs.setResult(null);
                        return;
                    }

                    if (cancellationToken.getIsCancellationRequested()) {
                        tcs.setException(new System.Threading.Tasks.TaskCanceledException("Closing has been cancelled.", tcs.task));
                        return;
                    }

                    task = System.Threading.Tasks.Task.delay(0);
                    task.continueWith(asyncBody);
                };
            try {
                this.state = "closesent";
                this.socket.close(closeStatus, statusDescription);
            } catch (e) {
                tcs.setException(System.Exception.create(e));
            }

            asyncBody();

            return tcs.task;
        },

        closeOutputAsync: function (closeStatus, statusDescription, cancellationToken) {
            this.throwIfNotConnected();

            if (this.state !== "open") {
                throw new System.InvalidOperationException.$ctor1("Socket is not in connected state");
            }

            var tcs = new System.Threading.Tasks.TaskCompletionSource();

            try {
                this.state = "closesent";
                this.socket.close(closeStatus, statusDescription);
                tcs.setResult(null);
            } catch (e) {
                tcs.setException(System.Exception.create(e));
            }

            return tcs.task;
        },

        abort: function () {
            this.Dispose();
        },

        Dispose: function () {
            if (this.disposed) {
                return;
            }

            this.disposed = true;
            this.messageBuffer = [];

            if (state === "open") {
                this.state = "closesent";
                this.socket.close();
            }
        },

        throwIfNotConnected: function () {
            if (this.disposed) {
                throw new System.InvalidOperationException.$ctor1("Socket is disposed.");
            }

            if (this.socket.readyState !== 1) {
                throw new System.InvalidOperationException.$ctor1("Socket is not connected.");
            }
        }
    });

    Bridge.define("System.Net.WebSockets.ClientWebSocketOptions", {
        ctor: function () {
            this.$initialize();
            this.isReadOnly = false;
            this.requestedSubProtocols = [];
        },

        setToReadOnly: function () {
            if (this.isReadOnly) {
                throw new System.InvalidOperationException.$ctor1("Options are already readonly.");
            }

            this.isReadOnly = true;
        },

        addSubProtocol: function (subProtocol) {
            if (this.isReadOnly) {
                throw new System.InvalidOperationException.$ctor1("Socket already started.");
            }

            if (this.requestedSubProtocols.indexOf(subProtocol) > -1) {
                throw new System.ArgumentException.$ctor1("Socket cannot have duplicate sub-protocols.", "subProtocol");
            }

            this.requestedSubProtocols.push(subProtocol);
        }
    });

    Bridge.define("System.Net.WebSockets.WebSocketReceiveResult", {
        ctor: function (count, messageType, endOfMessage, closeStatus, closeStatusDescription) {
            this.$initialize();
            this.count = count;
            this.messageType = messageType;
            this.endOfMessage = endOfMessage;
            this.closeStatus = closeStatus;
            this.closeStatusDescription = closeStatusDescription;
        },

        getCount: function () {
            return this.count;
        },

        getMessageType: function () {
            return this.messageType;
        },

        getEndOfMessage: function () {
            return this.endOfMessage;
        },

        getCloseStatus: function () {
            return this.closeStatus;
        },

        getCloseStatusDescription: function () {
            return this.closeStatusDescription;
        }
    });

    // @source Uri.js

    Bridge.assembly("System", {}, function ($asm, globals) {
        "use strict";

        Bridge.define("System.Uri", {
            statics: {
                methods: {
                    equals: function (uri1, uri2) {
                        if (uri1 == uri2) {
                            return true;
                        }

                        if (uri1 == null || uri2 == null) {
                            return false;
                        }

                        return uri2.equals(uri1);
                    },

                    notEquals: function (uri1, uri2) {
                        return !System.Uri.equals(uri1, uri2);
                    }
                }
            },

            ctor: function (uriString) {
                this.$initialize();
                this.absoluteUri = uriString;
            },

            getAbsoluteUri: function () {
                return this.absoluteUri;
            },

            toJSON: function () {
                return this.absoluteUri;
            },

            toString: function () {
                return this.absoluteUri;
            },

            equals: function (uri) {
                if (uri == null || !Bridge.is(uri, System.Uri)) {
                    return false;
                }

                return this.absoluteUri === uri.absoluteUri;
            }
        });
    }, true);

    // @source Generator.js

    Bridge.define("Bridge.GeneratorEnumerable", {
        inherits: [System.Collections.IEnumerable],

        config: {
            alias: [
            "GetEnumerator", "System$Collections$IEnumerable$GetEnumerator"
            ]
        },

        ctor: function (action) {
            this.$initialize();
            this.GetEnumerator = action;
            this.System$Collections$IEnumerable$GetEnumerator = action;
        }
    });

    Bridge.define("Bridge.GeneratorEnumerable$1", function (T)
    {
        return {
            inherits: [System.Collections.Generic.IEnumerable$1(T)],

            config: {
                alias: [
                "GetEnumerator", ["System$Collections$Generic$IEnumerable$1$" + Bridge.getTypeAlias(T) + "$GetEnumerator", "System$Collections$Generic$IEnumerable$1$GetEnumerator"]
                ]
            },

            ctor: function (action) {
                this.$initialize();
                this.GetEnumerator = action;
                this["System$Collections$Generic$IEnumerable$1$" + Bridge.getTypeAlias(T) + "$GetEnumerator"] = action;
                this["System$Collections$Generic$IEnumerable$1$GetEnumerator"] = action;
            }
        };
    });

    Bridge.define("Bridge.GeneratorEnumerator", {
        inherits: [System.Collections.IEnumerator],

        current: null,

        config: {
            properties: {
                Current: {
                    get: function () {
                        return this.getCurrent();
                    }
                }
            },

            alias: [
                "getCurrent", "System$Collections$IEnumerator$getCurrent",
                "moveNext", "System$Collections$IEnumerator$moveNext",
                "reset", "System$Collections$IEnumerator$reset",
                "Current", "System$Collections$IEnumerator$Current"
            ]
        },

        ctor: function (action) {
            this.$initialize();
            this.moveNext = action;
            this.System$Collections$IEnumerator$moveNext = action;
        },

        getCurrent: function () {
            return this.current;
        },

        getCurrent$1: function () {
            return this.current;
        },

        reset: function () {
            throw new System.NotSupportedException();
        }
    });

    Bridge.define("Bridge.GeneratorEnumerator$1", function (T) {
        return {
            inherits: [System.Collections.Generic.IEnumerator$1(T), System.IDisposable],

            current: null,

            config: {
                properties: {
                    Current: {
                        get: function () {
                            return this.getCurrent();
                        }
                    },

                    Current$1: {
                        get: function () {
                            return this.getCurrent();
                        }
                    }
                },
                alias: [
                    "getCurrent", ["System$Collections$Generic$IEnumerator$1$" + Bridge.getTypeAlias(T) + "$getCurrent$1", "System$Collections$Generic$IEnumerator$1$getCurrent$1"],
                    "Current", ["System$Collections$Generic$IEnumerator$1$" + Bridge.getTypeAlias(T) + "$Current$1", "System$Collections$Generic$IEnumerator$1$Current$1"],
                    "Current", "System$Collections$IEnumerator$Current",
                    "Dispose", "System$IDisposable$Dispose",
                    "moveNext", "System$Collections$IEnumerator$moveNext",
                    "reset", "System$Collections$IEnumerator$reset"
                ]
            },

            ctor: function (action, final) {
                this.$initialize();
                this.moveNext = action;
                this.System$Collections$IEnumerator$moveNext = action;
                this.final = final;
            },

            getCurrent: function () {
                return this.current;
            },

            getCurrent$1: function () {
                return this.current;
            },

            System$Collections$IEnumerator$getCurrent: function () {
                return this.current;
            },

            Dispose: function () {
                if (this.final) {
                    this.final();
                }
            },

            reset: function () {
                throw new System.NotSupportedException();
            }
        };
    });
    // @source linq.js

/*--------------------------------------------------------------------------
 * linq.js - LINQ for JavaScript
 * ver 3.0.4-Beta5 (Jun. 20th, 2013)
 *
 * created and maintained by neuecc <ils@neue.cc>
 * licensed under MIT License
 * http://linqjs.codeplex.com/
 *------------------------------------------------------------------------*/

(function (root, undefined) {
    // ReadOnly Function
    var Functions = {
        Identity: function (x) { return x; },
        True: function () { return true; },
        Blank: function () { }
    };

    // const Type
    var Types = {
        Boolean: typeof true,
        Number: typeof 0,
        String: typeof "",
        Object: typeof {},
        Undefined: typeof undefined,
        Function: typeof function () { }
    };

    // createLambda cache
    var funcCache = { "": Functions.Identity };

    // private utility methods
    var Utils = {
        // Create anonymous function from lambda expression string
        createLambda: function (expression) {
            if (expression == null) return Functions.Identity;
            if (typeof expression === Types.String) {
                // get from cache
                var f = funcCache[expression];
                if (f != null) {
                    return f;
                }

                if (expression.indexOf("=>") === -1) {
                    var regexp = new RegExp("[$]+", "g");

                    var maxLength = 0;
                    var match;
                    while ((match = regexp.exec(expression)) != null) {
                        var paramNumber = match[0].length;
                        if (paramNumber > maxLength) {
                            maxLength = paramNumber;
                        }
                    }

                    var argArray = [];
                    for (var i = 1; i <= maxLength; i++) {
                        var dollar = "";
                        for (var j = 0; j < i; j++) {
                            dollar += "$";
                        }
                        argArray.push(dollar);
                    }

                    var args = Array.prototype.join.call(argArray, ",");

                    f = new Function(args, "return " + expression);
                    funcCache[expression] = f;
                    return f;
                }
                else {
                    var expr = expression.match(/^[(\s]*([^()]*?)[)\s]*=>(.*)/);
                    f = new Function(expr[1], "return " + expr[2]);
                    funcCache[expression] = f;
                    return f;
                }
            }
            return expression;
        },

        isIEnumerable: function (obj) {
            if (typeof Enumerator !== Types.Undefined) {
                try {
                    new Enumerator(obj); // check JScript(IE)'s Enumerator
                    return true;
                }
                catch (e) { }
            }

            return false;
        },

        // IE8's defineProperty is defined but cannot use, therefore check defineProperties
        defineProperty: (Object.defineProperties != null)
            ? function (target, methodName, value) {
                Object.defineProperty(target, methodName, {
                    enumerable: false,
                    configurable: true,
                    writable: true,
                    value: value
                })
            }
            : function (target, methodName, value) {
                target[methodName] = value;
            },

        compare: function (a, b) {
            return (a === b) ? 0
                 : (a > b) ? 1
                 : -1;
        },

        Dispose: function (obj) {
            if (obj != null) obj.Dispose();
        }
    };

    // IEnumerator State
    var State = { Before: 0, Running: 1, After: 2 };

    // "Enumerator" is conflict JScript's "Enumerator"
    var IEnumerator = function (initialize, tryGetNext, dispose) {
        var yielder = new Yielder();
        var state = State.Before;

        this.getCurrent = yielder.getCurrent;
        this.reset = function () { throw new Error("Reset is not supported"); };

        this.moveNext = function () {
            try {
                switch (state) {
                    case State.Before:
                        state = State.Running;
                        initialize();
                        // fall through
                    case State.Running:
                        if (tryGetNext.apply(yielder)) {
                            return true;
                        }
                        else {
                            this.Dispose();
                            return false;
                        }
                    case State.After:
                        return false;
                }
            }
            catch (e) {
                this.Dispose();
                throw e;
            }
        };

        this.Dispose = function () {
            if (state != State.Running) return;

            try {
                dispose();
            }
            finally {
                state = State.After;
            }
        };

        this.System$IDisposable$Dispose = this.Dispose;
        this.getCurrent$1 = this.getCurrent;
        this.System$Collections$IEnumerator$getCurrent = this.getCurrent;
        this.System$Collections$IEnumerator$moveNext = this.moveNext;
        this.System$Collections$IEnumerator$reset = this.reset;

        Object.defineProperties(this,
        {
            "Current$1": {
                get: this.getCurrent,
                enumerable: true
            },

            "Current": {
                get: this.getCurrent,
                enumerable: true
            },

            "System$Collections$IEnumerator$Current": {
                get: this.getCurrent,
                enumerable: true
            }
        });
    };

    IEnumerator.$$inherits = [];
    Bridge.Class.addExtend(IEnumerator, [System.IDisposable, System.Collections.IEnumerator]);

    // for tryGetNext
    var Yielder = function () {
        var current = null;
        this.getCurrent = function () { return current; };
        this.yieldReturn = function (value) {
            current = value;
            return true;
        };
        this.yieldBreak = function () {
            return false;
        };
    };

    // Enumerable constuctor
    var Enumerable = function (GetEnumerator) {
        this.GetEnumerator = GetEnumerator;
    };

    Enumerable.$$inherits = [];
    Bridge.Class.addExtend(Enumerable, [System.Collections.IEnumerable]);

    // Utility

    Enumerable.Utils = {}; // container

    Enumerable.Utils.createLambda = function (expression) {
        return Utils.createLambda(expression);
    };

    Enumerable.Utils.createEnumerable = function (GetEnumerator) {
        return new Enumerable(GetEnumerator);
    };

    Enumerable.Utils.createEnumerator = function (initialize, tryGetNext, dispose) {
        return new IEnumerator(initialize, tryGetNext, dispose);
    };

    Enumerable.Utils.extendTo = function (type) {
        var typeProto = type.prototype;
        var enumerableProto;

        if (type === Array) {
            enumerableProto = ArrayEnumerable.prototype;
            Utils.defineProperty(typeProto, "getSource", function () {
                return this;
            });
        }
        else {
            enumerableProto = Enumerable.prototype;
            Utils.defineProperty(typeProto, "GetEnumerator", function () {
                return Enumerable.from(this).GetEnumerator();
            });
        }

        for (var methodName in enumerableProto) {
            var func = enumerableProto[methodName];

            // already extended
            if (typeProto[methodName] == func) continue;

            // already defined(example Array#reverse/join/forEach...)
            if (typeProto[methodName] != null) {
                methodName = methodName + "ByLinq";
                if (typeProto[methodName] == func) continue; // recheck
            }

            if (func instanceof Function) {
                Utils.defineProperty(typeProto, methodName, func);
            }
        }
    };

    // Generator

    Enumerable.choice = function () // variable argument
    {
        var args = arguments;

        return new Enumerable(function () {
            return new IEnumerator(
                function () {
                    args = (args[0] instanceof Array) ? args[0]
                        : (args[0].GetEnumerator != null) ? args[0].ToArray()
                        : args;
                },
                function () {
                    return this.yieldReturn(args[Math.floor(Math.random() * args.length)]);
                },
                Functions.Blank);
        });
    };

    Enumerable.cycle = function () // variable argument
    {
        var args = arguments;

        return new Enumerable(function () {
            var index = 0;
            return new IEnumerator(
                function () {
                    args = (args[0] instanceof Array) ? args[0]
                        : (args[0].GetEnumerator != null) ? args[0].ToArray()
                        : args;
                },
                function () {
                    if (index >= args.length) index = 0;
                    return this.yieldReturn(args[index++]);
                },
                Functions.Blank);
        });
    };

    // private singleton
    var emptyEnumerable = new Enumerable(function () {
            return new IEnumerator(
                Functions.Blank,
                function () { return false; },
                Functions.Blank);
        });
    Enumerable.empty = function () {
        return emptyEnumerable;
    };

    Enumerable.from = function (obj) {
        if (obj == null) {
            return Enumerable.empty();
        }
        if (obj instanceof Enumerable) {
            return obj;
        }
        if (typeof obj == Types.Number || typeof obj == Types.Boolean) {
            return Enumerable.repeat(obj, 1);
        }
        if (typeof obj == Types.String) {
            return new Enumerable(function () {
                var index = 0;
                return new IEnumerator(
                    Functions.Blank,
                    function () {
                        return (index < obj.length) ? this.yieldReturn(obj.charCodeAt(index++)) : false;
                    },
                    Functions.Blank);
            });
        }
        var ienum = Bridge.as(obj, System.Collections.IEnumerable);
        if (ienum) {
            return new Enumerable(function () {
                var enumerator;
                return new IEnumerator(
                    function () { enumerator = Bridge.getEnumerator(ienum); },
                    function () {
                        var ok = enumerator.moveNext();
                        return ok ? this.yieldReturn(enumerator.Current) : false;
                    },
                    function () {
                        var disposable = Bridge.as(enumerator, System.IDisposable);
                        if (disposable) {
                            disposable.Dispose();
                        }
                    }
                );
            });
        }
        if (typeof obj != Types.Function) {
            // array or array like object
            if (typeof obj.length == Types.Number) {
                return new ArrayEnumerable(obj);
            }

            // JScript's IEnumerable
            if (!(obj instanceof Object) && Utils.isIEnumerable(obj)) {
                return new Enumerable(function () {
                    var isFirst = true;
                    var enumerator;
                    return new IEnumerator(
                        function () { enumerator = new Enumerator(obj); },
                        function () {
                            if (isFirst) isFirst = false;
                            else enumerator.moveNext();

                            return (enumerator.atEnd()) ? false : this.yieldReturn(enumerator.item());
                        },
                        Functions.Blank);
                });
            }

            // WinMD IIterable<T>
            if (typeof Windows === Types.Object && typeof obj.first === Types.Function) {
                return new Enumerable(function () {
                    var isFirst = true;
                    var enumerator;
                    return new IEnumerator(
                        function () { enumerator = obj.first(); },
                        function () {
                            if (isFirst) isFirst = false;
                            else enumerator.moveNext();

                            return (enumerator.hasCurrent) ? this.yieldReturn(enumerator.current) : this.yieldBreak();
                        },
                        Functions.Blank);
                });
            }
        }

        // case function/object : Create keyValuePair[]
        return new Enumerable(function () {
            var array = [];
            var index = 0;

            return new IEnumerator(
                function () {
                    for (var key in obj) {
                        var value = obj[key];
                        if (!(value instanceof Function) && Object.prototype.hasOwnProperty.call(obj, key)) {
                            array.push({ key: key, value: value });
                        }
                    }
                },
                function () {
                    return (index < array.length)
                        ? this.yieldReturn(array[index++])
                        : false;
                },
                Functions.Blank);
        });
    },

    Enumerable.make = function (element) {
        return Enumerable.repeat(element, 1);
    };

    // Overload:function (input, pattern)
    // Overload:function (input, pattern, flags)
    Enumerable.matches = function (input, pattern, flags) {
        if (flags == null) flags = "";
        if (pattern instanceof RegExp) {
            flags += (pattern.ignoreCase) ? "i" : "";
            flags += (pattern.multiline) ? "m" : "";
            pattern = pattern.source;
        }
        if (flags.indexOf("g") === -1) flags += "g";

        return new Enumerable(function () {
            var regex;
            return new IEnumerator(
                function () { regex = new RegExp(pattern, flags); },
                function () {
                    var match = regex.exec(input);
                    return (match) ? this.yieldReturn(match) : false;
                },
                Functions.Blank);
        });
    };

    // Overload:function (start, count)
    // Overload:function (start, count, step)
    Enumerable.range = function (start, count, step) {
        if (step == null) step = 1;

        return new Enumerable(function () {
            var value;
            var index = 0;

            return new IEnumerator(
                function () { value = start - step; },
                function () {
                    return (index++ < count)
                        ? this.yieldReturn(value += step)
                        : this.yieldBreak();
                },
                Functions.Blank);
        });
    };

    // Overload:function (start, count)
    // Overload:function (start, count, step)
    Enumerable.rangeDown = function (start, count, step) {
        if (step == null) step = 1;

        return new Enumerable(function () {
            var value;
            var index = 0;

            return new IEnumerator(
                function () { value = start + step; },
                function () {
                    return (index++ < count)
                        ? this.yieldReturn(value -= step)
                        : this.yieldBreak();
                },
                Functions.Blank);
        });
    };

    // Overload:function (start, to)
    // Overload:function (start, to, step)
    Enumerable.rangeTo = function (start, to, step) {
        if (step == null) step = 1;

        if (start < to) {
            return new Enumerable(function () {
                var value;

                return new IEnumerator(
                function () { value = start - step; },
                function () {
                    var next = value += step;
                    return (next <= to)
                        ? this.yieldReturn(next)
                        : this.yieldBreak();
                },
                Functions.Blank);
            });
        }
        else {
            return new Enumerable(function () {
                var value;

                return new IEnumerator(
                function () { value = start + step; },
                function () {
                    var next = value -= step;
                    return (next >= to)
                        ? this.yieldReturn(next)
                        : this.yieldBreak();
                },
                Functions.Blank);
            });
        }
    };

    // Overload:function (element)
    // Overload:function (element, count)
    Enumerable.repeat = function (element, count) {
        if (count != null) return Enumerable.repeat(element).take(count);

        return new Enumerable(function () {
            return new IEnumerator(
                Functions.Blank,
                function () { return this.yieldReturn(element); },
                Functions.Blank);
        });
    };

    Enumerable.repeatWithFinalize = function (initializer, finalizer) {
        initializer = Utils.createLambda(initializer);
        finalizer = Utils.createLambda(finalizer);

        return new Enumerable(function () {
            var element;
            return new IEnumerator(
                function () { element = initializer(); },
                function () { return this.yieldReturn(element); },
                function () {
                    if (element != null) {
                        finalizer(element);
                        element = null;
                    }
                });
        });
    };

    // Overload:function (func)
    // Overload:function (func, count)
    Enumerable.generate = function (func, count) {
        if (count != null) return Enumerable.generate(func).take(count);
        func = Utils.createLambda(func);

        return new Enumerable(function () {
            return new IEnumerator(
                Functions.Blank,
                function () { return this.yieldReturn(func()); },
                Functions.Blank);
        });
    };

    // Overload:function ()
    // Overload:function (start)
    // Overload:function (start, step)
    Enumerable.toInfinity = function (start, step) {
        if (start == null) start = 0;
        if (step == null) step = 1;

        return new Enumerable(function () {
            var value;
            return new IEnumerator(
                function () { value = start - step; },
                function () { return this.yieldReturn(value += step); },
                Functions.Blank);
        });
    };

    // Overload:function ()
    // Overload:function (start)
    // Overload:function (start, step)
    Enumerable.toNegativeInfinity = function (start, step) {
        if (start == null) start = 0;
        if (step == null) step = 1;

        return new Enumerable(function () {
            var value;
            return new IEnumerator(
                function () { value = start + step; },
                function () { return this.yieldReturn(value -= step); },
                Functions.Blank);
        });
    };

    Enumerable.unfold = function (seed, func) {
        func = Utils.createLambda(func);

        return new Enumerable(function () {
            var isFirst = true;
            var value;
            return new IEnumerator(
                Functions.Blank,
                function () {
                    if (isFirst) {
                        isFirst = false;
                        value = seed;
                        return this.yieldReturn(value);
                    }
                    value = func(value);
                    return this.yieldReturn(value);
                },
                Functions.Blank);
        });
    };

    Enumerable.defer = function (enumerableFactory) {
        return new Enumerable(function () {
            var enumerator;

            return new IEnumerator(
                function () { enumerator = Enumerable.from(enumerableFactory()).GetEnumerator(); },
                function () {
                    return (enumerator.moveNext())
                        ? this.yieldReturn(enumerator.Current)
                        : this.yieldBreak();
                },
                function () {
                    Utils.Dispose(enumerator);
                });
        });
    };

    // Extension Methods

    /* Projection and Filtering Methods */

    // Overload:function (func)
    // Overload:function (func, resultSelector<element>)
    // Overload:function (func, resultSelector<element, nestLevel>)
    Enumerable.prototype.traverseBreadthFirst = function (func, resultSelector) {
        var source = this;
        func = Utils.createLambda(func);
        resultSelector = Utils.createLambda(resultSelector);

        return new Enumerable(function () {
            var enumerator;
            var nestLevel = 0;
            var buffer = [];

            return new IEnumerator(
                function () { enumerator = source.GetEnumerator(); },
                function () {
                    while (true) {
                        if (enumerator.moveNext()) {
                            buffer.push(enumerator.Current);
                            return this.yieldReturn(resultSelector(enumerator.Current, nestLevel));
                        }

                        var next = Enumerable.from(buffer).selectMany(function (x) { return func(x); });
                        if (!next.any()) {
                            return false;
                        }
                        else {
                            nestLevel++;
                            buffer = [];
                            Utils.Dispose(enumerator);
                            enumerator = next.GetEnumerator();
                        }
                    }
                },
                function () { Utils.Dispose(enumerator); });
        });
    };

    // Overload:function (func)
    // Overload:function (func, resultSelector<element>)
    // Overload:function (func, resultSelector<element, nestLevel>)
    Enumerable.prototype.traverseDepthFirst = function (func, resultSelector) {
        var source = this;
        func = Utils.createLambda(func);
        resultSelector = Utils.createLambda(resultSelector);

        return new Enumerable(function () {
            var enumeratorStack = [];
            var enumerator;

            return new IEnumerator(
                function () { enumerator = source.GetEnumerator(); },
                function () {
                    while (true) {
                        if (enumerator.moveNext()) {
                            var value = resultSelector(enumerator.Current, enumeratorStack.length);
                            enumeratorStack.push(enumerator);
                            enumerator = Enumerable.from(func(enumerator.Current)).GetEnumerator();
                            return this.yieldReturn(value);
                        }

                        if (enumeratorStack.length <= 0) return false;
                        Utils.Dispose(enumerator);
                        enumerator = enumeratorStack.pop();
                    }
                },
                function () {
                    try {
                        Utils.Dispose(enumerator);
                    }
                    finally {
                        Enumerable.from(enumeratorStack).forEach(function (s) { s.Dispose(); });
                    }
                });
        });
    };

    Enumerable.prototype.flatten = function () {
        var source = this;

        return new Enumerable(function () {
            var enumerator;
            var middleEnumerator = null;

            return new IEnumerator(
                function () { enumerator = source.GetEnumerator(); },
                function () {
                    while (true) {
                        if (middleEnumerator != null) {
                            if (middleEnumerator.moveNext()) {
                                return this.yieldReturn(middleEnumerator.Current);
                            }
                            else {
                                middleEnumerator = null;
                            }
                        }

                        if (enumerator.moveNext()) {
                            if (enumerator.Current instanceof Array) {
                                Utils.Dispose(middleEnumerator);
                                middleEnumerator = Enumerable.from(enumerator.Current)
                                    .selectMany(Functions.Identity)
                                    .flatten()
                                    .GetEnumerator();
                                continue;
                            }
                            else {
                                return this.yieldReturn(enumerator.Current);
                            }
                        }

                        return false;
                    }
                },
                function () {
                    try {
                        Utils.Dispose(enumerator);
                    }
                    finally {
                        Utils.Dispose(middleEnumerator);
                    }
                });
        });
    };

    Enumerable.prototype.pairwise = function (selector) {
        var source = this;
        selector = Utils.createLambda(selector);

        return new Enumerable(function () {
            var enumerator;

            return new IEnumerator(
                function () {
                    enumerator = source.GetEnumerator();
                    enumerator.moveNext();
                },
                function () {
                    var prev = enumerator.Current;
                    return (enumerator.moveNext())
                        ? this.yieldReturn(selector(prev, enumerator.Current))
                        : false;
                },
                function () { Utils.Dispose(enumerator); });
        });
    };

    // Overload:function (func)
    // Overload:function (seed,func<value,element>)
    Enumerable.prototype.scan = function (seed, func) {
        var isUseSeed;
        if (func == null) {
            func = Utils.createLambda(seed); // arguments[0]
            isUseSeed = false;
        } else {
            func = Utils.createLambda(func);
            isUseSeed = true;
        }
        var source = this;

        return new Enumerable(function () {
            var enumerator;
            var value;
            var isFirst = true;

            return new IEnumerator(
                function () { enumerator = source.GetEnumerator(); },
                function () {
                    if (isFirst) {
                        isFirst = false;
                        if (!isUseSeed) {
                            if (enumerator.moveNext()) {
                                return this.yieldReturn(value = enumerator.Current);
                            }
                        }
                        else {
                            return this.yieldReturn(value = seed);
                        }
                    }

                    return (enumerator.moveNext())
                        ? this.yieldReturn(value = func(value, enumerator.Current))
                        : false;
                },
                function () { Utils.Dispose(enumerator); });
        });
    };

    // Overload:function (selector<element>)
    // Overload:function (selector<element,index>)
    Enumerable.prototype.select = function (selector) {
        selector = Utils.createLambda(selector);

        if (selector.length <= 1) {
            return new WhereSelectEnumerable(this, null, selector);
        }
        else {
            var source = this;

            return new Enumerable(function () {
                var enumerator;
                var index = 0;

                return new IEnumerator(
                    function () { enumerator = source.GetEnumerator(); },
                    function () {
                        return (enumerator.moveNext())
                            ? this.yieldReturn(selector(enumerator.Current, index++))
                            : false;
                    },
                    function () { Utils.Dispose(enumerator); });
            });
        }
    };

    // Overload:function (collectionSelector<element>)
    // Overload:function (collectionSelector<element,index>)
    // Overload:function (collectionSelector<element>,resultSelector)
    // Overload:function (collectionSelector<element,index>,resultSelector)
    Enumerable.prototype.selectMany = function (collectionSelector, resultSelector) {
        var source = this;
        collectionSelector = Utils.createLambda(collectionSelector);
        if (resultSelector == null) resultSelector = function (a, b) { return b; };
        resultSelector = Utils.createLambda(resultSelector);

        return new Enumerable(function () {
            var enumerator;
            var middleEnumerator = undefined;
            var index = 0;

            return new IEnumerator(
                function () { enumerator = source.GetEnumerator(); },
                function () {
                    if (middleEnumerator === undefined) {
                        if (!enumerator.moveNext()) return false;
                    }
                    do {
                        if (middleEnumerator == null) {
                            var middleSeq = collectionSelector(enumerator.Current, index++);
                            middleEnumerator = Enumerable.from(middleSeq).GetEnumerator();
                        }
                        if (middleEnumerator.moveNext()) {
                            return this.yieldReturn(resultSelector(enumerator.Current, middleEnumerator.Current));
                        }
                        Utils.Dispose(middleEnumerator);
                        middleEnumerator = null;
                    } while (enumerator.moveNext());
                    return false;
                },
                function () {
                    try {
                        Utils.Dispose(enumerator);
                    }
                    finally {
                        Utils.Dispose(middleEnumerator);
                    }
                });
        });
    };

    // Overload:function (predicate<element>)
    // Overload:function (predicate<element,index>)
    Enumerable.prototype.where = function (predicate) {
        predicate = Utils.createLambda(predicate);

        if (predicate.length <= 1) {
            return new WhereEnumerable(this, predicate);
        }
        else {
            var source = this;

            return new Enumerable(function () {
                var enumerator;
                var index = 0;

                return new IEnumerator(
                    function () { enumerator = source.GetEnumerator(); },
                    function () {
                        while (enumerator.moveNext()) {
                            if (predicate(enumerator.Current, index++)) {
                                return this.yieldReturn(enumerator.Current);
                            }
                        }
                        return false;
                    },
                    function () { Utils.Dispose(enumerator); });
            });
        }
    };

    // Overload:function (selector<element>)
    // Overload:function (selector<element,index>)
    Enumerable.prototype.choose = function (selector) {
        selector = Utils.createLambda(selector);
        var source = this;

        return new Enumerable(function () {
            var enumerator;
            var index = 0;

            return new IEnumerator(
                function () { enumerator = source.GetEnumerator(); },
                function () {
                    while (enumerator.moveNext()) {
                        var result = selector(enumerator.Current, index++);
                        if (result != null) {
                            return this.yieldReturn(result);
                        }
                    }
                    return this.yieldBreak();
                },
                function () { Utils.Dispose(enumerator); });
        });
    };

    Enumerable.prototype.ofType = function (type) {
        var source = this;

        return new Enumerable(function () {
            var enumerator;

            return new IEnumerator(
                function () {
                    enumerator = Bridge.getEnumerator(source);
                },
                function () {
                    while (enumerator.moveNext()) {
                        var v = Bridge.as(enumerator.Current, type);
                        if (Bridge.hasValue(v)) {
                            return this.yieldReturn(v);
                        }
                    }
                    return false;
                },
                function () {
                    Utils.Dispose(enumerator);
                });
        });
    };

    // mutiple arguments, last one is selector, others are enumerable
    Enumerable.prototype.zip = function () {
        var args = arguments;
        var selector = Utils.createLambda(arguments[arguments.length - 1]);

        var source = this;
        // optimized case:argument is 2
        if (arguments.length == 2) {
            var second = arguments[0];

            return new Enumerable(function () {
                var firstEnumerator;
                var secondEnumerator;
                var index = 0;

                return new IEnumerator(
                function () {
                    firstEnumerator = source.GetEnumerator();
                    secondEnumerator = Enumerable.from(second).GetEnumerator();
                },
                function () {
                    if (firstEnumerator.moveNext() && secondEnumerator.moveNext()) {
                        return this.yieldReturn(selector(firstEnumerator.Current, secondEnumerator.Current, index++));
                    }
                    return false;
                },
                function () {
                    try {
                        Utils.Dispose(firstEnumerator);
                    } finally {
                        Utils.Dispose(secondEnumerator);
                    }
                });
            });
        }
        else {
            return new Enumerable(function () {
                var enumerators;
                var index = 0;

                return new IEnumerator(
                function () {
                    var array = Enumerable.make(source)
                        .concat(Enumerable.from(args).takeExceptLast().select(Enumerable.from))
                        .select(function (x) { return x.GetEnumerator() })
                        .ToArray();
                    enumerators = Enumerable.from(array);
                },
                function () {
                    if (enumerators.all(function (x) { return x.moveNext() })) {
                        var array = enumerators
                            .select(function (x) { return x.Current; })
                            .ToArray();
                        array.push(index++);
                        return this.yieldReturn(selector.apply(null, array));
                    }
                    else {
                        return this.yieldBreak();
                    }
                },
                function () {
                    Enumerable.from(enumerators).forEach(Utils.Dispose);
                });
            });
        }
    };

    // mutiple arguments
    Enumerable.prototype.merge = function () {
        var args = arguments;
        var source = this;

        return new Enumerable(function () {
            var enumerators;
            var index = -1;

            return new IEnumerator(
                function () {
                    enumerators = Enumerable.make(source)
                        .concat(Enumerable.from(args).select(Enumerable.from))
                        .select(function (x) { return x.GetEnumerator() })
                        .ToArray();
                },
                function () {
                    while (enumerators.length > 0) {
                        index = (index >= enumerators.length - 1) ? 0 : index + 1;
                        var enumerator = enumerators[index];

                        if (enumerator.moveNext()) {
                            return this.yieldReturn(enumerator.Current);
                        }
                        else {
                            enumerator.Dispose();
                            enumerators.splice(index--, 1);
                        }
                    }
                    return this.yieldBreak();
                },
                function () {
                    Enumerable.from(enumerators).forEach(Utils.Dispose);
                });
        });
    };

    /* Join Methods */

    // Overload:function (inner, outerKeySelector, innerKeySelector, resultSelector)
    // Overload:function (inner, outerKeySelector, innerKeySelector, resultSelector, compareSelector)
    Enumerable.prototype.join = function (inner, outerKeySelector, innerKeySelector, resultSelector, comparer) {
        outerKeySelector = Utils.createLambda(outerKeySelector);
        innerKeySelector = Utils.createLambda(innerKeySelector);
        resultSelector = Utils.createLambda(resultSelector);

        var source = this;

        return new Enumerable(function () {
            var outerEnumerator;
            var lookup;
            var innerElements = null;
            var innerCount = 0;

            return new IEnumerator(
                function () {
                    outerEnumerator = source.GetEnumerator();
                    lookup = Enumerable.from(inner).toLookup(innerKeySelector, Functions.Identity, comparer);
                },
                function () {
                    while (true) {
                        if (innerElements != null) {
                            var innerElement = innerElements[innerCount++];
                            if (innerElement !== undefined) {
                                return this.yieldReturn(resultSelector(outerEnumerator.Current, innerElement));
                            }

                            innerElement = null;
                            innerCount = 0;
                        }

                        if (outerEnumerator.moveNext()) {
                            var key = outerKeySelector(outerEnumerator.Current);
                            innerElements = lookup.get(key).ToArray();
                        } else {
                            return false;
                        }
                    }
                },
                function () { Utils.Dispose(outerEnumerator); });
        });
    };

    // Overload:function (inner, outerKeySelector, innerKeySelector, resultSelector)
    // Overload:function (inner, outerKeySelector, innerKeySelector, resultSelector, compareSelector)
    Enumerable.prototype.groupJoin = function (inner, outerKeySelector, innerKeySelector, resultSelector, comparer) {
        outerKeySelector = Utils.createLambda(outerKeySelector);
        innerKeySelector = Utils.createLambda(innerKeySelector);
        resultSelector = Utils.createLambda(resultSelector);
        var source = this;

        return new Enumerable(function () {
            var enumerator = source.GetEnumerator();
            var lookup = null;

            return new IEnumerator(
                function () {
                    enumerator = source.GetEnumerator();
                    lookup = Enumerable.from(inner).toLookup(innerKeySelector, Functions.Identity, comparer);
                },
                function () {
                    if (enumerator.moveNext()) {
                        var innerElement = lookup.get(outerKeySelector(enumerator.Current));
                        return this.yieldReturn(resultSelector(enumerator.Current, innerElement));
                    }
                    return false;
                },
                function () { Utils.Dispose(enumerator); });
        });
    };

    /* Set Methods */

    Enumerable.prototype.all = function (predicate) {
        predicate = Utils.createLambda(predicate);

        var result = true;
        this.forEach(function (x) {
            if (!predicate(x)) {
                result = false;
                return false; // break
            }
        });
        return result;
    };

    // Overload:function ()
    // Overload:function (predicate)
    Enumerable.prototype.any = function (predicate) {
        predicate = Utils.createLambda(predicate);

        var enumerator = this.GetEnumerator();
        try {
            if (arguments.length == 0) return enumerator.moveNext(); // case:function ()

            while (enumerator.moveNext()) // case:function (predicate)
            {
                if (predicate(enumerator.Current)) return true;
            }
            return false;
        }
        finally {
            Utils.Dispose(enumerator);
        }
    };

    Enumerable.prototype.isEmpty = function () {
        return !this.any();
    };

    // multiple arguments
    Enumerable.prototype.concat = function () {
        var source = this;

        if (arguments.length == 1) {
            var second = arguments[0];

            return new Enumerable(function () {
                var firstEnumerator;
                var secondEnumerator;

                return new IEnumerator(
                function () { firstEnumerator = source.GetEnumerator(); },
                function () {
                    if (secondEnumerator == null) {
                        if (firstEnumerator.moveNext()) return this.yieldReturn(firstEnumerator.Current);
                        secondEnumerator = Enumerable.from(second).GetEnumerator();
                    }
                    if (secondEnumerator.moveNext()) return this.yieldReturn(secondEnumerator.Current);
                    return false;
                },
                function () {
                    try {
                        Utils.Dispose(firstEnumerator);
                    }
                    finally {
                        Utils.Dispose(secondEnumerator);
                    }
                });
            });
        }
        else {
            var args = arguments;

            return new Enumerable(function () {
                var enumerators;

                return new IEnumerator(
                    function () {
                        enumerators = Enumerable.make(source)
                            .concat(Enumerable.from(args).select(Enumerable.from))
                            .select(function (x) { return x.GetEnumerator() })
                            .ToArray();
                    },
                    function () {
                        while (enumerators.length > 0) {
                            var enumerator = enumerators[0];

                            if (enumerator.moveNext()) {
                                return this.yieldReturn(enumerator.Current);
                            }
                            else {
                                enumerator.Dispose();
                                enumerators.splice(0, 1);
                            }
                        }
                        return this.yieldBreak();
                    },
                    function () {
                        Enumerable.from(enumerators).forEach(Utils.Dispose);
                    });
            });
        }
    };

    Enumerable.prototype.insert = function (index, second) {
        var source = this;

        return new Enumerable(function () {
            var firstEnumerator;
            var secondEnumerator;
            var count = 0;
            var isEnumerated = false;

            return new IEnumerator(
                function () {
                    firstEnumerator = source.GetEnumerator();
                    secondEnumerator = Enumerable.from(second).GetEnumerator();
                },
                function () {
                    if (count == index && secondEnumerator.moveNext()) {
                        isEnumerated = true;
                        return this.yieldReturn(secondEnumerator.Current);
                    }
                    if (firstEnumerator.moveNext()) {
                        count++;
                        return this.yieldReturn(firstEnumerator.Current);
                    }
                    if (!isEnumerated && secondEnumerator.moveNext()) {
                        return this.yieldReturn(secondEnumerator.Current);
                    }
                    return false;
                },
                function () {
                    try {
                        Utils.Dispose(firstEnumerator);
                    }
                    finally {
                        Utils.Dispose(secondEnumerator);
                    }
                });
        });
    };

    Enumerable.prototype.alternate = function (alternateValueOrSequence) {
        var source = this;

        return new Enumerable(function () {
            var buffer;
            var enumerator;
            var alternateSequence;
            var alternateEnumerator;

            return new IEnumerator(
                function () {
                    if (alternateValueOrSequence instanceof Array || alternateValueOrSequence.GetEnumerator != null) {
                        alternateSequence = Enumerable.from(Enumerable.from(alternateValueOrSequence).ToArray()); // freeze
                    }
                    else {
                        alternateSequence = Enumerable.make(alternateValueOrSequence);
                    }
                    enumerator = source.GetEnumerator();
                    if (enumerator.moveNext()) buffer = enumerator.Current;
                },
                function () {
                    while (true) {
                        if (alternateEnumerator != null) {
                            if (alternateEnumerator.moveNext()) {
                                return this.yieldReturn(alternateEnumerator.Current);
                            }
                            else {
                                alternateEnumerator = null;
                            }
                        }

                        if (buffer == null && enumerator.moveNext()) {
                            buffer = enumerator.Current; // hasNext
                            alternateEnumerator = alternateSequence.GetEnumerator();
                            continue; // GOTO
                        }
                        else if (buffer != null) {
                            var retVal = buffer;
                            buffer = null;
                            return this.yieldReturn(retVal);
                        }

                        return this.yieldBreak();
                    }
                },
                function () {
                    try {
                        Utils.Dispose(enumerator);
                    }
                    finally {
                        Utils.Dispose(alternateEnumerator);
                    }
                });
        });
    };

    // Overload:function (value)
    // Overload:function (value, compareSelector)
    Enumerable.prototype.contains = function (value, comparer) {
        comparer = comparer || System.Collections.Generic.EqualityComparer$1.$default;
        var enumerator = this.GetEnumerator();
        try {
            while (enumerator.moveNext()) {
                if (comparer.equals2(enumerator.Current, value)) return true;
            }
            return false;
        }
        finally {
            Utils.Dispose(enumerator);
        }
    };

    Enumerable.prototype.defaultIfEmpty = function (defaultValue) {
        var source = this;
        if (defaultValue === undefined) defaultValue = null;

        return new Enumerable(function () {
            var enumerator;
            var isFirst = true;

            return new IEnumerator(
                function () { enumerator = source.GetEnumerator(); },
                function () {
                    if (enumerator.moveNext()) {
                        isFirst = false;
                        return this.yieldReturn(enumerator.Current);
                    }
                    else if (isFirst) {
                        isFirst = false;
                        return this.yieldReturn(defaultValue);
                    }
                    return false;
                },
                function () { Utils.Dispose(enumerator); });
        });
    };

    // Overload:function ()
    // Overload:function (compareSelector)
    Enumerable.prototype.distinct = function (comparer) {
        return this.except(Enumerable.empty(), comparer);
    };

    Enumerable.prototype.distinctUntilChanged = function (compareSelector) {
        compareSelector = Utils.createLambda(compareSelector);
        var source = this;

        return new Enumerable(function () {
            var enumerator;
            var compareKey;
            var initial;

            return new IEnumerator(
                function () {
                    enumerator = source.GetEnumerator();
                },
                function () {
                    while (enumerator.moveNext()) {
                        var key = compareSelector(enumerator.Current);

                        if (initial) {
                            initial = false;
                            compareKey = key;
                            return this.yieldReturn(enumerator.Current);
                        }

                        if (compareKey === key) {
                            continue;
                        }

                        compareKey = key;
                        return this.yieldReturn(enumerator.Current);
                    }
                    return this.yieldBreak();
                },
                function () { Utils.Dispose(enumerator); });
        });
    };

    // Overload:function (second)
    // Overload:function (second, compareSelector)
    Enumerable.prototype.except = function (second, comparer) {
        var source = this;

        return new Enumerable(function () {
            var enumerator;
            var keys;

            return new IEnumerator(
                function () {
                    enumerator = source.GetEnumerator();
                    keys = new (System.Collections.Generic.Dictionary$2(System.Object, System.Object))(null, comparer);
                    Enumerable.from(second).forEach(function (key) { if (!keys.containsKey(key)) { keys.add(key); } });
                },
                function () {
                    while (enumerator.moveNext()) {
                        var current = enumerator.Current;
                        if (!keys.containsKey(current)) {
                            keys.add(current);
                            return this.yieldReturn(current);
                        }
                    }
                    return false;
                },
                function () { Utils.Dispose(enumerator); });
        });
    };

    // Overload:function (second)
    // Overload:function (second, compareSelector)
    Enumerable.prototype.intersect = function (second, comparer) {
        var source = this;

        return new Enumerable(function () {
            var enumerator;
            var keys;
            var outs;

            return new IEnumerator(
                function () {
                    enumerator = source.GetEnumerator();

                    keys = new (System.Collections.Generic.Dictionary$2(System.Object, System.Object))(null, comparer);
                    Enumerable.from(second).forEach(function (key) { if (!keys.containsKey(key)) { keys.add(key); } });
                    outs = new (System.Collections.Generic.Dictionary$2(System.Object, System.Object))(null, comparer);
                },
                function () {
                    while (enumerator.moveNext()) {
                        var current = enumerator.Current;
                        if (!outs.containsKey(current) && keys.containsKey(current)) {
                            outs.add(current);
                            return this.yieldReturn(current);
                        }
                    }
                    return false;
                },
                function () { Utils.Dispose(enumerator); });
        });
    };

    // Overload:function (second)
    // Overload:function (second, compareSelector)
    Enumerable.prototype.sequenceEqual = function (second, comparer) {
        comparer = comparer || System.Collections.Generic.EqualityComparer$1.$default;

        var firstEnumerator = this.GetEnumerator();
        try {
            var secondEnumerator = Enumerable.from(second).GetEnumerator();
            try {
                while (firstEnumerator.moveNext()) {
                    if (!secondEnumerator.moveNext()
                    || !comparer.equals2(firstEnumerator.Current, secondEnumerator.Current)) {
                        return false;
                    }
                }

                if (secondEnumerator.moveNext()) return false;
                return true;
            }
            finally {
                Utils.Dispose(secondEnumerator);
            }
        }
        finally {
            Utils.Dispose(firstEnumerator);
        }
    };

    Enumerable.prototype.union = function (second, comparer) {
        var source = this;

        return new Enumerable(function () {
            var firstEnumerator;
            var secondEnumerator;
            var keys;

            return new IEnumerator(
                function () {
                    firstEnumerator = source.GetEnumerator();
                    keys = new (System.Collections.Generic.Dictionary$2(System.Object, System.Object))(null, comparer);
                },
                function () {
                    var current;
                    if (secondEnumerator === undefined) {
                        while (firstEnumerator.moveNext()) {
                            current = firstEnumerator.Current;
                            if (!keys.containsKey(current)) {
                                keys.add(current);
                                return this.yieldReturn(current);
                            }
                        }
                        secondEnumerator = Enumerable.from(second).GetEnumerator();
                    }
                    while (secondEnumerator.moveNext()) {
                        current = secondEnumerator.Current;
                        if (!keys.containsKey(current)) {
                            keys.add(current);
                            return this.yieldReturn(current);
                        }
                    }
                    return false;
                },
                function () {
                    try {
                        Utils.Dispose(firstEnumerator);
                    }
                    finally {
                        Utils.Dispose(secondEnumerator);
                    }
                });
        });
    };

    /* Ordering Methods */

    Enumerable.prototype.orderBy = function (keySelector, comparer) {
        return new OrderedEnumerable(this, keySelector, comparer, false);
    };

    Enumerable.prototype.orderByDescending = function (keySelector, comparer) {
        return new OrderedEnumerable(this, keySelector, comparer, true);
    };

    Enumerable.prototype.reverse = function () {
        var source = this;

        return new Enumerable(function () {
            var buffer;
            var index;

            return new IEnumerator(
                function () {
                    buffer = source.ToArray();
                    index = buffer.length;
                },
                function () {
                    return (index > 0)
                        ? this.yieldReturn(buffer[--index])
                        : false;
                },
                Functions.Blank);
        });
    };

    Enumerable.prototype.shuffle = function () {
        var source = this;

        return new Enumerable(function () {
            var buffer;

            return new IEnumerator(
                function () { buffer = source.ToArray(); },
                function () {
                    if (buffer.length > 0) {
                        var i = Math.floor(Math.random() * buffer.length);
                        return this.yieldReturn(buffer.splice(i, 1)[0]);
                    }
                    return false;
                },
                Functions.Blank);
        });
    };

    Enumerable.prototype.weightedSample = function (weightSelector) {
        weightSelector = Utils.createLambda(weightSelector);
        var source = this;

        return new Enumerable(function () {
            var sortedByBound;
            var totalWeight = 0;

            return new IEnumerator(
                function () {
                    sortedByBound = source
                        .choose(function (x) {
                            var weight = weightSelector(x);
                            if (weight <= 0) return null; // ignore 0

                            totalWeight += weight;
                            return { value: x, bound: totalWeight };
                        })
                        .ToArray();
                },
                function () {
                    if (sortedByBound.length > 0) {
                        var draw = Math.floor(Math.random() * totalWeight) + 1;

                        var lower = -1;
                        var upper = sortedByBound.length;
                        while (upper - lower > 1) {
                            var index = Math.floor((lower + upper) / 2);
                            if (sortedByBound[index].bound >= draw) {
                                upper = index;
                            }
                            else {
                                lower = index;
                            }
                        }

                        return this.yieldReturn(sortedByBound[upper].value);
                    }

                    return this.yieldBreak();
                },
                Functions.Blank);
        });
    };

    /* Grouping Methods */

    // Overload:function (keySelector)
    // Overload:function (keySelector,elementSelector)
    // Overload:function (keySelector,elementSelector,resultSelector)
    // Overload:function (keySelector,elementSelector,resultSelector,compareSelector)
    Enumerable.prototype.groupBy = function (keySelector, elementSelector, resultSelector, comparer) {
        var source = this;
        keySelector = Utils.createLambda(keySelector);
        elementSelector = Utils.createLambda(elementSelector);
        if (resultSelector != null) resultSelector = Utils.createLambda(resultSelector);

        return new Enumerable(function () {
            var enumerator;

            return new IEnumerator(
                function () {
                    enumerator = source.toLookup(keySelector, elementSelector, comparer)
                        .toEnumerable()
                        .GetEnumerator();
                },
                function () {
                    while (enumerator.moveNext()) {
                        return (resultSelector == null)
                            ? this.yieldReturn(enumerator.Current)
                            : this.yieldReturn(resultSelector(enumerator.Current.key(), enumerator.Current));
                    }
                    return false;
                },
                function () { Utils.Dispose(enumerator); });
        });
    };

    // Overload:function (keySelector)
    // Overload:function (keySelector,elementSelector)
    // Overload:function (keySelector,elementSelector,resultSelector)
    // Overload:function (keySelector,elementSelector,resultSelector,compareSelector)
    Enumerable.prototype.partitionBy = function (keySelector, elementSelector, resultSelector, comparer) {
        var source = this;
        keySelector = Utils.createLambda(keySelector);
        elementSelector = Utils.createLambda(elementSelector);
        comparer = comparer || System.Collections.Generic.EqualityComparer$1.$default;
        var hasResultSelector;
        if (resultSelector == null) {
            hasResultSelector = false;
            resultSelector = function (key, group) { return new Grouping(key, group); };
        }
        else {
            hasResultSelector = true;
            resultSelector = Utils.createLambda(resultSelector);
        }

        return new Enumerable(function () {
            var enumerator;
            var key;
            var group = [];

            return new IEnumerator(
                function () {
                    enumerator = source.GetEnumerator();
                    if (enumerator.moveNext()) {
                        key = keySelector(enumerator.Current);
                        group.push(elementSelector(enumerator.Current));
                    }
                },
                function () {
                    var hasNext;
                    while ((hasNext = enumerator.moveNext()) == true) {
                        if (comparer.equals2(key, keySelector(enumerator.Current))) {
                            group.push(elementSelector(enumerator.Current));
                        }
                        else break;
                    }

                    if (group.length > 0) {
                        var result = (hasResultSelector)
                            ? resultSelector(key, Enumerable.from(group))
                            : resultSelector(key, group);
                        if (hasNext) {
                            key = keySelector(enumerator.Current);
                            group = [elementSelector(enumerator.Current)];
                        }
                        else group = [];

                        return this.yieldReturn(result);
                    }

                    return false;
                },
                function () { Utils.Dispose(enumerator); });
        });
    };

    Enumerable.prototype.buffer = function (count) {
        var source = this;

        return new Enumerable(function () {
            var enumerator;

            return new IEnumerator(
                function () { enumerator = source.GetEnumerator(); },
                function () {
                    var array = [];
                    var index = 0;
                    while (enumerator.moveNext()) {
                        array.push(enumerator.Current);
                        if (++index >= count) return this.yieldReturn(array);
                    }
                    if (array.length > 0) return this.yieldReturn(array);
                    return false;
                },
                function () { Utils.Dispose(enumerator); });
        });
    };

    /* Aggregate Methods */

    // Overload:function (func)
    // Overload:function (seed,func)
    // Overload:function (seed,func,resultSelector)
    Enumerable.prototype.aggregate = function (seed, func, resultSelector) {
        resultSelector = Utils.createLambda(resultSelector);
        return resultSelector(this.scan(seed, func, resultSelector).last());
    };

    // Overload:function ()
    // Overload:function (selector)
    Enumerable.prototype.average = function (selector, def) {
        if (selector && !def && !Bridge.isFunction(selector)) {
            def = selector;
            selector = null;
        }

        selector = Utils.createLambda(selector);

        var sum = def || 0;
        var count = 0;
        this.forEach(function (x) {
            x = selector(x);

            if (x instanceof System.Decimal || System.Int64.is64Bit(x)) {
                sum = x.add(sum);
            }
            else if (sum instanceof System.Decimal || System.Int64.is64Bit(sum)) {
                sum = sum.add(x);
            } else {
                sum += x;
            }

            ++count;
        });

        if (count === 0) {
            throw new System.InvalidOperationException.$ctor1("Sequence contains no elements");
        }

        return (sum instanceof System.Decimal || System.Int64.is64Bit(sum)) ? sum.div(count) : (sum / count);
    };

    Enumerable.prototype.nullableAverage = function (selector, def) {
        if (this.any(Bridge.isNull)) {
            return null;
        }

        return this.average(selector, def);
    };

    // Overload:function ()
    // Overload:function (predicate)
    Enumerable.prototype.count = function (predicate) {
        predicate = (predicate == null) ? Functions.True : Utils.createLambda(predicate);

        var count = 0;
        this.forEach(function (x, i) {
            if (predicate(x, i))++count;
        });
        return count;
    };

    // Overload:function ()
    // Overload:function (selector)
    Enumerable.prototype.max = function (selector) {
        if (selector == null) selector = Functions.Identity;
        return this.select(selector).aggregate(function (a, b) {
            return (Bridge.compare(a, b, true) === 1) ? a : b;
        });
    };

    Enumerable.prototype.nullableMax = function (selector) {
        if (this.any(Bridge.isNull)) {
            return null;
        }

        return this.max(selector);
    };

    // Overload:function ()
    // Overload:function (selector)
    Enumerable.prototype.min = function (selector) {
        if (selector == null) selector = Functions.Identity;
        return this.select(selector).aggregate(function (a, b) {
            return (Bridge.compare(a, b, true) === -1) ? a : b;
        });
    };

    Enumerable.prototype.nullableMin = function (selector) {
        if (this.any(Bridge.isNull)) {
            return null;
        }

        return this.min(selector);
    };

    Enumerable.prototype.maxBy = function (keySelector) {
        keySelector = Utils.createLambda(keySelector);
        return this.aggregate(function (a, b) {
            return (Bridge.compare(keySelector(a), keySelector(b), true) === 1) ? a : b;
        });
    };

    Enumerable.prototype.minBy = function (keySelector) {
        keySelector = Utils.createLambda(keySelector);
        return this.aggregate(function (a, b) {
            return (Bridge.compare(keySelector(a), keySelector(b), true) === -1) ? a : b;
        });
    };

    // Overload:function ()
    // Overload:function (selector)
    Enumerable.prototype.sum = function (selector, def) {
        if (selector && !def && !Bridge.isFunction(selector)) {
            def = selector;
            selector = null;
        }

        if (selector == null) selector = Functions.Identity;
        var s = this.select(selector).aggregate(0, function (a, b) {
             if (a instanceof System.Decimal || System.Int64.is64Bit(a)) {
                 return a.add(b);
             }
             if (b instanceof System.Decimal || System.Int64.is64Bit(b)) {
                 return b.add(a);
             }
             return a + b;
        });

        if (s === 0 && def) {
            return def;
        }

        return s;
    };

    Enumerable.prototype.nullableSum = function (selector, def) {
        if (this.any(Bridge.isNull)) {
            return null;
        }

        return this.sum(selector, def);
    };

    /* Paging Methods */

    Enumerable.prototype.elementAt = function (index) {
        var value;
        var found = false;
        this.forEach(function (x, i) {
            if (i == index) {
                value = x;
                found = true;
                return false;
            }
        });

        if (!found) throw new Error("index is less than 0 or greater than or equal to the number of elements in source.");
        return value;
    };

    Enumerable.prototype.elementAtOrDefault = function (index, defaultValue) {
        if (defaultValue === undefined) defaultValue = null;
        var value;
        var found = false;
        this.forEach(function (x, i) {
            if (i == index) {
                value = x;
                found = true;
                return false;
            }
        });

        return (!found) ? defaultValue : value;
    };

    // Overload:function ()
    // Overload:function (predicate)
    Enumerable.prototype.first = function (predicate) {
        if (predicate != null) return this.where(predicate).first();

        var value;
        var found = false;
        this.forEach(function (x) {
            value = x;
            found = true;
            return false;
        });

        if (!found) throw new Error("first:No element satisfies the condition.");
        return value;
    };

    Enumerable.prototype.firstOrDefault = function (predicate, defaultValue) {
        if (defaultValue === undefined) defaultValue = null;
        if (predicate != null) return this.where(predicate).firstOrDefault(null, defaultValue);

        var value;
        var found = false;
        this.forEach(function (x) {
            value = x;
            found = true;
            return false;
        });
        return (!found) ? defaultValue : value;
    };

    // Overload:function ()
    // Overload:function (predicate)
    Enumerable.prototype.last = function (predicate) {
        if (predicate != null) return this.where(predicate).last();

        var value;
        var found = false;
        this.forEach(function (x) {
            found = true;
            value = x;
        });

        if (!found) throw new Error("last:No element satisfies the condition.");
        return value;
    };

    // Overload:function (defaultValue)
    // Overload:function (defaultValue,predicate)
    Enumerable.prototype.lastOrDefault = function (predicate, defaultValue) {
        if (defaultValue === undefined) defaultValue = null;
        if (predicate != null) return this.where(predicate).lastOrDefault(null, defaultValue);

        var value;
        var found = false;
        this.forEach(function (x) {
            found = true;
            value = x;
        });
        return (!found) ? defaultValue : value;
    };

    // Overload:function ()
    // Overload:function (predicate)
    Enumerable.prototype.single = function (predicate) {
        if (predicate != null) return this.where(predicate).single();

        var value;
        var found = false;
        this.forEach(function (x) {
            if (!found) {
                found = true;
                value = x;
            } else throw new Error("single:sequence contains more than one element.");
        });

        if (!found) throw new Error("single:No element satisfies the condition.");
        return value;
    };

    // Overload:function (defaultValue)
    // Overload:function (defaultValue,predicate)
    Enumerable.prototype.singleOrDefault = function (predicate, defaultValue) {
        if (defaultValue === undefined) defaultValue = null;
        if (predicate != null) return this.where(predicate).singleOrDefault(null, defaultValue);

        var value;
        var found = false;
        this.forEach(function (x) {
            if (!found) {
                found = true;
                value = x;
            } else throw new Error("single:sequence contains more than one element.");
        });

        return (!found) ? defaultValue : value;
    };

    Enumerable.prototype.skip = function (count) {
        var source = this;

        return new Enumerable(function () {
            var enumerator;
            var index = 0;

            return new IEnumerator(
                function () {
                    enumerator = source.GetEnumerator();
                    while (index++ < count && enumerator.moveNext()) {
                    }
                    ;
                },
                function () {
                    return (enumerator.moveNext())
                        ? this.yieldReturn(enumerator.Current)
                        : false;
                },
                function () { Utils.Dispose(enumerator); });
        });
    };

    // Overload:function (predicate<element>)
    // Overload:function (predicate<element,index>)
    Enumerable.prototype.skipWhile = function (predicate) {
        predicate = Utils.createLambda(predicate);
        var source = this;

        return new Enumerable(function () {
            var enumerator;
            var index = 0;
            var isSkipEnd = false;

            return new IEnumerator(
                function () { enumerator = source.GetEnumerator(); },
                function () {
                    while (!isSkipEnd) {
                        if (enumerator.moveNext()) {
                            if (!predicate(enumerator.Current, index++)) {
                                isSkipEnd = true;
                                return this.yieldReturn(enumerator.Current);
                            }
                            continue;
                        } else return false;
                    }

                    return (enumerator.moveNext())
                        ? this.yieldReturn(enumerator.Current)
                        : false;
                },
                function () { Utils.Dispose(enumerator); });
        });
    };

    Enumerable.prototype.take = function (count) {
        var source = this;

        return new Enumerable(function () {
            var enumerator;
            var index = 0;

            return new IEnumerator(
                function () { enumerator = source.GetEnumerator(); },
                function () {
                    return (index++ < count && enumerator.moveNext())
                        ? this.yieldReturn(enumerator.Current)
                        : false;
                },
                function () { Utils.Dispose(enumerator); }
            );
        });
    };

    // Overload:function (predicate<element>)
    // Overload:function (predicate<element,index>)
    Enumerable.prototype.takeWhile = function (predicate) {
        predicate = Utils.createLambda(predicate);
        var source = this;

        return new Enumerable(function () {
            var enumerator;
            var index = 0;

            return new IEnumerator(
                function () { enumerator = source.GetEnumerator(); },
                function () {
                    return (enumerator.moveNext() && predicate(enumerator.Current, index++))
                        ? this.yieldReturn(enumerator.Current)
                        : false;
                },
                function () { Utils.Dispose(enumerator); });
        });
    };

    // Overload:function ()
    // Overload:function (count)
    Enumerable.prototype.takeExceptLast = function (count) {
        if (count == null) count = 1;
        var source = this;

        return new Enumerable(function () {
            if (count <= 0) return source.GetEnumerator(); // do nothing

            var enumerator;
            var q = [];

            return new IEnumerator(
                function () { enumerator = source.GetEnumerator(); },
                function () {
                    while (enumerator.moveNext()) {
                        if (q.length == count) {
                            q.push(enumerator.Current);
                            return this.yieldReturn(q.shift());
                        }
                        q.push(enumerator.Current);
                    }
                    return false;
                },
                function () { Utils.Dispose(enumerator); });
        });
    };

    Enumerable.prototype.takeFromLast = function (count) {
        if (count <= 0 || count == null) return Enumerable.empty();
        var source = this;

        return new Enumerable(function () {
            var sourceEnumerator;
            var enumerator;
            var q = [];

            return new IEnumerator(
                function () { sourceEnumerator = source.GetEnumerator(); },
                function () {
                    if (enumerator == null) {
                        while (sourceEnumerator.moveNext()) {
                            if (q.length == count) q.shift();
                            q.push(sourceEnumerator.Current);
                        }
                        enumerator = Enumerable.from(q).GetEnumerator();
                    }
                    return (enumerator.moveNext())
                        ? this.yieldReturn(enumerator.Current)
                        : false;
                },
                function () { Utils.Dispose(enumerator); });
        });
    };

    // Overload:function (item)
    // Overload:function (predicate)
    Enumerable.prototype.indexOf = function (item, comparer) {
        var found = null;

        // item as predicate
        if (typeof (item) === Types.Function) {
            this.forEach(function (x, i) {
                if (item(x, i)) {
                    found = i;
                    return false;
                }
            });
        }
        else {
            comparer = comparer || System.Collections.Generic.EqualityComparer$1.$default;
            this.forEach(function (x, i) {
                if (comparer.equals2(x, item)) {
                    found = i;
                    return false;
                }
            });
        }

        return (found !== null) ? found : -1;
    };

    // Overload:function (item)
    // Overload:function (predicate)
    Enumerable.prototype.lastIndexOf = function (item, comparer) {
        var result = -1;

        // item as predicate
        if (typeof (item) === Types.Function) {
            this.forEach(function (x, i) {
                if (item(x, i)) result = i;
            });
        }
        else {
            comparer = comparer || System.Collections.Generic.EqualityComparer$1.$default;
            this.forEach(function (x, i) {
                if (comparer.equals2(x, item)) result = i;
            });
        }

        return result;
    };

    /* Convert Methods */

    Enumerable.prototype.asEnumerable = function () {
        return Enumerable.from(this);
    };

    Enumerable.prototype.ToArray = function (T) {
        var array = System.Array.init([], T || System.Object);
        this.forEach(function (x) { array.push(x); });
        return array;
    };

    Enumerable.prototype.toList = function (T) {
        var array = [];
        this.forEach(function (x) { array.push(x); });
        return new (System.Collections.Generic.List$1(T || System.Object).$ctor1)(array);
    };

    // Overload:function (keySelector)
    // Overload:function (keySelector, elementSelector)
    // Overload:function (keySelector, elementSelector, compareSelector)
    Enumerable.prototype.toLookup = function (keySelector, elementSelector, comparer) {
        keySelector = Utils.createLambda(keySelector);
        elementSelector = Utils.createLambda(elementSelector);

        var dict = new (System.Collections.Generic.Dictionary$2(System.Object, System.Object))(null, comparer);
        var order = [];
        this.forEach(function (x) {
            var key = keySelector(x);
            var element = elementSelector(x);

            var array = { v: null };
            if (dict.tryGetValue(key, array)) {
                array.v.push(element);
            }
            else {
                order.push(key);
                dict.add(key, [element]);
            }
        });
        return new Lookup(dict, order);
    };

    Enumerable.prototype.toObject = function (keySelector, elementSelector) {
        keySelector = Utils.createLambda(keySelector);
        elementSelector = Utils.createLambda(elementSelector);

        var obj = {};
        this.forEach(function (x) {
            obj[keySelector(x)] = elementSelector(x);
        });
        return obj;
    };

    // Overload:function (keySelector, elementSelector)
    // Overload:function (keySelector, elementSelector, compareSelector)
    Enumerable.prototype.toDictionary = function (keySelector, elementSelector, keyType, valueType, comparer) {
        keySelector = Utils.createLambda(keySelector);
        elementSelector = Utils.createLambda(elementSelector);

        var dict = new (System.Collections.Generic.Dictionary$2(keyType, valueType))(null, comparer);
        this.forEach(function (x) {
            dict.add(keySelector(x), elementSelector(x));
        });
        return dict;
    };

    // Overload:function ()
    // Overload:function (replacer)
    // Overload:function (replacer, space)
    Enumerable.prototype.toJSONString = function (replacer, space) {
        if (typeof JSON === Types.Undefined || JSON.stringify == null) {
            throw new Error("toJSONString can't find JSON.stringify. This works native JSON support Browser or include json2.js");
        }
        return JSON.stringify(this.ToArray(), replacer, space);
    };

    // Overload:function ()
    // Overload:function (separator)
    // Overload:function (separator,selector)
    Enumerable.prototype.toJoinedString = function (separator, selector) {
        if (separator == null) separator = "";
        if (selector == null) selector = Functions.Identity;

        return this.select(selector).ToArray().join(separator);
    };

    /* Action Methods */

    // Overload:function (action<element>)
    // Overload:function (action<element,index>)
    Enumerable.prototype.doAction = function (action) {
        var source = this;
        action = Utils.createLambda(action);

        return new Enumerable(function () {
            var enumerator;
            var index = 0;

            return new IEnumerator(
                function () { enumerator = source.GetEnumerator(); },
                function () {
                    if (enumerator.moveNext()) {
                        action(enumerator.Current, index++);
                        return this.yieldReturn(enumerator.Current);
                    }
                    return false;
                },
                function () { Utils.Dispose(enumerator); });
        });
    };

    // Overload:function (action<element>)
    // Overload:function (action<element,index>)
    // Overload:function (func<element,bool>)
    // Overload:function (func<element,index,bool>)
    Enumerable.prototype.forEach = function (action) {
        action = Utils.createLambda(action);

        var index = 0;
        var enumerator = this.GetEnumerator();
        try {
            while (enumerator.moveNext()) {
                if (action(enumerator.Current, index++) === false) break;
            }
        } finally {
            Utils.Dispose(enumerator);
        }
    };

    // Overload:function ()
    // Overload:function (separator)
    // Overload:function (separator,selector)
    Enumerable.prototype.write = function (separator, selector) {
        if (separator == null) separator = "";
        selector = Utils.createLambda(selector);

        var isFirst = true;
        this.forEach(function (item) {
            if (isFirst) isFirst = false;
            else document.write(separator);
            document.write(selector(item));
        });
    };

    // Overload:function ()
    // Overload:function (selector)
    Enumerable.prototype.writeLine = function (selector) {
        selector = Utils.createLambda(selector);

        this.forEach(function (item) {
            document.writeln(selector(item) + "<br />");
        });
    };

    Enumerable.prototype.force = function () {
        var enumerator = this.GetEnumerator();

        try {
            while (enumerator.moveNext()) {
            }
        }
        finally {
            Utils.Dispose(enumerator);
        }
    };

    /* Functional Methods */

    Enumerable.prototype.letBind = function (func) {
        func = Utils.createLambda(func);
        var source = this;

        return new Enumerable(function () {
            var enumerator;

            return new IEnumerator(
                function () {
                    enumerator = Enumerable.from(func(source)).GetEnumerator();
                },
                function () {
                    return (enumerator.moveNext())
                        ? this.yieldReturn(enumerator.Current)
                        : false;
                },
                function () { Utils.Dispose(enumerator); });
        });
    };

    Enumerable.prototype.share = function () {
        var source = this;
        var sharedEnumerator;
        var disposed = false;

        return new DisposableEnumerable(function () {
            return new IEnumerator(
                function () {
                    if (sharedEnumerator == null) {
                        sharedEnumerator = source.GetEnumerator();
                    }
                },
                function () {
                    if (disposed) throw new Error("enumerator is disposed");

                    return (sharedEnumerator.moveNext())
                        ? this.yieldReturn(sharedEnumerator.Current)
                        : false;
                },
                Functions.Blank
            );
        }, function () {
            disposed = true;
            Utils.Dispose(sharedEnumerator);
        });
    };

    Enumerable.prototype.memoize = function () {
        var source = this;
        var cache;
        var enumerator;
        var disposed = false;

        return new DisposableEnumerable(function () {
            var index = -1;

            return new IEnumerator(
                function () {
                    if (enumerator == null) {
                        enumerator = source.GetEnumerator();
                        cache = [];
                    }
                },
                function () {
                    if (disposed) throw new Error("enumerator is disposed");

                    index++;
                    if (cache.length <= index) {
                        return (enumerator.moveNext())
                            ? this.yieldReturn(cache[index] = enumerator.Current)
                            : false;
                    }

                    return this.yieldReturn(cache[index]);
                },
                Functions.Blank
            );
        }, function () {
            disposed = true;
            Utils.Dispose(enumerator);
            cache = null;
        });
    };

    /* Error Handling Methods */

    Enumerable.prototype.catchError = function (handler) {
        handler = Utils.createLambda(handler);
        var source = this;

        return new Enumerable(function () {
            var enumerator;

            return new IEnumerator(
                function () { enumerator = source.GetEnumerator(); },
                function () {
                    try {
                        return (enumerator.moveNext())
                            ? this.yieldReturn(enumerator.Current)
                            : false;
                    } catch (e) {
                        handler(e);
                        return false;
                    }
                },
                function () { Utils.Dispose(enumerator); });
        });
    };

    Enumerable.prototype.finallyAction = function (finallyAction) {
        finallyAction = Utils.createLambda(finallyAction);
        var source = this;

        return new Enumerable(function () {
            var enumerator;

            return new IEnumerator(
                function () { enumerator = source.GetEnumerator(); },
                function () {
                    return (enumerator.moveNext())
                        ? this.yieldReturn(enumerator.Current)
                        : false;
                },
                function () {
                    try {
                        Utils.Dispose(enumerator);
                    } finally {
                        finallyAction();
                    }
                });
        });
    };

    /* For Debug Methods */

    // Overload:function ()
    // Overload:function (selector)
    Enumerable.prototype.log = function (selector) {
        selector = Utils.createLambda(selector);

        return this.doAction(function (item) {
            if (typeof console !== Types.Undefined) {
                console.log(selector(item));
            }
        });
    };

    // Overload:function ()
    // Overload:function (message)
    // Overload:function (message,selector)
    Enumerable.prototype.trace = function (message, selector) {
        if (message == null) message = "Trace";
        selector = Utils.createLambda(selector);

        return this.doAction(function (item) {
            if (typeof console !== Types.Undefined) {
                console.log(message, selector(item));
            }
        });
    };

    // private
    var defaultComparer = {
        compare: function (x, y) {
            if (!Bridge.hasValue(x)) {
                return !Bridge.hasValue(y) ? 0 : -1;
            } else if (!Bridge.hasValue(y)) {
                return 1;
            }

            if (typeof x == "string" && typeof y == "string") {
                var result = System.String.compare(x, y, true);

                if (result !== 0) {
                    return result;
                }
            }

            return Bridge.compare(x, y);
        }
    };
    var OrderedEnumerable = function (source, keySelector, comparer, descending, parent) {
        this.source = source;
        this.keySelector = Utils.createLambda(keySelector);
        this.comparer = comparer || defaultComparer;
        this.descending = descending;
        this.parent = parent;
    };
    OrderedEnumerable.prototype = new Enumerable();
    OrderedEnumerable.prototype.constructor = OrderedEnumerable;
    Bridge.definei("System.Linq.IOrderedEnumerable$1");
    OrderedEnumerable.$$inherits = [];
    Bridge.Class.addExtend(OrderedEnumerable, [System.Collections.IEnumerable, System.Linq.IOrderedEnumerable$1]);

    OrderedEnumerable.prototype.createOrderedEnumerable = function (keySelector, comparer, descending) {
        return new OrderedEnumerable(this.source, keySelector, comparer, descending, this);
    };

    OrderedEnumerable.prototype.thenBy = function (keySelector, comparer) {
        return this.createOrderedEnumerable(keySelector, comparer, false);
    };

    OrderedEnumerable.prototype.thenByDescending = function (keySelector, comparer) {
        return this.createOrderedEnumerable(keySelector, comparer, true);
    };

    OrderedEnumerable.prototype.GetEnumerator = function () {
        var self = this;
        var buffer;
        var indexes;
        var index = 0;

        return new IEnumerator(
            function () {
                buffer = [];
                indexes = [];
                self.source.forEach(function (item, index) {
                    buffer.push(item);
                    indexes.push(index);
                });
                var sortContext = SortContext.create(self, null);
                sortContext.GenerateKeys(buffer);

                indexes.sort(function (a, b) { return sortContext.compare(a, b); });
            },
            function () {
                return (index < indexes.length)
                    ? this.yieldReturn(buffer[indexes[index++]])
                    : false;
            },
            Functions.Blank
        );
    };

    var SortContext = function (keySelector, comparer, descending, child) {
        this.keySelector = keySelector;
        this.comparer = comparer;
        this.descending = descending;
        this.child = child;
        this.keys = null;
    };

    SortContext.create = function (orderedEnumerable, currentContext) {
        var context = new SortContext(orderedEnumerable.keySelector, orderedEnumerable.comparer, orderedEnumerable.descending, currentContext);
        if (orderedEnumerable.parent != null) return SortContext.create(orderedEnumerable.parent, context);
        return context;
    };

    SortContext.prototype.GenerateKeys = function (source) {
        var len = source.length;
        var keySelector = this.keySelector;
        var keys = new Array(len);
        for (var i = 0; i < len; i++) keys[i] = keySelector(source[i]);
        this.keys = keys;

        if (this.child != null) this.child.GenerateKeys(source);
    };

    SortContext.prototype.compare = function (index1, index2) {
        var comparison = this.comparer.compare(this.keys[index1], this.keys[index2]);

        if (comparison == 0) {
            if (this.child != null) return this.child.compare(index1, index2);
            return Utils.compare(index1, index2);
        }

        return (this.descending) ? -comparison : comparison;
    };

    var DisposableEnumerable = function (GetEnumerator, dispose) {
        this.Dispose = dispose;
        Enumerable.call(this, GetEnumerator);
    };
    DisposableEnumerable.prototype = new Enumerable();

    // optimize array or arraylike object

    var ArrayEnumerable = function (source) {
        this.getSource = function () { return source; };
    };
    ArrayEnumerable.prototype = new Enumerable();

    ArrayEnumerable.prototype.any = function (predicate) {
        return (predicate == null)
            ? (this.getSource().length > 0)
            : Enumerable.prototype.any.apply(this, arguments);
    };

    ArrayEnumerable.prototype.count = function (predicate) {
        return (predicate == null)
            ? this.getSource().length
            : Enumerable.prototype.count.apply(this, arguments);
    };

    ArrayEnumerable.prototype.elementAt = function (index) {
        var source = this.getSource();
        return (0 <= index && index < source.length)
            ? source[index]
            : Enumerable.prototype.elementAt.apply(this, arguments);
    };

    ArrayEnumerable.prototype.elementAtOrDefault = function (index, defaultValue) {
        if (defaultValue === undefined) defaultValue = null;
        var source = this.getSource();
        return (0 <= index && index < source.length)
            ? source[index]
            : defaultValue;
    };

    ArrayEnumerable.prototype.first = function (predicate) {
        var source = this.getSource();
        return (predicate == null && source.length > 0)
            ? source[0]
            : Enumerable.prototype.first.apply(this, arguments);
    };

    ArrayEnumerable.prototype.firstOrDefault = function (predicate, defaultValue) {
        if (defaultValue === undefined) defaultValue = null;
        if (predicate != null) {
            return Enumerable.prototype.firstOrDefault.apply(this, arguments);
        }

        var source = this.getSource();
        return source.length > 0 ? source[0] : defaultValue;
    };

    ArrayEnumerable.prototype.last = function (predicate) {
        var source = this.getSource();
        return (predicate == null && source.length > 0)
            ? source[source.length - 1]
            : Enumerable.prototype.last.apply(this, arguments);
    };

    ArrayEnumerable.prototype.lastOrDefault = function (predicate, defaultValue) {
        if (defaultValue === undefined) defaultValue = null;
        if (predicate != null) {
            return Enumerable.prototype.lastOrDefault.apply(this, arguments);
        }

        var source = this.getSource();
        return source.length > 0 ? source[source.length - 1] : defaultValue;
    };

    ArrayEnumerable.prototype.skip = function (count) {
        var source = this.getSource();

        return new Enumerable(function () {
            var index;

            return new IEnumerator(
                function () { index = (count < 0) ? 0 : count; },
                function () {
                    return (index < source.length)
                        ? this.yieldReturn(source[index++])
                        : false;
                },
                Functions.Blank);
        });
    };

    ArrayEnumerable.prototype.takeExceptLast = function (count) {
        if (count == null) count = 1;
        return this.take(this.getSource().length - count);
    };

    ArrayEnumerable.prototype.takeFromLast = function (count) {
        return this.skip(this.getSource().length - count);
    };

    ArrayEnumerable.prototype.reverse = function () {
        var source = this.getSource();

        return new Enumerable(function () {
            var index;

            return new IEnumerator(
                function () {
                    index = source.length;
                },
                function () {
                    return (index > 0)
                        ? this.yieldReturn(source[--index])
                        : false;
                },
                Functions.Blank);
        });
    };

    ArrayEnumerable.prototype.sequenceEqual = function (second, comparer) {
        if ((second instanceof ArrayEnumerable || second instanceof Array)
            && comparer == null
            && Enumerable.from(second).count() != this.count()) {
            return false;
        }

        return Enumerable.prototype.sequenceEqual.apply(this, arguments);
    };

    ArrayEnumerable.prototype.toJoinedString = function (separator, selector) {
        var source = this.getSource();
        if (selector != null || !(source instanceof Array)) {
            return Enumerable.prototype.toJoinedString.apply(this, arguments);
        }

        if (separator == null) separator = "";
        return source.join(separator);
    };

    ArrayEnumerable.prototype.GetEnumerator = function () {
        return new Bridge.ArrayEnumerator(this.getSource());
    };

    // optimization for multiple where and multiple select and whereselect

    var WhereEnumerable = function (source, predicate) {
        this.prevSource = source;
        this.prevPredicate = predicate; // predicate.length always <= 1
    };
    WhereEnumerable.prototype = new Enumerable();

    WhereEnumerable.prototype.where = function (predicate) {
        predicate = Utils.createLambda(predicate);

        if (predicate.length <= 1) {
            var prevPredicate = this.prevPredicate;
            var composedPredicate = function (x) { return prevPredicate(x) && predicate(x); };
            return new WhereEnumerable(this.prevSource, composedPredicate);
        }
        else {
            // if predicate use index, can't compose
            return Enumerable.prototype.where.call(this, predicate);
        }
    };

    WhereEnumerable.prototype.select = function (selector) {
        selector = Utils.createLambda(selector);

        return (selector.length <= 1)
            ? new WhereSelectEnumerable(this.prevSource, this.prevPredicate, selector)
            : Enumerable.prototype.select.call(this, selector);
    };

    WhereEnumerable.prototype.GetEnumerator = function () {
        var predicate = this.prevPredicate;
        var source = this.prevSource;
        var enumerator;

        return new IEnumerator(
            function () { enumerator = source.GetEnumerator(); },
            function () {
                while (enumerator.moveNext()) {
                    if (predicate(enumerator.Current)) {
                        return this.yieldReturn(enumerator.Current);
                    }
                }
                return false;
            },
            function () { Utils.Dispose(enumerator); });
    };

    var WhereSelectEnumerable = function (source, predicate, selector) {
        this.prevSource = source;
        this.prevPredicate = predicate; // predicate.length always <= 1 or null
        this.prevSelector = selector; // selector.length always <= 1
    };
    WhereSelectEnumerable.prototype = new Enumerable();

    WhereSelectEnumerable.prototype.where = function (predicate) {
        predicate = Utils.createLambda(predicate);

        return (predicate.length <= 1)
            ? new WhereEnumerable(this, predicate)
            : Enumerable.prototype.where.call(this, predicate);
    };

    WhereSelectEnumerable.prototype.select = function (selector) {
        selector = Utils.createLambda(selector);

        if (selector.length <= 1) {
            var prevSelector = this.prevSelector;
            var composedSelector = function (x) { return selector(prevSelector(x)); };
            return new WhereSelectEnumerable(this.prevSource, this.prevPredicate, composedSelector);
        }
        else {
            // if selector use index, can't compose
            return Enumerable.prototype.select.call(this, selector);
        }
    };

    WhereSelectEnumerable.prototype.GetEnumerator = function () {
        var predicate = this.prevPredicate;
        var selector = this.prevSelector;
        var source = this.prevSource;
        var enumerator;

        return new IEnumerator(
            function () { enumerator = source.GetEnumerator(); },
            function () {
                while (enumerator.moveNext()) {
                    if (predicate == null || predicate(enumerator.Current)) {
                        return this.yieldReturn(selector(enumerator.Current));
                    }
                }
                return false;
            },
            function () { Utils.Dispose(enumerator); });
    };

    // Collections

    // dictionary = Dictionary<TKey, TValue[]>
    var Lookup = function (dictionary, order) {
        this.count = function () {
            return dictionary.getCount();
        };
        this.get = function (key) {
            var value = { v: null };
            var success = dictionary.tryGetValue(key, value);
            return Enumerable.from(success ? value.v : []);
        };
        this.contains = function (key) {
            return dictionary.containsKey(key);
        };
        this.toEnumerable = function () {
            return Enumerable.from(order).select(function (key) {
                return new Grouping(key, dictionary.get(key));
            });
        };
        this.GetEnumerator = function () {
            return this.toEnumerable().GetEnumerator();
        };
    };

    Bridge.definei("System.Linq.ILookup$2");
    Lookup.$$inherits = [];
    Bridge.Class.addExtend(Lookup, [System.Collections.IEnumerable, System.Linq.ILookup$2]);

    var Grouping = function (groupKey, elements) {
        this.key = function () {
            return groupKey;
        };
        ArrayEnumerable.call(this, elements);
    };
    Grouping.prototype = new ArrayEnumerable();
    Bridge.definei("System.Linq.IGrouping$2");
    Grouping.prototype.constructor = Grouping;

    Grouping.$$inherits = [];
    Bridge.Class.addExtend(Grouping, [System.Collections.IEnumerable, System.Linq.IGrouping$2]);

    // module export
    /*if (typeof define === Types.Function && define.amd) { // AMD
        define("linqjs", [], function () { return Enumerable; });
    } else if (typeof module !== Types.Undefined && module.exports) { // Node
        module.exports = Enumerable;
    } else {
        root.Enumerable = Enumerable;
    }*/

    Bridge.Linq = {};
    Bridge.Linq.Enumerable = Enumerable;

    System.Linq = System.Linq || {};
    System.Linq.Enumerable = Enumerable;
    System.Linq.Grouping$2 = Grouping;
    System.Linq.Lookup$2 = Lookup;
    System.Linq.OrderedEnumerable$1 = OrderedEnumerable;
})(Bridge.global);

    // @source CollectionDataContractAttribute.js

    Bridge.define("System.Runtime.Serialization.CollectionDataContractAttribute", {
        inherits: [System.Attribute],
        fields: {
            _name: null,
            _ns: null,
            _itemName: null,
            _keyName: null,
            _valueName: null,
            _isReference: false,
            _isNameSetExplicitly: false,
            _isNamespaceSetExplicitly: false,
            _isReferenceSetExplicitly: false,
            _isItemNameSetExplicitly: false,
            _isKeyNameSetExplicitly: false,
            _isValueNameSetExplicitly: false
        },
        props: {
            Namespace: {
                get: function () {
                    return this._ns;
                },
                set: function (value) {
                    this._ns = value;
                    this._isNamespaceSetExplicitly = true;
                }
            },
            IsNamespaceSetExplicitly: {
                get: function () {
                    return this._isNamespaceSetExplicitly;
                }
            },
            Name: {
                get: function () {
                    return this._name;
                },
                set: function (value) {
                    this._name = value;
                    this._isNameSetExplicitly = true;
                }
            },
            IsNameSetExplicitly: {
                get: function () {
                    return this._isNameSetExplicitly;
                }
            },
            ItemName: {
                get: function () {
                    return this._itemName;
                },
                set: function (value) {
                    this._itemName = value;
                    this._isItemNameSetExplicitly = true;
                }
            },
            IsItemNameSetExplicitly: {
                get: function () {
                    return this._isItemNameSetExplicitly;
                }
            },
            KeyName: {
                get: function () {
                    return this._keyName;
                },
                set: function (value) {
                    this._keyName = value;
                    this._isKeyNameSetExplicitly = true;
                }
            },
            IsReference: {
                get: function () {
                    return this._isReference;
                },
                set: function (value) {
                    this._isReference = value;
                    this._isReferenceSetExplicitly = true;
                }
            },
            IsReferenceSetExplicitly: {
                get: function () {
                    return this._isReferenceSetExplicitly;
                }
            },
            IsKeyNameSetExplicitly: {
                get: function () {
                    return this._isKeyNameSetExplicitly;
                }
            },
            ValueName: {
                get: function () {
                    return this._valueName;
                },
                set: function (value) {
                    this._valueName = value;
                    this._isValueNameSetExplicitly = true;
                }
            },
            IsValueNameSetExplicitly: {
                get: function () {
                    return this._isValueNameSetExplicitly;
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Attribute.ctor.call(this);
            }
        }
    });

    // @source ContractNamespaceAttribute.js

    Bridge.define("System.Runtime.Serialization.ContractNamespaceAttribute", {
        inherits: [System.Attribute],
        fields: {
            _clrNamespace: null,
            _contractNamespace: null
        },
        props: {
            ClrNamespace: {
                get: function () {
                    return this._clrNamespace;
                },
                set: function (value) {
                    this._clrNamespace = value;
                }
            },
            ContractNamespace: {
                get: function () {
                    return this._contractNamespace;
                }
            }
        },
        ctors: {
            ctor: function (contractNamespace) {
                this.$initialize();
                System.Attribute.ctor.call(this);
                this._contractNamespace = contractNamespace;
            }
        }
    });

    // @source DataContractAttribute.js

    Bridge.define("System.Runtime.Serialization.DataContractAttribute", {
        inherits: [System.Attribute],
        fields: {
            _name: null,
            _ns: null,
            _isNameSetExplicitly: false,
            _isNamespaceSetExplicitly: false,
            _isReference: false,
            _isReferenceSetExplicitly: false
        },
        props: {
            IsReference: {
                get: function () {
                    return this._isReference;
                },
                set: function (value) {
                    this._isReference = value;
                    this._isReferenceSetExplicitly = true;
                }
            },
            IsReferenceSetExplicitly: {
                get: function () {
                    return this._isReferenceSetExplicitly;
                }
            },
            Namespace: {
                get: function () {
                    return this._ns;
                },
                set: function (value) {
                    this._ns = value;
                    this._isNamespaceSetExplicitly = true;
                }
            },
            IsNamespaceSetExplicitly: {
                get: function () {
                    return this._isNamespaceSetExplicitly;
                }
            },
            Name: {
                get: function () {
                    return this._name;
                },
                set: function (value) {
                    this._name = value;
                    this._isNameSetExplicitly = true;
                }
            },
            IsNameSetExplicitly: {
                get: function () {
                    return this._isNameSetExplicitly;
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Attribute.ctor.call(this);
            }
        }
    });

    // @source DataMemberAttribute.js

    Bridge.define("System.Runtime.Serialization.DataMemberAttribute", {
        inherits: [System.Attribute],
        fields: {
            _name: null,
            _isNameSetExplicitly: false,
            _order: 0,
            _isRequired: false,
            _emitDefaultValue: false
        },
        props: {
            Name: {
                get: function () {
                    return this._name;
                },
                set: function (value) {
                    this._name = value;
                    this._isNameSetExplicitly = true;
                }
            },
            IsNameSetExplicitly: {
                get: function () {
                    return this._isNameSetExplicitly;
                }
            },
            Order: {
                get: function () {
                    return this._order;
                },
                set: function (value) {
                    if (value < 0) {
                        throw new System.Runtime.Serialization.InvalidDataContractException.$ctor1("Property 'Order' in DataMemberAttribute attribute cannot be a negative number.");
                    }
                    this._order = value;
                }
            },
            IsRequired: {
                get: function () {
                    return this._isRequired;
                },
                set: function (value) {
                    this._isRequired = value;
                }
            },
            EmitDefaultValue: {
                get: function () {
                    return this._emitDefaultValue;
                },
                set: function (value) {
                    this._emitDefaultValue = value;
                }
            }
        },
        ctors: {
            init: function () {
                this._order = -1;
                this._emitDefaultValue = true;
            },
            ctor: function () {
                this.$initialize();
                System.Attribute.ctor.call(this);
            }
        }
    });

    // @source EnumMemberAttribute.js

    Bridge.define("System.Runtime.Serialization.EnumMemberAttribute", {
        inherits: [System.Attribute],
        fields: {
            _value: null,
            _isValueSetExplicitly: false
        },
        props: {
            Value: {
                get: function () {
                    return this._value;
                },
                set: function (value) {
                    this._value = value;
                    this._isValueSetExplicitly = true;
                }
            },
            IsValueSetExplicitly: {
                get: function () {
                    return this._isValueSetExplicitly;
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Attribute.ctor.call(this);
            }
        }
    });

    // @source IDeserializationCallback.js

    Bridge.define("System.Runtime.Serialization.IDeserializationCallback", {
        $kind: "interface"
    });

    // @source IFormatterConverter.js

    Bridge.define("System.Runtime.Serialization.IFormatterConverter", {
        $kind: "interface"
    });

    // @source IgnoreDataMemberAttribute.js

    Bridge.define("System.Runtime.Serialization.IgnoreDataMemberAttribute", {
        inherits: [System.Attribute],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Attribute.ctor.call(this);
            }
        }
    });

    // @source InvalidDataContractException.js

    Bridge.define("System.Runtime.Serialization.InvalidDataContractException", {
        inherits: [System.Exception],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Exception.ctor.call(this);
            },
            $ctor1: function (message) {
                this.$initialize();
                System.Exception.ctor.call(this, message);
            },
            $ctor2: function (message, innerException) {
                this.$initialize();
                System.Exception.ctor.call(this, message, innerException);
            }
        }
    });

    // @source IObjectReference.js

    Bridge.define("System.Runtime.Serialization.IObjectReference", {
        $kind: "interface"
    });

    // @source ISafeSerializationData.js

    Bridge.define("System.Runtime.Serialization.ISafeSerializationData", {
        $kind: "interface"
    });

    // @source ISerializable.js

    Bridge.define("System.Runtime.Serialization.ISerializable", {
        $kind: "interface"
    });

    // @source ISerializationSurrogateProvider.js

    Bridge.define("System.Runtime.Serialization.ISerializationSurrogateProvider", {
        $kind: "interface"
    });

    // @source KnownTypeAttribute.js

    Bridge.define("System.Runtime.Serialization.KnownTypeAttribute", {
        inherits: [System.Attribute],
        fields: {
            _methodName: null,
            _type: null
        },
        props: {
            MethodName: {
                get: function () {
                    return this._methodName;
                }
            },
            Type: {
                get: function () {
                    return this._type;
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Attribute.ctor.call(this);
            },
            $ctor2: function (type) {
                this.$initialize();
                System.Attribute.ctor.call(this);
                this._type = type;
            },
            $ctor1: function (methodName) {
                this.$initialize();
                System.Attribute.ctor.call(this);
                this._methodName = methodName;
            }
        }
    });

    // @source SerializationEntry.js

    Bridge.define("System.Runtime.Serialization.SerializationEntry", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new System.Runtime.Serialization.SerializationEntry(); }
            }
        },
        fields: {
            _name: null,
            _value: null,
            _type: null
        },
        props: {
            Value: {
                get: function () {
                    return this._value;
                }
            },
            Name: {
                get: function () {
                    return this._name;
                }
            },
            ObjectType: {
                get: function () {
                    return this._type;
                }
            }
        },
        ctors: {
            $ctor1: function (entryName, entryValue, entryType) {
                this.$initialize();
                this._name = entryName;
                this._value = entryValue;
                this._type = entryType;
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
                var h = Bridge.addHash([7645431029, this._name, this._value, this._type]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, System.Runtime.Serialization.SerializationEntry)) {
                    return false;
                }
                return Bridge.equals(this._name, o._name) && Bridge.equals(this._value, o._value) && Bridge.equals(this._type, o._type);
            },
            $clone: function (to) {
                var s = to || new System.Runtime.Serialization.SerializationEntry();
                s._name = this._name;
                s._value = this._value;
                s._type = this._type;
                return s;
            }
        }
    });

    // @source SerializationException.js

    Bridge.define("System.Runtime.Serialization.SerializationException", {
        inherits: [System.SystemException],
        statics: {
            fields: {
                s_nullMessage: null
            },
            ctors: {
                init: function () {
                    this.s_nullMessage = "Serialization error.";
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.SystemException.$ctor1.call(this, System.Runtime.Serialization.SerializationException.s_nullMessage);
                this.HResult = -2146233076;
            },
            $ctor1: function (message) {
                this.$initialize();
                System.SystemException.$ctor1.call(this, message);
                this.HResult = -2146233076;
            },
            $ctor2: function (message, innerException) {
                this.$initialize();
                System.SystemException.$ctor2.call(this, message, innerException);
                this.HResult = -2146233076;
            }
        }
    });

    // @source SerializationInfoEnumerator.js

    Bridge.define("System.Runtime.Serialization.SerializationInfoEnumerator", {
        inherits: [System.Collections.IEnumerator],
        fields: {
            _members: null,
            _data: null,
            _types: null,
            _numItems: 0,
            _currItem: 0,
            _current: false
        },
        props: {
            System$Collections$IEnumerator$Current: {
                get: function () {
                    return this.Current.$clone();
                }
            },
            Current: {
                get: function () {
                    if (this._current === false) {
                        throw new System.InvalidOperationException.$ctor1("Enumeration has either not started or has already finished.");
                    }
                    return new System.Runtime.Serialization.SerializationEntry.$ctor1(this._members[System.Array.index(this._currItem, this._members)], this._data[System.Array.index(this._currItem, this._data)], this._types[System.Array.index(this._currItem, this._types)]);
                }
            },
            Name: {
                get: function () {
                    if (this._current === false) {
                        throw new System.InvalidOperationException.$ctor1("Enumeration has either not started or has already finished.");
                    }
                    return this._members[System.Array.index(this._currItem, this._members)];
                }
            },
            Value: {
                get: function () {
                    if (this._current === false) {
                        throw new System.InvalidOperationException.$ctor1("Enumeration has either not started or has already finished.");
                    }
                    return this._data[System.Array.index(this._currItem, this._data)];
                }
            },
            ObjectType: {
                get: function () {
                    if (this._current === false) {
                        throw new System.InvalidOperationException.$ctor1("Enumeration has either not started or has already finished.");
                    }
                    return this._types[System.Array.index(this._currItem, this._types)];
                }
            }
        },
        alias: [
            "moveNext", "System$Collections$IEnumerator$moveNext",
            "reset", "System$Collections$IEnumerator$reset"
        ],
        ctors: {
            ctor: function (members, info, types, numItems) {
                this.$initialize();

                this._members = members;
                this._data = info;
                this._types = types;

                this._numItems = (numItems - 1) | 0;
                this._currItem = -1;
                this._current = false;
            }
        },
        methods: {
            moveNext: function () {
                if (this._currItem < this._numItems) {
                    this._currItem = (this._currItem + 1) | 0;
                    this._current = true;
                } else {
                    this._current = false;
                }

                return this._current;
            },
            reset: function () {
                this._currItem = -1;
                this._current = false;
            }
        }
    });

    // @source StreamingContext.js

    Bridge.define("System.Runtime.Serialization.StreamingContext", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new System.Runtime.Serialization.StreamingContext(); }
            }
        },
        fields: {
            _additionalContext: null,
            _state: 0
        },
        props: {
            State: {
                get: function () {
                    return this._state;
                }
            },
            Context: {
                get: function () {
                    return this._additionalContext;
                }
            }
        },
        ctors: {
            $ctor1: function (state) {
                System.Runtime.Serialization.StreamingContext.$ctor2.call(this, state, null);
            },
            $ctor2: function (state, additional) {
                this.$initialize();
                this._state = state;
                this._additionalContext = additional;
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            equals: function (obj) {
                if (!(Bridge.is(obj, System.Runtime.Serialization.StreamingContext))) {
                    return false;
                }
                var ctx = System.Nullable.getValue(Bridge.cast(Bridge.unbox(obj, System.Runtime.Serialization.StreamingContext), System.Runtime.Serialization.StreamingContext));
                return Bridge.referenceEquals(ctx._additionalContext, this._additionalContext) && ctx._state === this._state;
            },
            getHashCode: function () {
                return this._state;
            },
            $clone: function (to) {
                var s = to || new System.Runtime.Serialization.StreamingContext();
                s._additionalContext = this._additionalContext;
                s._state = this._state;
                return s;
            }
        }
    });

    // @source StreamingContextStates.js

    Bridge.define("System.Runtime.Serialization.StreamingContextStates", {
        $kind: "enum",
        statics: {
            fields: {
                CrossProcess: 1,
                CrossMachine: 2,
                File: 4,
                Persistence: 8,
                Remoting: 16,
                Other: 32,
                Clone: 64,
                CrossAppDomain: 128,
                All: 255
            }
        },
        $flags: true
    });

    // @source OnSerializingAttribute.js

    Bridge.define("System.Runtime.Serialization.OnSerializingAttribute", {
        inherits: [System.Attribute]
    });

    // @source OnSerializedAttribute.js

    Bridge.define("System.Runtime.Serialization.OnSerializedAttribute", {
        inherits: [System.Attribute]
    });

    // @source OnDeserializingAttribute.js

    Bridge.define("System.Runtime.Serialization.OnDeserializingAttribute", {
        inherits: [System.Attribute]
    });

    // @source OnDeserializedAttribute.js

    Bridge.define("System.Runtime.Serialization.OnDeserializedAttribute", {
        inherits: [System.Attribute]
    });

    // @source SecurityException.js

    Bridge.define("System.Security.SecurityException", {
        inherits: [System.SystemException],
        statics: {
            fields: {
                DemandedName: null,
                GrantedSetName: null,
                RefusedSetName: null,
                DeniedName: null,
                PermitOnlyName: null,
                UrlName: null
            },
            ctors: {
                init: function () {
                    this.DemandedName = "Demanded";
                    this.GrantedSetName = "GrantedSet";
                    this.RefusedSetName = "RefusedSet";
                    this.DeniedName = "Denied";
                    this.PermitOnlyName = "PermitOnly";
                    this.UrlName = "Url";
                }
            }
        },
        props: {
            Demanded: null,
            DenySetInstance: null,
            GrantedSet: null,
            Method: null,
            PermissionState: null,
            PermissionType: null,
            PermitOnlySetInstance: null,
            RefusedSet: null,
            Url: null
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.SystemException.$ctor1.call(this, "Security error.");
                this.HResult = -2146233078;
            },
            $ctor1: function (message) {
                this.$initialize();
                System.SystemException.$ctor1.call(this, message);
                this.HResult = -2146233078;
            },
            $ctor2: function (message, inner) {
                this.$initialize();
                System.SystemException.$ctor2.call(this, message, inner);
                this.HResult = -2146233078;
            },
            $ctor3: function (message, type) {
                this.$initialize();
                System.SystemException.$ctor1.call(this, message);
                this.HResult = -2146233078;
                this.PermissionType = type;
            },
            $ctor4: function (message, type, state) {
                this.$initialize();
                System.SystemException.$ctor1.call(this, message);
                this.HResult = -2146233078;
                this.PermissionType = type;
                this.PermissionState = state;
            }
        },
        methods: {
            toString: function () {
                return Bridge.toString(this);
            }
        }
    });

    // @source UnauthorizedAccessException.js

    Bridge.define("System.UnauthorizedAccessException", {
        inherits: [System.SystemException],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.SystemException.$ctor1.call(this, "Attempted to perform an unauthorized operation.");
                this.HResult = -2147024891;
            },
            $ctor1: function (message) {
                this.$initialize();
                System.SystemException.$ctor1.call(this, message);
                this.HResult = -2147024891;
            },
            $ctor2: function (message, inner) {
                this.$initialize();
                System.SystemException.$ctor2.call(this, message, inner);
                this.HResult = -2147024891;
            }
        }
    });

    // @source UnhandledExceptionEventArgs.js

    Bridge.define("System.UnhandledExceptionEventArgs", {
        fields: {
            _exception: null,
            _isTerminating: false
        },
        props: {
            ExceptionObject: {
                get: function () {
                    return this._exception;
                }
            },
            IsTerminating: {
                get: function () {
                    return this._isTerminating;
                }
            }
        },
        ctors: {
            ctor: function (exception, isTerminating) {
                this.$initialize();
                System.Object.call(this);
                this._exception = exception;
                this._isTerminating = isTerminating;
            }
        }
    });

    // @source Regex.js

    Bridge.define("System.Text.RegularExpressions.Regex", {
        statics: {
            _cacheSize: 15,
            _defaultMatchTimeout: System.TimeSpan.fromMilliseconds(-1),

            getCacheSize: function () {
                return System.Text.RegularExpressions.Regex._cacheSize;
            },

            setCacheSize: function (value) {
                if (value < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("value");
                }

                System.Text.RegularExpressions.Regex._cacheSize = value;
                //TODO: remove extra items from cache
            },

            escape: function (str) {
                if (str == null) {
                    throw new System.ArgumentNullException.$ctor1("str");
                }

                return System.Text.RegularExpressions.RegexParser.escape(str);
            },

            unescape: function (str) {
                if (str == null) {
                    throw new System.ArgumentNullException.$ctor1("str");
                }

                return System.Text.RegularExpressions.RegexParser.unescape(str);
            },

            isMatch: function (input, pattern, options, matchTimeout) {
                var scope = System.Text.RegularExpressions;

                if (!Bridge.isDefined(options)) {
                    options = scope.RegexOptions.None;
                }

                if (!Bridge.isDefined(matchTimeout)) {
                    matchTimeout = scope.Regex._defaultMatchTimeout;
                }

                var regex = new System.Text.RegularExpressions.Regex.ctor(pattern, options, matchTimeout, true);

                return regex.isMatch(input);
            },

            match: function (input, pattern, options, matchTimeout) {
                var scope = System.Text.RegularExpressions;

                if (!Bridge.isDefined(options)) {
                    options = scope.RegexOptions.None;
                }

                if (!Bridge.isDefined(matchTimeout)) {
                    matchTimeout = scope.Regex._defaultMatchTimeout;
                }

                var regex = new System.Text.RegularExpressions.Regex.ctor(pattern, options, matchTimeout, true);

                return regex.match(input);
            },

            matches: function (input, pattern, options, matchTimeout) {
                var scope = System.Text.RegularExpressions;

                if (!Bridge.isDefined(options)) {
                    options = scope.RegexOptions.None;
                }

                if (!Bridge.isDefined(matchTimeout)) {
                    matchTimeout = scope.Regex._defaultMatchTimeout;
                }

                var regex = new System.Text.RegularExpressions.Regex.ctor(pattern, options, matchTimeout, true);

                return regex.matches(input);
            },

            replace: function (input, pattern, replacement, options, matchTimeout) {
                var scope = System.Text.RegularExpressions;

                if (!Bridge.isDefined(options)) {
                    options = scope.RegexOptions.None;
                }

                if (!Bridge.isDefined(matchTimeout)) {
                    matchTimeout = scope.Regex._defaultMatchTimeout;
                }

                var regex = new System.Text.RegularExpressions.Regex.ctor(pattern, options, matchTimeout, true);

                return regex.replace(input, replacement);
            },

            split: function (input, pattern, options, matchTimeout) {
                var scope = System.Text.RegularExpressions;

                if (!Bridge.isDefined(options)) {
                    options = scope.RegexOptions.None;
                }

                if (!Bridge.isDefined(matchTimeout)) {
                    matchTimeout = scope.Regex._defaultMatchTimeout;
                }

                var regex = new System.Text.RegularExpressions.Regex.ctor(pattern, options, matchTimeout, true);

                return regex.split(input);
            }
        },

        _pattern: "",
        _matchTimeout: System.TimeSpan.fromMilliseconds(-1),
        _runner: null,
        _caps: null,
        _capsize: 0,
        _capnames: null,
        _capslist: null,

        config: {
            init: function () {
                this._options = System.Text.RegularExpressions.RegexOptions.None;
            }
        },

        ctor: function (pattern, options, matchTimeout, useCache) {
            this.$initialize();

            if (!Bridge.isDefined(options)) {
                options = System.Text.RegularExpressions.RegexOptions.None;
            }

            if (!Bridge.isDefined(matchTimeout)) {
                matchTimeout = System.TimeSpan.fromMilliseconds(-1);
            }

            if (!Bridge.isDefined(useCache)) {
                useCache = false;
            }

            var scope = System.Text.RegularExpressions;

            if (pattern == null) {
                throw new System.ArgumentNullException.$ctor1("pattern");
            }

            if (options < scope.RegexOptions.None || ((options >> 10) !== 0)) {
                throw new System.ArgumentOutOfRangeException.$ctor1("options");
            }

            if (((options & scope.RegexOptions.ECMAScript) !== 0) &&
                ((options & ~(scope.RegexOptions.ECMAScript |
                    scope.RegexOptions.IgnoreCase |
                    scope.RegexOptions.Multiline |
                    scope.RegexOptions.CultureInvariant
                )) !== 0)) {
                throw new System.ArgumentOutOfRangeException.$ctor1("options");
            }

            // Check if the specified options are supported.
            var supportedOptions =
                System.Text.RegularExpressions.RegexOptions.IgnoreCase |
                System.Text.RegularExpressions.RegexOptions.Multiline |
                System.Text.RegularExpressions.RegexOptions.Singleline |
                System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace |
                System.Text.RegularExpressions.RegexOptions.ExplicitCapture;

            if ((options | supportedOptions) !== supportedOptions) {
                throw new System.NotSupportedException.$ctor1("Specified Regex options are not supported.");
            }

            this._validateMatchTimeout(matchTimeout);

            this._pattern = pattern;
            this._options = options;
            this._matchTimeout = matchTimeout;
            this._runner = new scope.RegexRunner(this);

            //TODO: cache
            var patternInfo = this._runner.parsePattern();

            this._capnames = patternInfo.sparseSettings.sparseSlotNameMap;
            this._capslist = patternInfo.sparseSettings.sparseSlotNameMap.keys;
            this._capsize = this._capslist.length;
        },

        getMatchTimeout: function () {
            return this._matchTimeout;
        },

        getOptions: function () {
            return this._options;
        },

        getRightToLeft: function () {
            return (this._options & System.Text.RegularExpressions.RegexOptions.RightToLeft) !== 0;
        },

        isMatch: function (input, startat) {
            if (input == null) {
                throw new System.ArgumentNullException.$ctor1("input");
            }

            if (!Bridge.isDefined(startat)) {
                startat = this.getRightToLeft() ? input.length : 0;
            }

            var match = this._runner.run(true, -1, input, 0, input.length, startat);

            return match == null;
        },

        match: function (input, startat, arg3) {
            if (input == null) {
                throw new System.ArgumentNullException.$ctor1("input");
            }

            var length = input.length,
                beginning = 0;

            if (arguments.length === 3) {
                beginning = startat;
                length = arg3;
                startat = this.getRightToLeft() ? beginning + length : beginning;
            } else if (!Bridge.isDefined(startat)) {
                startat = this.getRightToLeft() ? length : 0;
            }

            return this._runner.run(false, -1, input, beginning, length, startat);
        },

        matches: function (input, startat) {
            if (input == null) {
                throw new System.ArgumentNullException.$ctor1("input");
            }

            if (!Bridge.isDefined(startat)) {
                startat = this.getRightToLeft() ? input.length : 0;
            }

            return new System.Text.RegularExpressions.MatchCollection(this, input, 0, input.length, startat);
        },

        getGroupNames: function () {
            if (this._capslist == null) {
                var invariantCulture = System.Globalization.CultureInfo.invariantCulture;

                var result = [];
                var max = this._capsize;
                var i;

                for (i = 0; i < max; i++) {
                    result[i] = System.Convert.toString(i, invariantCulture, System.Convert.typeCodes.Int32);
                }

                return result;
            } else {
                return this._capslist.slice();
            }
        },

        getGroupNumbers: function () {
            var caps = this._caps;
            var result;
            var key;
            var max;
            var i;

            if (caps == null) {
                result = [];
                max = this._capsize;
                for (i = 0; i < max; i++) {
                    result.push(i);
                }
            } else {
                result = [];

                for (key in caps) {
                    if (caps.hasOwnProperty(key)) {
                        result[caps[key]] = key;
                    }
                }
            }

            return result;
        },

        groupNameFromNumber: function (i) {
            if (this._capslist == null) {
                if (i >= 0 && i < this._capsize) {
                    var invariantCulture = System.Globalization.CultureInfo.invariantCulture;

                    return System.Convert.toString(i, invariantCulture, System.Convert.typeCodes.Int32);
                }

                return "";
            } else {
                if (this._caps != null) {
                    var obj = this._caps[i];

                    if (obj == null) {
                        return "";
                    }

                    return parseInt(obj);
                }

                if (i >= 0 && i < this._capslist.length) {
                    return this._capslist[i];
                }

                return "";
            }
        },

        groupNumberFromName: function (name) {
            if (name == null) {
                throw new System.ArgumentNullException.$ctor1("name");
            }

            // look up name if we have a hashtable of names
            if (this._capnames != null) {
                var ret = this._capnames[name];

                if (ret == null) {
                    return -1;
                }

                return parseInt(ret);
            }

            // convert to an int if it looks like a number
            var result = 0;
            var ch;
            var i;

            for (i = 0; i < name.Length; i++) {
                ch = name[i];

                if (ch > "9" || ch < "0") {
                    return -1;
                }

                result *= 10;
                result += (ch - "0");
            }

            // return int if it's in range
            if (result >= 0 && result < this._capsize) {
                return result;
            }

            return -1;
        },

        replace: function (input, evaluator, count, startat) {
            if (input == null) {
                throw new System.ArgumentNullException.$ctor1("input");
            }

            if (!Bridge.isDefined(count)) {
                count = -1;
            }

            if (!Bridge.isDefined(startat)) {
                startat = this.getRightToLeft() ? input.length : 0;
            }

            if (evaluator == null) {
                throw new System.ArgumentNullException.$ctor1("evaluator");
            }

            if (Bridge.isFunction(evaluator)) {
                return System.Text.RegularExpressions.RegexReplacement.replace(evaluator, this, input, count, startat);
            }

            var repl = System.Text.RegularExpressions.RegexParser.parseReplacement(evaluator, this._caps, this._capsize, this._capnames, this._options);
            //TODO: Cache

            return repl.replace(this, input, count, startat);
        },

        split: function (input, count, startat) {
            if (input == null) {
                throw new System.ArgumentNullException.$ctor1("input");
            }

            if (!Bridge.isDefined(count)) {
                count = 0;
            }

            if (!Bridge.isDefined(startat)) {
                startat = this.getRightToLeft() ? input.length : 0;
            }

            return System.Text.RegularExpressions.RegexReplacement.split(this, input, count, startat);
        },

        _validateMatchTimeout: function (matchTimeout) {
            var ms = matchTimeout.getTotalMilliseconds();

            if (-1 === ms) {
                return;
            }

            if (ms > 0 && ms <= 2147483646) {
                return;
            }

            throw new System.ArgumentOutOfRangeException.$ctor1("matchTimeout");
        }
    });

    // @source RegexCapture.js

    Bridge.define("System.Text.RegularExpressions.Capture", {
        _text: "",
        _index: 0,
        _length: 0,

        ctor: function (text, i, l) {
            this.$initialize();
            this._text = text;
            this._index = i;
            this._length = l;
        },

        getIndex: function () {
            return this._index;
        },

        getLength: function () {
            return this._length;
        },

        getValue: function () {
            return this._text.substr(this._index, this._length);
        },

        toString: function () {
            return this.getValue();
        },

        _getOriginalString: function () {
            return this._text;
        },

        _getLeftSubstring: function () {
            return this._text.slice(0, _index);
        },

        _getRightSubstring: function () {
            return this._text.slice(this._index + this._length, this._text.length);
        }
    });

    // @source RegexCaptureCollection.js

    Bridge.define("System.Text.RegularExpressions.CaptureCollection", {
        inherits: function () {
            return [System.Collections.ICollection];
        },

        config: {
            properties: {
                Count: {
                    get: function () {
                        return this._capcount;
                    }
                }
            },

            alias: [
            "GetEnumerator", "System$Collections$IEnumerable$GetEnumerator",
            "getCount", "System$Collections$ICollection$getCount",
            "Count", "System$Collections$ICollection$Count",
            "copyTo", "System$Collections$ICollection$copyTo"
            ]
        },

        _group: null,
        _capcount: 0,
        _captures: null,

        ctor: function (group) {
            this.$initialize();
            this._group = group;
            this._capcount = group._capcount;
        },

        getSyncRoot: function () {
            return this._group;
        },

        getIsSynchronized: function () {
            return false;
        },

        getIsReadOnly: function () {
            return true;
        },

        getCount: function () {
            return this._capcount;
        },

        get: function (i) {
            if (i === this._capcount - 1 && i >= 0) {
                return this._group;
            }

            if (i >= this._capcount || i < 0) {
                throw new System.ArgumentOutOfRangeException.$ctor1("i");
            }

            this._ensureCapturesInited();

            return this._captures[i];
        },

        copyTo: function (array, arrayIndex) {
            if (array == null) {
                throw new System.ArgumentNullException.$ctor1("array");
            }

            if (array.length < arrayIndex + this._capcount) {
                throw new System.IndexOutOfRangeException();
            }

            var capture;
            var i;
            var j;

            for (i = arrayIndex, j = 0; j < this._capcount; i++, j++) {
                capture = this.get(j);
                System.Array.set(array, capture, [i]);
            }
        },

        GetEnumerator: function () {
            return new System.Text.RegularExpressions.CaptureEnumerator(this);
        },

        _ensureCapturesInited: function () {
            // first time a capture is accessed, compute them all
            if (this._captures == null) {
                var captures = [];
                var j;

                captures.length = this._capcount;

                for (j = 0; j < this._capcount - 1; j++) {
                    var index = this._group._caps[j * 2];
                    var length = this._group._caps[j * 2 + 1];

                    captures[j] = new System.Text.RegularExpressions.Capture(this._group._text, index, length);
                }

                if (this._capcount > 0) {
                    captures[this._capcount - 1] = this._group;
                }

                this._captures = captures;
            }
        }
    });

    Bridge.define("System.Text.RegularExpressions.CaptureEnumerator", {
        inherits: function () {
            return [System.Collections.IEnumerator];
        },

        config: {
            properties: {
                Current: {
                    get: function () {
                        return this.getCurrent();
                    }
                }
            },
            alias: [
                "getCurrent", "System$Collections$IEnumerator$getCurrent",
                "moveNext", "System$Collections$IEnumerator$moveNext",
                "reset", "System$Collections$IEnumerator$reset",
                "Current", "System$Collections$IEnumerator$Current"
            ]
        },

        _captureColl: null,
        _curindex: 0,

        ctor: function (captureColl) {
            this.$initialize();
            this._curindex = -1;
            this._captureColl = captureColl;
        },

        moveNext: function () {
            var size = this._captureColl.getCount();

            if (this._curindex >= size) {
                return false;
            }

            this._curindex++;
            return (this._curindex < size);
        },

        getCurrent: function () {
            return this.getCapture();
        },

        getCapture: function () {
            if (this._curindex < 0 || this._curindex >= this._captureColl.getCount()) {
                throw new System.InvalidOperationException.$ctor1("Enumeration has either not started or has already finished.");
            }

            return this._captureColl.get(this._curindex);
        },

        reset: function () {
            this._curindex = -1;
        }
    });

    // @source RegexGroup.js

    Bridge.define("System.Text.RegularExpressions.Group", {
        inherits: function () {
            return [System.Text.RegularExpressions.Capture];
        },

        statics: {
            config: {
                init: function () {
                    var empty = new System.Text.RegularExpressions.Group("", [], 0);

                    this.getEmpty = function () {
                        return empty;
                    }
                }
            },

            synchronized: function (group) {
                if (group == null) {
                    throw new System.ArgumentNullException.$ctor1("group");
                }

                // force Captures to be computed.
                var captures = group.getCaptures();

                if (captures.getCount() > 0) {
                    captures.get(0);
                }

                return group;
            }
        },

        _caps: null,
        _capcount: 0,
        _capColl: null,

        ctor: function (text, caps, capcount) {
            this.$initialize();
            var scope = System.Text.RegularExpressions;
            var index = capcount === 0 ? 0 : caps[(capcount - 1) * 2];
            var length = capcount === 0 ? 0 : caps[(capcount * 2) - 1];

            scope.Capture.ctor.call(this, text, index, length);

            this._caps = caps;
            this._capcount = capcount;
        },

        getSuccess: function () {
            return this._capcount !== 0;
        },

        getCaptures: function () {
            if (this._capColl == null) {
                this._capColl = new System.Text.RegularExpressions.CaptureCollection(this);
            }

            return this._capColl;
        }
    });

    // @source RegexGroupCollection.js

    Bridge.define("System.Text.RegularExpressions.GroupCollection", {
        inherits: function () {
            return [System.Collections.ICollection];
        },

        config: {
            properties: {
                Count: {
                    get: function () {
                        return this._match._matchcount.length;
                    }
                }
            },
            alias: [
            "GetEnumerator", "System$Collections$IEnumerable$GetEnumerator",
            "getCount", "System$Collections$ICollection$getCount",
            "Count", "System$Collections$ICollection$Count",
            "copyTo", "System$Collections$ICollection$copyTo"
            ]
        },

        _match: null,
        _captureMap: null,
        _groups: null,

        ctor: function (match, caps) {
            this.$initialize();
            this._match = match;
            this._captureMap = caps;
        },

        getSyncRoot: function () {
            return this._match;
        },

        getIsSynchronized: function () {
            return false;
        },

        getIsReadOnly: function () {
            return true;
        },

        getCount: function () {
            return this._match._matchcount.length;
        },

        get: function (groupnum) {
            return this._getGroup(groupnum);
        },

        getByName: function (groupname) {
            if (this._match._regex == null) {
                return System.Text.RegularExpressions.Group.getEmpty();
            }

            var groupnum = this._match._regex.groupNumberFromName(groupname);

            return this._getGroup(groupnum);
        },

        copyTo: function (array, arrayIndex) {
            if (array == null) {
                throw new System.ArgumentNullException.$ctor1("array");
            }

            var count = this.getCount();

            if (array.length < arrayIndex + count) {
                throw new System.IndexOutOfRangeException();
            }

            var group;
            var i;
            var j;

            for (i = arrayIndex, j = 0; j < count; i++, j++) {
                group = this._getGroup(j);
                System.Array.set(array, group, [i]);
            }
        },

        GetEnumerator: function () {
            return new System.Text.RegularExpressions.GroupEnumerator(this);
        },

        _getGroup: function (groupnum) {
            var group;

            if (this._captureMap != null) {
                var num = this._captureMap[groupnum];

                if (num == null) {
                    group = System.Text.RegularExpressions.Group.getEmpty();
                } else {
                    group = this._getGroupImpl(num);
                }
            } else {
                if (groupnum >= this._match._matchcount.length || groupnum < 0) {
                    group = System.Text.RegularExpressions.Group.getEmpty();
                } else {
                    group = this._getGroupImpl(groupnum);
                }
            }

            return group;
        },

        _getGroupImpl: function (groupnum) {
            if (groupnum === 0) {
                return this._match;
            }

            this._ensureGroupsInited();

            return this._groups[groupnum];
        },

        _ensureGroupsInited: function () {
            // Construct all the Group objects the first time GetGroup is called
            if (this._groups == null) {
                var groups = [];

                groups.length = this._match._matchcount.length;

                if (groups.length > 0) {
                    groups[0] = this._match;
                }

                var matchText;
                var matchCaps;
                var matchCapcount;
                var i;

                for (i = 0; i < groups.length - 1; i++) {
                    matchText = this._match._text;
                    matchCaps = this._match._matches[i + 1];
                    matchCapcount = this._match._matchcount[i + 1];
                    groups[i + 1] = new System.Text.RegularExpressions.Group(matchText, matchCaps, matchCapcount);
                }

                this._groups = groups;
            }
        }
    });

    Bridge.define("System.Text.RegularExpressions.GroupEnumerator", {
        inherits: function () {
            return [System.Collections.IEnumerator];
        },

        config: {
            properties: {
                Current: {
                    get: function () {
                        return this.getCurrent();
                    }
                }
            },

            alias: [
                "getCurrent", "System$Collections$IEnumerator$getCurrent",
                "moveNext", "System$Collections$IEnumerator$moveNext",
                "reset", "System$Collections$IEnumerator$reset",
                "Current", "System$Collections$IEnumerator$Current"
            ]
        },

        _groupColl: null,
        _curindex: 0,

        ctor: function (groupColl) {
            this.$initialize();
            this._curindex = -1;
            this._groupColl = groupColl;
        },

        moveNext: function () {
            var size = this._groupColl.getCount();

            if (this._curindex >= size) {
                return false;
            }

            this._curindex++;

            return (this._curindex < size);
        },

        getCurrent: function () {
            return this.getCapture();
        },

        getCapture: function () {
            if (this._curindex < 0 || this._curindex >= this._groupColl.getCount()) {
                throw new System.InvalidOperationException.$ctor1("Enumeration has either not started or has already finished.");
            }

            return this._groupColl.get(this._curindex);
        },

        reset: function () {
            this._curindex = -1;
        }
    });

    // @source RegexMatch.js

    Bridge.define("System.Text.RegularExpressions.Match", {
        inherits: function () {
            return [System.Text.RegularExpressions.Group];
        },

        statics: {
            config: {
                init: function () {
                    var empty = new System.Text.RegularExpressions.Match(null, 1, "", 0, 0, 0);

                    this.getEmpty = function () {
                        return empty;
                    }
                }
            },

            synchronized: function (match) {
                if (match == null) {
                    throw new System.ArgumentNullException.$ctor1("match");
                }

                // Populate all groups by looking at each one
                var groups = match.getGroups();
                var groupsCount = groups.getCount();
                var group;
                var i;

                for (i = 0; i < groupsCount; i++) {
                    group = groups.get(i);
                    System.Text.RegularExpressions.Group.synchronized(group);
                }

                return match;
            }
        },

        _regex: null,
        _matchcount: null,
        _matches: null,
        _textbeg: 0,
        _textend: 0,
        _textstart: 0,
        _groupColl: null,
        _textpos: 0,

        ctor: function (regex, capcount, text, begpos, len, startpos) {
            this.$initialize();
            var scope = System.Text.RegularExpressions;
            var caps = [0, 0];

            scope.Group.ctor.call(this, text, caps, 0);

            this._regex = regex;

            this._matchcount = [];
            this._matchcount.length = capcount;

            var i;

            for (i = 0; i < capcount; i++) {
                this._matchcount[i] = 0;
            }

            this._matches = [];
            this._matches.length = capcount;
            this._matches[0] = caps;

            this._textbeg = begpos;
            this._textend = begpos + len;
            this._textstart = startpos;
        },

        getGroups: function () {
            if (this._groupColl == null) {
                this._groupColl = new System.Text.RegularExpressions.GroupCollection(this, null);
            }

            return this._groupColl;
        },

        nextMatch: function () {
            if (this._regex == null) {
                return this;
            }

            return this._regex._runner.run(false, this._length, this._text, this._textbeg, this._textend - this._textbeg, this._textpos);
        },

        result: function (replacement) {
            if (replacement == null) {
                throw new System.ArgumentNullException.$ctor1("replacement");
            }

            if (this._regex == null) {
                throw new System.NotSupportedException.$ctor1("Result cannot be called on a failed Match.");
            }

            var repl = System.Text.RegularExpressions.RegexParser.parseReplacement(replacement, this._regex._caps, this._regex._capsize, this._regex._capnames, this._regex._options);
            //TODO: cache

            return repl.replacement(this);
        },

        _isMatched: function (cap) {
            return cap < this._matchcount.length && this._matchcount[cap] > 0 && this._matches[cap][this._matchcount[cap] * 2 - 1] !== (-3 + 1);
        },

        _addMatch: function (cap, start, len) {
            if (this._matches[cap] == null) {
                this._matches[cap] = new Array(2);
            }

            var capcount = this._matchcount[cap];

            if (capcount * 2 + 2 > this._matches[cap].length) {
                var oldmatches = this._matches[cap];
                var newmatches = new Array(capcount * 8);
                var j;

                for (j = 0; j < capcount * 2; j++) {
                    newmatches[j] = oldmatches[j];
                }

                this._matches[cap] = newmatches;
            }

            this._matches[cap][capcount * 2] = start;
            this._matches[cap][capcount * 2 + 1] = len;
            this._matchcount[cap] = capcount + 1;
        },

        _tidy: function (textpos) {
            var interval = this._matches[0];
            this._index = interval[0];
            this._length = interval[1];
            this._textpos = textpos;
            this._capcount = this._matchcount[0];
        },

        _groupToStringImpl: function (groupnum) {
            var c = this._matchcount[groupnum];

            if (c === 0) {
                return "";
            }

            var matches = this._matches[groupnum];
            var capIndex = matches[(c - 1) * 2];
            var capLength = matches[(c * 2) - 1];

            return this._text.slice(capIndex, capIndex + capLength);
        },

        _lastGroupToStringImpl: function () {
            return this._groupToStringImpl(this._matchcount.length - 1);
        }
    });

    Bridge.define("System.Text.RegularExpressions.MatchSparse", {
        inherits: function () {
            return [System.Text.RegularExpressions.Match];
        },

        _caps: null,

        ctor: function (regex, caps, capcount, text, begpos, len, startpos) {
            this.$initialize();
            var scope = System.Text.RegularExpressions;
            scope.Match.ctor.call(this, regex, capcount, text, begpos, len, startpos);

            this._caps = caps;
        },

        getGroups: function () {
            if (this._groupColl == null) {
                this._groupColl = new System.Text.RegularExpressions.GroupCollection(this, this._caps);
            }

            return this._groupColl;
        },
    });

    // @source RegexMatchCollection.js

    Bridge.define("System.Text.RegularExpressions.MatchCollection", {
        inherits: function () {
            return [System.Collections.ICollection];
        },

        config: {
            properties: {
                Count: {
                    get: function () {
                        return this.getCount();
                    }
                }
            },
            alias: [
            "GetEnumerator", "System$Collections$IEnumerable$GetEnumerator",
            "getCount", "System$Collections$ICollection$getCount",
            "Count", "System$Collections$ICollection$Count",
            "copyTo", "System$Collections$ICollection$copyTo"
            ]
        },

        _regex: null,
        _input: null,
        _beginning: 0,
        _length: 0,
        _startat: 0,
        _prevlen: 0,
        _matches: null,
        _done: false,

        ctor: function (regex, input, beginning, length, startat) {
            this.$initialize();
            if (startat < 0 || startat > input.Length) {
                throw new System.ArgumentOutOfRangeException.$ctor1("startat");
            }

            this._regex = regex;
            this._input = input;
            this._beginning = beginning;
            this._length = length;
            this._startat = startat;
            this._prevlen = -1;
            this._matches = [];
        },

        getCount: function () {
            if (!this._done) {
                this._getMatch(0x7FFFFFFF);
            }

            return this._matches.length;
        },

        getSyncRoot: function () {
            return this;
        },

        getIsSynchronized: function () {
            return false;
        },

        getIsReadOnly: function () {
            return true;
        },

        get: function (i) {
            var match = this._getMatch(i);

            if (match == null) {
                throw new System.ArgumentOutOfRangeException.$ctor1("i");
            }

            return match;
        },

        copyTo: function (array, arrayIndex) {
            if (array == null) {
                throw new System.ArgumentNullException.$ctor1("array");
            }

            var count = this.getCount();

            if (array.length < arrayIndex + count) {
                throw new System.IndexOutOfRangeException();
            }

            var match;
            var i;
            var j;

            for (i = arrayIndex, j = 0; j < count; i++, j++) {
                match = this._getMatch(j);
                System.Array.set(array, match, [i]);
            }
        },

        GetEnumerator: function () {
            return new System.Text.RegularExpressions.MatchEnumerator(this);
        },

        _getMatch: function (i) {
            if (i < 0) {
                return null;
            }

            if (this._matches.length > i) {
                return this._matches[i];
            }

            if (this._done) {
                return null;
            }

            var match;

            do {
                match = this._regex._runner.run(false, this._prevLen, this._input, this._beginning, this._length, this._startat);
                if (!match.getSuccess()) {
                    this._done = true;
                    return null;
                }

                this._matches.push(match);

                this._prevLen = match._length;
                this._startat = match._textpos;
            } while (this._matches.length <= i);

            return match;
        }
    });

    Bridge.define("System.Text.RegularExpressions.MatchEnumerator", {
        inherits: function () {
            return [System.Collections.IEnumerator];
        },

        config: {
            properties: {
                Current: {
                    get: function () {
                        return this.getCurrent();
                    }
                }
            },

            alias: [
                "getCurrent", "System$Collections$IEnumerator$getCurrent",
                "moveNext", "System$Collections$IEnumerator$moveNext",
                "reset", "System$Collections$IEnumerator$reset",
                "Current", "System$Collections$IEnumerator$Current"
            ]
        },

        _matchcoll: null,
        _match: null,
        _curindex: 0,
        _done: false,

        ctor: function (matchColl) {
            this.$initialize();
            this._matchcoll = matchColl;
        },

        moveNext: function () {
            if (this._done) {
                return false;
            }

            this._match = this._matchcoll._getMatch(this._curindex);
            this._curindex++;

            if (this._match == null) {
                this._done = true;

                return false;
            }

            return true;
        },

        getCurrent: function () {
            if (this._match == null) {
                throw new System.InvalidOperationException.$ctor1("Enumeration has either not started or has already finished.");
            }

            return this._match;
        },

        reset: function () {
            this._curindex = 0;
            this._done = false;
            this._match = null;
        }
    });

    // @source RegexOptions.js

    Bridge.define("System.Text.RegularExpressions.RegexOptions", {
        statics: {
            None: 0x0000,
            IgnoreCase: 0x0001,
            Multiline: 0x0002,
            ExplicitCapture: 0x0004,
            Compiled: 0x0008,
            Singleline: 0x0010,
            IgnorePatternWhitespace: 0x0020,
            RightToLeft: 0x0040,
            ECMAScript: 0x0100,
            CultureInvariant: 0x0200
        },

        $kind: "enum",
        $flags: true
    });

    // @source RegexRunner.js

    Bridge.define("System.Text.RegularExpressions.RegexRunner", {
        statics: {},

        _runregex: null,
        _netEngine: null,

        _runtext: "", // text to search
        _runtextpos: 0, // current position in text

        _runtextbeg: 0, // beginning of text to search
        _runtextend: 0, // end of text to search
        _runtextstart: 0, // starting point for search
        _quick: false, // true value means IsMatch method call
        _prevlen: 0,

        ctor: function (regex) {
            this.$initialize();

            if (regex == null) {
                throw new System.ArgumentNullException.$ctor1("regex");
            }

            this._runregex = regex;

            var options = regex.getOptions();
            var optionsEnum = System.Text.RegularExpressions.RegexOptions;

            var isCaseInsensitive = (options & optionsEnum.IgnoreCase) === optionsEnum.IgnoreCase;
            var isMultiline = (options & optionsEnum.Multiline) === optionsEnum.Multiline;
            var isSingleline = (options & optionsEnum.Singleline) === optionsEnum.Singleline;
            var isIgnoreWhitespace = (options & optionsEnum.IgnorePatternWhitespace) === optionsEnum.IgnorePatternWhitespace;
            var isExplicitCapture = (options & optionsEnum.ExplicitCapture) === optionsEnum.ExplicitCapture;

            var timeoutMs = regex._matchTimeout.getTotalMilliseconds();

            this._netEngine = new System.Text.RegularExpressions.RegexEngine(regex._pattern, isCaseInsensitive, isMultiline, isSingleline, isIgnoreWhitespace, isExplicitCapture, timeoutMs);
        },

        run: function (quick, prevlen, input, beginning, length, startat) {
            if (startat < 0 || startat > input.Length) {
                throw new System.ArgumentOutOfRangeException.$ctor4("start", "Start index cannot be less than 0 or greater than input length.");
            }

            if (length < 0 || length > input.Length) {
                throw new ArgumentOutOfRangeException("length", "Length cannot be less than 0 or exceed input length.");
            }

            this._runtext = input;
            this._runtextbeg = beginning;
            this._runtextend = beginning + length;
            this._runtextstart = startat;
            this._quick = quick;
            this._prevlen = prevlen;

            var stoppos;
            var bump;

            if (this._runregex.getRightToLeft()) {
                stoppos = this._runtextbeg;
                bump = -1;
            } else {
                stoppos = this._runtextend;
                bump = 1;
            }

            if (this._prevlen === 0) {
                if (this._runtextstart === stoppos) {
                    return System.Text.RegularExpressions.Match.getEmpty();
                }

                this._runtextstart += bump;
            }

            // Execute Regex:
            var jsMatch = this._netEngine.match(this._runtext, this._runtextstart);

            // Convert the results:
            var result = this._convertNetEngineResults(jsMatch);
            return result;
        },

        parsePattern: function () {
            var result = this._netEngine.parsePattern();

            return result;
        },

        _convertNetEngineResults: function (jsMatch) {
            if (jsMatch.success && this._quick) {
                return null; // in quick mode, a successful match returns null
            }

            if (!jsMatch.success) {
                return System.Text.RegularExpressions.Match.getEmpty();
            }

            var patternInfo = this.parsePattern();
            var match;

            if (patternInfo.sparseSettings.isSparse) {
                match = new System.Text.RegularExpressions.MatchSparse(this._runregex, patternInfo.sparseSettings.sparseSlotMap, jsMatch.groups.length, this._runtext, 0, this._runtext.length, this._runtextstart);
            } else {
                match = new System.Text.RegularExpressions.Match(this._runregex, jsMatch.groups.length, this._runtext, 0, this._runtext.length, this._runtextstart);
            }

            var jsGroup;
            var jsCapture;
            var grOrder;
            var i;
            var j;

            for (i = 0; i < jsMatch.groups.length; i++) {
                jsGroup = jsMatch.groups[i];

                // Paste group index/length according to group ordering:
                grOrder = 0;

                if (jsGroup.descriptor != null) {
                    grOrder = this._runregex.groupNumberFromName(jsGroup.descriptor.name);
                }

                for (j = 0; j < jsGroup.captures.length; j++) {
                    jsCapture = jsGroup.captures[j];
                    match._addMatch(grOrder, jsCapture.capIndex, jsCapture.capLength);
                }
            }

            var textEndPos = jsMatch.capIndex + jsMatch.capLength;

            match._tidy(textEndPos);

            return match;
        }
    });

    // @source RegexParser.js

    Bridge.define("System.Text.RegularExpressions.RegexParser", {
        statics: {
            _Q: 5, // quantifier
            _S: 4, // ordinary stopper
            _Z: 3, // ScanBlank stopper
            _X: 2, // whitespace
            _E: 1, // should be escaped

            _category: [
                //0 1 2  3  4  5  6  7  8  9  A  B  C  D  E  F  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
                0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                //! " #  $  %  &  '  (  )  *  +  ,  -  .  /  0  1  2  3  4  5  6  7  8  9  :  ;  <  =  >  ?
                2, 0, 0, 3, 4, 0, 0, 0, 4, 4, 5, 5, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5,
                //@ A B  C  D  E  F  G  H  I  J  K  L  M  N  O  P  Q  R  S  T  U  V  W  X  Y  Z  [  \  ]  ^  _
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 4, 0,
                //' a b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  {  |  }  ~
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 4, 0, 0, 0
            ],

            escape: function (input) {
                var sb;
                var ch;
                var lastpos;
                var i;

                for (i = 0; i < input.length; i++) {
                    if (System.Text.RegularExpressions.RegexParser._isMetachar(input[i])) {
                        sb = "";
                        ch = input[i];

                        sb += input.slice(0, i);

                        do {
                            sb += "\\";

                            switch (ch) {
                                case "\n":
                                    ch = "n";
                                    break;
                                case "\r":
                                    ch = "r";
                                    break;
                                case "\t":
                                    ch = "t";
                                    break;
                                case "\f":
                                    ch = "f";
                                    break;
                            }

                            sb += ch;
                            i++;
                            lastpos = i;

                            while (i < input.length) {
                                ch = input[i];

                                if (System.Text.RegularExpressions.RegexParser._isMetachar(ch)) {
                                    break;
                                }

                                i++;
                            }

                            sb += input.slice(lastpos, i);
                        } while (i < input.length);

                        return sb;
                    }
                }

                return input;
            },

            unescape: function (input) {
                var culture = System.Globalization.CultureInfo.invariantCulture;
                var sb;
                var lastpos;
                var i;
                var p;

                for (i = 0; i < input.length; i++) {
                    if (input[i] === "\\") {
                        sb = "";
                        p = new System.Text.RegularExpressions.RegexParser(culture);
                        p._setPattern(input);

                        sb += input.slice(0, i);

                        do {
                            i++;

                            p._textto(i);

                            if (i < input.length) {
                                sb += p._scanCharEscape();
                            }

                            i = p._textpos();
                            lastpos = i;

                            while (i < input.length && input[i] !== "\\") {
                                i++;
                            }

                            sb += input.slice(lastpos, i);
                        } while (i < input.length);

                        return sb;
                    }
                }

                return input;
            },

            parseReplacement: function (rep, caps, capsize, capnames, op) {
                var culture = System.Globalization.CultureInfo.getCurrentCulture(); // TODO: InvariantCulture
                var p = new System.Text.RegularExpressions.RegexParser(culture);

                p._options = op;
                p._noteCaptures(caps, capsize, capnames);
                p._setPattern(rep);

                var root = p._scanReplacement();

                return new System.Text.RegularExpressions.RegexReplacement(rep, root, caps);
            },

            _isMetachar: function (ch) {
                var code = ch.charCodeAt(0);

                return (code <= "|".charCodeAt(0) && System.Text.RegularExpressions.RegexParser._category[code] >= System.Text.RegularExpressions.RegexParser._E);
            }
        },

        _caps: null,
        _capsize: 0,
        _capnames: null,
        _pattern: "",
        _currentPos: 0,
        _concatenation: null,
        _culture: null,

        config: {
            init: function () {
                this._options = System.Text.RegularExpressions.RegexOptions.None;
            }
        },

        ctor: function (culture) {
            this.$initialize();
            this._culture = culture;
            this._caps = {};
        },

        _noteCaptures: function (caps, capsize, capnames) {
            this._caps = caps;
            this._capsize = capsize;
            this._capnames = capnames;
        },

        _setPattern: function (pattern) {
            if (pattern == null) {
                pattern = "";
            }

            this._pattern = pattern || "";
            this._currentPos = 0;
        },

        _scanReplacement: function () {
            this._concatenation = new System.Text.RegularExpressions.RegexNode(System.Text.RegularExpressions.RegexNode.Concatenate, this._options);
            var c;
            var startpos;
            var dollarNode;

            while (true) {
                c = this._charsRight();

                if (c === 0) {
                    break;
                }

                startpos = this._textpos();

                while (c > 0 && this._rightChar() !== "$") {
                    this._moveRight();
                    c--;
                }

                this._addConcatenate(startpos, this._textpos() - startpos);

                if (c > 0) {
                    if (this._moveRightGetChar() === "$") {
                        dollarNode = this._scanDollar();
                        this._concatenation.addChild(dollarNode);
                    }
                }
            }

            return this._concatenation;
        },

        _addConcatenate: function (pos, cch /*, bool isReplacement*/ ) {
            if (cch === 0) {
                return;
            }

            var node;

            if (cch > 1) {
                var str = this._pattern.slice(pos, pos + cch);

                node = new System.Text.RegularExpressions.RegexNode(System.Text.RegularExpressions.RegexNode.Multi, this._options, str);
            } else {
                var ch = this._pattern[pos];

                node = new System.Text.RegularExpressions.RegexNode(System.Text.RegularExpressions.RegexNode.One, this._options, ch);
            }

            this._concatenation.addChild(node);
        },

        _useOptionE: function () {
            return (this._options & System.Text.RegularExpressions.RegexOptions.ECMAScript) !== 0;
        },

        _makeException: function (message) {
            return new System.ArgumentException("Incorrect pattern. " + message);
        },

        _scanDollar: function () {
            var maxValueDiv10 = 214748364; // Int32.MaxValue / 10;
            var maxValueMod10 = 7; // Int32.MaxValue % 10;

            if (this._charsRight() === 0) {
                return new System.Text.RegularExpressions.RegexNode(System.Text.RegularExpressions.RegexNode.One, this._options, "$");
            }

            var ch = this._rightChar();
            var angled;
            var backpos = this._textpos();
            var lastEndPos = backpos;

            // Note angle
            if (ch === "{" && this._charsRight() > 1) {
                angled = true;
                this._moveRight();
                ch = this._rightChar();
            } else {
                angled = false;
            }

            // Try to parse backreference: \1 or \{1} or \{cap}

            var capnum;
            var digit;

            if (ch >= "0" && ch <= "9") {
                if (!angled && this._useOptionE()) {
                    capnum = -1;
                    var newcapnum = ch - "0";

                    this._moveRight();

                    if (this._isCaptureSlot(newcapnum)) {
                        capnum = newcapnum;
                        lastEndPos = this._textpos();
                    }

                    while (this._charsRight() > 0 && (ch = this._rightChar()) >= "0" && ch <= "9") {
                        digit = ch - "0";
                        if (newcapnum > (maxValueDiv10) || (newcapnum === (maxValueDiv10) && digit > (maxValueMod10))) {
                            throw this._makeException("Capture group is out of range.");
                        }

                        newcapnum = newcapnum * 10 + digit;

                        this._moveRight();

                        if (this._isCaptureSlot(newcapnum)) {
                            capnum = newcapnum;
                            lastEndPos = this._textpos();
                        }
                    }
                    this._textto(lastEndPos);

                    if (capnum >= 0) {
                        return new System.Text.RegularExpressions.RegexNode(System.Text.RegularExpressions.RegexNode.Ref, this._options, capnum);
                    }
                } else {
                    capnum = this._scanDecimal();

                    if (!angled || this._charsRight() > 0 && this._moveRightGetChar() === "}") {
                        if (this._isCaptureSlot(capnum)) {
                            return new System.Text.RegularExpressions.RegexNode(System.Text.RegularExpressions.RegexNode.Ref, this._options, capnum);
                        }
                    }
                }
            } else if (angled && this._isWordChar(ch)) {
                var capname = this._scanCapname();

                if (this._charsRight() > 0 && this._moveRightGetChar() === "}") {
                    if (this._isCaptureName(capname)) {
                        var captureSlot = this._captureSlotFromName(capname);

                        return new System.Text.RegularExpressions.RegexNode(System.Text.RegularExpressions.RegexNode.Ref, this._options, captureSlot);
                    }
                }
            } else if (!angled) {
                capnum = 1;

                switch (ch) {
                    case "$":
                        this._moveRight();
                        return new System.Text.RegularExpressions.RegexNode(System.Text.RegularExpressions.RegexNode.One, this._options, "$");

                    case "&":
                        capnum = 0;
                        break;

                    case "`":
                        capnum = System.Text.RegularExpressions.RegexReplacement.LeftPortion;
                        break;

                    case "\'":
                        capnum = System.Text.RegularExpressions.RegexReplacement.RightPortion;
                        break;

                    case "+":
                        capnum = System.Text.RegularExpressions.RegexReplacement.LastGroup;
                        break;

                    case "_":
                        capnum = System.Text.RegularExpressions.RegexReplacement.WholeString;
                        break;
                }

                if (capnum !== 1) {
                    this._moveRight();

                    return new System.Text.RegularExpressions.RegexNode(System.Text.RegularExpressions.RegexNode.Ref, this._options, capnum);
                }
            }

            // unrecognized $: literalize

            this._textto(backpos);

            return new System.Text.RegularExpressions.RegexNode(System.Text.RegularExpressions.RegexNode.One, this._options, "$");
        },

        _scanDecimal: function () {
            // Scans any number of decimal digits (pegs value at 2^31-1 if too large)

            var maxValueDiv10 = 214748364; // Int32.MaxValue / 10;
            var maxValueMod10 = 7; // Int32.MaxValue % 10;
            var i = 0;
            var ch;
            var d;

            while (this._charsRight() > 0) {
                ch = this._rightChar();

                if (ch < "0" || ch > "9") {
                    break;
                }

                d = ch - "0";

                this._moveRight();

                if (i > (maxValueDiv10) || (i === (maxValueDiv10) && d > (maxValueMod10))) {
                    throw this._makeException("Capture group is out of range.");
                }

                i *= 10;
                i += d;
            }

            return i;
        },

        _scanOctal: function () {
            var d;
            var i;
            var c;

            // Consume octal chars only up to 3 digits and value 0377

            c = 3;

            if (c > this._charsRight()) {
                c = this._charsRight();
            }

            for (i = 0; c > 0 && (d = this._rightChar() - "0") <= 7; c -= 1) {
                this._moveRight();

                i *= 8;
                i += d;

                if (this._useOptionE() && i >= 0x20) {
                    break;
                }
            }

            // Octal codes only go up to 255.  Any larger and the behavior that Perl follows
            // is simply to truncate the high bits.
            i &= 0xFF;

            return String.fromCharCode(i);
        },

        _scanHex: function (c) {
            var i;
            var d;

            i = 0;

            if (this._charsRight() >= c) {
                for (; c > 0 && ((d = this._hexDigit(this._moveRightGetChar())) >= 0); c -= 1) {
                    i *= 0x10;
                    i += d;
                }
            }

            if (c > 0) {
                throw this._makeException("Insufficient hexadecimal digits.");
            }

            return i;
        },

        _hexDigit: function (ch) {
            var d;

            var code = ch.charCodeAt(0);

            if ((d = code - "0".charCodeAt(0)) <= 9) {
                return d;
            }

            if ((d = code - "a".charCodeAt(0)) <= 5) {
                return d + 0xa;
            }

            if ((d = code - "A".charCodeAt(0)) <= 5) {
                return d + 0xa;
            }

            return -1;
        },

        _scanControl: function () {
            if (this._charsRight() <= 0) {
                throw this._makeException("Missing control character.");
            }

            var ch = this._moveRightGetChar();

            // \ca interpreted as \cA

            var code = ch.charCodeAt(0);

            if (code >= "a".charCodeAt(0) && code <= "z".charCodeAt(0)) {
                code = code - ("a".charCodeAt(0) - "A".charCodeAt(0));
            }

            if ((code = (code - "@".charCodeAt(0))) < " ".charCodeAt(0)) {
                return String.fromCharCode(code);
            }

            throw this._makeException("Unrecognized control character.");
        },

        _scanCapname: function () {
            var startpos = this._textpos();

            while (this._charsRight() > 0) {
                if (!this._isWordChar(this._moveRightGetChar())) {
                    this._moveLeft();

                    break;
                }
            }

            return _pattern.slice(startpos, this._textpos());
        },

        _scanCharEscape: function () {
            var ch = this._moveRightGetChar();

            if (ch >= "0" && ch <= "7") {
                this._moveLeft();

                return this._scanOctal();
            }

            switch (ch) {
                case "x":
                    return this._scanHex(2);
                case "u":
                    return this._scanHex(4);
                case "a":
                    return "\u0007";
                case "b":
                    return "\b";
                case "e":
                    return "\u001B";
                case "f":
                    return "\f";
                case "n":
                    return "\n";
                case "r":
                    return "\r";
                case "t":
                    return "\t";
                case "v":
                    return "\u000B";
                case "c":
                    return this._scanControl();
                default:
                    var isInvalidBasicLatin = ch === '8' || ch === '9' || ch === '_';
                    if (isInvalidBasicLatin || (!this._useOptionE() && this._isWordChar(ch))) {
                        throw this._makeException("Unrecognized escape sequence \\" + ch + ".");
                    }
                    return ch;
            }
        },

        _captureSlotFromName: function (capname) {
            return this._capnames[capname];
        },

        _isCaptureSlot: function (i) {
            if (this._caps != null) {
                return this._caps[i] != null;
            }

            return (i >= 0 && i < this._capsize);
        },

        _isCaptureName: function (capname) {
            if (this._capnames == null) {
                return false;
            }

            return _capnames[capname] != null;
        },

        _isWordChar: function (ch) {
            // Partial implementation,
            // see the link for more details (http://referencesource.microsoft.com/#System/regex/system/text/regularexpressions/RegexParser.cs,1156)
            return System.Char.isLetter(ch.charCodeAt(0));
        },

        _charsRight: function () {
            return this._pattern.length - this._currentPos;
        },

        _rightChar: function () {
            return this._pattern[this._currentPos];
        },

        _moveRightGetChar: function () {
            return this._pattern[this._currentPos++];
        },

        _moveRight: function () {
            this._currentPos++;
        },

        _textpos: function () {
            return this._currentPos;
        },

        _textto: function (pos) {
            this._currentPos = pos;
        },

        _moveLeft: function () {
            this._currentPos--;
        }
    });

    // @source RegexNode.js

    Bridge.define("System.Text.RegularExpressions.RegexNode", {
        statics: {
            One: 9, // char     a
            Multi: 12, // string   abcdef
            Ref: 13, // index    \1
            Empty: 23, //          ()
            Concatenate: 25 //          ab
        },

        _type: 0,
        _str: null,
        _children: null,
        _next: null,
        _m: 0,

        config: {
            init: function () {
                this._options = System.Text.RegularExpressions.RegexOptions.None;
            }
        },

        ctor: function (type, options, arg) {
            this.$initialize();
            this._type = type;
            this._options = options;

            if (type === System.Text.RegularExpressions.RegexNode.Ref) {
                this._m = arg;
            } else {
                this._str = arg || null;
            }
        },

        addChild: function (newChild) {
            if (this._children == null) {
                this._children = [];
            }

            var reducedChild = newChild._reduce();
            this._children.push(reducedChild);
            reducedChild._next = this;
        },

        childCount: function () {
            return this._children == null ? 0 : this._children.length;
        },

        child: function (i) {
            return this._children[i];
        },

        _reduce: function () {
            // Warning: current implementation is just partial (for Replacement servicing)

            var n;

            switch (this._type) {
                case System.Text.RegularExpressions.RegexNode.Concatenate:
                    n = this._reduceConcatenation();
                    break;

                default:
                    n = this;
                    break;
            }

            return n;
        },

        _reduceConcatenation: function () {
            var wasLastString = false;
            var optionsLast = 0;
            var optionsAt;
            var at;
            var prev;
            var i;
            var j;
            var k;

            if (this._children == null) {
                return new System.Text.RegularExpressions.RegexNode(System.Text.RegularExpressions.RegexNode.Empty, this._options);
            }

            for (i = 0, j = 0; i < this._children.length; i++, j++) {
                at = this._children[i];

                if (j < i) {
                    this._children[j] = at;
                }

                if (at._type === System.Text.RegularExpressions.RegexNode.Concatenate && at._isRightToLeft()) {
                    for (k = 0; k < at._children.length; k++) {
                        at._children[k]._next = this;
                    }

                    this._children.splice.apply(this._children, [i + 1, 0].concat(at._children)); // _children.InsertRange(i + 1, at._children);
                    j--;
                } else if (at._type === System.Text.RegularExpressions.RegexNode.Multi || at._type === System.Text.RegularExpressions.RegexNode.One) {
                    // Cannot merge strings if L or I options differ
                    optionsAt = at._options & (System.Text.RegularExpressions.RegexOptions.RightToLeft | System.Text.RegularExpressions.RegexOptions.IgnoreCase);

                    if (!wasLastString || optionsLast !== optionsAt) {
                        wasLastString = true;
                        optionsLast = optionsAt;
                        continue;
                    }

                    prev = this._children[--j];

                    if (prev._type === System.Text.RegularExpressions.RegexNode.One) {
                        prev._type = System.Text.RegularExpressions.RegexNode.Multi;
                        prev._str = prev._str;
                    }

                    if ((optionsAt & System.Text.RegularExpressions.RegexOptions.RightToLeft) === 0) {
                        prev._str += at._str;
                    } else {
                        prev._str = at._str + prev._str;
                    }
                } else if (at._type === System.Text.RegularExpressions.RegexNode.Empty) {
                    j--;
                } else {
                    wasLastString = false;
                }
            }

            if (j < i) {
                this._children.splice(j, i - j);
            }

            return this._stripEnation(System.Text.RegularExpressions.RegexNode.Empty);
        },

        _stripEnation: function (emptyType) {
            switch (this.childCount()) {
                case 0:
                    return new scope.RegexNode(emptyType, this._options);
                case 1:
                    return this.child(0);
                default:
                    return this;
            }
        },

        _isRightToLeft: function () {
            if ((this._options & System.Text.RegularExpressions.RegexOptions.RightToLeft) > 0) {
                return true;
            }

            return false;
        },
    });

    // @source RegexReplacement.js

    Bridge.define("System.Text.RegularExpressions.RegexReplacement", {
        statics: {
            replace: function (evaluator, regex, input, count, startat) {
                if (evaluator == null) {
                    throw new System.ArgumentNullException.$ctor1("evaluator");
                }

                if (count < -1) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("count", "Count cannot be less than -1.");
                }

                if (startat < 0 || startat > input.length) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("startat", "Start index cannot be less than 0 or greater than input length.");
                }

                if (count === 0) {
                    return input;
                }

                var match = regex.match(input, startat);

                if (!match.getSuccess()) {
                    return input;
                } else {
                    var sb = "";
                    var prevat;
                    var matchIndex;
                    var matchLength;

                    if (!regex.getRightToLeft()) {
                        prevat = 0;

                        do {
                            matchIndex = match.getIndex();
                            matchLength = match.getLength();

                            if (matchIndex !== prevat) {
                                sb += input.slice(prevat, matchIndex);
                            }

                            prevat = matchIndex + matchLength;
                            sb += evaluator(match);

                            if (--count === 0) {
                                break;
                            }

                            match = match.nextMatch();
                        } while (match.getSuccess());

                        if (prevat < input.length) {
                            sb += input.slice(prevat, input.length);
                        }
                    } else {
                        var al = [];

                        prevat = input.length;

                        do {
                            matchIndex = match.getIndex();
                            matchLength = match.getLength();

                            if (matchIndex + matchLength !== prevat) {
                                al.push(input.slice(matchIndex + matchLength, prevat));
                            }

                            prevat = matchIndex;
                            al.push(evaluator(match));

                            if (--count === 0) {
                                break;
                            }

                            match = match.nextMatch();
                        } while (match.getSuccess());

                        sb = new StringBuilder();

                        if (prevat > 0) {
                            sb += sb.slice(0, prevat);
                        }

                        var i;

                        for (i = al.length - 1; i >= 0; i--) {
                            sb += al[i];
                        }
                    }

                    return sb;
                }
            },

            split: function (regex, input, count, startat) {
                if (count < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("count", "Count can't be less than 0.");
                }

                if (startat < 0 || startat > input.length) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("startat", "Start index cannot be less than 0 or greater than input length.");
                }

                var result = [];

                if (count === 1) {
                    result.push(input);

                    return result;
                }

                --count;
                var match = regex.match(input, startat);

                if (!match.getSuccess()) {
                    result.push(input);
                } else {
                    var i;
                    var prevat;
                    var matchIndex;
                    var matchLength;
                    var matchGroups;
                    var matchGroupsCount;

                    if (!regex.getRightToLeft()) {
                        prevat = 0;

                        for (;;) {
                            matchIndex = match.getIndex();
                            matchLength = match.getLength();
                            matchGroups = match.getGroups();
                            matchGroupsCount = matchGroups.getCount();

                            result.push(input.slice(prevat, matchIndex));
                            prevat = matchIndex + matchLength;

                            // add all matched capture groups to the list.
                            for (i = 1; i < matchGroupsCount; i++) {
                                if (match._isMatched(i)) {
                                    result.push(matchGroups.get(i).toString());
                                }
                            }

                            --count;
                            if (count === 0) {
                                break;
                            }

                            match = match.nextMatch();

                            if (!match.getSuccess()) {
                                break;
                            }
                        }

                        result.push(input.slice(prevat, input.length));
                    } else {
                        prevat = input.length;

                        for (;;) {
                            matchIndex = match.getIndex();
                            matchLength = match.getLength();
                            matchGroups = match.getGroups();
                            matchGroupsCount = matchGroups.getCount();

                            result.push(input.slice(matchIndex + matchLength, prevat));
                            prevat = matchIndex;

                            // add all matched capture groups to the list.
                            for (i = 1; i < matchGroupsCount; i++) {
                                if (match._isMatched(i)) {
                                    result.push(matchGroups.get(i).toString());
                                }
                            }

                            --count;
                            if (count === 0) {
                                break;
                            }

                            match = match.nextMatch();

                            if (!match.getSuccess()) {
                                break;
                            }
                        }

                        result.push(input.slice(0, prevat));
                        result.reverse();
                    }
                }

                return result;
            },

            Specials: 4,
            LeftPortion: -1,
            RightPortion: -2,
            LastGroup: -3,
            WholeString: -4
        },

        _rep: "",
        _strings: [], // table of string constants
        _rules: [], // negative -> group #, positive -> string #

        ctor: function (rep, concat, caps) {
            this.$initialize();
            this._rep = rep;

            if (concat._type !== System.Text.RegularExpressions.RegexNode.Concatenate) {
                throw new System.ArgumentException.$ctor1("Replacement error.");
            }

            var sb = "";
            var strings = [];
            var rules = [];
            var slot;
            var child;
            var i;

            for (i = 0; i < concat.childCount(); i++) {
                child = concat.child(i);

                switch (child._type) {
                    case System.Text.RegularExpressions.RegexNode.Multi:
                    case System.Text.RegularExpressions.RegexNode.One:
                        sb += child._str;
                        break;

                    case System.Text.RegularExpressions.RegexNode.Ref:
                        if (sb.length > 0) {
                            rules.push(strings.length);
                            strings.push(sb);
                            sb = "";
                        }

                        slot = child._m;

                        if (caps != null && slot >= 0) {
                            slot = caps[slot];
                        }

                        rules.push(-System.Text.RegularExpressions.RegexReplacement.Specials - 1 - slot);
                        break;
                    default:
                        throw new System.ArgumentException.$ctor1("Replacement error.");
                }
            }

            if (sb.length > 0) {
                rules.push(strings.length);
                strings.push(sb);
            }

            this._strings = strings;
            this._rules = rules;
        },

        getPattern: function () {
            return _rep;
        },

        replacement: function (match) {
            return this._replacementImpl("", match);
        },

        replace: function (regex, input, count, startat) {
            if (count < -1) {
                throw new System.ArgumentOutOfRangeException.$ctor4("count", "Count cannot be less than -1.");
            }

            if (startat < 0 || startat > input.length) {
                throw new System.ArgumentOutOfRangeException.$ctor4("startat", "Start index cannot be less than 0 or greater than input length.");
            }

            if (count === 0) {
                return input;
            }

            var match = regex.match(input, startat);

            if (!match.getSuccess()) {
                return input;
            } else {
                var sb = "";
                var prevat;
                var matchIndex;
                var matchLength;

                if (!regex.getRightToLeft()) {
                    prevat = 0;

                    do {
                        matchIndex = match.getIndex();
                        matchLength = match.getLength();

                        if (matchIndex !== prevat) {
                            sb += input.slice(prevat, matchIndex);
                        }

                        prevat = matchIndex + matchLength;
                        sb = this._replacementImpl(sb, match);

                        if (--count === 0) {
                            break;
                        }

                        match = match.nextMatch();
                    } while (match.getSuccess());

                    if (prevat < input.length) {
                        sb += input.slice(prevat, input.length);
                    }
                } else {
                    var al = [];

                    prevat = input.length;

                    do {
                        matchIndex = match.getIndex();
                        matchLength = match.getLength();

                        if (matchIndex + matchLength !== prevat) {
                            al.push(input.slice(matchIndex + matchLength, prevat));
                        }

                        prevat = matchIndex;
                        this._replacementImplRTL(al, match);

                        if (--count === 0) {
                            break;
                        }

                        match = match.nextMatch();
                    } while (match.getSuccess());

                    if (prevat > 0) {
                        sb += sb.slice(0, prevat);
                    }

                    var i;

                    for (i = al.length - 1; i >= 0; i--) {
                        sb += al[i];
                    }
                }

                return sb;
            }
        },

        _replacementImpl: function (sb, match) {
            var specials = System.Text.RegularExpressions.RegexReplacement.Specials;
            var r;
            var i;

            for (i = 0; i < this._rules.length; i++) {
                r = this._rules[i];

                if (r >= 0) {
                    // string lookup
                    sb += this._strings[r];
                } else if (r < -specials) {
                    // group lookup
                    sb += match._groupToStringImpl(-specials - 1 - r);
                } else {
                    // special insertion patterns
                    switch (-specials - 1 - r) {
                        case System.Text.RegularExpressions.RegexReplacement.LeftPortion:
                            sb += match._getLeftSubstring();
                            break;
                        case System.Text.RegularExpressions.RegexReplacement.RightPortion:
                            sb += match._getRightSubstring();
                            break;
                        case System.Text.RegularExpressions.RegexReplacement.LastGroup:
                            sb += match._lastGroupToStringImpl();
                            break;
                        case System.Text.RegularExpressions.RegexReplacement.WholeString:
                            sb += match._getOriginalString();
                            break;
                    }
                }
            }

            return sb;
        },

        _replacementImplRTL: function (al, match) {
            var specials = System.Text.RegularExpressions.RegexReplacement.Specials;
            var r;
            var i;

            for (i = _rules.length - 1; i >= 0; i--) {
                r = this._rules[i];

                if (r >= 0) {
                    // string lookup
                    al.push(this._strings[r]);
                } else if (r < -specials) {
                    // group lookup
                    al.push(match._groupToStringImpl(-specials - 1 - r));
                } else {
                    // special insertion patterns
                    switch (-specials - 1 - r) {
                        case System.Text.RegularExpressions.RegexReplacement.LeftPortion:
                            al.push(match._getLeftSubstring());
                            break;
                        case System.Text.RegularExpressions.RegexReplacement.RightPortion:
                            al.push(match._getRightSubstring());
                            break;
                        case System.Text.RegularExpressions.RegexReplacement.LastGroup:
                            al.push(match._lastGroupToStringImpl());
                            break;
                        case System.Text.RegularExpressions.RegexReplacement.WholeString:
                            al.push(match._getOriginalString());
                            break;
                    }
                }
            }
        }
    });

    // @source RegexEngine.js

    Bridge.define("System.Text.RegularExpressions.RegexEngine", {
        _pattern: "",
        _patternInfo: null,

        _text: "",
        _textStart: 0,
        _timeoutMs: -1,
        _timeoutTime: -1,
        _settings: null,

        _branchType: {
            base: 0,
            offset: 1,
            lazy: 2,
            greedy: 3,
            or: 4
        },

        _branchResultKind: {
            ok: 1,
            endPass: 2,
            nextPass: 3,
            nextBranch: 4
        },

        // ============================================================================================
        // Public functions
        // ============================================================================================
        ctor: function (pattern, isCaseInsensitive, isMultiLine, isSingleline, isIgnoreWhitespace, isExplicitCapture, timeoutMs) {
            this.$initialize();

            if (pattern == null) {
                throw new System.ArgumentNullException.$ctor1("pattern");
            }

            this._pattern = pattern;
            this._timeoutMs = timeoutMs;
            this._settings = {
                ignoreCase: isCaseInsensitive,
                multiline: isMultiLine,
                singleline: isSingleline,
                ignoreWhitespace: isIgnoreWhitespace,
                explicitCapture: isExplicitCapture
            };
        },

        match: function (text, textStart) {
            if (text == null) {
                throw new System.ArgumentNullException.$ctor1("text");
            }

            if (textStart != null && (textStart < 0 || textStart > text.length)) {
                throw new System.ArgumentOutOfRangeException.$ctor4("textStart", "Start index cannot be less than 0 or greater than input length.");
            }

            this._text = text;
            this._textStart = textStart;
            this._timeoutTime = this._timeoutMs > 0 ? new Date().getTime() + System.Convert.toInt32(this._timeoutMs + 0.5) : -1;

            // Get group descriptors
            var patternInfo = this.parsePattern();

            if (patternInfo.shouldFail) {
                return this._getEmptyMatch();
            }

            this._checkTimeout();

            var scanRes = this._scanAndTransformResult(textStart, patternInfo.tokens, false, null);

            return scanRes;
        },

        parsePattern: function () {
            if (this._patternInfo == null) {
                var parser = System.Text.RegularExpressions.RegexEngineParser;
                var patternInfo = parser.parsePattern(this._pattern, this._cloneSettings(this._settings));
                this._patternInfo = patternInfo;
            }

            return this._patternInfo;
        },

        // ============================================================================================
        // Engine main logic
        // ============================================================================================
        _scanAndTransformResult: function (textPos, tokens, noOffset, desiredLen) {
            var state = this._scan(textPos, this._text.length, tokens, noOffset, desiredLen);
            var transformedRes = this._collectScanResults(state, textPos);
            return transformedRes;
        },

        _scan: function (textPos, textEndPos, tokens, noOffset, desiredLen) {
            var resKind = this._branchResultKind;
            var branches = [];
            branches.grCaptureCache = {};

            var branch = null;
            var res = null;

            // Empty pattern case:
            if (tokens.length === 0) {
                var state = new System.Text.RegularExpressions.RegexEngineState();
                state.capIndex = textPos;
                state.txtIndex = textPos;
                state.capLength = 0;

                return state;
            }

            // Init base branch:
            var baseBranchType = noOffset ? this._branchType.base : this._branchType.offset;

            var endPos = this._patternInfo.isContiguous ? textPos : textEndPos;
            var baseBranch = new System.Text.RegularExpressions.RegexEngineBranch(baseBranchType, textPos, textPos, endPos);

            baseBranch.pushPass(0, tokens, this._cloneSettings(this._settings));
            baseBranch.started = true;
            baseBranch.state.txtIndex = textPos;
            branches.push(baseBranch);

            while (branches.length) {
                branch = branches[branches.length - 1];

                res = this._scanBranch(textEndPos, branches, branch);

                if (res === resKind.ok && (desiredLen == null || branch.state.capLength === desiredLen)) {
                    return branch.state;
                }

                //if (!this.branchLimit) {
                //    this.branchLimit = 1;
                //} else {
                //    this.branchLimit++;
                //    if (this.branchLimit > 200000) {
                //        alert("Too many branches :(");
                //        break;
                //    }
                //}

                this._advanceToNextBranch(branches, branch);
                this._checkTimeout();
            }

            return null;
        },

        _scanBranch: function (textEndPos, branches, branch) {
            var resKind = this._branchResultKind;
            var pass;
            var res;

            if (branch.mustFail) {
                branch.mustFail = false;

                return resKind.nextBranch;
            }

            while (branch.hasPass()) {
                pass = branch.peekPass();

                if (pass.tokens == null || pass.tokens.length === 0) {
                    res = resKind.endPass;
                } else {
                    // Add alternation branches before scanning:
                    if (this._addAlternationBranches(branches, branch, pass) === resKind.nextBranch) {
                        return resKind.nextBranch;
                    }

                    // Scan:
                    res = this._scanPass(textEndPos, branches, branch, pass);
                }

                switch (res) {
                    case resKind.nextBranch:
                        // Move to the next branch:
                        return res;

                    case resKind.nextPass:
                        // switch to the recently added pass
                        continue;

                    case resKind.endPass:
                    case resKind.ok:
                        // End of pass has been reached:
                        branch.popPass();
                        break;

                    default:
                        throw new System.InvalidOperationException.$ctor1("Unexpected branch result.");
                }
            }

            return resKind.ok;
        },

        _scanPass: function (textEndPos, branches, branch, pass) {
            var resKind = this._branchResultKind;
            var passEndIndex = pass.tokens.length;
            var token;
            var probe;
            var res;

            while (pass.index < passEndIndex) {
                token = pass.tokens[pass.index];
                probe = pass.probe;

                // Add probing:
                if (probe == null) {
                    if (this._addBranchBeforeProbing(branches, branch, pass, token)) {
                        return resKind.nextBranch;
                    }
                } else {
                    if (probe.value < probe.min || probe.forced) {
                        res = this._scanToken(textEndPos, branches, branch, pass, token);

                        if (res !== resKind.ok) {
                            return res;
                        }

                        probe.value += 1;
                        probe.forced = false;

                        continue;
                    }

                    this._addBranchAfterProbing(branches, branch, pass, probe);

                    if (probe.forced) {
                        continue;
                    }

                    pass.probe = null;
                    pass.index++;

                    continue;
                }

                // Process the token:
                res = this._scanToken(textEndPos, branches, branch, pass, token);

                // Process the result of the token scan:
                switch (res) {
                    case resKind.nextBranch:
                    case resKind.nextPass:
                    case resKind.endPass:
                        return res;

                    case resKind.ok:
                        // Advance to the next token within the current pass:
                        pass.index++;
                        break;

                    default:
                        throw new System.InvalidOperationException.$ctor1("Unexpected branch-pass result.");
                }
            }

            return resKind.ok;
        },

        _addAlternationBranches: function (branches, branch, pass) {
            var tokenTypes = System.Text.RegularExpressions.RegexEngineParser.tokenTypes;
            var branchTypes = this._branchType;
            var passEndIndex = pass.tokens.length;
            var resKind = this._branchResultKind;
            var orIndexes;
            var newBranch;
            var newPass;
            var token;
            var i;

            // Scan potential alternations:
            if (!pass.alternationHandled && !pass.tokens.noAlternation) {
                orIndexes = [-1];

                for (i = 0; i < passEndIndex; i++) {
                    token = pass.tokens[i];

                    if (token.type === tokenTypes.alternation) {
                        orIndexes.push(i);
                    }
                }

                if (orIndexes.length > 1) {
                    for (i = 0; i < orIndexes.length; i++) {
                        newBranch = new System.Text.RegularExpressions.RegexEngineBranch(branchTypes.or, i, 0, orIndexes.length, branch.state);
                        newBranch.isNotFailing = true;
                        newPass = newBranch.peekPass();
                        newPass.alternationHandled = true;
                        newPass.index = orIndexes[i] + 1;
                        branches.splice(branches.length - i, 0, newBranch);
                    }

                    // The last branch must fail:
                    branches[branches.length - orIndexes.length].isNotFailing = false;

                    // The parent branch must be ended up immediately:
                    branch.mustFail = true;

                    pass.alternationHandled = true;

                    return resKind.nextBranch;
                } else {
                    pass.tokens.noAlternation = true;
                }
            }

            return resKind.ok;
        },

        _addBranchBeforeProbing: function (branches, branch, pass, token) {
            // Add +, *, ? branches:
            var probe = this._tryGetTokenProbe(token);

            if (probe == null) {
                return false;
            }

            pass.probe = probe;

            var branchType = probe.isLazy ? this._branchType.lazy : this._branchType.greedy;
            var newBranch = new System.Text.RegularExpressions.RegexEngineBranch(branchType, probe.value, probe.min, probe.max, branch.state);

            branches.push(newBranch);

            return true;
        },

        _addBranchAfterProbing: function (branches, branch, pass, probe) {
            if (probe.isLazy) {
                if (probe.value + 1 <= probe.max) {
                    var lazyBranch = branch.clone();
                    var lazyProbe = lazyBranch.peekPass().probe;

                    lazyBranch.value += 1;
                    lazyProbe.forced = true;

                    // add to the left from the current branch
                    branches.splice(branches.length - 1, 0, lazyBranch);
                    branch.isNotFailing = true;
                }
            } else {
                if (probe.value + 1 <= probe.max) {
                    var greedyBranch = branch.clone();

                    greedyBranch.started = true;
                    greedyBranch.peekPass().probe = null;
                    greedyBranch.peekPass().index++;
                    branches.splice(branches.length - 1, 0, greedyBranch);

                    probe.forced = true;
                    branch.value += 1;
                    branch.isNotFailing = true;
                }
            }
        },

        _tryGetTokenProbe: function (token) {
            var qtoken = token.qtoken;

            if (qtoken == null) {
                return null;
            }

            var tokenTypes = System.Text.RegularExpressions.RegexEngineParser.tokenTypes;
            var min;
            var max;

            if (qtoken.type === tokenTypes.quantifier) {
                switch (qtoken.value) {
                    case "*":
                    case "*?":
                        min = 0;
                        max = 2147483647;
                        break;

                    case "+":
                    case "+?":
                        min = 1;
                        max = 2147483647;
                        break;

                    case "?":
                    case "??":
                        min = 0;
                        max = 1;
                        break;

                    default:
                        throw new System.InvalidOperationException.$ctor1("Unexpected quantifier value.");
                }
            } else if (qtoken.type === tokenTypes.quantifierN) {
                min = qtoken.data.n;
                max = qtoken.data.n;
            } else if (qtoken.type === tokenTypes.quantifierNM) {
                min = qtoken.data.n;
                max = qtoken.data.m != null ? qtoken.data.m : 2147483647;
            } else {
                return null;
            }

            var probe = new System.Text.RegularExpressions.RegexEngineProbe(min, max, 0, qtoken.data.isLazy);
            return probe;
        },

        _advanceToNextBranch: function (branches, branch) {
            if (branches.length === 0) {
                return;
            }

            var lastBranch = branches[branches.length - 1];

            if (!lastBranch.started) {
                lastBranch.started = true;
                return;
            }

            if (branch !== lastBranch) {
                throw new System.InvalidOperationException.$ctor1("Current branch is supposed to be the last one.");
            }

            if (branches.length === 1 && branch.type === this._branchType.offset) {
                branch.value++;
                branch.state.txtIndex = branch.value;
                branch.mustFail = false;

                // clear state:
                branch.state.capIndex = null;
                branch.state.capLength = 0;
                branch.state.groups.length = 0;
                branch.state.passes.length = 1;
                branch.state.passes[0].clearState(this._cloneSettings(this._settings));

                if (branch.value > branch.max) {
                    branches.pop();
                }
            } else {
                branches.pop();

                if (!branch.isNotFailing) {
                    lastBranch = branches[branches.length - 1];
                    this._advanceToNextBranch(branches, lastBranch);

                    return;
                }
            }
        },

        _collectScanResults: function (state, textPos) {
            var groupDescs = this._patternInfo.groups;
            var text = this._text;
            var processedGroupNames = {};
            var capGroups;
            var capGroup;
            var groupsMap = {};
            var groupDesc;
            var capture;
            var group;
            var i;

            // Create Empty match object:
            var match = this._getEmptyMatch();

            if (state != null) {
                capGroups = state.groups;

                // For successful match fill Match object:
                this._fillMatch(match, state.capIndex, state.capLength, textPos);

                // Fill group captures:
                for (i = 0; i < capGroups.length; i++) {
                    capGroup = capGroups[i];
                    groupDesc = groupDescs[capGroup.rawIndex - 1];

                    if (groupDesc.constructs.skipCapture) {
                        continue;
                    }

                    capture = {
                        capIndex: capGroup.capIndex,
                        capLength: capGroup.capLength,
                        value: text.slice(capGroup.capIndex, capGroup.capIndex + capGroup.capLength)
                    };

                    group = groupsMap[groupDesc.name];

                    if (group == null) {
                        group = {
                            capIndex: 0,
                            capLength: 0,
                            value: "",
                            success: false,
                            captures: [capture]
                        };

                        groupsMap[groupDesc.name] = group;
                    } else {
                        group.captures.push(capture);
                    }
                }

                // Add groups to Match in the required order:
                for (i = 0; i < groupDescs.length; i++) {
                    groupDesc = groupDescs[i];

                    if (groupDesc.constructs.skipCapture) {
                        continue;
                    }

                    if (processedGroupNames[groupDesc.name] === true) {
                        continue;
                    }

                    group = groupsMap[groupDesc.name];

                    if (group == null) {
                        group = {
                            capIndex: 0,
                            capLength: 0,
                            value: "",
                            success: false,
                            captures: []
                        };
                    } else {
                        // Update group values with the last capture info:
                        if (group.captures.length > 0) {
                            capture = group.captures[group.captures.length - 1];

                            group.capIndex = capture.capIndex;
                            group.capLength = capture.capLength;
                            group.value = capture.value;
                            group.success = true;
                        }
                    }

                    processedGroupNames[groupDesc.name] = true;
                    group.descriptor = groupDesc; // TODO: check if we can get rid of this
                    match.groups.push(group);
                }
            }

            return match;
        },

        // ============================================================================================
        // Token processing
        // ============================================================================================
        _scanToken: function (textEndPos, branches, branch, pass, token) {
            var tokenTypes = System.Text.RegularExpressions.RegexEngineParser.tokenTypes;
            var resKind = this._branchResultKind;

            switch (token.type) {
                case tokenTypes.group:
                case tokenTypes.groupImnsx:
                case tokenTypes.alternationGroup:
                    return this._scanGroupToken(textEndPos, branches, branch, pass, token);

                case tokenTypes.groupImnsxMisc:
                    return this._scanGroupImnsxToken(token.group.constructs, pass.settings);

                case tokenTypes.charGroup:
                    return this._scanCharGroupToken(branches, branch, pass, token, false);

                case tokenTypes.charNegativeGroup:
                    return this._scanCharNegativeGroupToken(branches, branch, pass, token, false);

                case tokenTypes.escChar:
                case tokenTypes.escCharOctal:
                case tokenTypes.escCharHex:
                case tokenTypes.escCharUnicode:
                case tokenTypes.escCharCtrl:
                    return this._scanLiteral(textEndPos, branches, branch, pass, token.data.ch);

                case tokenTypes.escCharOther:
                case tokenTypes.escCharClass:
                    return this._scanEscapeToken(branches, branch, pass, token);

                case tokenTypes.escCharClassCategory:
                    throw new System.NotSupportedException.$ctor1("Unicode Category constructions are not supported.");

                case tokenTypes.escCharClassBlock:
                    throw new System.NotSupportedException.$ctor1("Unicode Named block constructions are not supported.");

                case tokenTypes.escCharClassDot:
                    return this._scanDotToken(textEndPos, branches, branch, pass);

                case tokenTypes.escBackrefNumber:
                    return this._scanBackrefNumberToken(textEndPos, branches, branch, pass, token);

                case tokenTypes.escBackrefName:
                    return this._scanBackrefNameToken(textEndPos, branches, branch, pass, token);

                case tokenTypes.anchor:
                case tokenTypes.escAnchor:
                    return this._scanAnchorToken(textEndPos, branches, branch, pass, token);

                case tokenTypes.groupConstruct:
                case tokenTypes.groupConstructName:
                case tokenTypes.groupConstructImnsx:
                case tokenTypes.groupConstructImnsxMisc:
                    return resKind.ok;

                case tokenTypes.alternationGroupCondition:
                case tokenTypes.alternationGroupRefNameCondition:
                case tokenTypes.alternationGroupRefNumberCondition:
                    return this._scanAlternationConditionToken(textEndPos, branches, branch, pass, token);

                case tokenTypes.alternation:
                    return resKind.endPass;

                case tokenTypes.commentInline:
                case tokenTypes.commentXMode:
                    return resKind.ok;

                default:
                    return this._scanLiteral(textEndPos, branches, branch, pass, token.value);
            }
        },

        _scanGroupToken: function (textEndPos, branches, branch, pass, token) {
            var tokenTypes = System.Text.RegularExpressions.RegexEngineParser.tokenTypes;
            var resKind = this._branchResultKind;
            var textIndex = branch.state.txtIndex;

            if (pass.onHold) {
                if (token.type === tokenTypes.group) {
                    var rawIndex = token.group.rawIndex;
                    var capIndex = pass.onHoldTextIndex;
                    var capLength = textIndex - capIndex;

                    // Cache value to avoid proceeding with the already checked route:
                    var tokenCache = branches.grCaptureCache[rawIndex];

                    if (tokenCache == null) {
                        tokenCache = {};
                        branches.grCaptureCache[rawIndex] = tokenCache;
                    }

                    var key = capIndex.toString() + "_" + capLength.toString();

                    if (tokenCache[key] == null) {
                        tokenCache[key] = true;
                    } else {
                        return resKind.nextBranch;
                    }

                    if (!token.group.constructs.emptyCapture) {
                        if (token.group.isBalancing) {
                            branch.state.logCaptureGroupBalancing(token.group, capIndex);
                        } else {
                            branch.state.logCaptureGroup(token.group, capIndex, capLength);
                        }
                    }
                }

                pass.onHold = false;
                pass.onHoldTextIndex = -1;

                return resKind.ok;
            }

            if (token.type === tokenTypes.group ||
                token.type === tokenTypes.groupImnsx) {
                var constructs = token.group.constructs;

                // Update Pass settings:
                this._scanGroupImnsxToken(constructs, pass.settings);

                // Scan Grouping constructs:
                if (constructs.isPositiveLookahead || constructs.isNegativeLookahead ||
                    constructs.isPositiveLookbehind || constructs.isNegativeLookbehind) {
                    var scanLookRes = this._scanLook(branch, textIndex, textEndPos, token);

                    return scanLookRes;
                } else if (constructs.isNonbacktracking) {
                    var scanNonBacktrackingRes = this._scanNonBacktracking(branch, textIndex, textEndPos, token);

                    return scanNonBacktrackingRes;
                }
            }

            // Continue scanning a regular group:
            pass.onHoldTextIndex = textIndex;
            pass.onHold = true;

            branch.pushPass(0, token.children, this._cloneSettings(pass.settings));

            return resKind.nextPass;
        },

        _scanGroupImnsxToken: function (constructs, settings) {
            var resKind = this._branchResultKind;

            if (constructs.isIgnoreCase != null) {
                settings.ignoreCase = constructs.isIgnoreCase;
            }

            if (constructs.isMultiline != null) {
                settings.multiline = constructs.isMultiline;
            }

            if (constructs.isSingleLine != null) {
                settings.singleline = constructs.isSingleLine;
            }

            if (constructs.isIgnoreWhitespace != null) {
                settings.ignoreWhitespace = constructs.isIgnoreWhitespace;
            }

            if (constructs.isExplicitCapture != null) {
                settings.explicitCapture = constructs.isExplicitCapture;
            }

            return resKind.ok;
        },

        _scanAlternationConditionToken: function (textEndPos, branches, branch, pass, token) {
            var tokenTypes = System.Text.RegularExpressions.RegexEngineParser.tokenTypes;
            var resKind = this._branchResultKind;
            var children = token.children;
            var textIndex = branch.state.txtIndex;
            var res = resKind.nextBranch;

            if (token.type === tokenTypes.alternationGroupRefNameCondition ||
                token.type === tokenTypes.alternationGroupRefNumberCondition) {
                var grCapture = branch.state.resolveBackref(token.data.packedSlotId);

                if (grCapture != null) {
                    res = resKind.ok;
                } else {
                    res = resKind.nextBranch;
                }
            } else {
                // Resolve expression:
                var state = this._scan(textIndex, textEndPos, children, true, null);

                if (this._combineScanResults(branch, state)) {
                    res = resKind.ok;
                }
            }

            if (res === resKind.nextBranch && pass.tokens.noAlternation) {
                res = resKind.endPass;
            }

            return res;
        },

        _scanLook: function (branch, textIndex, textEndPos, token) {
            var constructs = token.group.constructs;
            var resKind = this._branchResultKind;
            var children = token.children;
            var expectedRes;
            var actualRes;

            var isLookahead = constructs.isPositiveLookahead || constructs.isNegativeLookahead;
            var isLookbehind = constructs.isPositiveLookbehind || constructs.isNegativeLookbehind;

            if (isLookahead || isLookbehind) {
                children = children.slice(1, children.length); // remove constructs

                expectedRes = constructs.isPositiveLookahead || constructs.isPositiveLookbehind;

                if (isLookahead) {
                    actualRes = this._scanLookAhead(branch, textIndex, textEndPos, children);
                } else {
                    actualRes = this._scanLookBehind(branch, textIndex, textEndPos, children);
                }

                if (expectedRes === actualRes) {
                    return resKind.ok;
                } else {
                    return resKind.nextBranch;
                }
            }

            return null;
        },

        _scanLookAhead: function (branch, textIndex, textEndPos, tokens) {
            var state = this._scan(textIndex, textEndPos, tokens, true, null);

            return this._combineScanResults(branch, state);
        },

        _scanLookBehind: function (branch, textIndex, textEndPos, tokens) {
            var currIndex = textIndex;
            var strLen;
            var state;

            while (currIndex >= 0) {
                strLen = textIndex - currIndex;
                state = this._scan(currIndex, textEndPos, tokens, true, strLen);

                if (this._combineScanResults(branch, state)) {
                    return true;
                }

                --currIndex;
            }

            return false;
        },

        _scanNonBacktracking: function (branch, textIndex, textEndPos, token) {
            var resKind = this._branchResultKind;
            var children = token.children;
            children = children.slice(1, children.length); // remove constructs

            var state = this._scan(textIndex, textEndPos, children, true, null);

            if (!state) {
                return resKind.nextBranch;
            }

            branch.state.logCapture(state.capLength);

            return resKind.ok;
        },

        _scanLiteral: function (textEndPos, branches, branch, pass, literal) {
            var resKind = this._branchResultKind;
            var index = branch.state.txtIndex;

            if (index + literal.length > textEndPos) {
                return resKind.nextBranch;
            }

            var i;

            if (pass.settings.ignoreCase) {
                for (i = 0; i < literal.length; i++) {
                    if (this._text[index + i].toLowerCase() !== literal[i].toLowerCase()) {
                        return resKind.nextBranch;
                    }
                }
            } else {
                for (i = 0; i < literal.length; i++) {
                    if (this._text[index + i] !== literal[i]) {
                        return resKind.nextBranch;
                    }
                }
            }

            branch.state.logCapture(literal.length);

            return resKind.ok;
        },

        _scanWithJsRegex: function (branches, branch, pass, token, tokenValue) {
            var resKind = this._branchResultKind;
            var index = branch.state.txtIndex;
            var ch = this._text[index];

            if (ch == null) {
                ch = "";
            }

            var options = pass.settings.ignoreCase ? "i" : "";

            var rgx = token.rgx;

            if (rgx == null) {
                if (tokenValue == null) {
                    tokenValue = token.value;
                }

                rgx = new RegExp(tokenValue, options);
                token.rgx = rgx;
            }

            if (rgx.test(ch)) {
                branch.state.logCapture(ch.length);

                return resKind.ok;
            }

            return resKind.nextBranch;
        },

        _scanWithJsRegex2: function (textIndex, pattern) {
            var resKind = this._branchResultKind;
            var ch = this._text[textIndex];

            if (ch == null) {
                ch = "";
            }

            var rgx = new RegExp(pattern, "");

            if (rgx.test(ch)) {
                return resKind.ok;
            }

            return resKind.nextBranch;
        },

        _scanCharGroupToken: function (branches, branch, pass, token, skipLoggingCapture) {
            var tokenTypes = System.Text.RegularExpressions.RegexEngineParser.tokenTypes;
            var resKind = this._branchResultKind;
            var index = branch.state.txtIndex;
            var ch = this._text[index];

            if (ch == null) {
                return resKind.nextBranch;
            }

            var i;
            var j;
            var n = ch.charCodeAt(0);
            var ranges = token.data.ranges;
            var range;
            var upperCh;

            // Check susbstruct group:
            if (token.data.substractToken != null) {
                var substractRes;

                if (token.data.substractToken.type === tokenTypes.charGroup) {
                    substractRes = this._scanCharGroupToken(branches, branch, pass, token.data.substractToken, true);
                } else if (token.data.substractToken.type === tokenTypes.charNegativeGroup) {
                    substractRes = this._scanCharNegativeGroupToken(branches, branch, pass, token.data.substractToken, true);
                } else {
                    throw new System.InvalidOperationException.$ctor1("Unexpected substuct group token.");
                }

                if (substractRes === resKind.ok) {
                    return token.type === tokenTypes.charGroup ? resKind.nextBranch : resKind.ok;
                }
            }

            // Try CharClass tokens like: \s \S \d \D
            if (ranges.charClassToken != null) {
                var charClassRes = this._scanWithJsRegex(branches, branch, pass, ranges.charClassToken);

                if (charClassRes === resKind.ok) {
                    return resKind.ok;
                }
            }

            // 2 iterations - to handle both cases: upper and lower
            for (j = 0; j < 2; j++) {
                //TODO: [Performance] Use binary search
                for (i = 0; i < ranges.length; i++) {
                    range = ranges[i];

                    if (range.n > n) {
                        break;
                    }

                    if (n <= range.m) {
                        if (!skipLoggingCapture) {
                            branch.state.logCapture(1);
                        }

                        return resKind.ok;
                    }
                }

                if (upperCh == null && pass.settings.ignoreCase) {
                    upperCh = ch.toUpperCase();

                    // Invert case for the 2nd attempt;
                    if (ch === upperCh) {
                        ch = ch.toLowerCase();
                    } else {
                        ch = upperCh;
                    }

                    n = ch.charCodeAt(0);
                }
            }

            return resKind.nextBranch;
        },

        _scanCharNegativeGroupToken: function (branches, branch, pass, token, skipLoggingCapture) {
            var resKind = this._branchResultKind;
            var index = branch.state.txtIndex;
            var ch = this._text[index];

            if (ch == null) {
                return resKind.nextBranch;
            }

            // Get result for positive group:
            var positiveRes = this._scanCharGroupToken(branches, branch, pass, token, true);

            // Inverse the positive result:
            if (positiveRes === resKind.ok) {
                return resKind.nextBranch;
            }

            if (!skipLoggingCapture) {
                branch.state.logCapture(1);
            }

            return resKind.ok;
        },

        _scanEscapeToken: function (branches, branch, pass, token) {
            return this._scanWithJsRegex(branches, branch, pass, token);
        },

        _scanDotToken: function (textEndPos, branches, branch, pass) {
            var resKind = this._branchResultKind;
            var index = branch.state.txtIndex;

            if (pass.settings.singleline) {
                if (index < textEndPos) {
                    branch.state.logCapture(1);

                    return resKind.ok;
                }
            } else {
                if (index < textEndPos && this._text[index] !== "\n") {
                    branch.state.logCapture(1);

                    return resKind.ok;
                }
            }

            return resKind.nextBranch;
        },

        _scanBackrefNumberToken: function (textEndPos, branches, branch, pass, token) {
            var resKind = this._branchResultKind;

            var grCapture = branch.state.resolveBackref(token.data.slotId);

            if (grCapture == null) {
                return resKind.nextBranch;
            }

            var grCaptureTxt = this._text.slice(grCapture.capIndex, grCapture.capIndex + grCapture.capLength);

            return this._scanLiteral(textEndPos, branches, branch, pass, grCaptureTxt);
        },

        _scanBackrefNameToken: function (textEndPos, branches, branch, pass, token) {
            var resKind = this._branchResultKind;

            var grCapture = branch.state.resolveBackref(token.data.slotId);

            if (grCapture == null) {
                return resKind.nextBranch;
            }

            var grCaptureTxt = this._text.slice(grCapture.capIndex, grCapture.capIndex + grCapture.capLength);

            return this._scanLiteral(textEndPos, branches, branch, pass, grCaptureTxt);
        },

        _scanAnchorToken: function (textEndPos, branches, branch, pass, token) {
            var resKind = this._branchResultKind;
            var index = branch.state.txtIndex;

            if (token.value === "\\b" || token.value === "\\B") {
                var prevIsWord = index > 0 && this._scanWithJsRegex2(index - 1, "\\w") === resKind.ok;
                var currIsWord = this._scanWithJsRegex2(index, "\\w") === resKind.ok;

                if ((prevIsWord === currIsWord) === (token.value === "\\B")) {
                    return resKind.ok;
                }
            } else if (token.value === "^") {
                if (index === 0) {
                    return resKind.ok;
                }

                if (pass.settings.multiline && this._text[index - 1] === "\n") {
                    return resKind.ok;
                }
            } else if (token.value === "$") {
                if (index === textEndPos) {
                    return resKind.ok;
                }

                if (pass.settings.multiline && this._text[index] === "\n") {
                    return resKind.ok;
                }
            } else if (token.value === "\\A") {
                if (index === 0) {
                    return resKind.ok;
                }
            } else if (token.value === "\\z") {
                if (index === textEndPos) {
                    return resKind.ok;
                }
            } else if (token.value === "\\Z") {
                if (index === textEndPos) {
                    return resKind.ok;
                }

                if (index === textEndPos - 1 && this._text[index] === "\n") {
                    return resKind.ok;
                }
            } else if (token.value === "\\G") {
                return resKind.ok;
            }

            return resKind.nextBranch;
        },

        // ============================================================================================
        // Auxiliary functions
        // ============================================================================================
        _cloneSettings: function (settings) {
            var cloned = {
                ignoreCase: settings.ignoreCase,
                multiline: settings.multiline,
                singleline: settings.singleline,
                ignoreWhitespace: settings.ignoreWhitespace,
                explicitCapture: settings.explicitCapture
            };

            return cloned;
        },

        _combineScanResults: function (branch, srcState) {
            if (srcState != null) {
                var dstGroups = branch.state.groups;
                var srcGroups = srcState.groups;
                var srcGroupsLen = srcGroups.length;
                var i;

                for (i = 0; i < srcGroupsLen; ++i) {
                    dstGroups.push(srcGroups[i]);
                }

                return true;
            }
            return false;
        },

        _getEmptyMatch: function () {
            var match = {
                capIndex: 0,    // start index of total capture
                capLength: 0,   // length of total capture
                success: false,
                value: "",
                groups: [],
                captures: []
            };

            return match;
        },

        _fillMatch: function (match, capIndex, capLength, textPos) {
            if (capIndex == null) {
                capIndex = textPos;
            }

            match.capIndex = capIndex;
            match.capLength = capLength;
            match.success = true;
            match.value = this._text.slice(capIndex, capIndex + capLength);

            match.groups.push({
                capIndex: capIndex,
                capLength: capLength,
                value: match.value,
                success: true,
                captures: [
                    {
                        capIndex: capIndex,
                        capLength: capLength,
                        value: match.value
                    }
                ]
            });

            match.captures.push(match.groups[0].captures[0]);
        },

        _checkTimeout: function () {
            if (this._timeoutTime < 0) {
                return;
            }

            var time = new Date().getTime();

            if (time >= this._timeoutTime) {
                throw new System.RegexMatchTimeoutException(this._text, this._pattern, System.TimeSpan.fromMilliseconds(this._timeoutMs));
            }
        }
    });

    // @source RegexEngineBranch.js

    Bridge.define("System.Text.RegularExpressions.RegexEngineBranch", {
        type: 0,
        value: 0,
        min: 0,
        max: 0,

        isStarted: false,
        isNotFailing: false,

        state: null,

        ctor: function (branchType, currVal, minVal, maxVal, parentState) {
            this.$initialize();

            this.type = branchType;

            this.value = currVal;
            this.min = minVal;
            this.max = maxVal;

            this.state = parentState != null ? parentState.clone() : new System.Text.RegularExpressions.RegexEngineState();
        },

        pushPass: function (index, tokens, settings) {
            var pass = new System.Text.RegularExpressions.RegexEnginePass(index, tokens, settings);

            this.state.passes.push(pass);
        },

        peekPass: function () {
            return this.state.passes[this.state.passes.length - 1];
        },

        popPass: function () {
            return this.state.passes.pop();
        },

        hasPass: function () {
            return this.state.passes.length > 0;
        },

        clone: function () {
            var cloned = new System.Text.RegularExpressions.RegexEngineBranch(this.type, this.value, this.min, this.max, this.state);

            cloned.isNotFailing = this.isNotFailing;

            return cloned;
        }
    });

    // @source RegexEngineState.js

    Bridge.define("System.Text.RegularExpressions.RegexEngineState", {
        txtIndex: 0, // current index
        capIndex: null, // first index of captured text
        capLength: 0, // current length
        passes: null,
        groups: null, // captured groups

        ctor: function () {
            this.$initialize();

            this.passes = [];
            this.groups = [];
        },

        logCapture: function (length) {
            if (this.capIndex == null) {
                this.capIndex = this.txtIndex;
            }

            this.txtIndex += length;
            this.capLength += length;
        },

        logCaptureGroup: function (group, index, length) {
            this.groups.push({ rawIndex: group.rawIndex, slotId: group.packedSlotId, capIndex: index, capLength: length });
        },

        logCaptureGroupBalancing: function (group, capIndex) {
            var balancingSlotId = group.balancingSlotId;
            var groups = this.groups;
            var index = groups.length - 1;
            var group2;
            var group2Index;

            while (index >= 0) {
                if (groups[index].slotId === balancingSlotId) {
                    group2 = groups[index];
                    group2Index = index;

                    break;
                }
                --index;
            }

            if (group2 != null && group2Index != null) {
                groups.splice(group2Index, 1); // remove group2 from the collection

                // Add balancing group value:
                if (group.constructs.name1 != null) {
                    var balCapIndex = group2.capIndex + group2.capLength;
                    var balCapLength = capIndex - balCapIndex;

                    this.logCaptureGroup(group, balCapIndex, balCapLength);
                }

                return true;
            }

            return false;
        },

        resolveBackref: function (packedSlotId) {
            var groups = this.groups;
            var index = groups.length - 1;

            while (index >= 0) {
                if (groups[index].slotId === packedSlotId) {
                    return groups[index];
                }

                --index;
            }

            return null;
        },

        clone: function () {
            var cloned = new System.Text.RegularExpressions.RegexEngineState();
            cloned.txtIndex = this.txtIndex;
            cloned.capIndex = this.capIndex;
            cloned.capLength = this.capLength;

            // Clone passes:
            var clonedPasses = cloned.passes;
            var thisPasses = this.passes;
            var len = thisPasses.length;
            var clonedItem;
            var i;

            for (i = 0; i < len; i++) {
                clonedItem = thisPasses[i].clone();
                clonedPasses.push(clonedItem);
            }

            // Clone groups:
            var clonedGroups = cloned.groups;
            var thisGroups = this.groups;
            len = thisGroups.length;

            for (i = 0; i < len; i++) {
                clonedItem = thisGroups[i];
                clonedGroups.push(clonedItem);
            }

            return cloned;
        }
    });

    // @source RegexEnginePass.js

    Bridge.define("System.Text.RegularExpressions.RegexEnginePass", {
        index: 0,
        tokens: null,
        probe: null,

        onHold: false,
        onHoldTextIndex: -1,
        alternationHandled: false,

        settings: null,

        ctor: function (index, tokens, settings) {
            this.$initialize();

            this.index = index;
            this.tokens = tokens;
            this.settings = settings;
        },

        clearState: function (settings) {
            this.index = 0;
            this.probe = null;
            this.onHold = false;
            this.onHoldTextIndex = -1;
            this.alternationHandled = false;
            this.settings = settings;
        },

        clone: function () {
            var cloned = new System.Text.RegularExpressions.RegexEnginePass(this.index, this.tokens, this.settings);

            cloned.onHold = this.onHold;
            cloned.onHoldTextIndex = this.onHoldTextIndex;
            cloned.alternationHandled = this.alternationHandled;
            cloned.probe = this.probe != null ? this.probe.clone() : null;

            return cloned;
        }
    });

    // @source RegexEngineProbe.js

    Bridge.define("System.Text.RegularExpressions.RegexEngineProbe", {
        min: 0,
        max: 0,
        value: 0,
        isLazy: false,
        forced: false,

        ctor: function (min, max, value, isLazy) {
            this.$initialize();

            this.min = min;
            this.max = max;
            this.value = value;
            this.isLazy = isLazy;
            this.forced = false;
        },

        clone: function () {
            var cloned = new System.Text.RegularExpressions.RegexEngineProbe(this.min, this.max, this.value, this.isLazy);

            cloned.forced = this.forced;

            return cloned;
        }
    });

    // @source RegexEngineParser.js

    Bridge.define("System.Text.RegularExpressions.RegexEngineParser", {
        statics: {
            _hexSymbols: "0123456789abcdefABCDEF",
            _octSymbols: "01234567",
            _decSymbols: "0123456789",

            _escapedChars: "abtrvfnexcu",
            _escapedCharClasses: "pPwWsSdD",
            _escapedAnchors: "AZzGbB",
            _escapedSpecialSymbols: " .,$^{}[]()|*+-=?\\|/\"':;~!@#%&",

            _whiteSpaceChars: " \r\n\t\v\f\u00A0\uFEFF", //TODO: This is short version of .NET WhiteSpace category.
            _unicodeCategories: ["Lu", "Ll", "Lt", "Lm", "Lo", "L", "Mn", "Mc", "Me", "M", "Nd", "Nl", "No", "N", "Pc", "Pd", "Ps", "Pe", "Pi", "Pf", "Po", "P", "Sm", "Sc", "Sk", "So", "S", "Zs", "Zl", "Zp", "Z", "Cc", "Cf", "Cs", "Co", "Cn", "C"],
            _namedCharBlocks: ["IsBasicLatin", "IsLatin-1Supplement", "IsLatinExtended-A", "IsLatinExtended-B", "IsIPAExtensions", "IsSpacingModifierLetters", "IsCombiningDiacriticalMarks", "IsGreek", "IsGreekandCoptic", "IsCyrillic", "IsCyrillicSupplement", "IsArmenian", "IsHebrew", "IsArabic", "IsSyriac", "IsThaana", "IsDevanagari", "IsBengali", "IsGurmukhi", "IsGujarati", "IsOriya", "IsTamil", "IsTelugu", "IsKannada", "IsMalayalam", "IsSinhala", "IsThai", "IsLao", "IsTibetan", "IsMyanmar", "IsGeorgian", "IsHangulJamo", "IsEthiopic", "IsCherokee", "IsUnifiedCanadianAboriginalSyllabics", "IsOgham", "IsRunic", "IsTagalog", "IsHanunoo", "IsBuhid", "IsTagbanwa", "IsKhmer", "IsMongolian", "IsLimbu", "IsTaiLe", "IsKhmerSymbols", "IsPhoneticExtensions", "IsLatinExtendedAdditional", "IsGreekExtended", "IsGeneralPunctuation", "IsSuperscriptsandSubscripts", "IsCurrencySymbols", "IsCombiningDiacriticalMarksforSymbols", "IsCombiningMarksforSymbols", "IsLetterlikeSymbols", "IsNumberForms", "IsArrows", "IsMathematicalOperators", "IsMiscellaneousTechnical", "IsControlPictures", "IsOpticalCharacterRecognition", "IsEnclosedAlphanumerics", "IsBoxDrawing", "IsBlockElements", "IsGeometricShapes", "IsMiscellaneousSymbols", "IsDingbats", "IsMiscellaneousMathematicalSymbols-A", "IsSupplementalArrows-A", "IsBraillePatterns", "IsSupplementalArrows-B", "IsMiscellaneousMathematicalSymbols-B", "IsSupplementalMathematicalOperators", "IsMiscellaneousSymbolsandArrows", "IsCJKRadicalsSupplement", "IsKangxiRadicals", "IsIdeographicDescriptionCharacters", "IsCJKSymbolsandPunctuation", "IsHiragana", "IsKatakana", "IsBopomofo", "IsHangulCompatibilityJamo", "IsKanbun", "IsBopomofoExtended", "IsKatakanaPhoneticExtensions", "IsEnclosedCJKLettersandMonths", "IsCJKCompatibility", "IsCJKUnifiedIdeographsExtensionA", "IsYijingHexagramSymbols", "IsCJKUnifiedIdeographs", "IsYiSyllables", "IsYiRadicals", "IsHangulSyllables", "IsHighSurrogates", "IsHighPrivateUseSurrogates", "IsLowSurrogates", "IsPrivateUse or IsPrivateUseArea", "IsCJKCompatibilityIdeographs", "IsAlphabeticPresentationForms", "IsArabicPresentationForms-A", "IsVariationSelectors", "IsCombiningHalfMarks", "IsCJKCompatibilityForms", "IsSmallFormVariants", "IsArabicPresentationForms-B", "IsHalfwidthandFullwidthForms", "IsSpecials"],
            _controlChars: ["@", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "[", "\\", "]", "^", "_"],

            tokenTypes: {
                literal: 0,

                escChar: 110,
                escCharOctal: 111,
                escCharHex: 112,
                escCharCtrl: 113,
                escCharUnicode: 114,
                escCharOther: 115,

                escCharClass: 120,
                escCharClassCategory: 121,
                escCharClassBlock: 122,
                escCharClassDot: 123,

                escAnchor: 130,

                escBackrefNumber: 140,
                escBackrefName: 141,

                charGroup: 200,
                charNegativeGroup: 201,
                charInterval: 202,

                anchor: 300,

                group: 400,
                groupImnsx: 401,
                groupImnsxMisc: 402,

                groupConstruct: 403,
                groupConstructName: 404,
                groupConstructImnsx: 405,
                groupConstructImnsxMisc: 406,

                quantifier: 500,
                quantifierN: 501,
                quantifierNM: 502,

                alternation: 600,
                alternationGroup: 601,
                alternationGroupCondition: 602,
                alternationGroupRefNumberCondition: 603,
                alternationGroupRefNameCondition: 604,

                commentInline: 700,
                commentXMode: 701
            },

            parsePattern: function (pattern, settings) {
                var scope = System.Text.RegularExpressions.RegexEngineParser;

                // Parse tokens in the original pattern:
                var tokens = scope._parsePatternImpl(pattern, settings, 0, pattern.length);

                // Collect and fill group descriptors into Group tokens.
                // We need do it before any token modification.
                var groups = [];
                scope._fillGroupDescriptors(tokens, groups);

                // Fill Sparse Info:
                var sparseSettings = scope._getGroupSparseInfo(groups);

                // Fill balancing info for the groups with "name2":
                scope._fillBalancingGroupInfo(groups, sparseSettings);

                // Transform tokens for usage in JS RegExp:
                scope._preTransformBackrefTokens(pattern, tokens, sparseSettings);
                scope._transformRawTokens(settings, tokens, sparseSettings, [], [], 0);

                // Update group descriptors as tokens have been transformed (at least indexes were changed):
                scope._updateGroupDescriptors(tokens);

                var result = {
                    groups: groups,
                    sparseSettings: sparseSettings,
                    isContiguous: settings.isContiguous || false,
                    shouldFail: settings.shouldFail || false,
                    tokens: tokens
                };

                return result;
            },

            _transformRawTokens: function (settings, tokens, sparseSettings, allowedPackedSlotIds, nestedGroupIds, nestingLevel) {
                var scope = System.Text.RegularExpressions.RegexEngineParser;
                var tokenTypes = scope.tokenTypes;
                var prevToken;
                var token;
                var value;
                var packedSlotId;
                var groupNumber;
                var matchRes;
                var localNestedGroupIds;
                var localSettings;
                var qtoken;
                var i;

                // Transform/adjust tokens collection to work with JS RegExp:
                for (i = 0; i < tokens.length; i++) {
                    token = tokens[i];

                    if (i < tokens.length - 1) {
                        qtoken = tokens[i + 1];

                        switch (qtoken.type) {
                            case tokenTypes.quantifier:
                            case tokenTypes.quantifierN:
                            case tokenTypes.quantifierNM:
                                token.qtoken = qtoken;
                                tokens.splice(i + 1, 1);
                                --i;
                        }
                    }

                    if (token.type === tokenTypes.escBackrefNumber) {
                        groupNumber = token.data.number;
                        packedSlotId = sparseSettings.getPackedSlotIdBySlotNumber(groupNumber);

                        if (packedSlotId == null) {
                            throw new System.ArgumentException.$ctor1("Reference to undefined group number " + groupNumber.toString() + ".");
                        }

                        if (allowedPackedSlotIds.indexOf(packedSlotId) < 0) {
                            settings.shouldFail = true; // Backreferences to unreachable group number lead to an empty match.

                            continue;
                        }

                        token.data.slotId = packedSlotId;
                    } else if (token.type === tokenTypes.escBackrefName) {
                        value = token.data.name;
                        packedSlotId = sparseSettings.getPackedSlotIdBySlotName(value);

                        if (packedSlotId == null) {
                            // TODO: Move this code to earlier stages
                            // If the name is number, treat the backreference as a numbered:
                            matchRes = scope._matchChars(value, 0, value.length, scope._decSymbols);

                            if (matchRes.matchLength === value.length) {
                                value = "\\" + value;
                                scope._updatePatternToken(token, tokenTypes.escBackrefNumber, token.index, value.length, value);
                                --i; // process the token again

                                continue;
                            }

                            throw new System.ArgumentException.$ctor1("Reference to undefined group name '" + value + "'.");
                        }

                        if (allowedPackedSlotIds.indexOf(packedSlotId) < 0) {
                            settings.shouldFail = true; // Backreferences to unreachable group number lead to an empty match.

                            continue;
                        }

                        token.data.slotId = packedSlotId;
                    } else if (token.type === tokenTypes.anchor || token.type === tokenTypes.escAnchor) {
                        if (token.value === "\\G") {
                            if (nestingLevel === 0 && i === 0) {
                                settings.isContiguous = true;
                            } else {
                                settings.shouldFail = true;
                            }

                            tokens.splice(i, 1);
                            --i;

                            continue;
                        }
                    } else if (token.type === tokenTypes.commentInline || token.type === tokenTypes.commentXMode) {
                        // We can safely remove comments from the pattern
                        tokens.splice(i, 1);
                        --i;

                        continue;
                    } else if (token.type === tokenTypes.literal) {
                        // Combine literal tokens for better performance:
                        if (i > 0 && !token.qtoken) {
                            prevToken = tokens[i - 1];

                            if (prevToken.type === tokenTypes.literal && !prevToken.qtoken) {
                                prevToken.value += token.value;
                                prevToken.length += token.length;

                                tokens.splice(i, 1);
                                --i;

                                continue;
                            }
                        }
                    } else if (token.type === tokenTypes.alternationGroupCondition) {
                        if (token.data != null) {
                            if (token.data.number != null) {
                                packedSlotId = sparseSettings.getPackedSlotIdBySlotNumber(token.data.number);

                                if (packedSlotId == null) {
                                    throw new System.ArgumentException.$ctor1("Reference to undefined group number " + value + ".");
                                }

                                token.data.packedSlotId = packedSlotId;
                                scope._updatePatternToken(token, tokenTypes.alternationGroupRefNumberCondition, token.index, token.length, token.value);
                            } else {
                                packedSlotId = sparseSettings.getPackedSlotIdBySlotName(token.data.name);

                                if (packedSlotId != null) {
                                    token.data.packedSlotId = packedSlotId;
                                    scope._updatePatternToken(token, tokenTypes.alternationGroupRefNameCondition, token.index, token.length, token.value);
                                } else {
                                    delete token.data;
                                }
                            }
                        }
                    }

                    // Update children tokens:
                    if (token.children && token.children.length) {
                        localNestedGroupIds = token.type === tokenTypes.group ? [token.group.rawIndex] : [];
                        localNestedGroupIds = localNestedGroupIds.concat(nestedGroupIds);

                        localSettings = token.localSettings || settings;
                        scope._transformRawTokens(localSettings, token.children, sparseSettings, allowedPackedSlotIds, localNestedGroupIds, nestingLevel + 1);
                        settings.shouldFail = settings.shouldFail || localSettings.shouldFail;
                        settings.isContiguous = settings.isContiguous || localSettings.isContiguous;
                    }

                    // Group is processed. Now it can be referenced with Backref:
                    if (token.type === tokenTypes.group) {
                        allowedPackedSlotIds.push(token.group.packedSlotId);
                    }
                }
            },

            _fillGroupDescriptors: function (tokens, groups) {
                var scope = System.Text.RegularExpressions.RegexEngineParser;
                var group;
                var i;

                // Fill group structure:
                scope._fillGroupStructure(groups, tokens, null);

                // Assign name or id:
                var groupId = 1;

                for (i = 0; i < groups.length; i++) {
                    group = groups[i];

                    if (group.constructs.name1 != null) {
                        group.name = group.constructs.name1;
                        group.hasName = true;
                    } else {
                        group.hasName = false;
                        group.name = groupId.toString();
                        ++groupId;
                    }
                }
            },

            _fillGroupStructure: function (groups, tokens, parentGroup) {
                var scope = System.Text.RegularExpressions.RegexEngineParser;
                var tokenTypes = scope.tokenTypes;
                var group;
                var token;
                var constructs;
                var constructCandidateToken;
                var hasChildren;
                var i;

                for (i = 0; i < tokens.length; i++) {
                    token = tokens[i];
                    hasChildren = token.children && token.children.length;

                    if (token.type === tokenTypes.group || token.type === tokenTypes.groupImnsx || token.type === tokenTypes.groupImnsxMisc) {
                        group = {
                            rawIndex: groups.length + 1,
                            number: -1,

                            parentGroup: null,
                            innerGroups: [],

                            name: null,
                            hasName: false,

                            constructs: null,
                            quantifier: null,

                            exprIndex: -1,
                            exprLength: 0,
                            expr: null,
                            exprFull: null
                        };

                        token.group = group;

                        if (token.type === tokenTypes.group) {
                            groups.push(group);

                            if (parentGroup != null) {
                                token.group.parentGroup = parentGroup;
                                parentGroup.innerGroups.push(group);
                            }
                        }

                        // fill group constructs:
                        constructCandidateToken = hasChildren ? token.children[0] : null;
                        group.constructs = scope._fillGroupConstructs(constructCandidateToken);
                        constructs = group.constructs;

                        if (token.isNonCapturingExplicit) {
                            delete token.isNonCapturingExplicit;
                            constructs.isNonCapturingExplicit = true;
                        }

                        if (token.isEmptyCapturing) {
                            delete token.isEmptyCapturing;
                            constructs.emptyCapture = true;
                        }

                        constructs.skipCapture =
                            constructs.isNonCapturing ||
                            constructs.isNonCapturingExplicit ||
                            constructs.isNonbacktracking ||
                            constructs.isPositiveLookahead ||
                            constructs.isNegativeLookahead ||
                            constructs.isPositiveLookbehind ||
                            constructs.isNegativeLookbehind ||
                            (constructs.name1 == null && constructs.name2 != null);
                    }

                    // fill group descriptors for inner tokens:
                    if (hasChildren) {
                        scope._fillGroupStructure(groups, token.children, token.group);
                    }
                }
            },

            _getGroupSparseInfo: function (groups) {
                var scope = System.Text.RegularExpressions.RegexEngineParser;

                var explNumberedGroups = {};
                var explNumberedGroupKeys = [];
                var explNamedGroups = {};
                var explGroups;

                var numberedGroups;
                var slotNumber;
                var slotName;
                var group;
                var i;
                var j;

                var sparseSlotMap = { 0: 0 };
                sparseSlotMap.lastSlot = 0;

                var sparseSlotNameMap = { "0": 0 };
                sparseSlotNameMap.keys = ["0"];

                // Fill Explicit Numbers:
                for (i = 0; i < groups.length; i++) {
                    group = groups[i];

                    if (group.constructs.skipCapture) {
                        continue;
                    }

                    if (group.constructs.isNumberName1) {
                        slotNumber = parseInt(group.constructs.name1);
                        explNumberedGroupKeys.push(slotNumber);

                        if (explNumberedGroups[slotNumber]) {
                            explNumberedGroups[slotNumber].push(group);
                        } else {
                            explNumberedGroups[slotNumber] = [group];
                        }
                    } else {
                        slotName = group.constructs.name1;

                        if (explNamedGroups[slotName]) {
                            explNamedGroups[slotName].push(group);
                        } else {
                            explNamedGroups[slotName] = [group];
                        }
                    }
                }

                // Sort explicitly set Number names:
                var sortNum = function (a, b) {
                    return a - b;
                };

                explNumberedGroupKeys.sort(sortNum);

                // Add group without names first (emptyCapture = false first, than emptyCapture = true):
                var allowEmptyCapture = false;

                for (j = 0; j < 2; j++) {
                    for (i = 0; i < groups.length; i++) {
                        group = groups[i];

                        if (group.constructs.skipCapture) {
                            continue;
                        }

                        if ((group.constructs.emptyCapture === true) !== allowEmptyCapture) {
                            continue;
                        }

                        slotNumber = sparseSlotNameMap.keys.length;

                        if (!group.hasName) {
                            numberedGroups = [group];
                            explGroups = explNumberedGroups[slotNumber];

                            if (explGroups != null) {
                                numberedGroups = numberedGroups.concat(explGroups);
                                explNumberedGroups[slotNumber] = null;
                            }

                            scope._addSparseSlotForSameNamedGroups(numberedGroups, slotNumber, sparseSlotMap, sparseSlotNameMap);
                        }
                    }
                    allowEmptyCapture = true;
                }

                // Then add named groups:
                for (i = 0; i < groups.length; i++) {
                    group = groups[i];

                    if (group.constructs.skipCapture) {
                        continue;
                    }

                    if (!group.hasName || group.constructs.isNumberName1) {
                        continue;
                    }

                    // If the slot is already occupied by an explicitly numbered group,
                    // add this group to the slot:
                    slotNumber = sparseSlotNameMap.keys.length;
                    explGroups = explNumberedGroups[slotNumber];

                    while (explGroups != null) {
                        scope._addSparseSlotForSameNamedGroups(explGroups, slotNumber, sparseSlotMap, sparseSlotNameMap);

                        explNumberedGroups[slotNumber] = null; // Group is processed.
                        slotNumber = sparseSlotNameMap.keys.length;
                        explGroups = explNumberedGroups[slotNumber];
                    }

                    if (!group.constructs.isNumberName1) {
                        slotNumber = sparseSlotNameMap.keys.length;
                        explGroups = explNumberedGroups[slotNumber];

                        while (explGroups != null) {
                            scope._addSparseSlotForSameNamedGroups(explGroups, slotNumber, sparseSlotMap, sparseSlotNameMap);

                            explNumberedGroups[slotNumber] = null; // Group is processed.
                            slotNumber = sparseSlotNameMap.keys.length;
                            explGroups = explNumberedGroups[slotNumber];
                        }
                    }

                    // Add the named group(s) to the 1st free slot:
                    slotName = group.constructs.name1;
                    explGroups = explNamedGroups[slotName];

                    if (explGroups != null) {
                        scope._addSparseSlotForSameNamedGroups(explGroups, slotNumber, sparseSlotMap, sparseSlotNameMap);
                        explNamedGroups[slotName] = null;  // Group is processed.
                    }
                }

                // Add the rest explicitly numbered groups:
                for (i = 0; i < explNumberedGroupKeys.length; i++) {
                    slotNumber = explNumberedGroupKeys[i];
                    explGroups = explNumberedGroups[slotNumber];

                    if (explGroups != null) {
                        scope._addSparseSlotForSameNamedGroups(explGroups, slotNumber, sparseSlotMap, sparseSlotNameMap);

                        explNumberedGroups[slotNumber] = null; // Group is processed.
                    }
                }

                return {
                    isSparse: sparseSlotMap.isSparse || false, //sparseSlotNumbers.length !== (1 + sparseSlotNumbers[sparseSlotNumbers.length - 1]),
                    sparseSlotMap: sparseSlotMap,           // <SlotNumber, PackedSlotId>
                    sparseSlotNameMap: sparseSlotNameMap,   // <SlotName, PackedSlotId>

                    getPackedSlotIdBySlotNumber: function (slotNumber) {
                        return this.sparseSlotMap[slotNumber];
                    },

                    getPackedSlotIdBySlotName: function (slotName) {
                        return this.sparseSlotNameMap[slotName];
                    }
                };
            },

            _addSparseSlot: function (group, slotNumber, sparseSlotMap, sparseSlotNameMap) {
                var packedSlotId = sparseSlotNameMap.keys.length; // 0-based index. Raw Slot number, 0,1..n (without gaps)

                group.packedSlotId = packedSlotId;

                sparseSlotMap[slotNumber] = packedSlotId;
                sparseSlotNameMap[group.name] = packedSlotId;
                sparseSlotNameMap.keys.push(group.name);

                if (!sparseSlotMap.isSparse && ((slotNumber - sparseSlotMap.lastSlot) > 1)) {
                    sparseSlotMap.isSparse = true;
                }

                sparseSlotMap.lastSlot = slotNumber;
            },

            _addSparseSlotForSameNamedGroups: function (groups, slotNumber, sparseSlotMap, sparseSlotNameMap) {
                var scope = System.Text.RegularExpressions.RegexEngineParser;
                var i;

                scope._addSparseSlot(groups[0], slotNumber, sparseSlotMap, sparseSlotNameMap);
                var sparseSlotId = groups[0].sparseSlotId;
                var packedSlotId = groups[0].packedSlotId;

                // Assign SlotID for all expl. named groups in this slot.
                if (groups.length > 1) {
                    for (i = 1; i < groups.length; i++) {
                        groups[i].sparseSlotId = sparseSlotId;
                        groups[i].packedSlotId = packedSlotId;
                    }
                }
            },

            _fillGroupConstructs: function (childToken) {
                var scope = System.Text.RegularExpressions.RegexEngineParser;
                var tokenTypes = scope.tokenTypes;
                var constructs = {
                    name1: null,
                    name2: null,

                    isNumberName1: false,
                    isNumberName2: false,

                    isNonCapturing: false,
                    isNonCapturingExplicit: false,

                    isIgnoreCase: null,
                    isMultiline: null,
                    isExplicitCapture: null,
                    isSingleLine: null,
                    isIgnoreWhitespace: null,

                    isPositiveLookahead: false,
                    isNegativeLookahead: false,
                    isPositiveLookbehind: false,
                    isNegativeLookbehind: false,

                    isNonbacktracking: false
                };

                if (childToken == null) {
                    return constructs;
                }

                if (childToken.type === tokenTypes.groupConstruct) {
                    // ?:
                    // ?=
                    // ?!
                    // ?<=
                    // ?<!
                    // ?>

                    switch (childToken.value) {
                        case "?:":
                            constructs.isNonCapturing = true;
                            break;

                        case "?=":
                            constructs.isPositiveLookahead = true;
                            break;

                        case "?!":
                            constructs.isNegativeLookahead = true;
                            break;

                        case "?>":
                            constructs.isNonbacktracking = true;
                            break;

                        case "?<=":
                            constructs.isPositiveLookbehind = true;
                            break;

                        case "?<!":
                            constructs.isNegativeLookbehind = true;
                            break;

                        default:
                            throw new System.ArgumentException.$ctor1("Unrecognized grouping construct.");
                    }
                } else if (childToken.type === tokenTypes.groupConstructName) {
                    // ?<name1>
                    // ?'name1'
                    // ?<name1-name2>
                    // ?'name1-name2'

                    var nameExpr = childToken.value.slice(2, childToken.length - 1);
                    var groupNames = nameExpr.split("-");

                    if (groupNames.length === 0 || groupNames.length > 2) {
                        throw new System.ArgumentException.$ctor1("Invalid group name.");
                    }

                    if (groupNames[0].length) {
                        constructs.name1 = groupNames[0];

                        var nameRes1 = scope._validateGroupName(groupNames[0]);

                        constructs.isNumberName1 = nameRes1.isNumberName;
                    }

                    if (groupNames.length === 2) {
                        constructs.name2 = groupNames[1];

                        var nameRes2 = scope._validateGroupName(groupNames[1]);

                        constructs.isNumberName2 = nameRes2.isNumberName;
                    }
                } else if (childToken.type === tokenTypes.groupConstructImnsx || childToken.type === tokenTypes.groupConstructImnsxMisc) {
                    // ?imnsx-imnsx:
                    var imnsxPostfixLen = childToken.type === tokenTypes.groupConstructImnsx ? 1 : 0;
                    var imnsxExprLen = childToken.length - 1 - imnsxPostfixLen; // - prefix - postfix
                    var imnsxVal = true;
                    var ch;
                    var i;

                    for (i = 1; i <= imnsxExprLen; i++) {
                        ch = childToken.value[i];

                        if (ch === "-") {
                            imnsxVal = false;
                        } else if (ch === "i") {
                            constructs.isIgnoreCase = imnsxVal;
                        } else if (ch === "m") {
                            constructs.isMultiline = imnsxVal;
                        } else if (ch === "n") {
                            constructs.isExplicitCapture = imnsxVal;
                        } else if (ch === "s") {
                            constructs.isSingleLine = imnsxVal;
                        } else if (ch === "x") {
                            constructs.isIgnoreWhitespace = imnsxVal;
                        }
                    }
                }

                return constructs;
            },

            _validateGroupName: function (name) {
                if (!name || !name.length) {
                    throw new System.ArgumentException.$ctor1("Invalid group name: Group names must begin with a word character.");
                }

                var isDigit = name[0] >= "0" && name[0] <= "9";

                if (isDigit) {
                    var scope = System.Text.RegularExpressions.RegexEngineParser;
                    var res = scope._matchChars(name, 0, name.length, scope._decSymbols);

                    if (res.matchLength !== name.length) {
                        throw new System.ArgumentException.$ctor1("Invalid group name: Group names must begin with a word character.");
                    }
                }

                return {
                    isNumberName: isDigit
                };
            },

            _fillBalancingGroupInfo: function (groups, sparseSettings) {
                var group;
                var i;

                // Assign name or id:
                for (i = 0; i < groups.length; i++) {
                    group = groups[i];

                    if (group.constructs.name2 != null) {
                        group.isBalancing = true;

                        group.balancingSlotId = sparseSettings.getPackedSlotIdBySlotName(group.constructs.name2);

                        if (group.balancingSlotId == null) {
                            throw new System.ArgumentException.$ctor1("Reference to undefined group name '" + group.constructs.name2 + "'.");
                        }
                    }
                }
            },

            _preTransformBackrefTokens: function (pattern, tokens, sparseSettings) {
                var scope = System.Text.RegularExpressions.RegexEngineParser;
                var tokenTypes = scope.tokenTypes;

                var groupNumber;
                var octalCharToken;
                var extraLength;
                var literalToken;
                var token;
                var i;

                for (i = 0; i < tokens.length; i++) {
                    token = tokens[i];

                    if (token.type === tokenTypes.escBackrefNumber) {
                        groupNumber = token.data.number;

                        if (groupNumber >= 1 && sparseSettings.getPackedSlotIdBySlotNumber(groupNumber) != null) {
                            // Expressions from \10 and greater are considered backreferences
                            // if there is a group corresponding to that number;
                            // otherwise, they are interpreted as octal codes.
                            continue; // validated
                        }

                        if (groupNumber <= 9) {
                            // The expressions \1 through \9 are always interpreted as backreferences, and not as octal codes.
                            throw new System.ArgumentException.$ctor1("Reference to undefined group number " + groupNumber.toString() + ".");
                        }

                        // Otherwise, transform the token to OctalNumber:
                        octalCharToken = scope._parseOctalCharToken(token.value, 0, token.length);

                        if (octalCharToken == null) {
                            throw new System.ArgumentException.$ctor1("Unrecognized escape sequence " + token.value.slice(0, 2) + ".");
                        }

                        extraLength = token.length - octalCharToken.length;
                        scope._modifyPatternToken(token, pattern, tokenTypes.escCharOctal, null, octalCharToken.length);
                        token.data = octalCharToken.data;

                        if (extraLength > 0) {
                            literalToken = scope._createPatternToken(pattern, tokenTypes.literal, token.index + token.length, extraLength);
                            tokens.splice(i + 1, 0, literalToken);
                        }
                    }

                    if (token.children && token.children.length) {
                        scope._preTransformBackrefTokens(pattern, token.children, sparseSettings);
                    }
                }
            },

            _updateGroupDescriptors: function (tokens, parentIndex) {
                var scope = System.Text.RegularExpressions.RegexEngineParser;
                var tokenTypes = scope.tokenTypes;
                var group;
                var token;
                var quantCandidateToken;
                var childrenValue;
                var childrenIndex;
                var i;

                var index = parentIndex || 0;

                for (i = 0; i < tokens.length; i++) {
                    token = tokens[i];
                    token.index = index;

                    // Calculate children indexes/lengths to update parent length:
                    if (token.children) {
                        childrenIndex = token.childrenPostfix.length;
                        scope._updateGroupDescriptors(token.children, index + childrenIndex);

                        // Update parent value if children have been changed:
                        childrenValue = scope._constructPattern(token.children);
                        token.value = token.childrenPrefix + childrenValue + token.childrenPostfix;
                        token.length = token.value.length;
                    }

                    // Update group information:
                    if (token.type === tokenTypes.group && token.group) {
                        group = token.group;
                        group.exprIndex = token.index;
                        group.exprLength = token.length;

                        if (i + 1 < tokens.length) {
                            quantCandidateToken = tokens[i + 1];

                            if (quantCandidateToken.type === tokenTypes.quantifier ||
                                quantCandidateToken.type === tokenTypes.quantifierN ||
                                quantCandidateToken.type === tokenTypes.quantifierNM) {
                                group.quantifier = quantCandidateToken.value;
                            }
                        }

                        group.expr = token.value;
                        group.exprFull = group.expr + (group.quantifier != null ? group.quantifier : "");
                    }

                    // Update current index:
                    index += token.length;
                }
            },

            _constructPattern: function (tokens) {
                var pattern = "";
                var token;
                var i;

                for (i = 0; i < tokens.length; i++) {
                    token = tokens[i];
                    pattern += token.value;
                }

                return pattern;
            },

            _parsePatternImpl: function (pattern, settings, startIndex, endIndex) {
                if (pattern == null) {
                    throw new System.ArgumentNullException.$ctor1("pattern");
                }

                if (startIndex < 0 || startIndex > pattern.length) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("startIndex");
                }

                if (endIndex < startIndex || endIndex > pattern.length) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("endIndex");
                }

                var scope = System.Text.RegularExpressions.RegexEngineParser;
                var tokenTypes = scope.tokenTypes;
                var tokens = [];
                var token;
                var ch;
                var i;

                i = startIndex;

                while (i < endIndex) {
                    ch = pattern[i];

                    // Ignore whitespaces (if it was requested):
                    if (settings.ignoreWhitespace && scope._whiteSpaceChars.indexOf(ch) >= 0) {
                        ++i;

                        continue;
                    }

                    if (ch === ".") {
                        token = scope._parseDotToken(pattern, i, endIndex);
                    } else if (ch === "\\") {
                        token = scope._parseEscapeToken(pattern, i, endIndex);
                    } else if (ch === "[") {
                        token = scope._parseCharRangeToken(pattern, i, endIndex);
                    } else if (ch === "^" || ch === "$") {
                        token = scope._parseAnchorToken(pattern, i);
                    } else if (ch === "(") {
                        token = scope._parseGroupToken(pattern, settings, i, endIndex);
                    } else if (ch === "|") {
                        token = scope._parseAlternationToken(pattern, i);
                    } else if (ch === "#" && settings.ignoreWhitespace) {
                        token = scope._parseXModeCommentToken(pattern, i, endIndex);
                    } else {
                        token = scope._parseQuantifierToken(pattern, i, endIndex);
                    }

                    if (token == null) {
                        token = scope._createPatternToken(pattern, tokenTypes.literal, i, 1);
                    }

                    if (token != null) {
                        tokens.push(token);
                        i += token.length;
                    }
                }

                return tokens;
            },

            _parseEscapeToken: function (pattern, i, endIndex) {
                var scope = System.Text.RegularExpressions.RegexEngineParser;
                var tokenTypes = scope.tokenTypes;

                var ch = pattern[i];

                if (ch !== "\\") {
                    return null;
                }

                if (i + 1 >= endIndex) {
                    throw new System.ArgumentException.$ctor1("Illegal \\ at end of pattern.");
                }

                ch = pattern[i + 1];

                // Parse a sequence for a numbered reference ("Backreference Constructs")
                if (ch >= "1" && ch <= "9") {
                    // check if the number is a group backreference
                    var groupDigits = scope._matchChars(pattern, i + 1, endIndex, scope._decSymbols, 3); // assume: there are not more than 999 groups
                    var backrefNumberToken = scope._createPatternToken(pattern, tokenTypes.escBackrefNumber, i, 1 + groupDigits.matchLength); // "\nnn"

                    backrefNumberToken.data = { number: parseInt(groupDigits.match, 10) };

                    return backrefNumberToken;
                }

                // Parse a sequence for "Anchors"
                if (scope._escapedAnchors.indexOf(ch) >= 0) {
                    return scope._createPatternToken(pattern, tokenTypes.escAnchor, i, 2); // "\A" or "\Z" or "\z" or "\G" or "\b" or "\B"
                }

                // Parse a sequence for "Character Escapes" or "Character Classes"
                var escapedCharToken = scope._parseEscapedChar(pattern, i, endIndex);

                if (escapedCharToken != null) {
                    return escapedCharToken;
                }

                // Parse a sequence for a named backreference ("Backreference Constructs")
                if (ch === "k") {
                    if (i + 2 < endIndex) {
                        var nameQuoteCh = pattern[i + 2];

                        if (nameQuoteCh === "'" || nameQuoteCh === "<") {
                            var closingCh = nameQuoteCh === "<" ? ">" : "'";
                            var refNameChars = scope._matchUntil(pattern, i + 3, endIndex, closingCh);

                            if (refNameChars.unmatchLength === 1 && refNameChars.matchLength > 0) {
                                var backrefNameToken = scope._createPatternToken(pattern, tokenTypes.escBackrefName, i, 3 + refNameChars.matchLength + 1); // "\k<Name>" or "\k'Name'"

                                backrefNameToken.data = { name: refNameChars.match };

                                return backrefNameToken;
                            }
                        }
                    }

                    throw new System.ArgumentException.$ctor1("Malformed \\k<...> named back reference.");
                }

                // Temp fix (until IsWordChar is not supported):
                // See more: https://referencesource.microsoft.com/#System/regex/system/text/regularexpressions/RegexParser.cs,1414
                // Unescaping of any of the following ASCII characters results in the character itself
                var code = ch.charCodeAt(0);

                if ((code >= 0 && code < 48) ||
                    (code > 57 && code < 65) ||
                    (code > 90 && code < 95) ||
                    (code === 96) ||
                    (code > 122 && code < 128)) {
                    var token = scope._createPatternToken(pattern, tokenTypes.escChar, i, 2);

                    token.data = { n: code, ch: ch };

                    return token;
                }

                // Unrecognized escape sequence:
                throw new System.ArgumentException.$ctor1("Unrecognized escape sequence \\" + ch + ".");
            },

            _parseOctalCharToken: function (pattern, i, endIndex) {
                var scope = System.Text.RegularExpressions.RegexEngineParser;
                var tokenTypes = scope.tokenTypes;

                var ch = pattern[i];

                if (ch === "\\" && i + 1 < endIndex) {
                    ch = pattern[i + 1];

                    if (ch >= "0" && ch <= "7") {
                        var octalDigits = scope._matchChars(pattern, i + 1, endIndex, scope._octSymbols, 3);
                        var octalVal = parseInt(octalDigits.match, 8);
                        var token = scope._createPatternToken(pattern, tokenTypes.escCharOctal, i, 1 + octalDigits.matchLength); // "\0" or "\nn" or "\nnn"

                        token.data = { n: octalVal, ch: String.fromCharCode(octalVal) };

                        return token;
                    }
                }

                return null;
            },

            _parseEscapedChar: function (pattern, i, endIndex) {
                var scope = System.Text.RegularExpressions.RegexEngineParser;
                var tokenTypes = scope.tokenTypes;
                var token;

                var ch = pattern[i];

                if (ch !== "\\" || i + 1 >= endIndex) {
                    return null;
                }

                ch = pattern[i + 1];

                // Parse a sequence for "Character Escapes"
                if (scope._escapedChars.indexOf(ch) >= 0) {
                    if (ch === "x") {
                        var hexDigits = scope._matchChars(pattern, i + 2, endIndex, scope._hexSymbols, 2);

                        if (hexDigits.matchLength !== 2) {
                            throw new System.ArgumentException.$ctor1("Insufficient hexadecimal digits.");
                        }

                        var hexVal = parseInt(hexDigits.match, 16);

                        token = scope._createPatternToken(pattern, tokenTypes.escCharHex, i, 4); // "\xnn"
                        token.data = { n: hexVal, ch: String.fromCharCode(hexVal) };

                        return token;
                    } else if (ch === "c") {
                        if (i + 2 >= endIndex) {
                            throw new System.ArgumentException.$ctor1("Missing control character.");
                        }

                        var ctrlCh = pattern[i + 2];

                        ctrlCh = ctrlCh.toUpperCase();

                        var ctrlIndex = this._controlChars.indexOf(ctrlCh);

                        if (ctrlIndex >= 0) {
                            token = scope._createPatternToken(pattern, tokenTypes.escCharCtrl, i, 3); // "\cx" or "\cX"
                            token.data = { n: ctrlIndex, ch: String.fromCharCode(ctrlIndex) };

                            return token;
                        }

                        throw new System.ArgumentException.$ctor1("Unrecognized control character.");
                    } else if (ch === "u") {
                        var ucodeDigits = scope._matchChars(pattern, i + 2, endIndex, scope._hexSymbols, 4);

                        if (ucodeDigits.matchLength !== 4) {
                            throw new System.ArgumentException.$ctor1("Insufficient hexadecimal digits.");
                        }

                        var ucodeVal = parseInt(ucodeDigits.match, 16);

                        token = scope._createPatternToken(pattern, tokenTypes.escCharUnicode, i, 6); // "\unnnn"
                        token.data = { n: ucodeVal, ch: String.fromCharCode(ucodeVal) };

                        return token;
                    }

                    token = scope._createPatternToken(pattern, tokenTypes.escChar, i, 2); // "\a" or "\b" or "\t" or "\r" or "\v" or "f" or "n" or "e"-

                    var escVal;

                    switch (ch) {
                        case "a":
                            escVal = 7;
                            break;
                        case "b":
                            escVal = 8;
                            break;
                        case "t":
                            escVal = 9;
                            break;
                        case "r":
                            escVal = 13;
                            break;
                        case "v":
                            escVal = 11;
                            break;
                        case "f":
                            escVal = 12;
                            break;
                        case "n":
                            escVal = 10;
                            break;
                        case "e":
                            escVal = 27;
                            break;

                        default:
                            throw new System.ArgumentException.$ctor1("Unexpected escaped char: '" + ch + "'.");
                    }

                    token.data = { n: escVal, ch: String.fromCharCode(escVal) };

                    return token;
                }

                // Parse a sequence for an octal character("Character Escapes")
                if (ch >= "0" && ch <= "7") {
                    var octalCharToken = scope._parseOctalCharToken(pattern, i, endIndex);

                    return octalCharToken;
                }

                // Parse a sequence for "Character Classes"
                if (scope._escapedCharClasses.indexOf(ch) >= 0) {
                    if (ch === "p" || ch === "P") {
                        var catNameChars = scope._matchUntil(pattern, i + 2, endIndex, "}"); // the longest category name is 37 + 2 brackets, but .NET does not limit the value on this step

                        if (catNameChars.matchLength < 2 || catNameChars.match[0] !== "{" || catNameChars.unmatchLength !== 1) {
                            throw new System.ArgumentException.$ctor1("Incomplete \p{X} character escape.");
                        }

                        var catName = catNameChars.match.slice(1);

                        if (scope._unicodeCategories.indexOf(catName) >= 0) {
                            return scope._createPatternToken(pattern, tokenTypes.escCharClassCategory, i, 2 + catNameChars.matchLength + 1); // "\p{Name}" or "\P{Name}"
                        }

                        if (scope._namedCharBlocks.indexOf(catName) >= 0) {
                            return scope._createPatternToken(pattern, tokenTypes.escCharClassBlock, i, 2 + catNameChars.matchLength + 1); // "\p{Name}" or "\P{Name}"
                        }

                        throw new System.ArgumentException.$ctor1("Unknown property '" + catName + "'.");
                    }

                    return scope._createPatternToken(pattern, tokenTypes.escCharClass, i, 2); // "\w" or "\W" or "\s" or "\S" or "\d" or "\D"
                }

                // Some other literal
                if (scope._escapedSpecialSymbols.indexOf(ch) >= 0) {
                    token = scope._createPatternToken(pattern, tokenTypes.escCharOther, i, 2); // "\." or "\$" or ... "\\"
                    token.data = { n: ch.charCodeAt(0), ch: ch };
                    return token;
                }

                return null;
            },

            _parseCharRangeToken: function (pattern, i, endIndex) {
                var scope = System.Text.RegularExpressions.RegexEngineParser;
                var tokenTypes = scope.tokenTypes;
                var tokens = [];
                var intervalToken;
                var substractToken;
                var token;
                var isNegative = false;
                var noMoreTokenAllowed = false;
                var hasSubstractToken = false;

                var ch = pattern[i];

                if (ch !== "[") {
                    return null;
                }

                var index = i + 1;
                var closeBracketIndex = -1;
                var toInc;

                if (index < endIndex && pattern[index] === "^") {
                    isNegative = true;
                    index ++;
                }

                var startIndex = index;

                while (index < endIndex) {
                    ch = pattern[index];

                    noMoreTokenAllowed = hasSubstractToken;

                    if (ch === "-" && index + 1 < endIndex && pattern[index + 1] === "[") {
                        substractToken = scope._parseCharRangeToken(pattern, index + 1, endIndex);
                        substractToken.childrenPrefix = "-" + substractToken.childrenPrefix;
                        substractToken.length ++;
                        token = substractToken;
                        toInc = substractToken.length;
                        hasSubstractToken = true;
                    } else if (ch === "\\") {
                        token = scope._parseEscapedChar(pattern, index, endIndex);

                        if (token == null) {
                            throw new System.ArgumentException.$ctor1("Unrecognized escape sequence \\" + ch + ".");
                        }
                        toInc = token.length;
                    } else if (ch === "]" && index > startIndex) {
                        closeBracketIndex = index;

                        break;
                    } else {
                        token = scope._createPatternToken(pattern, tokenTypes.literal, index, 1);
                        toInc = 1;
                    }

                    if (noMoreTokenAllowed) {
                        throw new System.ArgumentException.$ctor1("A subtraction must be the last element in a character class.");
                    }

                    // Check for interval:
                    if (tokens.length > 1) {
                        intervalToken = scope._parseCharIntervalToken(pattern, tokens[tokens.length - 2], tokens[tokens.length - 1], token);

                        if (intervalToken != null) {
                            tokens.pop(); //pop Dush
                            tokens.pop(); //pop Interval start
                            token = intervalToken;
                        }
                    }

                    // Add token:
                    if (token != null) {
                        tokens.push(token);
                        index += toInc;
                    }
                }

                if (closeBracketIndex < 0 || tokens.length < 1) {
                    throw new System.ArgumentException.$ctor1("Unterminated [] set.");
                }

                var groupToken;

                if (!isNegative) {
                    groupToken = scope._createPatternToken(pattern, tokenTypes.charGroup, i, 1 + closeBracketIndex - i, tokens, "[", "]");
                } else {
                    groupToken = scope._createPatternToken(pattern, tokenTypes.charNegativeGroup, i, 1 + closeBracketIndex - i, tokens, "[^", "]");
                }

                // Create full range data:
                var ranges = scope._tidyCharRange(tokens);

                groupToken.data = { ranges: ranges };

                if (substractToken != null) {
                    groupToken.data.substractToken = substractToken;
                }

                return groupToken;
            },

            _parseCharIntervalToken: function (pattern, intervalStartToken, dashToken, intervalEndToken) {
                var scope = System.Text.RegularExpressions.RegexEngineParser;
                var tokenTypes = scope.tokenTypes;

                if (dashToken.type !== tokenTypes.literal || dashToken.value !== "-") {
                    return null;
                }

                if (intervalStartToken.type !== tokenTypes.literal &&
                    intervalStartToken.type !== tokenTypes.escChar &&
                    intervalStartToken.type !== tokenTypes.escCharOctal &&
                    intervalStartToken.type !== tokenTypes.escCharHex &&
                    intervalStartToken.type !== tokenTypes.escCharCtrl &&
                    intervalStartToken.type !== tokenTypes.escCharUnicode &&
                    intervalStartToken.type !== tokenTypes.escCharOther) {
                    return null;
                }

                if (intervalEndToken.type !== tokenTypes.literal &&
                    intervalEndToken.type !== tokenTypes.escChar &&
                    intervalEndToken.type !== tokenTypes.escCharOctal &&
                    intervalEndToken.type !== tokenTypes.escCharHex &&
                    intervalEndToken.type !== tokenTypes.escCharCtrl &&
                    intervalEndToken.type !== tokenTypes.escCharUnicode &&
                    intervalEndToken.type !== tokenTypes.escCharOther) {
                    return null;
                }

                var startN;
                var startCh;

                if (intervalStartToken.type === tokenTypes.literal) {
                    startN = intervalStartToken.value.charCodeAt(0);
                    startCh = intervalStartToken.value;
                } else {
                    startN = intervalStartToken.data.n;
                    startCh = intervalStartToken.data.ch;
                }

                var endN;
                var endCh;

                if (intervalEndToken.type === tokenTypes.literal) {
                    endN = intervalEndToken.value.charCodeAt(0);
                    endCh = intervalEndToken.value;
                } else {
                    endN = intervalEndToken.data.n;
                    endCh = intervalEndToken.data.ch;
                }

                if (startN > endN) {
                    throw new System.NotSupportedException.$ctor1("[x-y] range in reverse order.");
                }

                var index = intervalStartToken.index;
                var length = intervalStartToken.length + dashToken.length + intervalEndToken.length;
                var intervalToken = scope._createPatternToken(pattern, tokenTypes.charInterval, index, length, [intervalStartToken, dashToken, intervalEndToken], "", "");

                intervalToken.data = {
                    startN: startN,
                    startCh: startCh,
                    endN: endN,
                    endCh: endCh
                };

                return intervalToken;
            },

            _tidyCharRange: function (tokens) {
                var scope = System.Text.RegularExpressions.RegexEngineParser;
                var tokenTypes = scope.tokenTypes;

                var j;
                var k;
                var n;
                var m;
                var token;
                var ranges = [];
                var classTokens = [];

                var range;
                var nextRange;
                var toSkip;

                for (j = 0; j < tokens.length; j++) {
                    token = tokens[j];

                    if (token.type === tokenTypes.literal) {
                        n = token.value.charCodeAt(0);
                        m = n;
                    } else if (token.type === tokenTypes.charInterval) {
                        n = token.data.startN;
                        m = token.data.endN;
                    } else if (token.type === tokenTypes.literal ||
                        token.type === tokenTypes.escChar ||
                        token.type === tokenTypes.escCharOctal ||
                        token.type === tokenTypes.escCharHex ||
                        token.type === tokenTypes.escCharCtrl ||
                        token.type === tokenTypes.escCharUnicode ||
                        token.type === tokenTypes.escCharOther) {
                        n = token.data.n;
                        m = n;
                    } else if (
                        token.type === tokenTypes.charGroup ||
                        token.type === tokenTypes.charNegativeGroup) {
                        continue;
                    } else {
                        classTokens.push(token);
                        continue;
                    }

                    if (ranges.length === 0) {
                        ranges.push({ n: n, m: m });
                        continue;
                    }

                    //TODO: [Performance] Use binary search
                    for (k = 0; k < ranges.length; k++) {
                        if (ranges[k].n > n) {
                            break;
                        }
                    }

                    ranges.splice(k, 0, { n: n, m: m });
                }

                // Combine ranges:
                for (j = 0; j < ranges.length; j++) {
                    range = ranges[j];

                    toSkip = 0;

                    for (k = j + 1; k < ranges.length; k++) {
                        nextRange = ranges[k];

                        if (nextRange.n > 1 + range.m) {
                            break;
                        }

                        toSkip++;

                        if (nextRange.m > range.m) {
                            range.m = nextRange.m;
                        }
                    }
                    if (toSkip > 0) {
                        ranges.splice(j + 1, toSkip);
                    }
                }

                if (classTokens.length > 0) {
                    var charClassStr = "[" + scope._constructPattern(classTokens) + "]";
                    ranges.charClassToken = scope._createPatternToken(charClassStr, tokenTypes.charGroup, 0, charClassStr.length, tokens, "[", "]");
                }

                return ranges;
            },

            _parseDotToken: function (pattern, i) {
                var scope = System.Text.RegularExpressions.RegexEngineParser;
                var tokenTypes = scope.tokenTypes;

                var ch = pattern[i];

                if (ch !== ".") {
                    return null;
                }

                return scope._createPatternToken(pattern, tokenTypes.escCharClassDot, i, 1);
            },

            _parseAnchorToken: function (pattern, i) {
                var scope = System.Text.RegularExpressions.RegexEngineParser;
                var tokenTypes = scope.tokenTypes;

                var ch = pattern[i];

                if (ch !== "^" && ch !== "$") {
                    return null;
                }

                return scope._createPatternToken(pattern, tokenTypes.anchor, i, 1);
            },

            _updateSettingsFromConstructs: function (settings, constructs) {
                if (constructs.isIgnoreWhitespace != null) {
                    settings.ignoreWhitespace = constructs.isIgnoreWhitespace;
                }

                if (constructs.isExplicitCapture != null) {
                    settings.explicitCapture = constructs.isExplicitCapture;
                }
            },

            _parseGroupToken: function (pattern, settings, i, endIndex) {
                var scope = System.Text.RegularExpressions.RegexEngineParser;
                var tokenTypes = scope.tokenTypes;
                var groupSettings = {
                    ignoreWhitespace: settings.ignoreWhitespace,
                    explicitCapture: settings.explicitCapture
                };

                var ch = pattern[i];

                if (ch !== "(") {
                    return null;
                }

                var bracketLvl = 1;
                var sqBracketCtx = false;
                var bodyIndex = i + 1;
                var closeBracketIndex = -1;

                var isComment = false;
                var isAlternation = false;
                var isInlineOptions = false;
                var isImnsxConstructed = false;
                var isNonCapturingExplicit = false;

                var grConstructs = null;

                // Parse the Group construct, if any:
                var constructToken = scope._parseGroupConstructToken(pattern, groupSettings, i + 1, endIndex);

                if (constructToken != null) {
                    grConstructs = this._fillGroupConstructs(constructToken);

                    bodyIndex += constructToken.length;

                    if (constructToken.type === tokenTypes.commentInline) {
                        isComment = true;
                    } else if (constructToken.type === tokenTypes.alternationGroupCondition) {
                        isAlternation = true;
                    } else if (constructToken.type === tokenTypes.groupConstructImnsx) {
                        this._updateSettingsFromConstructs(groupSettings, grConstructs);
                        isImnsxConstructed = true;
                    } else if (constructToken.type === tokenTypes.groupConstructImnsxMisc) {
                        this._updateSettingsFromConstructs(settings, grConstructs); // parent settings!
                        isInlineOptions = true;
                    }
                }

                if (groupSettings.explicitCapture && (grConstructs == null || grConstructs.name1 == null)) {
                    isNonCapturingExplicit = true;
                }

                var index = bodyIndex;

                while (index < endIndex) {
                    ch = pattern[index];

                    if (ch === "\\") {
                        index ++; // skip the escaped char
                    } else if (ch === "[") {
                        sqBracketCtx = true;
                    } else if (ch === "]" && sqBracketCtx) {
                        sqBracketCtx = false;
                    } else if (!sqBracketCtx) {
                        if (ch === "(" && !isComment) {
                            ++bracketLvl;
                        } else if (ch === ")") {
                            --bracketLvl;

                            if (bracketLvl === 0) {
                                closeBracketIndex = index;
                                break;
                            }
                        }
                    }

                    ++index;
                }

                var result = null;

                if (isComment) {
                    if (closeBracketIndex < 0) {
                        throw new System.ArgumentException.$ctor1("Unterminated (?#...) comment.");
                    }

                    result = scope._createPatternToken(pattern, tokenTypes.commentInline, i, 1 + closeBracketIndex - i);
                } else {
                    if (closeBracketIndex < 0) {
                        throw new System.ArgumentException.$ctor1("Not enough )'s.");
                    }

                    // Parse the "Body" of the group
                    var innerTokens = scope._parsePatternImpl(pattern, groupSettings, bodyIndex, closeBracketIndex);

                    if (constructToken != null) {
                        innerTokens.splice(0, 0, constructToken);
                    }

                    // If there is an Alternation expression, treat the group as Alternation group
                    if (isAlternation) {
                        var innerTokensLen = innerTokens.length;
                        var innerToken;
                        var j;

                        // Check that there is only 1 alternation symbol:
                        var altCount = 0;

                        for (j = 0; j < innerTokensLen; j++) {
                            innerToken = innerTokens[j];

                            if (innerToken.type === tokenTypes.alternation) {
                                ++altCount;

                                if (altCount > 1) {
                                    throw new System.ArgumentException.$ctor1("Too many | in (?()|).");
                                }
                            }
                        }

                        if (altCount === 0) {
                            // Though .NET works with this case, it ends up with unexpected result. Let's avoid this behaviour.
                            throw new System.NotSupportedException.$ctor1("Alternation group without | is not supported.");
                        }

                        var altGroupToken = scope._createPatternToken(pattern, tokenTypes.alternationGroup, i, 1 + closeBracketIndex - i, innerTokens, "(", ")");

                        result = altGroupToken;
                    } else {
                        // Create Group token:
                        var tokenType = tokenTypes.group;

                        if (isInlineOptions) {
                            tokenType = tokenTypes.groupImnsxMisc;
                        } else if (isImnsxConstructed) {
                            tokenType = tokenTypes.groupImnsx;
                        }

                        var groupToken = scope._createPatternToken(pattern, tokenType, i, 1 + closeBracketIndex - i, innerTokens, "(", ")");

                        groupToken.localSettings = groupSettings;
                        result = groupToken;
                    }
                }

                if (isNonCapturingExplicit) {
                    result.isNonCapturingExplicit = true;
                }

                return result;
            },

            _parseGroupConstructToken: function (pattern, settings, i, endIndex) {
                // ?<name1>
                // ?'name1'
                // ?<name1-name2>
                // ?'name1-name2'
                // ?:
                // ?imnsx-imnsx
                // ?=
                // ?!
                // ?<=
                // ?<!
                // ?>
                // ?#

                var scope = System.Text.RegularExpressions.RegexEngineParser;
                var tokenTypes = scope.tokenTypes;

                var ch = pattern[i];

                if (ch !== "?" || i + 1 >= endIndex) {
                    return null;
                }

                ch = pattern[i + 1];

                if (ch === ":" || ch === "=" || ch === "!" || ch === ">") {
                    return scope._createPatternToken(pattern, tokenTypes.groupConstruct, i, 2);
                }

                if (ch === "#") {
                    return scope._createPatternToken(pattern, tokenTypes.commentInline, i, 2);
                }

                if (ch === "(") {
                    return scope._parseAlternationGroupConditionToken(pattern, settings, i, endIndex);
                }

                if (ch === "<" && i + 2 < endIndex) {
                    var ch3 = pattern[i + 2];

                    if (ch3 === "=" || ch3 === "!") {
                        return scope._createPatternToken(pattern, tokenTypes.groupConstruct, i, 3);
                    }
                }

                if (ch === "<" || ch === "'") {
                    var closingCh = ch === "<" ? ">" : ch;
                    var nameChars = scope._matchUntil(pattern, i + 2, endIndex, closingCh);

                    if (nameChars.unmatchLength !== 1 || nameChars.matchLength === 0) {
                        throw new System.ArgumentException.$ctor1("Unrecognized grouping construct.");
                    }

                    var nameFirstCh = nameChars.match.slice(0, 1);

                    if ("`~@#$%^&*()+{}[]|\\/|'\";:,.?".indexOf(nameFirstCh) >= 0) {
                        // TODO: replace the "black list" of wrong characters with char class check:
                        // According to UTS#18 Unicode Regular Expressions (http://www.unicode.org/reports/tr18/)
                        // RL 1.4 Simple Word Boundaries  The class of <word_character> includes all Alphabetic
                        // values from the Unicode character database, from UnicodeData.txt [UData], plus the U+200C
                        // ZERO WIDTH NON-JOINER and U+200D ZERO WIDTH JOINER.
                        throw new System.ArgumentException.$ctor1("Invalid group name: Group names must begin with a word character.");
                    }

                    return scope._createPatternToken(pattern, tokenTypes.groupConstructName, i, 2 + nameChars.matchLength + 1);
                }

                var imnsxChars = scope._matchChars(pattern, i + 1, endIndex, "imnsx-");

                if (imnsxChars.matchLength > 0 && (imnsxChars.unmatchCh === ":" || imnsxChars.unmatchCh === ")")) {
                    var imnsxTokenType = imnsxChars.unmatchCh === ":" ? tokenTypes.groupConstructImnsx : tokenTypes.groupConstructImnsxMisc;
                    var imnsxPostfixLen = imnsxChars.unmatchCh === ":" ? 1 : 0;

                    return scope._createPatternToken(pattern, imnsxTokenType, i, 1 + imnsxChars.matchLength + imnsxPostfixLen);
                }

                throw new System.ArgumentException.$ctor1("Unrecognized grouping construct.");
            },

            _parseQuantifierToken: function (pattern, i, endIndex) {
                var scope = System.Text.RegularExpressions.RegexEngineParser;
                var tokenTypes = scope.tokenTypes;
                var token = null;

                var ch = pattern[i];

                if (ch === "*" || ch === "+" || ch === "?") {
                    token = scope._createPatternToken(pattern, tokenTypes.quantifier, i, 1);
                    token.data = { val: ch };
                } else if (ch === "{") {
                    var dec1Chars = scope._matchChars(pattern, i + 1, endIndex, scope._decSymbols);

                    if (dec1Chars.matchLength !== 0) {
                        if (dec1Chars.unmatchCh === "}") {
                            token = scope._createPatternToken(pattern, tokenTypes.quantifierN, i, 1 + dec1Chars.matchLength + 1);
                            token.data = {
                                n: parseInt(dec1Chars.match, 10)
                            };
                        } else if (dec1Chars.unmatchCh === ",") {
                            var dec2Chars = scope._matchChars(pattern, dec1Chars.unmatchIndex + 1, endIndex, scope._decSymbols);

                            if (dec2Chars.unmatchCh === "}") {
                                token = scope._createPatternToken(pattern, tokenTypes.quantifierNM, i, 1 + dec1Chars.matchLength + 1 + dec2Chars.matchLength + 1);
                                token.data = {
                                    n: parseInt(dec1Chars.match, 10),
                                    m: null
                                };

                                if (dec2Chars.matchLength !== 0) {
                                    token.data.m = parseInt(dec2Chars.match, 10);

                                    if (token.data.n > token.data.m) {
                                        throw new System.ArgumentException.$ctor1("Illegal {x,y} with x > y.");
                                    }
                                }
                            }
                        }
                    }
                }

                if (token != null) {
                    var nextChIndex = i + token.length;

                    if (nextChIndex < endIndex) {
                        var nextCh = pattern[nextChIndex];

                        if (nextCh === "?") {
                            this._modifyPatternToken(token, pattern, token.type, token.index, token.length + 1);
                            token.data.isLazy = true;
                        }
                    }
                }

                return token;
            },

            _parseAlternationToken: function (pattern, i) {
                var scope = System.Text.RegularExpressions.RegexEngineParser;
                var tokenTypes = scope.tokenTypes;

                var ch = pattern[i];

                if (ch !== "|") {
                    return null;
                }

                return scope._createPatternToken(pattern, tokenTypes.alternation, i, 1);
            },

            _parseAlternationGroupConditionToken: function (pattern, settings, i, endIndex) {
                var scope = System.Text.RegularExpressions.RegexEngineParser;
                var tokenTypes = scope.tokenTypes;
                var constructToken;
                var childToken;
                var data = null;

                var ch = pattern[i];

                if (ch !== "?" || i + 1 >= endIndex || pattern[i + 1] !== "(") {
                    return null;
                }

                // Parse Alternation condition as a group:
                var expr = scope._parseGroupToken(pattern, settings, i + 1, endIndex);

                if (expr == null) {
                    return null;
                }

                if (expr.type === tokenTypes.commentInline) {
                    throw new System.ArgumentException.$ctor1("Alternation conditions cannot be comments.");
                }

                var children = expr.children;

                if (children && children.length) {
                    constructToken = children[0];

                    if (constructToken.type === tokenTypes.groupConstructName) {
                        throw new System.ArgumentException.$ctor1("Alternation conditions do not capture and cannot be named.");
                    }

                    if (constructToken.type === tokenTypes.groupConstruct || constructToken.type === tokenTypes.groupConstructImnsx) {
                        childToken = scope._findFirstGroupWithoutConstructs(children);

                        if (childToken != null) {
                            childToken.isEmptyCapturing = true;
                        }
                    }

                    if (constructToken.type === tokenTypes.literal) {
                        var literalVal = expr.value.slice(1, expr.value.length - 1);
                        var isDigit = literalVal[0] >= "0" && literalVal[0] <= "9";

                        if (isDigit) {
                            var res = scope._matchChars(literalVal, 0, literalVal.length, scope._decSymbols);

                            if (res.matchLength !== literalVal.length) {
                                throw new System.ArgumentException.$ctor1("Malformed Alternation group number: " + literalVal + ".");
                            }

                            var number = parseInt(literalVal, 10);
                            data = { number: number };
                        } else {
                            data = { name: literalVal };
                        }
                    }
                }

                // Add "Noncapturing" construct if there are no other ones.
                if (!children.length || (children[0].type !== tokenTypes.groupConstruct && children[0].type !== tokenTypes.groupConstructImnsx)) {
                    constructToken = scope._createPatternToken("?:", tokenTypes.groupConstruct, 0, 2);
                    children.splice(0, 0, constructToken);
                }

                // Transform Group token to Alternation expression token:
                var token = scope._createPatternToken(pattern, tokenTypes.alternationGroupCondition, expr.index - 1, 1 + expr.length, [expr], "?", "");

                if (data != null) {
                    token.data = data;
                }

                return token;
            },

            _findFirstGroupWithoutConstructs: function (tokens) {
                var scope = System.Text.RegularExpressions.RegexEngineParser;
                var tokenTypes = scope.tokenTypes;
                var result = null;
                var token;
                var i;

                for (i = 0; i < tokens.length; ++i) {
                    token = tokens[i];

                    if (token.type === tokenTypes.group && token.children && token.children.length) {
                        if (token.children[0].type !== tokenTypes.groupConstruct && token.children[0].type !== tokenTypes.groupConstructImnsx) {
                            result = token;

                            break;
                        }

                        if (token.children && token.children.length) {
                            result = scope._findFirstGroupWithoutConstructs(token.children);

                            if (result != null) {
                                break;
                            }
                        }
                    }
                }

                return result;
            },

            _parseXModeCommentToken: function (pattern, i, endIndex) {
                var scope = System.Text.RegularExpressions.RegexEngineParser;
                var tokenTypes = scope.tokenTypes;

                var ch = pattern[i];

                if (ch !== "#") {
                    return null;
                }

                var index = i + 1;

                while (index < endIndex) {
                    ch = pattern[index];
                    ++index; // index should be changed before breaking

                    if (ch === "\n") {
                        break;
                    }
                }

                return scope._createPatternToken(pattern, tokenTypes.commentXMode, i, index - i);
            },

            _createLiteralToken: function (body) {
                var scope = System.Text.RegularExpressions.RegexEngineParser;
                var token = scope._createPatternToken(body, scope.tokenTypes.literal, 0, body.length);

                return token;
            },

            _createPositiveLookaheadToken: function (body, settings) {
                var scope = System.Text.RegularExpressions.RegexEngineParser;

                var pattern = "(?=" + body + ")";
                var groupToken = scope._parseGroupToken(pattern, settings, 0, pattern.length);

                return groupToken;
            },

            _createPatternToken: function (pattern, type, i, len, innerTokens, innerTokensPrefix, innerTokensPostfix) {
                var token = {
                    type: type,
                    index: i,
                    length: len,
                    value: pattern.slice(i, i + len)
                };

                if (innerTokens != null && innerTokens.length > 0) {
                    token.children = innerTokens;
                    token.childrenPrefix = innerTokensPrefix;
                    token.childrenPostfix = innerTokensPostfix;
                }

                return token;
            },

            _modifyPatternToken: function (token, pattern, type, i, len) {
                if (type != null) {
                    token.type = type;
                }

                if (i != null || len != null) {
                    if (i != null) {
                        token.index = i;
                    }

                    if (len != null) {
                        token.length = len;
                    }

                    token.value = pattern.slice(token.index, token.index + token.length);
                }
            },

            _updatePatternToken: function (token, type, i, len, value) {
                token.type = type;
                token.index = i;
                token.length = len;
                token.value = value;
            },

            _matchChars: function (str, startIndex, endIndex, allowedChars, maxLength) {
                var res = {
                    match: "",
                    matchIndex: -1,
                    matchLength: 0,
                    unmatchCh: "",
                    unmatchIndex: -1,
                    unmatchLength: 0
                };

                var index = startIndex;
                var ch;

                if (maxLength != null && maxLength >= 0) {
                    endIndex = startIndex + maxLength;
                }

                while (index < endIndex) {
                    ch = str[index];

                    if (allowedChars.indexOf(ch) < 0) {
                        res.unmatchCh = ch;
                        res.unmatchIndex = index;
                        res.unmatchLength = 1;

                        break;
                    }

                    index++;
                }

                if (index > startIndex) {
                    res.match = str.slice(startIndex, index);
                    res.matchIndex = startIndex;
                    res.matchLength = index - startIndex;
                }

                return res;
            },

            _matchUntil: function (str, startIndex, endIndex, unallowedChars, maxLength) {
                var res = {
                    match: "",
                    matchIndex: -1,
                    matchLength: 0,
                    unmatchCh: "",
                    unmatchIndex: -1,
                    unmatchLength: 0
                };

                var index = startIndex;
                var ch;

                if (maxLength != null && maxLength >= 0) {
                    endIndex = startIndex + maxLength;
                }

                while (index < endIndex) {
                    ch = str[index];

                    if (unallowedChars.indexOf(ch) >= 0) {
                        res.unmatchCh = ch;
                        res.unmatchIndex = index;
                        res.unmatchLength = 1;

                        break;
                    }

                    index++;
                }

                if (index > startIndex) {
                    res.match = str.slice(startIndex, index);
                    res.matchIndex = startIndex;
                    res.matchLength = index - startIndex;
                }

                return res;
            }
        }
    });

    // @source BitConverter.js

    Bridge.define("System.BitConverter", {
        statics: {
            fields: {
                isLittleEndian: false,
                arg_ArrayPlusOffTooSmall: null
            },
            ctors: {
                init: function () {
                    this.isLittleEndian = System.BitConverter.getIsLittleEndian();
                    this.arg_ArrayPlusOffTooSmall = "Destination array is not long enough to copy all the items in the collection. Check array index and length.";
                }
            },
            methods: {
                getBytes: function (value) {
                    return value ? System.Array.init([1], System.Byte) : System.Array.init([0], System.Byte);
                },
                getBytes$1: function (value) {
                    return System.BitConverter.getBytes$3(Bridge.Int.sxs(value & 65535));
                },
                getBytes$3: function (value) {
                    var view = System.BitConverter.view(2);
                    view.setInt16(0, value);

                    return System.BitConverter.getViewBytes(view);
                },
                getBytes$4: function (value) {
                    var view = System.BitConverter.view(4);
                    view.setInt32(0, value);

                    return System.BitConverter.getViewBytes(view);
                },
                getBytes$5: function (value) {
                    var view = System.BitConverter.getView(value);

                    return System.BitConverter.getViewBytes(view);
                },
                getBytes$7: function (value) {
                    var view = System.BitConverter.view(2);
                    view.setUint16(0, value);

                    return System.BitConverter.getViewBytes(view);
                },
                getBytes$8: function (value) {
                    var view = System.BitConverter.view(4);
                    view.setUint32(0, value);

                    return System.BitConverter.getViewBytes(view);
                },
                getBytes$9: function (value) {
                    var view = System.BitConverter.getView(System.Int64.clip64(value));

                    return System.BitConverter.getViewBytes(view);
                },
                getBytes$6: function (value) {
                    var view = System.BitConverter.view(4);
                    view.setFloat32(0, value);

                    return System.BitConverter.getViewBytes(view);
                },
                getBytes$2: function (value) {
                    if (isNaN(value)) {
                        if (System.BitConverter.isLittleEndian) {
                            return System.Array.init([0, 0, 0, 0, 0, 0, 248, 255], System.Byte);
                        } else {
                            return System.Array.init([255, 248, 0, 0, 0, 0, 0, 0], System.Byte);
                        }
                    }

                    var view = System.BitConverter.view(8);
                    view.setFloat64(0, value);

                    return System.BitConverter.getViewBytes(view);
                },
                toChar: function (value, startIndex) {
                    return ((System.BitConverter.toInt16(value, startIndex)) & 65535);
                },
                toInt16: function (value, startIndex) {
                    System.BitConverter.checkArguments(value, startIndex, 2);

                    var view = System.BitConverter.view(2);

                    System.BitConverter.setViewBytes(view, value, -1, startIndex);

                    return view.getInt16(0);
                },
                toInt32: function (value, startIndex) {
                    System.BitConverter.checkArguments(value, startIndex, 4);

                    var view = System.BitConverter.view(4);

                    System.BitConverter.setViewBytes(view, value, -1, startIndex);

                    return view.getInt32(0);
                },
                toInt64: function (value, startIndex) {
                    System.BitConverter.checkArguments(value, startIndex, 8);

                    var low = System.BitConverter.toInt32(value, startIndex);
                    var high = System.BitConverter.toInt32(value, ((startIndex + 4) | 0));

                    if (System.BitConverter.isLittleEndian) {
                        return System.Int64([low, high]);
                    }

                    return System.Int64([high, low]);
                },
                toUInt16: function (value, startIndex) {
                    return ((System.BitConverter.toInt16(value, startIndex)) & 65535);
                },
                toUInt32: function (value, startIndex) {
                    return ((System.BitConverter.toInt32(value, startIndex)) >>> 0);
                },
                toUInt64: function (value, startIndex) {
                    var l = System.BitConverter.toInt64(value, startIndex);

                    return System.UInt64([l.value.low, l.value.high]);
                },
                toSingle: function (value, startIndex) {
                    System.BitConverter.checkArguments(value, startIndex, 4);

                    var view = System.BitConverter.view(4);

                    System.BitConverter.setViewBytes(view, value, -1, startIndex);

                    return view.getFloat32(0);
                },
                toDouble: function (value, startIndex) {
                    System.BitConverter.checkArguments(value, startIndex, 8);

                    var view = System.BitConverter.view(8);

                    System.BitConverter.setViewBytes(view, value, -1, startIndex);

                    return view.getFloat64(0);
                },
                toString$2: function (value, startIndex, length) {
                    if (value == null) {
                        throw new System.ArgumentNullException.$ctor1("value");
                    }

                    if (startIndex < 0 || startIndex >= value.length && startIndex > 0) {
                        throw new System.ArgumentOutOfRangeException.$ctor1("startIndex");
                    }

                    if (length < 0) {
                        throw new System.ArgumentOutOfRangeException.$ctor1("length");
                    }

                    if (startIndex > ((value.length - length) | 0)) {
                        throw new System.ArgumentException.$ctor1(System.BitConverter.arg_ArrayPlusOffTooSmall);
                    }

                    if (length === 0) {
                        return "";
                    }

                    if (length > (715827882)) {
                        throw new System.ArgumentOutOfRangeException.$ctor4("length", Bridge.toString((715827882)));
                    }

                    var chArrayLength = Bridge.Int.mul(length, 3);

                    var chArray = System.Array.init(chArrayLength, 0, System.Char);
                    var i = 0;
                    var index = startIndex;

                    for (i = 0; i < chArrayLength; i = (i + 3) | 0) {
                        var b = value[System.Array.index(Bridge.identity(index, (index = (index + 1) | 0)), value)];
                        chArray[System.Array.index(i, chArray)] = System.BitConverter.getHexValue(((Bridge.Int.div(b, 16)) | 0));
                        chArray[System.Array.index(((i + 1) | 0), chArray)] = System.BitConverter.getHexValue(b % 16);
                        chArray[System.Array.index(((i + 2) | 0), chArray)] = 45;
                    }

                    return System.String.fromCharArray(chArray, 0, ((chArray.length - 1) | 0));
                },
                toString: function (value) {
                    if (value == null) {
                        throw new System.ArgumentNullException.$ctor1("value");
                    }

                    return System.BitConverter.toString$2(value, 0, value.length);
                },
                toString$1: function (value, startIndex) {
                    if (value == null) {
                        throw new System.ArgumentNullException.$ctor1("value");
                    }

                    return System.BitConverter.toString$2(value, startIndex, ((value.length - startIndex) | 0));
                },
                toBoolean: function (value, startIndex) {
                    System.BitConverter.checkArguments(value, startIndex, 1);

                    return (value[System.Array.index(startIndex, value)] === 0) ? false : true;
                },
                doubleToInt64Bits: function (value) {
                    var view = System.BitConverter.view(8);
                    view.setFloat64(0, value);

                    return System.Int64([view.getInt32(4), view.getInt32(0)]);
                },
                int64BitsToDouble: function (value) {
                    var view = System.BitConverter.getView(value);

                    return view.getFloat64(0);
                },
                getHexValue: function (i) {
                    if (i < 10) {
                        return ((((i + 48) | 0)) & 65535);
                    }

                    return ((((((i - 10) | 0) + 65) | 0)) & 65535);
                },
                getViewBytes: function (view, count, startIndex) {
                    if (count === void 0) { count = -1; }
                    if (startIndex === void 0) { startIndex = 0; }
                    if (count === -1) {
                        count = view.byteLength;
                    }

                    var r = System.Array.init(count, 0, System.Byte);

                    if (System.BitConverter.isLittleEndian) {
                        for (var i = (count - 1) | 0; i >= 0; i = (i - 1) | 0) {
                            r[System.Array.index(i, r)] = view.getUint8(Bridge.identity(startIndex, (startIndex = (startIndex + 1) | 0)));
                        }
                    } else {
                        for (var i1 = 0; i1 < count; i1 = (i1 + 1) | 0) {
                            r[System.Array.index(i1, r)] = view.getUint8(Bridge.identity(startIndex, (startIndex = (startIndex + 1) | 0)));
                        }
                    }

                    return r;
                },
                setViewBytes: function (view, value, count, startIndex) {
                    if (count === void 0) { count = -1; }
                    if (startIndex === void 0) { startIndex = 0; }
                    if (count === -1) {
                        count = view.byteLength;
                    }

                    if (System.BitConverter.isLittleEndian) {
                        for (var i = (count - 1) | 0; i >= 0; i = (i - 1) | 0) {
                            view.setUint8(i, value[System.Array.index(Bridge.identity(startIndex, (startIndex = (startIndex + 1) | 0)), value)]);
                        }
                    } else {
                        for (var i1 = 0; i1 < count; i1 = (i1 + 1) | 0) {
                            view.setUint8(i1, value[System.Array.index(Bridge.identity(startIndex, (startIndex = (startIndex + 1) | 0)), value)]);
                        }
                    }
                },
                view: function (length) {
                    var buffer = new ArrayBuffer(length);
                    var view = new DataView(buffer);

                    return view;
                },
                getView: function (value) {
                    var view = System.BitConverter.view(8);

                    view.setInt32(4, value.value.low);
                    view.setInt32(0, value.value.high);

                    return view;
                },
                getIsLittleEndian: function () {
                    var view = System.BitConverter.view(2);

                    view.setUint8(0, 170);
                    view.setUint8(1, 187);

                    if (view.getUint16(0) === 43707) {
                        return true;
                    }

                    return false;
                },
                checkArguments: function (value, startIndex, size) {
                    if (value == null) {
                        throw new System.ArgumentNullException.$ctor1("null");
                    }

                    if (System.Int64((startIndex >>> 0)).gte(System.Int64(value.length))) {
                        throw new System.ArgumentOutOfRangeException.$ctor1("startIndex");
                    }

                    if (startIndex > ((value.length - size) | 0)) {
                        throw new System.ArgumentException.$ctor1(System.BitConverter.arg_ArrayPlusOffTooSmall);
                    }
                }
            }
        }
    });

    // @source BitArray.js

    Bridge.define("System.Collections.BitArray", {
        inherits: [System.Collections.ICollection,System.ICloneable],
        statics: {
            fields: {
                BitsPerInt32: 0,
                BytesPerInt32: 0,
                BitsPerByte: 0,
                _ShrinkThreshold: 0
            },
            ctors: {
                init: function () {
                    this.BitsPerInt32 = 32;
                    this.BytesPerInt32 = 4;
                    this.BitsPerByte = 8;
                    this._ShrinkThreshold = 256;
                }
            },
            methods: {
                GetArrayLength: function (n, div) {
                    return n > 0 ? ((((((Bridge.Int.div((((n - 1) | 0)), div)) | 0)) + 1) | 0)) : 0;
                }
            }
        },
        fields: {
            m_array: null,
            m_length: 0,
            _version: 0
        },
        props: {
            Length: {
                get: function () {
                    return this.m_length;
                },
                set: function (value) {
                    if (value < 0) {
                        throw new System.ArgumentOutOfRangeException.$ctor4("value", "Non-negative number required.");
                    }

                    var newints = System.Collections.BitArray.GetArrayLength(value, System.Collections.BitArray.BitsPerInt32);
                    if (newints > this.m_array.length || ((newints + System.Collections.BitArray._ShrinkThreshold) | 0) < this.m_array.length) {
                        var newarray = System.Array.init(newints, 0, System.Int32);
                        System.Array.copy(this.m_array, 0, newarray, 0, newints > this.m_array.length ? this.m_array.length : newints);
                        this.m_array = newarray;
                    }

                    if (value > this.m_length) {
                        var last = (System.Collections.BitArray.GetArrayLength(this.m_length, System.Collections.BitArray.BitsPerInt32) - 1) | 0;
                        var bits = this.m_length % 32;
                        if (bits > 0) {
                            this.m_array[System.Array.index(last, this.m_array)] = this.m_array[System.Array.index(last, this.m_array)] & ((((1 << bits) - 1) | 0));
                        }

                        System.Array.fill(this.m_array, 0, ((last + 1) | 0), ((((newints - last) | 0) - 1) | 0));
                    }

                    this.m_length = value;
                    this._version = (this._version + 1) | 0;
                }
            },
            Count: {
                get: function () {
                    return this.m_length;
                }
            },
            System$Collections$ICollection$IsSynchronized: {
                get: function () {
                    return false;
                }
            },
            System$Collections$ICollection$SyncRoot: {
                get: function () {
                    return this;
                }
            },
            IsReadOnly: {
                get: function () {
                    return false;
                }
            }
        },
        alias: [
            "copyTo", "System$Collections$ICollection$copyTo",
            "Count", "System$Collections$ICollection$Count",
            "clone", "System$ICloneable$clone",
            "GetEnumerator", "System$Collections$IEnumerable$GetEnumerator"
        ],
        ctors: {
            $ctor3: function (length) {
                System.Collections.BitArray.$ctor4.call(this, length, false);
            },
            $ctor4: function (length, defaultValue) {
                this.$initialize();
                if (length < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("length", "Index is less than zero.");
                }

                this.m_array = System.Array.init(System.Collections.BitArray.GetArrayLength(length, System.Collections.BitArray.BitsPerInt32), 0, System.Int32);
                this.m_length = length;

                var fillValue = defaultValue ? (-1) : 0;
                for (var i = 0; i < this.m_array.length; i = (i + 1) | 0) {
                    this.m_array[System.Array.index(i, this.m_array)] = fillValue;
                }

                this._version = 0;
            },
            $ctor1: function (bytes) {
                this.$initialize();
                if (bytes == null) {
                    throw new System.ArgumentNullException.$ctor1("bytes");
                }
                if (bytes.length > 268435455) {
                    throw new System.ArgumentException.$ctor3(System.String.format("The input array length must not exceed Int32.MaxValue / {0}. Otherwise BitArray.Length would exceed Int32.MaxValue.", [Bridge.box(System.Collections.BitArray.BitsPerByte, System.Int32)]), "bytes");
                }

                this.m_array = System.Array.init(System.Collections.BitArray.GetArrayLength(bytes.length, System.Collections.BitArray.BytesPerInt32), 0, System.Int32);
                this.m_length = Bridge.Int.mul(bytes.length, System.Collections.BitArray.BitsPerByte);

                var i = 0;
                var j = 0;
                while (((bytes.length - j) | 0) >= 4) {
                    this.m_array[System.Array.index(Bridge.identity(i, (i = (i + 1) | 0)), this.m_array)] = (bytes[System.Array.index(j, bytes)] & 255) | ((bytes[System.Array.index(((j + 1) | 0), bytes)] & 255) << 8) | ((bytes[System.Array.index(((j + 2) | 0), bytes)] & 255) << 16) | ((bytes[System.Array.index(((j + 3) | 0), bytes)] & 255) << 24);
                    j = (j + 4) | 0;
                }

                var r = (bytes.length - j) | 0;
                if (r === 3) {
                    this.m_array[System.Array.index(i, this.m_array)] = ((bytes[System.Array.index(((j + 2) | 0), bytes)] & 255) << 16);
                    r = 2;
                }

                if (r === 2) {
                    this.m_array[System.Array.index(i, this.m_array)] = this.m_array[System.Array.index(i, this.m_array)] | ((bytes[System.Array.index(((j + 1) | 0), bytes)] & 255) << 8);
                    r = 1;
                }

                if (r === 1) {
                    this.m_array[System.Array.index(i, this.m_array)] = this.m_array[System.Array.index(i, this.m_array)] | (bytes[System.Array.index(j, bytes)] & 255);
                }

                this._version = 0;
            },
            ctor: function (values) {
                var $t;
                this.$initialize();
                if (values == null) {
                    throw new System.ArgumentNullException.$ctor1("values");
                }

                this.m_array = System.Array.init(System.Collections.BitArray.GetArrayLength(values.length, System.Collections.BitArray.BitsPerInt32), 0, System.Int32);
                this.m_length = values.length;

                for (var i = 0; i < values.length; i = (i + 1) | 0) {
                    if (values[System.Array.index(i, values)]) {
                        this.m_array[System.Array.index(($t = ((Bridge.Int.div(i, 32)) | 0)), this.m_array)] = this.m_array[System.Array.index($t, this.m_array)] | (1 << (i % 32));
                    }
                }

                this._version = 0;
            },
            $ctor5: function (values) {
                this.$initialize();
                if (values == null) {
                    throw new System.ArgumentNullException.$ctor1("values");
                }
                if (values.length > 67108863) {
                    throw new System.ArgumentException.$ctor3(System.String.format("The input array length must not exceed Int32.MaxValue / {0}. Otherwise BitArray.Length would exceed Int32.MaxValue.", [Bridge.box(System.Collections.BitArray.BitsPerInt32, System.Int32)]), "values");
                }

                this.m_array = System.Array.init(values.length, 0, System.Int32);
                this.m_length = Bridge.Int.mul(values.length, System.Collections.BitArray.BitsPerInt32);

                System.Array.copy(values, 0, this.m_array, 0, values.length);

                this._version = 0;
            },
            $ctor2: function (bits) {
                this.$initialize();
                if (bits == null) {
                    throw new System.ArgumentNullException.$ctor1("bits");
                }

                var arrayLength = System.Collections.BitArray.GetArrayLength(bits.m_length, System.Collections.BitArray.BitsPerInt32);
                this.m_array = System.Array.init(arrayLength, 0, System.Int32);
                this.m_length = bits.m_length;

                System.Array.copy(bits.m_array, 0, this.m_array, 0, arrayLength);

                this._version = bits._version;
            }
        },
        methods: {
            getItem: function (index) {
                return this.Get(index);
            },
            setItem: function (index, value) {
                this.Set(index, value);
            },
            copyTo: function (array, index) {
                if (array == null) {
                    throw new System.ArgumentNullException.$ctor1("array");
                }

                if (index < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("index");
                }

                if (System.Array.getRank(array) !== 1) {
                    throw new System.ArgumentException.$ctor1("Only single dimensional arrays are supported for the requested action.");
                }

                if (Bridge.is(array, System.Array.type(System.Int32))) {
                    System.Array.copy(this.m_array, 0, array, index, System.Collections.BitArray.GetArrayLength(this.m_length, System.Collections.BitArray.BitsPerInt32));
                } else if (Bridge.is(array, System.Array.type(System.Byte))) {
                    var arrayLength = System.Collections.BitArray.GetArrayLength(this.m_length, System.Collections.BitArray.BitsPerByte);
                    if ((((array.length - index) | 0)) < arrayLength) {
                        throw new System.ArgumentException.$ctor1("Offset and length were out of bounds for the array or count is greater than the number of elements from index to the end of the source collection.");
                    }

                    var b = Bridge.cast(array, System.Array.type(System.Byte));
                    for (var i = 0; i < arrayLength; i = (i + 1) | 0) {
                        b[System.Array.index(((index + i) | 0), b)] = ((this.m_array[System.Array.index(((Bridge.Int.div(i, 4)) | 0), this.m_array)] >> (Bridge.Int.mul((i % 4), 8))) & 255) & 255;
                    }
                } else if (Bridge.is(array, System.Array.type(System.Boolean))) {
                    if (((array.length - index) | 0) < this.m_length) {
                        throw new System.ArgumentException.$ctor1("Offset and length were out of bounds for the array or count is greater than the number of elements from index to the end of the source collection.");
                    }

                    var b1 = Bridge.cast(array, System.Array.type(System.Boolean));
                    for (var i1 = 0; i1 < this.m_length; i1 = (i1 + 1) | 0) {
                        b1[System.Array.index(((index + i1) | 0), b1)] = ((this.m_array[System.Array.index(((Bridge.Int.div(i1, 32)) | 0), this.m_array)] >> (i1 % 32)) & 1) !== 0;
                    }
                } else {
                    throw new System.ArgumentException.$ctor1("Only supported array types for CopyTo on BitArrays are Boolean[], Int32[] and Byte[].");
                }
            },
            Get: function (index) {
                if (index < 0 || index >= this.Length) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("index", "Index was out of range. Must be non-negative and less than the size of the collection.");
                }

                return (this.m_array[System.Array.index(((Bridge.Int.div(index, 32)) | 0), this.m_array)] & (1 << (index % 32))) !== 0;
            },
            Set: function (index, value) {
                var $t, $t1;
                if (index < 0 || index >= this.Length) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("index", "Index was out of range. Must be non-negative and less than the size of the collection.");
                }

                if (value) {
                    this.m_array[System.Array.index(($t = ((Bridge.Int.div(index, 32)) | 0)), this.m_array)] = this.m_array[System.Array.index($t, this.m_array)] | (1 << (index % 32));
                } else {
                    this.m_array[System.Array.index(($t1 = ((Bridge.Int.div(index, 32)) | 0)), this.m_array)] = this.m_array[System.Array.index($t1, this.m_array)] & (~(1 << (index % 32)));
                }

                this._version = (this._version + 1) | 0;
            },
            SetAll: function (value) {
                var fillValue = value ? (-1) : 0;
                var ints = System.Collections.BitArray.GetArrayLength(this.m_length, System.Collections.BitArray.BitsPerInt32);
                for (var i = 0; i < ints; i = (i + 1) | 0) {
                    this.m_array[System.Array.index(i, this.m_array)] = fillValue;
                }

                this._version = (this._version + 1) | 0;
            },
            And: function (value) {
                if (value == null) {
                    throw new System.ArgumentNullException.$ctor1("value");
                }
                if (this.Length !== value.Length) {
                    throw new System.ArgumentException.$ctor1("Array lengths must be the same.");
                }

                var ints = System.Collections.BitArray.GetArrayLength(this.m_length, System.Collections.BitArray.BitsPerInt32);
                for (var i = 0; i < ints; i = (i + 1) | 0) {
                    this.m_array[System.Array.index(i, this.m_array)] = this.m_array[System.Array.index(i, this.m_array)] & value.m_array[System.Array.index(i, value.m_array)];
                }

                this._version = (this._version + 1) | 0;
                return this;
            },
            Or: function (value) {
                if (value == null) {
                    throw new System.ArgumentNullException.$ctor1("value");
                }
                if (this.Length !== value.Length) {
                    throw new System.ArgumentException.$ctor1("Array lengths must be the same.");
                }

                var ints = System.Collections.BitArray.GetArrayLength(this.m_length, System.Collections.BitArray.BitsPerInt32);
                for (var i = 0; i < ints; i = (i + 1) | 0) {
                    this.m_array[System.Array.index(i, this.m_array)] = this.m_array[System.Array.index(i, this.m_array)] | value.m_array[System.Array.index(i, value.m_array)];
                }

                this._version = (this._version + 1) | 0;
                return this;
            },
            Xor: function (value) {
                if (value == null) {
                    throw new System.ArgumentNullException.$ctor1("value");
                }
                if (this.Length !== value.Length) {
                    throw new System.ArgumentException.$ctor1("Array lengths must be the same.");
                }

                var ints = System.Collections.BitArray.GetArrayLength(this.m_length, System.Collections.BitArray.BitsPerInt32);
                for (var i = 0; i < ints; i = (i + 1) | 0) {
                    this.m_array[System.Array.index(i, this.m_array)] = this.m_array[System.Array.index(i, this.m_array)] ^ value.m_array[System.Array.index(i, value.m_array)];
                }

                this._version = (this._version + 1) | 0;
                return this;
            },
            Not: function () {
                var ints = System.Collections.BitArray.GetArrayLength(this.m_length, System.Collections.BitArray.BitsPerInt32);
                for (var i = 0; i < ints; i = (i + 1) | 0) {
                    this.m_array[System.Array.index(i, this.m_array)] = ~this.m_array[System.Array.index(i, this.m_array)];
                }

                this._version = (this._version + 1) | 0;
                return this;
            },
            clone: function () {
                var bitArray = new System.Collections.BitArray.$ctor5(this.m_array);
                bitArray._version = this._version;
                bitArray.m_length = this.m_length;
                return bitArray;
            },
            GetEnumerator: function () {
                return new System.Collections.BitArray.BitArrayEnumeratorSimple(this);
            }
        }
    });

    // @source BitArrayEnumeratorSimple.js

    Bridge.define("System.Collections.BitArray.BitArrayEnumeratorSimple", {
        inherits: [System.Collections.IEnumerator],
        $kind: "nested class",
        fields: {
            bitarray: null,
            index: 0,
            version: 0,
            currentElement: false
        },
        props: {
            Current: {
                get: function () {
                    if (this.index === -1) {
                        throw new System.InvalidOperationException.$ctor1("Enumeration has not started. Call MoveNext.");
                    }
                    if (this.index >= this.bitarray.Count) {
                        throw new System.InvalidOperationException.$ctor1("Enumeration already finished.");
                    }
                    return Bridge.box(this.currentElement, System.Boolean, System.Boolean.toString);
                }
            }
        },
        alias: [
            "moveNext", "System$Collections$IEnumerator$moveNext",
            "Current", "System$Collections$IEnumerator$Current",
            "reset", "System$Collections$IEnumerator$reset"
        ],
        ctors: {
            ctor: function (bitarray) {
                this.$initialize();
                this.bitarray = bitarray;
                this.index = -1;
                this.version = bitarray._version;
            }
        },
        methods: {
            moveNext: function () {
                if (this.version !== this.bitarray._version) {
                    throw new System.InvalidOperationException.$ctor1("Collection was modified; enumeration operation may not execute.");
                }
                if (this.index < (((this.bitarray.Count - 1) | 0))) {
                    this.index = (this.index + 1) | 0;
                    this.currentElement = this.bitarray.Get(this.index);
                    return true;
                } else {
                    this.index = this.bitarray.Count;
                }

                return false;
            },
            reset: function () {
                if (this.version !== this.bitarray._version) {
                    throw new System.InvalidOperationException.$ctor1("Collection was modified; enumeration operation may not execute.");
                }
                this.index = -1;
            }
        }
    });

    // @source BitHelper.js

    Bridge.define("System.Collections.Generic.BitHelper", {
        statics: {
            fields: {
                MarkedBitFlag: 0,
                IntSize: 0
            },
            ctors: {
                init: function () {
                    this.MarkedBitFlag = 1;
                    this.IntSize = 32;
                }
            },
            methods: {
                ToIntArrayLength: function (n) {
                    return n > 0 ? (((((Bridge.Int.div((((n - 1) | 0)), System.Collections.Generic.BitHelper.IntSize)) | 0) + 1) | 0)) : 0;
                }
            }
        },
        fields: {
            _length: 0,
            _array: null
        },
        ctors: {
            ctor: function (bitArray, length) {
                this.$initialize();
                this._array = bitArray;
                this._length = length;
            }
        },
        methods: {
            MarkBit: function (bitPosition) {
                var bitArrayIndex = (Bridge.Int.div(bitPosition, System.Collections.Generic.BitHelper.IntSize)) | 0;
                if (bitArrayIndex < this._length && bitArrayIndex >= 0) {
                    var flag = (System.Collections.Generic.BitHelper.MarkedBitFlag << (bitPosition % System.Collections.Generic.BitHelper.IntSize));
                    this._array[System.Array.index(bitArrayIndex, this._array)] = this._array[System.Array.index(bitArrayIndex, this._array)] | flag;
                }
            },
            IsMarked: function (bitPosition) {
                var bitArrayIndex = (Bridge.Int.div(bitPosition, System.Collections.Generic.BitHelper.IntSize)) | 0;
                if (bitArrayIndex < this._length && bitArrayIndex >= 0) {
                    var flag = (System.Collections.Generic.BitHelper.MarkedBitFlag << (bitPosition % System.Collections.Generic.BitHelper.IntSize));
                    return ((this._array[System.Array.index(bitArrayIndex, this._array)] & flag) !== 0);
                }
                return false;
            }
        }
    });

    // @source DictionaryKeyCollectionDebugView.js

    Bridge.define("System.Collections.Generic.DictionaryKeyCollectionDebugView$2", function (TKey, TValue) { return {
        fields: {
            _collection: null
        },
        props: {
            Items: {
                get: function () {
                    var items = System.Array.init(System.Array.getCount(this._collection, TKey), function (){
                        return Bridge.getDefaultValue(TKey);
                    }, TKey);
                    System.Array.copyTo(this._collection, items, 0, TKey);
                    return items;
                }
            }
        },
        ctors: {
            ctor: function (collection) {
                this.$initialize();
                if (collection == null) {
                    throw new System.ArgumentNullException.$ctor1("collection");
                }

                this._collection = collection;
            }
        }
    }; });

    // @source DictionaryValueCollectionDebugView.js

    Bridge.define("System.Collections.Generic.DictionaryValueCollectionDebugView$2", function (TKey, TValue) { return {
        fields: {
            _collection: null
        },
        props: {
            Items: {
                get: function () {
                    var items = System.Array.init(System.Array.getCount(this._collection, TValue), function (){
                        return Bridge.getDefaultValue(TValue);
                    }, TValue);
                    System.Array.copyTo(this._collection, items, 0, TValue);
                    return items;
                }
            }
        },
        ctors: {
            ctor: function (collection) {
                this.$initialize();
                if (collection == null) {
                    throw new System.ArgumentNullException.$ctor1("collection");
                }

                this._collection = collection;
            }
        }
    }; });

    // @source EnumerableHelpers.js

    Bridge.define("Bridge.Collections.EnumerableHelpers", {
        statics: {
            methods: {
                ToArray: function (T, source) {
                    var count = { };
                    var results = { v : Bridge.Collections.EnumerableHelpers.ToArray$1(T, source, count) };
                    System.Array.resize(results, count.v, Bridge.getDefaultValue(T));
                    return results.v;
                },
                ToArray$1: function (T, source, length) {
                    var en = Bridge.getEnumerator(source, T);
                    try {
                        if (en.System$Collections$IEnumerator$moveNext()) {
                            var DefaultCapacity = 4;
                            var arr = { v : System.Array.init(DefaultCapacity, function (){
                                return Bridge.getDefaultValue(T);
                            }, T) };
                            arr.v[System.Array.index(0, arr.v)] = en[Bridge.geti(en, "System$Collections$Generic$IEnumerator$1$" + Bridge.getTypeAlias(T) + "$Current$1", "System$Collections$Generic$IEnumerator$1$Current$1")];
                            var count = 1;

                            while (en.System$Collections$IEnumerator$moveNext()) {
                                if (count === arr.v.length) {
                                    var MaxArrayLength = 2146435071;

                                    var newLength = count << 1;
                                    if ((newLength >>> 0) > MaxArrayLength) {
                                        newLength = MaxArrayLength <= count ? ((count + 1) | 0) : MaxArrayLength;
                                    }

                                    System.Array.resize(arr, newLength, Bridge.getDefaultValue(T));
                                }

                                arr.v[System.Array.index(Bridge.identity(count, (count = (count + 1) | 0)), arr.v)] = en[Bridge.geti(en, "System$Collections$Generic$IEnumerator$1$" + Bridge.getTypeAlias(T) + "$Current$1", "System$Collections$Generic$IEnumerator$1$Current$1")];
                            }

                            length.v = count;
                            return arr.v;
                        }
                    }
                    finally {
                        if (Bridge.hasValue(en)) {
                            en.System$IDisposable$Dispose();
                        }
                    }

                    length.v = 0;
                    return System.Array.init(0, function (){
                        return Bridge.getDefaultValue(T);
                    }, T);
                }
            }
        }
    });

    // @source HashSet.js

    Bridge.define("System.Collections.Generic.HashSet$1", function (T) { return {
        inherits: [System.Collections.Generic.ICollection$1(T),System.Collections.Generic.ISet$1(T),System.Collections.Generic.IReadOnlyCollection$1(T)],
        statics: {
            fields: {
                Lower31BitMask: 0,
                ShrinkThreshold: 0
            },
            ctors: {
                init: function () {
                    this.Lower31BitMask = 2147483647;
                    this.ShrinkThreshold = 3;
                }
            },
            methods: {
                HashSetEquals: function (set1, set2, comparer) {
                    var $t, $t1, $t2;
                    if (set1 == null) {
                        return (set2 == null);
                    } else if (set2 == null) {
                        return false;
                    }
                    if (System.Collections.Generic.HashSet$1(T).AreEqualityComparersEqual(set1, set2)) {
                        if (set1.Count !== set2.Count) {
                            return false;
                        }
                        $t = Bridge.getEnumerator(set2);
                        try {
                            while ($t.moveNext()) {
                                var item = $t.Current;
                                if (!set1.contains(item)) {
                                    return false;
                                }
                            }
                        } finally {
                            if (Bridge.is($t, System.IDisposable)) {
                                $t.System$IDisposable$Dispose();
                            }
                        }
                        return true;
                    } else {
                        $t1 = Bridge.getEnumerator(set2);
                        try {
                            while ($t1.moveNext()) {
                                var set2Item = $t1.Current;
                                var found = false;
                                $t2 = Bridge.getEnumerator(set1);
                                try {
                                    while ($t2.moveNext()) {
                                        var set1Item = $t2.Current;
                                        if (comparer[Bridge.geti(comparer, "System$Collections$Generic$IEqualityComparer$1$" + Bridge.getTypeAlias(T) + "$equals2", "System$Collections$Generic$IEqualityComparer$1$equals2")](set2Item, set1Item)) {
                                            found = true;
                                            break;
                                        }
                                    }
                                } finally {
                                    if (Bridge.is($t2, System.IDisposable)) {
                                        $t2.System$IDisposable$Dispose();
                                    }
                                }
                                if (!found) {
                                    return false;
                                }
                            }
                        } finally {
                            if (Bridge.is($t1, System.IDisposable)) {
                                $t1.System$IDisposable$Dispose();
                            }
                        }
                        return true;
                    }
                },
                AreEqualityComparersEqual: function (set1, set2) {
                    return Bridge.equals(set1.Comparer, set2.Comparer);
                }
            }
        },
        fields: {
            _buckets: null,
            _slots: null,
            _count: 0,
            _lastIndex: 0,
            _freeList: 0,
            _comparer: null,
            _version: 0
        },
        props: {
            Count: {
                get: function () {
                    return this._count;
                }
            },
            IsReadOnly: {
                get: function () {
                    return false;
                }
            },
            Comparer: {
                get: function () {
                    return this._comparer;
                }
            }
        },
        alias: [
            "System$Collections$Generic$ICollection$1$add", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$add",
            "clear", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$clear",
            "contains", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$contains",
            "copyTo", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$copyTo",
            "remove", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$remove",
            "Count", ["System$Collections$Generic$IReadOnlyCollection$1$" + Bridge.getTypeAlias(T) + "$Count", "System$Collections$Generic$IReadOnlyCollection$1$Count"],
            "Count", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$Count",
            "IsReadOnly", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$IsReadOnly",
            "System$Collections$Generic$IEnumerable$1$GetEnumerator", "System$Collections$Generic$IEnumerable$1$" + Bridge.getTypeAlias(T) + "$GetEnumerator",
            "add", "System$Collections$Generic$ISet$1$" + Bridge.getTypeAlias(T) + "$add",
            "unionWith", "System$Collections$Generic$ISet$1$" + Bridge.getTypeAlias(T) + "$unionWith",
            "intersectWith", "System$Collections$Generic$ISet$1$" + Bridge.getTypeAlias(T) + "$intersectWith",
            "exceptWith", "System$Collections$Generic$ISet$1$" + Bridge.getTypeAlias(T) + "$exceptWith",
            "symmetricExceptWith", "System$Collections$Generic$ISet$1$" + Bridge.getTypeAlias(T) + "$symmetricExceptWith",
            "isSubsetOf", "System$Collections$Generic$ISet$1$" + Bridge.getTypeAlias(T) + "$isSubsetOf",
            "isProperSubsetOf", "System$Collections$Generic$ISet$1$" + Bridge.getTypeAlias(T) + "$isProperSubsetOf",
            "isSupersetOf", "System$Collections$Generic$ISet$1$" + Bridge.getTypeAlias(T) + "$isSupersetOf",
            "isProperSupersetOf", "System$Collections$Generic$ISet$1$" + Bridge.getTypeAlias(T) + "$isProperSupersetOf",
            "overlaps", "System$Collections$Generic$ISet$1$" + Bridge.getTypeAlias(T) + "$overlaps",
            "setEquals", "System$Collections$Generic$ISet$1$" + Bridge.getTypeAlias(T) + "$setEquals"
        ],
        ctors: {
            ctor: function () {
                System.Collections.Generic.HashSet$1(T).$ctor3.call(this, System.Collections.Generic.EqualityComparer$1(T).def);
            },
            $ctor3: function (comparer) {
                this.$initialize();
                if (comparer == null) {
                    comparer = System.Collections.Generic.EqualityComparer$1(T).def;
                }
                this._comparer = comparer;
                this._lastIndex = 0;
                this._count = 0;
                this._freeList = -1;
                this._version = 0;
            },
            $ctor1: function (collection) {
                System.Collections.Generic.HashSet$1(T).$ctor2.call(this, collection, System.Collections.Generic.EqualityComparer$1(T).def);
            },
            $ctor2: function (collection, comparer) {
                System.Collections.Generic.HashSet$1(T).$ctor3.call(this, comparer);
                if (collection == null) {
                    throw new System.ArgumentNullException.$ctor1("collection");
                }
                var suggestedCapacity = 0;
                var coll = Bridge.as(collection, System.Collections.Generic.ICollection$1(T));
                if (coll != null) {
                    suggestedCapacity = System.Array.getCount(coll, T);
                }
                this.Initialize(suggestedCapacity);
                this.unionWith(collection);
                if ((this._count === 0 && this._slots.length > System.Collections.HashHelpers.GetMinPrime()) || (this._count > 0 && ((Bridge.Int.div(this._slots.length, this._count)) | 0) > System.Collections.Generic.HashSet$1(T).ShrinkThreshold)) {
                    this.TrimExcess();
                }
            }
        },
        methods: {
            System$Collections$Generic$ICollection$1$add: function (item) {
                this.AddIfNotPresent(item);
            },
            add: function (item) {
                return this.AddIfNotPresent(item);
            },
            clear: function () {
                if (this._lastIndex > 0) {
                    for (var i = 0; i < this._lastIndex; i = (i + 1) | 0) {
                        this._slots[System.Array.index(i, this._slots)] = new (System.Collections.Generic.HashSet$1.Slot(T))();
                    }

                    for (var i1 = 0; i1 < this._buckets.length; i1 = (i1 + 1) | 0) {
                        this._buckets[System.Array.index(i1, this._buckets)] = 0;
                    }

                    this._lastIndex = 0;
                    this._count = 0;
                    this._freeList = -1;
                }
                this._version = (this._version + 1) | 0;
            },
            ArrayClear: function (array, index, length) { },
            contains: function (item) {
                if (this._buckets != null) {
                    var hashCode = this.InternalGetHashCode(item);
                    for (var i = (this._buckets[System.Array.index(hashCode % this._buckets.length, this._buckets)] - 1) | 0; i >= 0; i = this._slots[System.Array.index(i, this._slots)].next) {
                        if (this._slots[System.Array.index(i, this._slots)].hashCode === hashCode && this._comparer[Bridge.geti(this._comparer, "System$Collections$Generic$IEqualityComparer$1$" + Bridge.getTypeAlias(T) + "$equals2", "System$Collections$Generic$IEqualityComparer$1$equals2")](this._slots[System.Array.index(i, this._slots)].value, item)) {
                            return true;
                        }
                    }
                }
                return false;
            },
            copyTo: function (array, arrayIndex) {
                this.CopyTo$1(array, arrayIndex, this._count);
            },
            CopyTo: function (array) {
                this.CopyTo$1(array, 0, this._count);
            },
            CopyTo$1: function (array, arrayIndex, count) {
                if (array == null) {
                    throw new System.ArgumentNullException.$ctor1("array");
                }
                if (arrayIndex < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("arrayIndex");
                }
                if (count < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("count");
                }
                if (arrayIndex > array.length || count > ((array.length - arrayIndex) | 0)) {
                    throw new System.ArgumentException.$ctor1("Destination array is not long enough to copy all the items in the collection. Check array index and length.");
                }
                var numCopied = 0;
                for (var i = 0; i < this._lastIndex && numCopied < count; i = (i + 1) | 0) {
                    if (this._slots[System.Array.index(i, this._slots)].hashCode >= 0) {
                        array[System.Array.index(((arrayIndex + numCopied) | 0), array)] = this._slots[System.Array.index(i, this._slots)].value;
                        numCopied = (numCopied + 1) | 0;
                    }
                }
            },
            remove: function (item) {
                if (this._buckets != null) {
                    var hashCode = this.InternalGetHashCode(item);
                    var bucket = hashCode % this._buckets.length;
                    var last = -1;
                    for (var i = (this._buckets[System.Array.index(bucket, this._buckets)] - 1) | 0; i >= 0; last = i, i = this._slots[System.Array.index(i, this._slots)].next) {
                        if (this._slots[System.Array.index(i, this._slots)].hashCode === hashCode && this._comparer[Bridge.geti(this._comparer, "System$Collections$Generic$IEqualityComparer$1$" + Bridge.getTypeAlias(T) + "$equals2", "System$Collections$Generic$IEqualityComparer$1$equals2")](this._slots[System.Array.index(i, this._slots)].value, item)) {
                            if (last < 0) {
                                this._buckets[System.Array.index(bucket, this._buckets)] = (this._slots[System.Array.index(i, this._slots)].next + 1) | 0;
                            } else {
                                this._slots[System.Array.index(last, this._slots)].next = this._slots[System.Array.index(i, this._slots)].next;
                            }
                            this._slots[System.Array.index(i, this._slots)].hashCode = -1;
                            this._slots[System.Array.index(i, this._slots)].value = Bridge.getDefaultValue(T);
                            this._slots[System.Array.index(i, this._slots)].next = this._freeList;
                            this._count = (this._count - 1) | 0;
                            this._version = (this._version + 1) | 0;
                            if (this._count === 0) {
                                this._lastIndex = 0;
                                this._freeList = -1;
                            } else {
                                this._freeList = i;
                            }
                            return true;
                        }
                    }
                }
                return false;
            },
            GetEnumerator: function () {
                return new (System.Collections.Generic.HashSet$1.Enumerator(T)).$ctor1(this);
            },
            System$Collections$Generic$IEnumerable$1$GetEnumerator: function () {
                return new (System.Collections.Generic.HashSet$1.Enumerator(T)).$ctor1(this).$clone();
            },
            System$Collections$IEnumerable$GetEnumerator: function () {
                return new (System.Collections.Generic.HashSet$1.Enumerator(T)).$ctor1(this).$clone();
            },
            unionWith: function (other) {
                var $t;
                if (other == null) {
                    throw new System.ArgumentNullException.$ctor1("other");
                }
                $t = Bridge.getEnumerator(other, T);
                try {
                    while ($t.moveNext()) {
                        var item = $t.Current;
                        this.AddIfNotPresent(item);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            intersectWith: function (other) {
                if (other == null) {
                    throw new System.ArgumentNullException.$ctor1("other");
                }
                if (this._count === 0) {
                    return;
                }
                var otherAsCollection = Bridge.as(other, System.Collections.Generic.ICollection$1(T));
                if (otherAsCollection != null) {
                    if (System.Array.getCount(otherAsCollection, T) === 0) {
                        this.clear();
                        return;
                    }
                    var otherAsSet = Bridge.as(other, System.Collections.Generic.HashSet$1(T));
                    if (otherAsSet != null && System.Collections.Generic.HashSet$1(T).AreEqualityComparersEqual(this, otherAsSet)) {
                        this.IntersectWithHashSetWithSameEC(otherAsSet);
                        return;
                    }
                }
                this.IntersectWithEnumerable(other);
            },
            exceptWith: function (other) {
                var $t;
                if (other == null) {
                    throw new System.ArgumentNullException.$ctor1("other");
                }
                if (this._count === 0) {
                    return;
                }
                if (Bridge.referenceEquals(other, this)) {
                    this.clear();
                    return;
                }
                $t = Bridge.getEnumerator(other, T);
                try {
                    while ($t.moveNext()) {
                        var element = $t.Current;
                        this.remove(element);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            symmetricExceptWith: function (other) {
                if (other == null) {
                    throw new System.ArgumentNullException.$ctor1("other");
                }
                if (this._count === 0) {
                    this.unionWith(other);
                    return;
                }
                if (Bridge.referenceEquals(other, this)) {
                    this.clear();
                    return;
                }
                var otherAsSet = Bridge.as(other, System.Collections.Generic.HashSet$1(T));
                if (otherAsSet != null && System.Collections.Generic.HashSet$1(T).AreEqualityComparersEqual(this, otherAsSet)) {
                    this.SymmetricExceptWithUniqueHashSet(otherAsSet);
                } else {
                    this.SymmetricExceptWithEnumerable(other);
                }
            },
            isSubsetOf: function (other) {
                if (other == null) {
                    throw new System.ArgumentNullException.$ctor1("other");
                }
                if (this._count === 0) {
                    return true;
                }
                var otherAsSet = Bridge.as(other, System.Collections.Generic.HashSet$1(T));
                if (otherAsSet != null && System.Collections.Generic.HashSet$1(T).AreEqualityComparersEqual(this, otherAsSet)) {
                    if (this._count > otherAsSet.Count) {
                        return false;
                    }
                    return this.IsSubsetOfHashSetWithSameEC(otherAsSet);
                } else {
                    var result = this.CheckUniqueAndUnfoundElements(other, false);
                    return (result.uniqueCount === this._count && result.unfoundCount >= 0);
                }
            },
            isProperSubsetOf: function (other) {
                if (other == null) {
                    throw new System.ArgumentNullException.$ctor1("other");
                }
                var otherAsCollection = Bridge.as(other, System.Collections.Generic.ICollection$1(T));
                if (otherAsCollection != null) {
                    if (this._count === 0) {
                        return System.Array.getCount(otherAsCollection, T) > 0;
                    }
                    var otherAsSet = Bridge.as(other, System.Collections.Generic.HashSet$1(T));
                    if (otherAsSet != null && System.Collections.Generic.HashSet$1(T).AreEqualityComparersEqual(this, otherAsSet)) {
                        if (this._count >= otherAsSet.Count) {
                            return false;
                        }
                        return this.IsSubsetOfHashSetWithSameEC(otherAsSet);
                    }
                }
                var result = this.CheckUniqueAndUnfoundElements(other, false);
                return (result.uniqueCount === this._count && result.unfoundCount > 0);
            },
            isSupersetOf: function (other) {
                if (other == null) {
                    throw new System.ArgumentNullException.$ctor1("other");
                }
                var otherAsCollection = Bridge.as(other, System.Collections.Generic.ICollection$1(T));
                if (otherAsCollection != null) {
                    if (System.Array.getCount(otherAsCollection, T) === 0) {
                        return true;
                    }
                    var otherAsSet = Bridge.as(other, System.Collections.Generic.HashSet$1(T));
                    if (otherAsSet != null && System.Collections.Generic.HashSet$1(T).AreEqualityComparersEqual(this, otherAsSet)) {
                        if (otherAsSet.Count > this._count) {
                            return false;
                        }
                    }
                }
                return this.ContainsAllElements(other);
            },
            isProperSupersetOf: function (other) {
                if (other == null) {
                    throw new System.ArgumentNullException.$ctor1("other");
                }
                if (this._count === 0) {
                    return false;
                }
                var otherAsCollection = Bridge.as(other, System.Collections.Generic.ICollection$1(T));
                if (otherAsCollection != null) {
                    if (System.Array.getCount(otherAsCollection, T) === 0) {
                        return true;
                    }
                    var otherAsSet = Bridge.as(other, System.Collections.Generic.HashSet$1(T));
                    if (otherAsSet != null && System.Collections.Generic.HashSet$1(T).AreEqualityComparersEqual(this, otherAsSet)) {
                        if (otherAsSet.Count >= this._count) {
                            return false;
                        }
                        return this.ContainsAllElements(otherAsSet);
                    }
                }
                var result = this.CheckUniqueAndUnfoundElements(other, true);
                return (result.uniqueCount < this._count && result.unfoundCount === 0);
            },
            overlaps: function (other) {
                var $t;
                if (other == null) {
                    throw new System.ArgumentNullException.$ctor1("other");
                }
                if (this._count === 0) {
                    return false;
                }
                $t = Bridge.getEnumerator(other, T);
                try {
                    while ($t.moveNext()) {
                        var element = $t.Current;
                        if (this.contains(element)) {
                            return true;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return false;
            },
            setEquals: function (other) {
                if (other == null) {
                    throw new System.ArgumentNullException.$ctor1("other");
                }
                var otherAsSet = Bridge.as(other, System.Collections.Generic.HashSet$1(T));
                if (otherAsSet != null && System.Collections.Generic.HashSet$1(T).AreEqualityComparersEqual(this, otherAsSet)) {
                    if (this._count !== otherAsSet.Count) {
                        return false;
                    }
                    return this.ContainsAllElements(otherAsSet);
                } else {
                    var otherAsCollection = Bridge.as(other, System.Collections.Generic.ICollection$1(T));
                    if (otherAsCollection != null) {
                        if (this._count === 0 && System.Array.getCount(otherAsCollection, T) > 0) {
                            return false;
                        }
                    }
                    var result = this.CheckUniqueAndUnfoundElements(other, true);
                    return (result.uniqueCount === this._count && result.unfoundCount === 0);
                }
            },
            RemoveWhere: function (match) {
                if (Bridge.staticEquals(match, null)) {
                    throw new System.ArgumentNullException.$ctor1("match");
                }
                var numRemoved = 0;
                for (var i = 0; i < this._lastIndex; i = (i + 1) | 0) {
                    if (this._slots[System.Array.index(i, this._slots)].hashCode >= 0) {
                        var value = this._slots[System.Array.index(i, this._slots)].value;
                        if (match(value)) {
                            if (this.remove(value)) {
                                numRemoved = (numRemoved + 1) | 0;
                            }
                        }
                    }
                }
                return numRemoved;
            },
            TrimExcess: function () {
                if (this._count === 0) {
                    this._buckets = null;
                    this._slots = null;
                    this._version = (this._version + 1) | 0;
                } else {
                    var newSize = System.Collections.HashHelpers.GetPrime(this._count);
                    var newSlots = System.Array.init(newSize, function (){
                        return new (System.Collections.Generic.HashSet$1.Slot(T))();
                    }, System.Collections.Generic.HashSet$1.Slot(T));
                    var newBuckets = System.Array.init(newSize, 0, System.Int32);
                    var newIndex = 0;
                    for (var i = 0; i < this._lastIndex; i = (i + 1) | 0) {
                        if (this._slots[System.Array.index(i, this._slots)].hashCode >= 0) {
                            newSlots[System.Array.index(newIndex, newSlots)] = this._slots[System.Array.index(i, this._slots)].$clone();
                            var bucket = newSlots[System.Array.index(newIndex, newSlots)].hashCode % newSize;
                            newSlots[System.Array.index(newIndex, newSlots)].next = (newBuckets[System.Array.index(bucket, newBuckets)] - 1) | 0;
                            newBuckets[System.Array.index(bucket, newBuckets)] = (newIndex + 1) | 0;
                            newIndex = (newIndex + 1) | 0;
                        }
                    }
                    this._lastIndex = newIndex;
                    this._slots = newSlots;
                    this._buckets = newBuckets;
                    this._freeList = -1;
                }
            },
            Initialize: function (capacity) {
                var size = System.Collections.HashHelpers.GetPrime(capacity);
                this._buckets = System.Array.init(size, 0, System.Int32);
                this._slots = System.Array.init(size, function (){
                    return new (System.Collections.Generic.HashSet$1.Slot(T))();
                }, System.Collections.Generic.HashSet$1.Slot(T));
            },
            IncreaseCapacity: function () {
                var newSize = System.Collections.HashHelpers.ExpandPrime(this._count);
                if (newSize <= this._count) {
                    throw new System.ArgumentException.$ctor1("HashSet capacity is too big.");
                }
                this.SetCapacity(newSize, false);
            },
            SetCapacity: function (newSize, forceNewHashCodes) {
                var newSlots = System.Array.init(newSize, function (){
                    return new (System.Collections.Generic.HashSet$1.Slot(T))();
                }, System.Collections.Generic.HashSet$1.Slot(T));
                if (this._slots != null) {
                    for (var i = 0; i < this._lastIndex; i = (i + 1) | 0) {
                        newSlots[System.Array.index(i, newSlots)] = this._slots[System.Array.index(i, this._slots)].$clone();
                    }
                }
                if (forceNewHashCodes) {
                    for (var i1 = 0; i1 < this._lastIndex; i1 = (i1 + 1) | 0) {
                        if (newSlots[System.Array.index(i1, newSlots)].hashCode !== -1) {
                            newSlots[System.Array.index(i1, newSlots)].hashCode = this.InternalGetHashCode(newSlots[System.Array.index(i1, newSlots)].value);
                        }
                    }
                }
                var newBuckets = System.Array.init(newSize, 0, System.Int32);
                for (var i2 = 0; i2 < this._lastIndex; i2 = (i2 + 1) | 0) {
                    var bucket = newSlots[System.Array.index(i2, newSlots)].hashCode % newSize;
                    newSlots[System.Array.index(i2, newSlots)].next = (newBuckets[System.Array.index(bucket, newBuckets)] - 1) | 0;
                    newBuckets[System.Array.index(bucket, newBuckets)] = (i2 + 1) | 0;
                }
                this._slots = newSlots;
                this._buckets = newBuckets;
            },
            AddIfNotPresent: function (value) {
                if (this._buckets == null) {
                    this.Initialize(0);
                }
                var hashCode = this.InternalGetHashCode(value);
                var bucket = hashCode % this._buckets.length;
                for (var i = (this._buckets[System.Array.index(bucket, this._buckets)] - 1) | 0; i >= 0; i = this._slots[System.Array.index(i, this._slots)].next) {
                    if (this._slots[System.Array.index(i, this._slots)].hashCode === hashCode && this._comparer[Bridge.geti(this._comparer, "System$Collections$Generic$IEqualityComparer$1$" + Bridge.getTypeAlias(T) + "$equals2", "System$Collections$Generic$IEqualityComparer$1$equals2")](this._slots[System.Array.index(i, this._slots)].value, value)) {
                        return false;
                    }
                }
                var index;
                if (this._freeList >= 0) {
                    index = this._freeList;
                    this._freeList = this._slots[System.Array.index(index, this._slots)].next;
                } else {
                    if (this._lastIndex === this._slots.length) {
                        this.IncreaseCapacity();
                        bucket = hashCode % this._buckets.length;
                    }
                    index = this._lastIndex;
                    this._lastIndex = (this._lastIndex + 1) | 0;
                }
                this._slots[System.Array.index(index, this._slots)].hashCode = hashCode;
                this._slots[System.Array.index(index, this._slots)].value = value;
                this._slots[System.Array.index(index, this._slots)].next = (this._buckets[System.Array.index(bucket, this._buckets)] - 1) | 0;
                this._buckets[System.Array.index(bucket, this._buckets)] = (index + 1) | 0;
                this._count = (this._count + 1) | 0;
                this._version = (this._version + 1) | 0;
                return true;
            },
            ContainsAllElements: function (other) {
                var $t;
                $t = Bridge.getEnumerator(other, T);
                try {
                    while ($t.moveNext()) {
                        var element = $t.Current;
                        if (!this.contains(element)) {
                            return false;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return true;
            },
            IsSubsetOfHashSetWithSameEC: function (other) {
                var $t;
                $t = Bridge.getEnumerator(this);
                try {
                    while ($t.moveNext()) {
                        var item = $t.Current;
                        if (!other.contains(item)) {
                            return false;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return true;
            },
            IntersectWithHashSetWithSameEC: function (other) {
                for (var i = 0; i < this._lastIndex; i = (i + 1) | 0) {
                    if (this._slots[System.Array.index(i, this._slots)].hashCode >= 0) {
                        var item = this._slots[System.Array.index(i, this._slots)].value;
                        if (!other.contains(item)) {
                            this.remove(item);
                        }
                    }
                }
            },
            IntersectWithEnumerable: function (other) {
                var $t;
                var originalLastIndex = this._lastIndex;
                var intArrayLength = System.Collections.Generic.BitHelper.ToIntArrayLength(originalLastIndex);
                var bitHelper;
                var bitArray = System.Array.init(intArrayLength, 0, System.Int32);
                bitHelper = new System.Collections.Generic.BitHelper(bitArray, intArrayLength);
                $t = Bridge.getEnumerator(other, T);
                try {
                    while ($t.moveNext()) {
                        var item = $t.Current;
                        var index = this.InternalIndexOf(item);
                        if (index >= 0) {
                            bitHelper.MarkBit(index);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                for (var i = 0; i < originalLastIndex; i = (i + 1) | 0) {
                    if (this._slots[System.Array.index(i, this._slots)].hashCode >= 0 && !bitHelper.IsMarked(i)) {
                        this.remove(this._slots[System.Array.index(i, this._slots)].value);
                    }
                }
            },
            InternalIndexOf: function (item) {
                var hashCode = this.InternalGetHashCode(item);
                for (var i = (this._buckets[System.Array.index(hashCode % this._buckets.length, this._buckets)] - 1) | 0; i >= 0; i = this._slots[System.Array.index(i, this._slots)].next) {
                    if ((this._slots[System.Array.index(i, this._slots)].hashCode) === hashCode && this._comparer[Bridge.geti(this._comparer, "System$Collections$Generic$IEqualityComparer$1$" + Bridge.getTypeAlias(T) + "$equals2", "System$Collections$Generic$IEqualityComparer$1$equals2")](this._slots[System.Array.index(i, this._slots)].value, item)) {
                        return i;
                    }
                }
                return -1;
            },
            SymmetricExceptWithUniqueHashSet: function (other) {
                var $t;
                $t = Bridge.getEnumerator(other);
                try {
                    while ($t.moveNext()) {
                        var item = $t.Current;
                        if (!this.remove(item)) {
                            this.AddIfNotPresent(item);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            SymmetricExceptWithEnumerable: function (other) {
                var $t;
                var originalLastIndex = this._lastIndex;
                var intArrayLength = System.Collections.Generic.BitHelper.ToIntArrayLength(originalLastIndex);
                var itemsToRemove;
                var itemsAddedFromOther;
                var itemsToRemoveArray = System.Array.init(intArrayLength, 0, System.Int32);
                itemsToRemove = new System.Collections.Generic.BitHelper(itemsToRemoveArray, intArrayLength);
                var itemsAddedFromOtherArray = System.Array.init(intArrayLength, 0, System.Int32);
                itemsAddedFromOther = new System.Collections.Generic.BitHelper(itemsAddedFromOtherArray, intArrayLength);
                $t = Bridge.getEnumerator(other, T);
                try {
                    while ($t.moveNext()) {
                        var item = $t.Current;
                        var location = { v : 0 };
                        var added = this.AddOrGetLocation(item, location);
                        if (added) {
                            itemsAddedFromOther.MarkBit(location.v);
                        } else {
                            if (location.v < originalLastIndex && !itemsAddedFromOther.IsMarked(location.v)) {
                                itemsToRemove.MarkBit(location.v);
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                for (var i = 0; i < originalLastIndex; i = (i + 1) | 0) {
                    if (itemsToRemove.IsMarked(i)) {
                        this.remove(this._slots[System.Array.index(i, this._slots)].value);
                    }
                }
            },
            AddOrGetLocation: function (value, location) {
                var hashCode = this.InternalGetHashCode(value);
                var bucket = hashCode % this._buckets.length;
                for (var i = (this._buckets[System.Array.index(bucket, this._buckets)] - 1) | 0; i >= 0; i = this._slots[System.Array.index(i, this._slots)].next) {
                    if (this._slots[System.Array.index(i, this._slots)].hashCode === hashCode && this._comparer[Bridge.geti(this._comparer, "System$Collections$Generic$IEqualityComparer$1$" + Bridge.getTypeAlias(T) + "$equals2", "System$Collections$Generic$IEqualityComparer$1$equals2")](this._slots[System.Array.index(i, this._slots)].value, value)) {
                        location.v = i;
                        return false;
                    }
                }
                var index;
                if (this._freeList >= 0) {
                    index = this._freeList;
                    this._freeList = this._slots[System.Array.index(index, this._slots)].next;
                } else {
                    if (this._lastIndex === this._slots.length) {
                        this.IncreaseCapacity();
                        bucket = hashCode % this._buckets.length;
                    }
                    index = this._lastIndex;
                    this._lastIndex = (this._lastIndex + 1) | 0;
                }
                this._slots[System.Array.index(index, this._slots)].hashCode = hashCode;
                this._slots[System.Array.index(index, this._slots)].value = value;
                this._slots[System.Array.index(index, this._slots)].next = (this._buckets[System.Array.index(bucket, this._buckets)] - 1) | 0;
                this._buckets[System.Array.index(bucket, this._buckets)] = (index + 1) | 0;
                this._count = (this._count + 1) | 0;
                this._version = (this._version + 1) | 0;
                location.v = index;
                return true;
            },
            CheckUniqueAndUnfoundElements: function (other, returnIfUnfound) {
                var $t, $t1;
                var result = new (System.Collections.Generic.HashSet$1.ElementCount(T))();
                if (this._count === 0) {
                    var numElementsInOther = 0;
                    $t = Bridge.getEnumerator(other, T);
                    try {
                        while ($t.moveNext()) {
                            var item = $t.Current;
                            numElementsInOther = (numElementsInOther + 1) | 0;
                            break;
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    result.uniqueCount = 0;
                    result.unfoundCount = numElementsInOther;
                    return result.$clone();
                }
                var originalLastIndex = this._lastIndex;
                var intArrayLength = System.Collections.Generic.BitHelper.ToIntArrayLength(originalLastIndex);
                var bitHelper;
                var bitArray = System.Array.init(intArrayLength, 0, System.Int32);
                bitHelper = new System.Collections.Generic.BitHelper(bitArray, intArrayLength);
                var unfoundCount = 0;
                var uniqueFoundCount = 0;
                $t1 = Bridge.getEnumerator(other, T);
                try {
                    while ($t1.moveNext()) {
                        var item1 = $t1.Current;
                        var index = this.InternalIndexOf(item1);
                        if (index >= 0) {
                            if (!bitHelper.IsMarked(index)) {
                                bitHelper.MarkBit(index);
                                uniqueFoundCount = (uniqueFoundCount + 1) | 0;
                            }
                        } else {
                            unfoundCount = (unfoundCount + 1) | 0;
                            if (returnIfUnfound) {
                                break;
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }
                result.uniqueCount = uniqueFoundCount;
                result.unfoundCount = unfoundCount;
                return result.$clone();
            },
            ToArray: function () {
                var newArray = System.Array.init(this.Count, function (){
                    return Bridge.getDefaultValue(T);
                }, T);
                this.CopyTo(newArray);
                return newArray;
            },
            InternalGetHashCode: function (item) {
                if (item == null) {
                    return 0;
                }
                return this._comparer[Bridge.geti(this._comparer, "System$Collections$Generic$IEqualityComparer$1$" + Bridge.getTypeAlias(T) + "$getHashCode2", "System$Collections$Generic$IEqualityComparer$1$getHashCode2")](item) & System.Collections.Generic.HashSet$1(T).Lower31BitMask;
            }
        }
    }; });

    // @source ElementCount.js

    Bridge.define("System.Collections.Generic.HashSet$1.ElementCount", function (T) { return {
        $kind: "nested struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new (System.Collections.Generic.HashSet$1.ElementCount(T))(); }
            }
        },
        fields: {
            uniqueCount: 0,
            unfoundCount: 0
        },
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
                var h = Bridge.addHash([4920463385, this.uniqueCount, this.unfoundCount]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, System.Collections.Generic.HashSet$1.ElementCount(T))) {
                    return false;
                }
                return Bridge.equals(this.uniqueCount, o.uniqueCount) && Bridge.equals(this.unfoundCount, o.unfoundCount);
            },
            $clone: function (to) {
                var s = to || new (System.Collections.Generic.HashSet$1.ElementCount(T))();
                s.uniqueCount = this.uniqueCount;
                s.unfoundCount = this.unfoundCount;
                return s;
            }
        }
    }; });

    // @source Enumerator.js

    Bridge.define("System.Collections.Generic.HashSet$1.Enumerator", function (T) { return {
        inherits: [System.Collections.Generic.IEnumerator$1(T)],
        $kind: "nested struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new (System.Collections.Generic.HashSet$1.Enumerator(T))(); }
            }
        },
        fields: {
            _set: null,
            _index: 0,
            _version: 0,
            _current: Bridge.getDefaultValue(T)
        },
        props: {
            Current: {
                get: function () {
                    return this._current;
                }
            },
            System$Collections$IEnumerator$Current: {
                get: function () {
                    if (this._index === 0 || this._index === ((this._set._lastIndex + 1) | 0)) {
                        throw new System.InvalidOperationException.$ctor1("Enumeration has either not started or has already finished.");
                    }
                    return this.Current;
                }
            }
        },
        alias: [
            "Dispose", "System$IDisposable$Dispose",
            "moveNext", "System$Collections$IEnumerator$moveNext",
            "Current", ["System$Collections$Generic$IEnumerator$1$" + Bridge.getTypeAlias(T) + "$Current$1", "System$Collections$Generic$IEnumerator$1$Current$1"]
        ],
        ctors: {
            $ctor1: function (set) {
                this.$initialize();
                this._set = set;
                this._index = 0;
                this._version = set._version;
                this._current = Bridge.getDefaultValue(T);
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            Dispose: function () { },
            moveNext: function () {
                var $t, $t1;
                if (this._version !== this._set._version) {
                    throw new System.InvalidOperationException.$ctor1("Collection was modified; enumeration operation may not execute.");
                }
                while (this._index < this._set._lastIndex) {
                    if (($t = this._set._slots)[System.Array.index(this._index, $t)].hashCode >= 0) {
                        this._current = ($t1 = this._set._slots)[System.Array.index(this._index, $t1)].value;
                        this._index = (this._index + 1) | 0;
                        return true;
                    }
                    this._index = (this._index + 1) | 0;
                }
                this._index = (this._set._lastIndex + 1) | 0;
                this._current = Bridge.getDefaultValue(T);
                return false;
            },
            System$Collections$IEnumerator$reset: function () {
                if (this._version !== this._set._version) {
                    throw new System.InvalidOperationException.$ctor1("Collection was modified; enumeration operation may not execute.");
                }
                this._index = 0;
                this._current = Bridge.getDefaultValue(T);
            },
            getHashCode: function () {
                var h = Bridge.addHash([3788985113, this._set, this._index, this._version, this._current]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, System.Collections.Generic.HashSet$1.Enumerator(T))) {
                    return false;
                }
                return Bridge.equals(this._set, o._set) && Bridge.equals(this._index, o._index) && Bridge.equals(this._version, o._version) && Bridge.equals(this._current, o._current);
            },
            $clone: function (to) {
                var s = to || new (System.Collections.Generic.HashSet$1.Enumerator(T))();
                s._set = this._set;
                s._index = this._index;
                s._version = this._version;
                s._current = this._current;
                return s;
            }
        }
    }; });

    // @source Slot.js

    Bridge.define("System.Collections.Generic.HashSet$1.Slot", function (T) { return {
        $kind: "nested struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new (System.Collections.Generic.HashSet$1.Slot(T))(); }
            }
        },
        fields: {
            hashCode: 0,
            value: Bridge.getDefaultValue(T),
            next: 0
        },
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
                var h = Bridge.addHash([1953459283, this.hashCode, this.value, this.next]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, System.Collections.Generic.HashSet$1.Slot(T))) {
                    return false;
                }
                return Bridge.equals(this.hashCode, o.hashCode) && Bridge.equals(this.value, o.value) && Bridge.equals(this.next, o.next);
            },
            $clone: function (to) {
                var s = to || new (System.Collections.Generic.HashSet$1.Slot(T))();
                s.hashCode = this.hashCode;
                s.value = this.value;
                s.next = this.next;
                return s;
            }
        }
    }; });

    // @source Enumerator.js

    Bridge.define("System.Collections.Generic.List$1.Enumerator", function (T) { return {
        inherits: [System.Collections.Generic.IEnumerator$1(T),System.Collections.IEnumerator],
        $kind: "nested struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new (System.Collections.Generic.List$1.Enumerator(T))(); }
            }
        },
        fields: {
            list: null,
            index: 0,
            version: 0,
            current: Bridge.getDefaultValue(T)
        },
        props: {
            Current: {
                get: function () {
                    return this.current;
                }
            },
            System$Collections$IEnumerator$Current: {
                get: function () {
                    if (this.index === 0 || this.index === ((this.list._size + 1) | 0)) {
                        throw new System.InvalidOperationException.ctor();
                    }
                    return this.Current;
                }
            }
        },
        alias: [
            "Dispose", "System$IDisposable$Dispose",
            "moveNext", "System$Collections$IEnumerator$moveNext",
            "Current", ["System$Collections$Generic$IEnumerator$1$" + Bridge.getTypeAlias(T) + "$Current$1", "System$Collections$Generic$IEnumerator$1$Current$1"]
        ],
        ctors: {
            $ctor1: function (list) {
                this.$initialize();
                this.list = list;
                this.index = 0;
                this.version = list._version;
                this.current = Bridge.getDefaultValue(T);
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            Dispose: function () { },
            moveNext: function () {

                var localList = this.list;

                if (this.version === localList._version && ((this.index >>> 0) < (localList._size >>> 0))) {
                    this.current = localList._items[System.Array.index(this.index, localList._items)];
                    this.index = (this.index + 1) | 0;
                    return true;
                }
                return this.MoveNextRare();
            },
            MoveNextRare: function () {
                if (this.version !== this.list._version) {
                    throw new System.InvalidOperationException.ctor();
                }

                this.index = (this.list._size + 1) | 0;
                this.current = Bridge.getDefaultValue(T);
                return false;
            },
            System$Collections$IEnumerator$reset: function () {
                if (this.version !== this.list._version) {
                    throw new System.InvalidOperationException.ctor();
                }

                this.index = 0;
                this.current = Bridge.getDefaultValue(T);
            },
            getHashCode: function () {
                var h = Bridge.addHash([3788985113, this.list, this.index, this.version, this.current]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, System.Collections.Generic.List$1.Enumerator(T))) {
                    return false;
                }
                return Bridge.equals(this.list, o.list) && Bridge.equals(this.index, o.index) && Bridge.equals(this.version, o.version) && Bridge.equals(this.current, o.current);
            },
            $clone: function (to) {
                var s = to || new (System.Collections.Generic.List$1.Enumerator(T))();
                s.list = this.list;
                s.index = this.index;
                s.version = this.version;
                s.current = this.current;
                return s;
            }
        }
    }; });

    // @source Queue.js

    Bridge.define("System.Collections.Generic.Queue$1", function (T) { return {
        inherits: [System.Collections.Generic.IEnumerable$1(T),System.Collections.ICollection,System.Collections.Generic.IReadOnlyCollection$1(T)],
        statics: {
            fields: {
                MinimumGrow: 0,
                GrowFactor: 0,
                DefaultCapacity: 0
            },
            ctors: {
                init: function () {
                    this.MinimumGrow = 4;
                    this.GrowFactor = 200;
                    this.DefaultCapacity = 4;
                }
            }
        },
        fields: {
            _array: null,
            _head: 0,
            _tail: 0,
            _size: 0,
            _version: 0
        },
        props: {
            Count: {
                get: function () {
                    return this._size;
                }
            },
            System$Collections$ICollection$IsSynchronized: {
                get: function () {
                    return false;
                }
            },
            System$Collections$ICollection$SyncRoot: {
                get: function () {
                    return this;
                }
            },
            IsReadOnly: {
                get: function () {
                    return false;
                }
            }
        },
        alias: [
            "Count", ["System$Collections$Generic$IReadOnlyCollection$1$" + Bridge.getTypeAlias(T) + "$Count", "System$Collections$Generic$IReadOnlyCollection$1$Count"],
            "Count", "System$Collections$ICollection$Count",
            "copyTo", "System$Collections$ICollection$copyTo",
            "System$Collections$Generic$IEnumerable$1$GetEnumerator", "System$Collections$Generic$IEnumerable$1$" + Bridge.getTypeAlias(T) + "$GetEnumerator"
        ],
        ctors: {
            ctor: function () {
                this.$initialize();
                this._array = System.Array.init(0, function (){
                    return Bridge.getDefaultValue(T);
                }, T);
            },
            $ctor2: function (capacity) {
                this.$initialize();
                if (capacity < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("capacity", "Non-negative number required.");
                }
                this._array = System.Array.init(capacity, function (){
                    return Bridge.getDefaultValue(T);
                }, T);
            },
            $ctor1: function (collection) {
                this.$initialize();
                if (collection == null) {
                    throw new System.ArgumentNullException.$ctor1("collection");
                }

                this._array = System.Array.init(System.Collections.Generic.Queue$1(T).DefaultCapacity, function (){
                    return Bridge.getDefaultValue(T);
                }, T);

                var en = Bridge.getEnumerator(collection, T);
                try {
                    while (en.System$Collections$IEnumerator$moveNext()) {
                        this.Enqueue(en[Bridge.geti(en, "System$Collections$Generic$IEnumerator$1$" + Bridge.getTypeAlias(T) + "$Current$1", "System$Collections$Generic$IEnumerator$1$Current$1")]);
                    }
                }
                finally {
                    if (Bridge.hasValue(en)) {
                        en.System$IDisposable$Dispose();
                    }
                }
            }
        },
        methods: {
            copyTo: function (array, index) {
                if (array == null) {
                    throw new System.ArgumentNullException.$ctor1("array");
                }

                if (System.Array.getRank(array) !== 1) {
                    throw new System.ArgumentException.$ctor1("Only single dimensional arrays are supported for the requested action.");
                }

                if (index < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("index");
                }

                var arrayLen = array.length;
                if (((arrayLen - index) | 0) < this._size) {
                    throw new System.ArgumentException.$ctor1("Offset and length were out of bounds for the array or count is greater than the number of elements from index to the end of the source collection.");
                }

                var numToCopy = this._size;
                if (numToCopy === 0) {
                    return;
                }

                var firstPart = (((this._array.length - this._head) | 0) < numToCopy) ? ((this._array.length - this._head) | 0) : numToCopy;
                System.Array.copy(this._array, this._head, array, index, firstPart);

                numToCopy = (numToCopy - firstPart) | 0;
                if (numToCopy > 0) {
                    System.Array.copy(this._array, 0, array, ((((index + this._array.length) | 0) - this._head) | 0), numToCopy);
                }
            },
            CopyTo: function (array, arrayIndex) {
                if (array == null) {
                    throw new System.ArgumentNullException.$ctor1("array");
                }

                if (arrayIndex < 0 || arrayIndex > array.length) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("arrayIndex", "Index was out of range. Must be non-negative and less than the size of the collection.");
                }

                var arrayLen = array.length;
                if (((arrayLen - arrayIndex) | 0) < this._size) {
                    throw new System.ArgumentException.$ctor1("Offset and length were out of bounds for the array or count is greater than the number of elements from index to the end of the source collection.");
                }

                var numToCopy = (((arrayLen - arrayIndex) | 0) < this._size) ? (((arrayLen - arrayIndex) | 0)) : this._size;
                if (numToCopy === 0) {
                    return;
                }

                var firstPart = (((this._array.length - this._head) | 0) < numToCopy) ? ((this._array.length - this._head) | 0) : numToCopy;
                System.Array.copy(this._array, this._head, array, arrayIndex, firstPart);
                numToCopy = (numToCopy - firstPart) | 0;
                if (numToCopy > 0) {
                    System.Array.copy(this._array, 0, array, ((((arrayIndex + this._array.length) | 0) - this._head) | 0), numToCopy);
                }
            },
            Clear: function () {
                if (this._head < this._tail) {
                    System.Array.fill(this._array, Bridge.getDefaultValue(T), this._head, this._size);
                } else {
                    System.Array.fill(this._array, Bridge.getDefaultValue(T), this._head, ((this._array.length - this._head) | 0));
                    System.Array.fill(this._array, Bridge.getDefaultValue(T), 0, this._tail);
                }

                this._head = 0;
                this._tail = 0;
                this._size = 0;
                this._version = (this._version + 1) | 0;
            },
            Enqueue: function (item) {
                if (this._size === this._array.length) {
                    var newcapacity = (Bridge.Int.div(Bridge.Int.mul(this._array.length, System.Collections.Generic.Queue$1(T).GrowFactor), 100)) | 0;
                    if (newcapacity < ((this._array.length + System.Collections.Generic.Queue$1(T).MinimumGrow) | 0)) {
                        newcapacity = (this._array.length + System.Collections.Generic.Queue$1(T).MinimumGrow) | 0;
                    }
                    this.SetCapacity(newcapacity);
                }

                this._array[System.Array.index(this._tail, this._array)] = item;
                this._tail = this.MoveNext(this._tail);
                this._size = (this._size + 1) | 0;
                this._version = (this._version + 1) | 0;
            },
            GetEnumerator: function () {
                return new (System.Collections.Generic.Queue$1.Enumerator(T)).$ctor1(this);
            },
            System$Collections$Generic$IEnumerable$1$GetEnumerator: function () {
                return new (System.Collections.Generic.Queue$1.Enumerator(T)).$ctor1(this).$clone();
            },
            System$Collections$IEnumerable$GetEnumerator: function () {
                return new (System.Collections.Generic.Queue$1.Enumerator(T)).$ctor1(this).$clone();
            },
            Dequeue: function () {
                if (this._size === 0) {
                    throw new System.InvalidOperationException.$ctor1("Queue empty.");
                }

                var removed = this._array[System.Array.index(this._head, this._array)];
                this._array[System.Array.index(this._head, this._array)] = Bridge.getDefaultValue(T);
                this._head = this.MoveNext(this._head);
                this._size = (this._size - 1) | 0;
                this._version = (this._version + 1) | 0;
                return removed;
            },
            Peek: function () {
                if (this._size === 0) {
                    throw new System.InvalidOperationException.$ctor1("Queue empty.");
                }

                return this._array[System.Array.index(this._head, this._array)];
            },
            Contains: function (item) {
                var index = this._head;
                var count = this._size;

                var c = System.Collections.Generic.EqualityComparer$1(T).def;
                while (Bridge.identity(count, (count = (count - 1) | 0)) > 0) {
                    if (item == null) {
                        if (this._array[System.Array.index(index, this._array)] == null) {
                            return true;
                        }
                    } else if (this._array[System.Array.index(index, this._array)] != null && c.equals2(this._array[System.Array.index(index, this._array)], item)) {
                        return true;
                    }
                    index = this.MoveNext(index);
                }

                return false;
            },
            GetElement: function (i) {
                return this._array[System.Array.index((((this._head + i) | 0)) % this._array.length, this._array)];
            },
            ToArray: function () {
                var arr = System.Array.init(this._size, function (){
                    return Bridge.getDefaultValue(T);
                }, T);
                if (this._size === 0) {
                    return arr;
                }

                if (this._head < this._tail) {
                    System.Array.copy(this._array, this._head, arr, 0, this._size);
                } else {
                    System.Array.copy(this._array, this._head, arr, 0, ((this._array.length - this._head) | 0));
                    System.Array.copy(this._array, 0, arr, ((this._array.length - this._head) | 0), this._tail);
                }

                return arr;
            },
            SetCapacity: function (capacity) {
                var newarray = System.Array.init(capacity, function (){
                    return Bridge.getDefaultValue(T);
                }, T);
                if (this._size > 0) {
                    if (this._head < this._tail) {
                        System.Array.copy(this._array, this._head, newarray, 0, this._size);
                    } else {
                        System.Array.copy(this._array, this._head, newarray, 0, ((this._array.length - this._head) | 0));
                        System.Array.copy(this._array, 0, newarray, ((this._array.length - this._head) | 0), this._tail);
                    }
                }

                this._array = newarray;
                this._head = 0;
                this._tail = (this._size === capacity) ? 0 : this._size;
                this._version = (this._version + 1) | 0;
            },
            MoveNext: function (index) {
                var tmp = (index + 1) | 0;
                return (tmp === this._array.length) ? 0 : tmp;
            },
            TrimExcess: function () {
                var threshold = Bridge.Int.clip32(this._array.length * 0.9);
                if (this._size < threshold) {
                    this.SetCapacity(this._size);
                }
            }
        }
    }; });

    // @source ICollectionDebugView.js

    Bridge.define("System.Collections.Generic.ICollectionDebugView$1", function (T) { return {
        fields: {
            _collection: null
        },
        props: {
            Items: {
                get: function () {
                    var items = System.Array.init(System.Array.getCount(this._collection, T), function (){
                        return Bridge.getDefaultValue(T);
                    }, T);
                    System.Array.copyTo(this._collection, items, 0, T);
                    return items;
                }
            }
        },
        ctors: {
            ctor: function (collection) {
                this.$initialize();
                if (collection == null) {
                    throw new System.ArgumentNullException.$ctor1("collection");
                }

                this._collection = collection;
            }
        }
    }; });

    // @source IDictionaryDebugView.js

    Bridge.define("System.Collections.Generic.IDictionaryDebugView$2", function (K, V) { return {
        fields: {
            _dict: null
        },
        props: {
            Items: {
                get: function () {
                    var items = System.Array.init(System.Array.getCount(this._dict, System.Collections.Generic.KeyValuePair$2(K,V)), function (){
                        return new (System.Collections.Generic.KeyValuePair$2(K,V))();
                    }, System.Collections.Generic.KeyValuePair$2(K,V));
                    System.Array.copyTo(this._dict, items, 0, System.Collections.Generic.KeyValuePair$2(K,V));
                    return items;
                }
            }
        },
        ctors: {
            ctor: function (dictionary) {
                this.$initialize();
                if (dictionary == null) {
                    throw new System.ArgumentNullException.$ctor1("dictionary");
                }

                this._dict = dictionary;
            }
        }
    }; });

    // @source Enumerator.js

    Bridge.define("System.Collections.Generic.Queue$1.Enumerator", function (T) { return {
        inherits: [System.Collections.Generic.IEnumerator$1(T),System.Collections.IEnumerator],
        $kind: "nested struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new (System.Collections.Generic.Queue$1.Enumerator(T))(); }
            }
        },
        fields: {
            _q: null,
            _index: 0,
            _version: 0,
            _currentElement: Bridge.getDefaultValue(T)
        },
        props: {
            Current: {
                get: function () {
                    if (this._index < 0) {
                        if (this._index === -1) {
                            throw new System.InvalidOperationException.$ctor1("Enumeration has not started. Call MoveNext.");
                        } else {
                            throw new System.InvalidOperationException.$ctor1("Enumeration already finished.");
                        }
                    }
                    return this._currentElement;
                }
            },
            System$Collections$IEnumerator$Current: {
                get: function () {
                    return this.Current;
                }
            }
        },
        alias: [
            "Dispose", "System$IDisposable$Dispose",
            "moveNext", "System$Collections$IEnumerator$moveNext",
            "Current", ["System$Collections$Generic$IEnumerator$1$" + Bridge.getTypeAlias(T) + "$Current$1", "System$Collections$Generic$IEnumerator$1$Current$1"]
        ],
        ctors: {
            $ctor1: function (q) {
                this.$initialize();
                this._q = q;
                this._version = this._q._version;
                this._index = -1;
                this._currentElement = Bridge.getDefaultValue(T);
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            Dispose: function () {
                this._index = -2;
                this._currentElement = Bridge.getDefaultValue(T);
            },
            moveNext: function () {
                if (this._version !== this._q._version) {
                    throw new System.InvalidOperationException.$ctor1("Collection was modified; enumeration operation may not execute.");
                }

                if (this._index === -2) {
                    return false;
                }

                this._index = (this._index + 1) | 0;

                if (this._index === this._q._size) {
                    this._index = -2;
                    this._currentElement = Bridge.getDefaultValue(T);
                    return false;
                }

                this._currentElement = this._q.GetElement(this._index);
                return true;
            },
            System$Collections$IEnumerator$reset: function () {
                if (this._version !== this._q._version) {
                    throw new System.InvalidOperationException.$ctor1("Collection was modified; enumeration operation may not execute.");
                }
                this._index = -1;
                this._currentElement = Bridge.getDefaultValue(T);
            },
            getHashCode: function () {
                var h = Bridge.addHash([3788985113, this._q, this._index, this._version, this._currentElement]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, System.Collections.Generic.Queue$1.Enumerator(T))) {
                    return false;
                }
                return Bridge.equals(this._q, o._q) && Bridge.equals(this._index, o._index) && Bridge.equals(this._version, o._version) && Bridge.equals(this._currentElement, o._currentElement);
            },
            $clone: function (to) {
                var s = to || new (System.Collections.Generic.Queue$1.Enumerator(T))();
                s._q = this._q;
                s._index = this._index;
                s._version = this._version;
                s._currentElement = this._currentElement;
                return s;
            }
        }
    }; });

    // @source Stack.js

    Bridge.define("System.Collections.Generic.Stack$1", function (T) { return {
        inherits: [System.Collections.Generic.IEnumerable$1(T),System.Collections.ICollection,System.Collections.Generic.IReadOnlyCollection$1(T)],
        statics: {
            fields: {
                DefaultCapacity: 0
            },
            ctors: {
                init: function () {
                    this.DefaultCapacity = 4;
                }
            }
        },
        fields: {
            _array: null,
            _size: 0,
            _version: 0
        },
        props: {
            Count: {
                get: function () {
                    return this._size;
                }
            },
            System$Collections$ICollection$IsSynchronized: {
                get: function () {
                    return false;
                }
            },
            System$Collections$ICollection$SyncRoot: {
                get: function () {
                    return this;
                }
            },
            IsReadOnly: {
                get: function () {
                    return false;
                }
            }
        },
        alias: [
            "Count", ["System$Collections$Generic$IReadOnlyCollection$1$" + Bridge.getTypeAlias(T) + "$Count", "System$Collections$Generic$IReadOnlyCollection$1$Count"],
            "Count", "System$Collections$ICollection$Count",
            "copyTo", "System$Collections$ICollection$copyTo",
            "System$Collections$Generic$IEnumerable$1$GetEnumerator", "System$Collections$Generic$IEnumerable$1$" + Bridge.getTypeAlias(T) + "$GetEnumerator"
        ],
        ctors: {
            ctor: function () {
                this.$initialize();
                this._array = System.Array.init(0, function (){
                    return Bridge.getDefaultValue(T);
                }, T);
            },
            $ctor2: function (capacity) {
                this.$initialize();
                if (capacity < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("capacity", "Non-negative number required.");
                }
                this._array = System.Array.init(capacity, function (){
                    return Bridge.getDefaultValue(T);
                }, T);
            },
            $ctor1: function (collection) {
                this.$initialize();
                if (collection == null) {
                    throw new System.ArgumentNullException.$ctor1("collection");
                }
                var length = { };
                this._array = Bridge.Collections.EnumerableHelpers.ToArray$1(T, collection, length);
                this._size = length.v;
            }
        },
        methods: {
            Clear: function () {
                System.Array.fill(this._array, Bridge.getDefaultValue(T), 0, this._size);
                this._size = 0;
                this._version = (this._version + 1) | 0;
            },
            Contains: function (item) {
                var count = this._size;

                var c = System.Collections.Generic.EqualityComparer$1(T).def;
                while (Bridge.identity(count, (count = (count - 1) | 0)) > 0) {
                    if (item == null) {
                        if (this._array[System.Array.index(count, this._array)] == null) {
                            return true;
                        }
                    } else if (this._array[System.Array.index(count, this._array)] != null && c.equals2(this._array[System.Array.index(count, this._array)], item)) {
                        return true;
                    }
                }
                return false;
            },
            CopyTo: function (array, arrayIndex) {
                if (array == null) {
                    throw new System.ArgumentNullException.$ctor1("array");
                }

                if (arrayIndex < 0 || arrayIndex > array.length) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("arrayIndex", "Non-negative number required.");
                }

                if (((array.length - arrayIndex) | 0) < this._size) {
                    throw new System.ArgumentException.$ctor1("Offset and length were out of bounds for the array or count is greater than the number of elements from index to the end of the source collection.");
                }

                if (!Bridge.referenceEquals(array, this._array)) {
                    var srcIndex = 0;
                    var dstIndex = (arrayIndex + this._size) | 0;
                    for (var i = 0; i < this._size; i = (i + 1) | 0) {
                        array[System.Array.index(((dstIndex = (dstIndex - 1) | 0)), array)] = this._array[System.Array.index(Bridge.identity(srcIndex, (srcIndex = (srcIndex + 1) | 0)), this._array)];
                    }
                } else {
                    System.Array.copy(this._array, 0, array, arrayIndex, this._size);
                    System.Array.reverse(array, arrayIndex, this._size);
                }
            },
            copyTo: function (array, arrayIndex) {
                if (array == null) {
                    throw new System.ArgumentNullException.$ctor1("array");
                }

                if (System.Array.getRank(array) !== 1) {
                    throw new System.ArgumentException.$ctor1("Only single dimensional arrays are supported for the requested action.");
                }

                if (System.Array.getLower(array, 0) !== 0) {
                    throw new System.ArgumentException.$ctor1("The lower bound of target array must be zero.");
                }

                if (arrayIndex < 0 || arrayIndex > array.length) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("arrayIndex", "Non-negative number required.");
                }

                if (((array.length - arrayIndex) | 0) < this._size) {
                    throw new System.ArgumentException.$ctor1("Offset and length were out of bounds for the array or count is greater than the number of elements from index to the end of the source collection.");
                }

                try {
                    System.Array.copy(this._array, 0, array, arrayIndex, this._size);
                    System.Array.reverse(array, arrayIndex, this._size);
                } catch ($e1) {
                    $e1 = System.Exception.create($e1);
                    throw new System.ArgumentException.$ctor1("Target array type is not compatible with the type of items in the collection.");
                }
            },
            GetEnumerator: function () {
                return new (System.Collections.Generic.Stack$1.Enumerator(T)).$ctor1(this);
            },
            System$Collections$Generic$IEnumerable$1$GetEnumerator: function () {
                return new (System.Collections.Generic.Stack$1.Enumerator(T)).$ctor1(this).$clone();
            },
            System$Collections$IEnumerable$GetEnumerator: function () {
                return new (System.Collections.Generic.Stack$1.Enumerator(T)).$ctor1(this).$clone();
            },
            TrimExcess: function () {
                var threshold = Bridge.Int.clip32(this._array.length * 0.9);
                if (this._size < threshold) {
                    var localArray = { v : this._array };
                    System.Array.resize(localArray, this._size, Bridge.getDefaultValue(T));
                    this._array = localArray.v;
                    this._version = (this._version + 1) | 0;
                }
            },
            Peek: function () {
                if (this._size === 0) {
                    throw new System.InvalidOperationException.$ctor1("Stack empty.");
                }
                return this._array[System.Array.index(((this._size - 1) | 0), this._array)];
            },
            Pop: function () {
                if (this._size === 0) {
                    throw new System.InvalidOperationException.$ctor1("Stack empty.");
                }
                this._version = (this._version + 1) | 0;
                var item = this._array[System.Array.index(((this._size = (this._size - 1) | 0)), this._array)];
                this._array[System.Array.index(this._size, this._array)] = Bridge.getDefaultValue(T);
                return item;
            },
            Push: function (item) {
                if (this._size === this._array.length) {
                    var localArray = { v : this._array };
                    System.Array.resize(localArray, (this._array.length === 0) ? System.Collections.Generic.Stack$1(T).DefaultCapacity : Bridge.Int.mul(2, this._array.length), Bridge.getDefaultValue(T));
                    this._array = localArray.v;
                }
                this._array[System.Array.index(Bridge.identity(this._size, (this._size = (this._size + 1) | 0)), this._array)] = item;
                this._version = (this._version + 1) | 0;
            },
            ToArray: function () {
                var objArray = System.Array.init(this._size, function (){
                    return Bridge.getDefaultValue(T);
                }, T);
                var i = 0;
                while (i < this._size) {
                    objArray[System.Array.index(i, objArray)] = this._array[System.Array.index(((((this._size - i) | 0) - 1) | 0), this._array)];
                    i = (i + 1) | 0;
                }
                return objArray;
            }
        }
    }; });

    // @source Enumerator.js

    Bridge.define("System.Collections.Generic.Stack$1.Enumerator", function (T) { return {
        inherits: [System.Collections.Generic.IEnumerator$1(T),System.Collections.IEnumerator],
        $kind: "nested struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new (System.Collections.Generic.Stack$1.Enumerator(T))(); }
            }
        },
        fields: {
            _stack: null,
            _index: 0,
            _version: 0,
            _currentElement: Bridge.getDefaultValue(T)
        },
        props: {
            Current: {
                get: function () {
                    if (this._index === -2) {
                        throw new System.InvalidOperationException.$ctor1("Enumeration has not started. Call MoveNext.");
                    }
                    if (this._index === -1) {
                        throw new System.InvalidOperationException.$ctor1("Enumeration already finished.");
                    }
                    return this._currentElement;
                }
            },
            System$Collections$IEnumerator$Current: {
                get: function () {
                    if (this._index === -2) {
                        throw new System.InvalidOperationException.$ctor1("Enumeration has not started. Call MoveNext.");
                    }
                    if (this._index === -1) {
                        throw new System.InvalidOperationException.$ctor1("Enumeration already finished.");
                    }
                    return this._currentElement;
                }
            }
        },
        alias: [
            "Dispose", "System$IDisposable$Dispose",
            "moveNext", "System$Collections$IEnumerator$moveNext",
            "Current", ["System$Collections$Generic$IEnumerator$1$" + Bridge.getTypeAlias(T) + "$Current$1", "System$Collections$Generic$IEnumerator$1$Current$1"]
        ],
        ctors: {
            $ctor1: function (stack) {
                this.$initialize();
                this._stack = stack;
                this._version = this._stack._version;
                this._index = -2;
                this._currentElement = Bridge.getDefaultValue(T);
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            Dispose: function () {
                this._index = -1;
            },
            moveNext: function () {
                var $t, $t1;
                var retval;
                if (this._version !== this._stack._version) {
                    throw new System.InvalidOperationException.$ctor1("Collection was modified; enumeration operation may not execute.");
                }
                if (this._index === -2) {
                    this._index = (this._stack._size - 1) | 0;
                    retval = (this._index >= 0);
                    if (retval) {
                        this._currentElement = ($t = this._stack._array)[System.Array.index(this._index, $t)];
                    }
                    return retval;
                }
                if (this._index === -1) {
                    return false;
                }

                retval = (((this._index = (this._index - 1) | 0)) >= 0);
                if (retval) {
                    this._currentElement = ($t1 = this._stack._array)[System.Array.index(this._index, $t1)];
                } else {
                    this._currentElement = Bridge.getDefaultValue(T);
                }
                return retval;
            },
            System$Collections$IEnumerator$reset: function () {
                if (this._version !== this._stack._version) {
                    throw new System.InvalidOperationException.$ctor1("Collection was modified; enumeration operation may not execute.");
                }
                this._index = -2;
                this._currentElement = Bridge.getDefaultValue(T);
            },
            getHashCode: function () {
                var h = Bridge.addHash([3788985113, this._stack, this._index, this._version, this._currentElement]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, System.Collections.Generic.Stack$1.Enumerator(T))) {
                    return false;
                }
                return Bridge.equals(this._stack, o._stack) && Bridge.equals(this._index, o._index) && Bridge.equals(this._version, o._version) && Bridge.equals(this._currentElement, o._currentElement);
            },
            $clone: function (to) {
                var s = to || new (System.Collections.Generic.Stack$1.Enumerator(T))();
                s._stack = this._stack;
                s._index = this._index;
                s._version = this._version;
                s._currentElement = this._currentElement;
                return s;
            }
        }
    }; });

    // @source HashHelpers.js

    Bridge.define("System.Collections.HashHelpers", {
        statics: {
            fields: {
                HashPrime: 0,
                RandomSeed: 0,
                primes: null,
                MaxPrimeArrayLength: 0
            },
            ctors: {
                init: function () {
                    this.HashPrime = 101;
                    this.RandomSeed = System.Guid.NewGuid().getHashCode();
                    this.primes = System.Array.init([
                        3, 
                        7, 
                        11, 
                        17, 
                        23, 
                        29, 
                        37, 
                        47, 
                        59, 
                        71, 
                        89, 
                        107, 
                        131, 
                        163, 
                        197, 
                        239, 
                        293, 
                        353, 
                        431, 
                        521, 
                        631, 
                        761, 
                        919, 
                        1103, 
                        1327, 
                        1597, 
                        1931, 
                        2333, 
                        2801, 
                        3371, 
                        4049, 
                        4861, 
                        5839, 
                        7013, 
                        8419, 
                        10103, 
                        12143, 
                        14591, 
                        17519, 
                        21023, 
                        25229, 
                        30293, 
                        36353, 
                        43627, 
                        52361, 
                        62851, 
                        75431, 
                        90523, 
                        108631, 
                        130363, 
                        156437, 
                        187751, 
                        225307, 
                        270371, 
                        324449, 
                        389357, 
                        467237, 
                        560689, 
                        672827, 
                        807403, 
                        968897, 
                        1162687, 
                        1395263, 
                        1674319, 
                        2009191, 
                        2411033, 
                        2893249, 
                        3471899, 
                        4166287, 
                        4999559, 
                        5999471, 
                        7199369
                    ], System.Int32);
                    this.MaxPrimeArrayLength = 2146435069;
                }
            },
            methods: {
                Combine: function (h1, h2) {
                    var rol5 = (((((h1 >>> 0) << 5) >>> 0)) | ((h1 >>> 0) >>> 27)) >>> 0;
                    return ((((rol5 | 0) + h1) | 0)) ^ h2;
                },
                IsPrime: function (candidate) {
                    if ((candidate & 1) !== 0) {
                        var limit = Bridge.Int.clip32(Math.sqrt(candidate));
                        for (var divisor = 3; divisor <= limit; divisor = (divisor + 2) | 0) {
                            if ((candidate % divisor) === 0) {
                                return false;
                            }
                        }
                        return true;
                    }
                    return (candidate === 2);
                },
                GetPrime: function (min) {
                    if (min < 0) {
                        throw new System.ArgumentException.$ctor1("Hashtable's capacity overflowed and went negative. Check load factor, capacity and the current size of the table.");
                    }
                    for (var i = 0; i < System.Collections.HashHelpers.primes.length; i = (i + 1) | 0) {
                        var prime = System.Collections.HashHelpers.primes[System.Array.index(i, System.Collections.HashHelpers.primes)];
                        if (prime >= min) {
                            return prime;
                        }
                    }
                    for (var i1 = (min | 1); i1 < 2147483647; i1 = (i1 + 2) | 0) {
                        if (System.Collections.HashHelpers.IsPrime(i1) && ((((i1 - 1) | 0)) % System.Collections.HashHelpers.HashPrime !== 0)) {
                            return i1;
                        }
                    }
                    return min;
                },
                GetMinPrime: function () {
                    return System.Collections.HashHelpers.primes[System.Array.index(0, System.Collections.HashHelpers.primes)];
                },
                ExpandPrime: function (oldSize) {
                    var newSize = Bridge.Int.mul(2, oldSize);
                    if ((newSize >>> 0) > System.Collections.HashHelpers.MaxPrimeArrayLength && System.Collections.HashHelpers.MaxPrimeArrayLength > oldSize) {
                        return System.Collections.HashHelpers.MaxPrimeArrayLength;
                    }
                    return System.Collections.HashHelpers.GetPrime(newSize);
                }
            }
        }
    });

    // @source Collection.js

    Bridge.define("System.Collections.ObjectModel.Collection$1", function (T) { return {
        inherits: [System.Collections.Generic.IList$1(T),System.Collections.IList,System.Collections.Generic.IReadOnlyList$1(T)],
        statics: {
            methods: {
                IsCompatibleObject: function (value) {
                    return ((Bridge.is(value, T)) || (value == null && Bridge.getDefaultValue(T) == null));
                }
            }
        },
        fields: {
            items: null,
            _syncRoot: null
        },
        props: {
            Count: {
                get: function () {
                    return System.Array.getCount(this.items, T);
                }
            },
            Items: {
                get: function () {
                    return this.items;
                }
            },
            System$Collections$Generic$ICollection$1$IsReadOnly: {
                get: function () {
                    return System.Array.getIsReadOnly(this.items, T);
                }
            },
            System$Collections$ICollection$IsSynchronized: {
                get: function () {
                    return false;
                }
            },
            System$Collections$ICollection$SyncRoot: {
                get: function () {
                    if (this._syncRoot == null) {
                        var c = Bridge.as(this.items, System.Collections.ICollection);
                        if (c != null) {
                            this._syncRoot = c.System$Collections$ICollection$SyncRoot;
                        } else {
                            throw System.NotImplemented.ByDesign;
                        }
                    }
                    return this._syncRoot;
                }
            },
            System$Collections$IList$IsReadOnly: {
                get: function () {
                    return System.Array.getIsReadOnly(this.items, T);
                }
            },
            System$Collections$IList$IsFixedSize: {
                get: function () {
                    var list = Bridge.as(this.items, System.Collections.IList);
                    if (list != null) {
                        return System.Array.isFixedSize(list);
                    }
                    return System.Array.getIsReadOnly(this.items, T);
                }
            }
        },
        alias: [
            "Count", ["System$Collections$Generic$IReadOnlyCollection$1$" + Bridge.getTypeAlias(T) + "$Count", "System$Collections$Generic$IReadOnlyCollection$1$Count"],
            "Count", "System$Collections$ICollection$Count",
            "Count", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$Count",
            "getItem", ["System$Collections$Generic$IReadOnlyList$1$" + Bridge.getTypeAlias(T) + "$getItem", "System$Collections$Generic$IReadOnlyList$1$getItem"],
            "setItem", ["System$Collections$Generic$IReadOnlyList$1$" + Bridge.getTypeAlias(T) + "$setItem", "System$Collections$Generic$IReadOnlyList$1$setItem"],
            "getItem", "System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(T) + "$getItem",
            "setItem", "System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(T) + "$setItem",
            "add", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$add",
            "clear", "System$Collections$IList$clear",
            "clear", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$clear",
            "copyTo", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$copyTo",
            "contains", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$contains",
            "GetEnumerator", ["System$Collections$Generic$IEnumerable$1$" + Bridge.getTypeAlias(T) + "$GetEnumerator", "System$Collections$Generic$IEnumerable$1$GetEnumerator"],
            "indexOf", "System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(T) + "$indexOf",
            "insert", "System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(T) + "$insert",
            "remove", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$remove",
            "removeAt", "System$Collections$IList$removeAt",
            "removeAt", "System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(T) + "$removeAt",
            "System$Collections$Generic$ICollection$1$IsReadOnly", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$IsReadOnly"
        ],
        ctors: {
            ctor: function () {
                this.$initialize();
                this.items = new (System.Collections.Generic.List$1(T)).ctor();
            },
            $ctor1: function (list) {
                this.$initialize();
                if (list == null) {
                    System.ThrowHelper.ThrowArgumentNullException(System.ExceptionArgument.list);
                }
                this.items = list;
            }
        },
        methods: {
            getItem: function (index) {
                return System.Array.getItem(this.items, index, T);
            },
            setItem: function (index, value) {
                if (System.Array.getIsReadOnly(this.items, T)) {
                    System.ThrowHelper.ThrowNotSupportedException$1(System.ExceptionResource.NotSupported_ReadOnlyCollection);
                }

                if (index < 0 || index >= System.Array.getCount(this.items, T)) {
                    System.ThrowHelper.ThrowArgumentOutOfRange_IndexException();
                }

                this.SetItem(index, value);
            },
            System$Collections$IList$getItem: function (index) {
                return System.Array.getItem(this.items, index, T);
            },
            System$Collections$IList$setItem: function (index, value) {
                System.ThrowHelper.IfNullAndNullsAreIllegalThenThrow(T, value, System.ExceptionArgument.value);

                try {
                    this.setItem(index, Bridge.cast(Bridge.unbox(value, T), T));
                } catch ($e1) {
                    $e1 = System.Exception.create($e1);
                    if (Bridge.is($e1, System.InvalidCastException)) {
                        System.ThrowHelper.ThrowWrongValueTypeArgumentException(System.Object, value, T);
                    } else {
                        throw $e1;
                    }
                }
            },
            add: function (item) {
                if (System.Array.getIsReadOnly(this.items, T)) {
                    System.ThrowHelper.ThrowNotSupportedException$1(System.ExceptionResource.NotSupported_ReadOnlyCollection);
                }

                var index = System.Array.getCount(this.items, T);
                this.InsertItem(index, item);
            },
            System$Collections$IList$add: function (value) {
                if (System.Array.getIsReadOnly(this.items, T)) {
                    System.ThrowHelper.ThrowNotSupportedException$1(System.ExceptionResource.NotSupported_ReadOnlyCollection);
                }
                System.ThrowHelper.IfNullAndNullsAreIllegalThenThrow(T, value, System.ExceptionArgument.value);

                try {
                    this.add(Bridge.cast(Bridge.unbox(value, T), T));
                } catch ($e1) {
                    $e1 = System.Exception.create($e1);
                    if (Bridge.is($e1, System.InvalidCastException)) {
                        System.ThrowHelper.ThrowWrongValueTypeArgumentException(System.Object, value, T);
                    } else {
                        throw $e1;
                    }
                }

                return ((this.Count - 1) | 0);
            },
            clear: function () {
                if (System.Array.getIsReadOnly(this.items, T)) {
                    System.ThrowHelper.ThrowNotSupportedException$1(System.ExceptionResource.NotSupported_ReadOnlyCollection);
                }

                this.ClearItems();
            },
            copyTo: function (array, index) {
                System.Array.copyTo(this.items, array, index, T);
            },
            System$Collections$ICollection$copyTo: function (array, index) {
                if (array == null) {
                    System.ThrowHelper.ThrowArgumentNullException(System.ExceptionArgument.array);
                }

                if (System.Array.getRank(array) !== 1) {
                    System.ThrowHelper.ThrowArgumentException(System.ExceptionResource.Arg_RankMultiDimNotSupported);
                }

                if (System.Array.getLower(array, 0) !== 0) {
                    System.ThrowHelper.ThrowArgumentException(System.ExceptionResource.Arg_NonZeroLowerBound);
                }

                if (index < 0) {
                    System.ThrowHelper.ThrowIndexArgumentOutOfRange_NeedNonNegNumException();
                }

                if (((array.length - index) | 0) < this.Count) {
                    System.ThrowHelper.ThrowArgumentException(System.ExceptionResource.Arg_ArrayPlusOffTooSmall);
                }

                var tArray = Bridge.as(array, System.Array.type(T));
                if (tArray != null) {
                    System.Array.copyTo(this.items, tArray, index, T);
                } else {
                    var targetType = (Bridge.getType(array).$elementType || null);
                    var sourceType = T;
                    if (!(Bridge.Reflection.isAssignableFrom(targetType, sourceType) || Bridge.Reflection.isAssignableFrom(sourceType, targetType))) {
                        System.ThrowHelper.ThrowArgumentException_Argument_InvalidArrayType();
                    }

                    var objects = Bridge.as(array, System.Array.type(System.Object));
                    if (objects == null) {
                        System.ThrowHelper.ThrowArgumentException_Argument_InvalidArrayType();
                    }

                    var count = System.Array.getCount(this.items, T);
                    try {
                        for (var i = 0; i < count; i = (i + 1) | 0) {
                            objects[System.Array.index(Bridge.identity(index, (index = (index + 1) | 0)), objects)] = System.Array.getItem(this.items, i, T);
                        }
                    } catch ($e1) {
                        $e1 = System.Exception.create($e1);
                        if (Bridge.is($e1, System.ArrayTypeMismatchException)) {
                            System.ThrowHelper.ThrowArgumentException_Argument_InvalidArrayType();
                        } else {
                            throw $e1;
                        }
                    }
                }
            },
            contains: function (item) {
                return System.Array.contains(this.items, item, T);
            },
            System$Collections$IList$contains: function (value) {
                if (System.Collections.ObjectModel.Collection$1(T).IsCompatibleObject(value)) {
                    return this.contains(Bridge.cast(Bridge.unbox(value, T), T));
                }
                return false;
            },
            GetEnumerator: function () {
                return Bridge.getEnumerator(this.items, T);
            },
            System$Collections$IEnumerable$GetEnumerator: function () {
                return Bridge.getEnumerator(Bridge.cast(this.items, System.Collections.IEnumerable));
            },
            indexOf: function (item) {
                return System.Array.indexOf(this.items, item, 0, null, T);
            },
            System$Collections$IList$indexOf: function (value) {
                if (System.Collections.ObjectModel.Collection$1(T).IsCompatibleObject(value)) {
                    return this.indexOf(Bridge.cast(Bridge.unbox(value, T), T));
                }
                return -1;
            },
            insert: function (index, item) {
                if (System.Array.getIsReadOnly(this.items, T)) {
                    System.ThrowHelper.ThrowNotSupportedException$1(System.ExceptionResource.NotSupported_ReadOnlyCollection);
                }

                if (index < 0 || index > System.Array.getCount(this.items, T)) {
                    System.ThrowHelper.ThrowArgumentOutOfRangeException$2(System.ExceptionArgument.index, System.ExceptionResource.ArgumentOutOfRange_ListInsert);
                }

                this.InsertItem(index, item);
            },
            System$Collections$IList$insert: function (index, value) {
                if (System.Array.getIsReadOnly(this.items, T)) {
                    System.ThrowHelper.ThrowNotSupportedException$1(System.ExceptionResource.NotSupported_ReadOnlyCollection);
                }
                System.ThrowHelper.IfNullAndNullsAreIllegalThenThrow(T, value, System.ExceptionArgument.value);

                try {
                    this.insert(index, Bridge.cast(Bridge.unbox(value, T), T));
                } catch ($e1) {
                    $e1 = System.Exception.create($e1);
                    if (Bridge.is($e1, System.InvalidCastException)) {
                        System.ThrowHelper.ThrowWrongValueTypeArgumentException(System.Object, value, T);
                    } else {
                        throw $e1;
                    }
                }
            },
            remove: function (item) {
                if (System.Array.getIsReadOnly(this.items, T)) {
                    System.ThrowHelper.ThrowNotSupportedException$1(System.ExceptionResource.NotSupported_ReadOnlyCollection);
                }

                var index = System.Array.indexOf(this.items, item, 0, null, T);
                if (index < 0) {
                    return false;
                }
                this.RemoveItem(index);
                return true;
            },
            System$Collections$IList$remove: function (value) {
                if (System.Array.getIsReadOnly(this.items, T)) {
                    System.ThrowHelper.ThrowNotSupportedException$1(System.ExceptionResource.NotSupported_ReadOnlyCollection);
                }

                if (System.Collections.ObjectModel.Collection$1(T).IsCompatibleObject(value)) {
                    this.remove(Bridge.cast(Bridge.unbox(value, T), T));
                }
            },
            removeAt: function (index) {
                if (System.Array.getIsReadOnly(this.items, T)) {
                    System.ThrowHelper.ThrowNotSupportedException$1(System.ExceptionResource.NotSupported_ReadOnlyCollection);
                }

                if (index < 0 || index >= System.Array.getCount(this.items, T)) {
                    System.ThrowHelper.ThrowArgumentOutOfRange_IndexException();
                }

                this.RemoveItem(index);
            },
            ClearItems: function () {
                System.Array.clear(this.items, T);
            },
            InsertItem: function (index, item) {
                System.Array.insert(this.items, index, item, T);
            },
            RemoveItem: function (index) {
                System.Array.removeAt(this.items, index, T);
            },
            SetItem: function (index, item) {
                System.Array.setItem(this.items, index, item, T);
            }
        }
    }; });

    // @source ReadOnlyCollection.js

    Bridge.define("System.Collections.ObjectModel.ReadOnlyCollection$1", function (T) { return {
        inherits: [System.Collections.Generic.IList$1(T),System.Collections.IList,System.Collections.Generic.IReadOnlyList$1(T)],
        statics: {
            methods: {
                IsCompatibleObject: function (value) {
                    return ((Bridge.is(value, T)) || (value == null && Bridge.getDefaultValue(T) == null));
                }
            }
        },
        fields: {
            list: null
        },
        props: {
            Count: {
                get: function () {
                    return System.Array.getCount(this.list, T);
                }
            },
            System$Collections$ICollection$IsSynchronized: {
                get: function () {
                    return false;
                }
            },
            System$Collections$ICollection$SyncRoot: {
                get: function () {
                    return this;
                }
            },
            Items: {
                get: function () {
                    return this.list;
                }
            },
            System$Collections$IList$IsFixedSize: {
                get: function () {
                    return true;
                }
            },
            System$Collections$Generic$ICollection$1$IsReadOnly: {
                get: function () {
                    return true;
                }
            },
            System$Collections$IList$IsReadOnly: {
                get: function () {
                    return true;
                }
            }
        },
        alias: [
            "Count", ["System$Collections$Generic$IReadOnlyCollection$1$" + Bridge.getTypeAlias(T) + "$Count", "System$Collections$Generic$IReadOnlyCollection$1$Count"],
            "Count", "System$Collections$ICollection$Count",
            "Count", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$Count",
            "getItem", ["System$Collections$Generic$IReadOnlyList$1$" + Bridge.getTypeAlias(T) + "$getItem", "System$Collections$Generic$IReadOnlyList$1$getItem"],
            "contains", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$contains",
            "copyTo", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$copyTo",
            "GetEnumerator", ["System$Collections$Generic$IEnumerable$1$" + Bridge.getTypeAlias(T) + "$GetEnumerator", "System$Collections$Generic$IEnumerable$1$GetEnumerator"],
            "indexOf", "System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(T) + "$indexOf",
            "System$Collections$Generic$ICollection$1$IsReadOnly", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$IsReadOnly",
            "System$Collections$Generic$IList$1$getItem", "System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(T) + "$getItem",
            "System$Collections$Generic$IList$1$setItem", "System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(T) + "$setItem",
            "System$Collections$Generic$ICollection$1$add", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$add",
            "System$Collections$Generic$ICollection$1$clear", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$clear",
            "System$Collections$Generic$IList$1$insert", "System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(T) + "$insert",
            "System$Collections$Generic$ICollection$1$remove", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$remove",
            "System$Collections$Generic$IList$1$removeAt", "System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(T) + "$removeAt"
        ],
        ctors: {
            ctor: function (list) {
                this.$initialize();
                if (list == null) {
                    throw new System.ArgumentNullException.$ctor1("list");
                }
                this.list = list;
            }
        },
        methods: {
            getItem: function (index) {
                return System.Array.getItem(this.list, index, T);
            },
            System$Collections$Generic$IList$1$getItem: function (index) {
                return System.Array.getItem(this.list, index, T);
            },
            System$Collections$Generic$IList$1$setItem: function (index, value) {
                throw new System.NotSupportedException.ctor();
            },
            System$Collections$IList$getItem: function (index) {
                return System.Array.getItem(this.list, index, T);
            },
            System$Collections$IList$setItem: function (index, value) {
                throw new System.NotSupportedException.ctor();
            },
            contains: function (value) {
                return System.Array.contains(this.list, value, T);
            },
            System$Collections$IList$contains: function (value) {
                if (System.Collections.ObjectModel.ReadOnlyCollection$1(T).IsCompatibleObject(value)) {
                    return this.contains(Bridge.cast(Bridge.unbox(value, T), T));
                }
                return false;
            },
            copyTo: function (array, index) {
                System.Array.copyTo(this.list, array, index, T);
            },
            System$Collections$ICollection$copyTo: function (array, index) {
                if (array == null) {
                    throw new System.ArgumentNullException.$ctor1("array");
                }

                if (System.Array.getRank(array) !== 1) {
                    throw new System.ArgumentException.$ctor1("array");
                }

                if (System.Array.getLower(array, 0) !== 0) {
                    throw new System.ArgumentException.$ctor1("array");
                }

                if (index < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("index");
                }

                if (((array.length - index) | 0) < this.Count) {
                    throw new System.ArgumentException.ctor();
                }

                var items = Bridge.as(array, System.Array.type(T));
                if (items != null) {
                    System.Array.copyTo(this.list, items, index, T);
                } else {
                    var targetType = (Bridge.getType(array).$elementType || null);
                    var sourceType = T;
                    if (!(Bridge.Reflection.isAssignableFrom(targetType, sourceType) || Bridge.Reflection.isAssignableFrom(sourceType, targetType))) {
                        throw new System.ArgumentException.ctor();
                    }

                    var objects = Bridge.as(array, System.Array.type(System.Object));
                    if (objects == null) {
                        throw new System.ArgumentException.ctor();
                    }

                    var count = System.Array.getCount(this.list, T);
                    for (var i = 0; i < count; i = (i + 1) | 0) {
                        objects[System.Array.index(Bridge.identity(index, (index = (index + 1) | 0)), objects)] = System.Array.getItem(this.list, i, T);
                    }
                }
            },
            GetEnumerator: function () {
                return Bridge.getEnumerator(this.list, T);
            },
            System$Collections$IEnumerable$GetEnumerator: function () {
                return Bridge.getEnumerator(Bridge.cast(this.list, System.Collections.IEnumerable));
            },
            indexOf: function (value) {
                return System.Array.indexOf(this.list, value, 0, null, T);
            },
            System$Collections$IList$indexOf: function (value) {
                if (System.Collections.ObjectModel.ReadOnlyCollection$1(T).IsCompatibleObject(value)) {
                    return this.indexOf(Bridge.cast(Bridge.unbox(value, T), T));
                }
                return -1;
            },
            System$Collections$Generic$ICollection$1$add: function (value) {
                throw new System.NotSupportedException.ctor();
            },
            System$Collections$IList$add: function (value) {
                throw new System.NotSupportedException.ctor();
            },
            System$Collections$Generic$ICollection$1$clear: function () {
                throw new System.NotSupportedException.ctor();
            },
            System$Collections$IList$clear: function () {
                throw new System.NotSupportedException.ctor();
            },
            System$Collections$Generic$IList$1$insert: function (index, value) {
                throw new System.NotSupportedException.ctor();
            },
            System$Collections$IList$insert: function (index, value) {
                throw new System.NotSupportedException.ctor();
            },
            System$Collections$Generic$ICollection$1$remove: function (value) {
                throw new System.NotSupportedException.ctor();
            },
            System$Collections$IList$remove: function (value) {
                throw new System.NotSupportedException.ctor();
            },
            System$Collections$Generic$IList$1$removeAt: function (index) {
                throw new System.NotSupportedException.ctor();
            },
            System$Collections$IList$removeAt: function (index) {
                throw new System.NotSupportedException.ctor();
            }
        }
    }; });

    // @source BrowsableAttribute.js

    Bridge.define("System.ComponentModel.BrowsableAttribute", {
        inherits: [System.Attribute],
        statics: {
            fields: {
                yes: null,
                no: null,
                default: null
            },
            ctors: {
                init: function () {
                    this.yes = new System.ComponentModel.BrowsableAttribute(true);
                    this.no = new System.ComponentModel.BrowsableAttribute(false);
                    this.default = System.ComponentModel.BrowsableAttribute.yes;
                }
            }
        },
        fields: {
            browsable: false
        },
        props: {
            Browsable: {
                get: function () {
                    return this.browsable;
                }
            }
        },
        ctors: {
            init: function () {
                this.browsable = true;
            },
            ctor: function (browsable) {
                this.$initialize();
                System.Attribute.ctor.call(this);
                this.browsable = browsable;
            }
        },
        methods: {
            equals: function (obj) {
                if (Bridge.referenceEquals(obj, this)) {
                    return true;
                }

                var other = Bridge.as(obj, System.ComponentModel.BrowsableAttribute);

                return (other != null) && other.Browsable === this.browsable;
            },
            getHashCode: function () {
                return Bridge.getHashCode(this.browsable);
            }
        }
    });

    // @source DefaultValueAttribute.js

    Bridge.define("System.ComponentModel.DefaultValueAttribute", {
        inherits: [System.Attribute],
        fields: {
            _value: null
        },
        props: {
            Value: {
                get: function () {
                    return this._value;
                }
            }
        },
        ctors: {
            $ctor11: function (type, value) {
                this.$initialize();
                System.Attribute.ctor.call(this);
                try {
                    if ((type.prototype instanceof System.Enum)) {
                        this._value = System.Enum.parse(type, value, true);
                    } else if (Bridge.referenceEquals(type, System.TimeSpan)) {
                        throw System.NotImplemented.ByDesign;
                    } else {
                        throw System.NotImplemented.ByDesign;
                    }
                } catch ($e1) {
                    $e1 = System.Exception.create($e1);
                }
            },
            $ctor2: function (value) {
                this.$initialize();
                System.Attribute.ctor.call(this);
                this._value = Bridge.box(value, System.Char, String.fromCharCode, System.Char.getHashCode);
            },
            $ctor1: function (value) {
                this.$initialize();
                System.Attribute.ctor.call(this);
                this._value = Bridge.box(value, System.Byte);
            },
            $ctor4: function (value) {
                this.$initialize();
                System.Attribute.ctor.call(this);
                this._value = Bridge.box(value, System.Int16);
            },
            $ctor5: function (value) {
                this.$initialize();
                System.Attribute.ctor.call(this);
                this._value = Bridge.box(value, System.Int32);
            },
            $ctor6: function (value) {
                this.$initialize();
                System.Attribute.ctor.call(this);
                this._value = value;
            },
            $ctor9: function (value) {
                this.$initialize();
                System.Attribute.ctor.call(this);
                this._value = Bridge.box(value, System.Single, System.Single.format, System.Single.getHashCode);
            },
            $ctor3: function (value) {
                this.$initialize();
                System.Attribute.ctor.call(this);
                this._value = Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode);
            },
            ctor: function (value) {
                this.$initialize();
                System.Attribute.ctor.call(this);
                this._value = Bridge.box(value, System.Boolean, System.Boolean.toString);
            },
            $ctor10: function (value) {
                this.$initialize();
                System.Attribute.ctor.call(this);
                this._value = value;
            },
            $ctor7: function (value) {
                this.$initialize();
                System.Attribute.ctor.call(this);
                this._value = value;
            },
            $ctor8: function (value) {
                this.$initialize();
                System.Attribute.ctor.call(this);
                this._value = Bridge.box(value, System.SByte);
            },
            $ctor12: function (value) {
                this.$initialize();
                System.Attribute.ctor.call(this);
                this._value = Bridge.box(value, System.UInt16);
            },
            $ctor13: function (value) {
                this.$initialize();
                System.Attribute.ctor.call(this);
                this._value = Bridge.box(value, System.UInt32);
            },
            $ctor14: function (value) {
                this.$initialize();
                System.Attribute.ctor.call(this);
                this._value = value;
            }
        },
        methods: {
            equals: function (obj) {
                if (Bridge.referenceEquals(obj, this)) {
                    return true;
                }

                var other = Bridge.as(obj, System.ComponentModel.DefaultValueAttribute);

                if (other != null) {
                    if (this.Value != null) {
                        return Bridge.equals(this.Value, other.Value);
                    } else {
                        return (other.Value == null);
                    }
                }
                return false;
            },
            getHashCode: function () {
                return Bridge.getHashCode(this);
            },
            setValue: function (value) {
                this._value = value;
            }
        }
    });

    // @source Console.js

    Bridge.define("System.Console", {
        statics: {
            methods: {
                Write: function (value) {
                    var con = Bridge.global.console;

                    if (con && con.log) {
                        con.log(!Bridge.isDefined(Bridge.unbox(value)) ? "" : Bridge.unbox(value));
                    }
                },
                WriteLine: function (value) {
                    var con = Bridge.global.console;

                    if (con && con.log) {
                        con.log(!Bridge.isDefined(Bridge.unbox(value)) ? "" : Bridge.unbox(value));
                    }
                },
                TransformChars: function (buffer, all, index, count) {
                    if (all !== 1) {
                        if (buffer == null) {
                            throw new System.ArgumentNullException.$ctor1("buffer");
                        }

                        if (index < 0) {
                            throw new System.ArgumentOutOfRangeException.$ctor4("index", "less than zero");
                        }

                        if (count < 0) {
                            throw new System.ArgumentOutOfRangeException.$ctor4("count", "less than zero");
                        }

                        if (((index + count) | 0) > buffer.length) {
                            throw new System.ArgumentException.$ctor1("index plus count specify a position that is not within buffer.");
                        }
                    }

                    var s = "";
                    if (buffer != null) {
                        if (all === 1) {
                            index = 0;
                            count = buffer.length;
                        }

                        for (var i = index; i < ((index + count) | 0); i = (i + 1) | 0) {
                            s = (s || "") + String.fromCharCode(buffer[System.Array.index(i, buffer)]);
                        }
                    }

                    return s;
                },
                Clear: function () {
                    var con = Bridge.global.console;

                    if (con && con.clear) {
                        con.clear();
                    }
                }
            }
        }
    });

    // @source TokenType.js

    Bridge.define("System.TokenType", {
        $kind: "enum",
        statics: {
            fields: {
                NumberToken: 1,
                YearNumberToken: 2,
                Am: 3,
                Pm: 4,
                MonthToken: 5,
                EndOfString: 6,
                DayOfWeekToken: 7,
                TimeZoneToken: 8,
                EraToken: 9,
                DateWordToken: 10,
                UnknownToken: 11,
                HebrewNumber: 12,
                JapaneseEraToken: 13,
                TEraToken: 14,
                IgnorableSymbol: 15,
                SEP_Unk: 256,
                SEP_End: 512,
                SEP_Space: 768,
                SEP_Am: 1024,
                SEP_Pm: 1280,
                SEP_Date: 1536,
                SEP_Time: 1792,
                SEP_YearSuff: 2048,
                SEP_MonthSuff: 2304,
                SEP_DaySuff: 2560,
                SEP_HourSuff: 2816,
                SEP_MinuteSuff: 3072,
                SEP_SecondSuff: 3328,
                SEP_LocalTimeMark: 3584,
                SEP_DateOrOffset: 3840,
                RegularTokenMask: 255,
                SeparatorTokenMask: 65280
            }
        }
    });

    // @source UnitySerializationHolder.js

    Bridge.define("System.UnitySerializationHolder", {
        inherits: [System.Runtime.Serialization.ISerializable,System.Runtime.Serialization.IObjectReference],
        statics: {
            fields: {
                NullUnity: 0
            },
            ctors: {
                init: function () {
                    this.NullUnity = 2;
                }
            }
        },
        alias: ["GetRealObject", "System$Runtime$Serialization$IObjectReference$GetRealObject"],
        methods: {
            GetRealObject: function (context) {
                throw System.NotImplemented.ByDesign;

            }
        }
    });

    // @source DateTimeKind.js

    Bridge.define("System.DateTimeKind", {
        $kind: "enum",
        statics: {
            fields: {
                Unspecified: 0,
                Utc: 1,
                Local: 2
            }
        }
    });

    // @source DateTimeOffset.js

    Bridge.define("System.DateTimeOffset", {
        inherits: function () { return [System.IComparable,System.IFormattable,System.Runtime.Serialization.ISerializable,System.Runtime.Serialization.IDeserializationCallback,System.IComparable$1(System.DateTimeOffset),System.IEquatable$1(System.DateTimeOffset)]; },
        $kind: "struct",
        statics: {
            fields: {
                MaxOffset: System.Int64(0),
                MinOffset: System.Int64(0),
                UnixEpochTicks: System.Int64(0),
                UnixEpochSeconds: System.Int64(0),
                UnixEpochMilliseconds: System.Int64(0),
                MinValue: null,
                MaxValue: null
            },
            props: {
                Now: {
                    get: function () {
                        return new System.DateTimeOffset.$ctor1(System.DateTime.getNow());
                    }
                },
                UtcNow: {
                    get: function () {
                        return new System.DateTimeOffset.$ctor1(System.DateTime.getUtcNow());
                    }
                }
            },
            ctors: {
                init: function () {
                    this.MinValue = new System.DateTimeOffset();
                    this.MaxValue = new System.DateTimeOffset();
                    this.MaxOffset = System.Int64([1488826368,117]);
                    this.MinOffset = System.Int64([-1488826368,-118]);
                    this.UnixEpochTicks = System.Int64([-139100160,144670709]);
                    this.UnixEpochSeconds = System.Int64([2006054656,14]);
                    this.UnixEpochMilliseconds = System.Int64([304928768,14467]);
                    this.MinValue = new System.DateTimeOffset.$ctor5(System.DateTime.MinTicks, System.TimeSpan.zero);
                    this.MaxValue = new System.DateTimeOffset.$ctor5(System.DateTime.MaxTicks, System.TimeSpan.zero);
                }
            },
            methods: {
                Compare: function (first, second) {
                    return Bridge.compare(first.UtcDateTime, second.UtcDateTime);
                },
                Equals: function (first, second) {
                    return Bridge.equalsT(first.UtcDateTime, second.UtcDateTime);
                },
                FromFileTime: function (fileTime) {
                    return new System.DateTimeOffset.$ctor1(System.DateTime.FromFileTime(fileTime));
                },
                FromUnixTimeSeconds: function (seconds) {
                    var MinSeconds = System.Int64([-2006054656,-15]);
                    var MaxSeconds = System.Int64([-769665,58]);

                    if (seconds.lt(MinSeconds) || seconds.gt(MaxSeconds)) {
                        throw new System.ArgumentOutOfRangeException.$ctor4("seconds", System.String.format(System.Environment.GetResourceString("ArgumentOutOfRange_Range"), MinSeconds, MaxSeconds));
                    }

                    var ticks = seconds.mul(System.Int64(10000000)).add(System.DateTimeOffset.UnixEpochTicks);
                    return new System.DateTimeOffset.$ctor5(ticks, System.TimeSpan.zero);
                },
                FromUnixTimeMilliseconds: function (milliseconds) {
                    var MinMilliseconds = System.Int64([-304928768,-14468]);
                    var MaxMilliseconds = System.Int64([-769664001,58999]);

                    if (milliseconds.lt(MinMilliseconds) || milliseconds.gt(MaxMilliseconds)) {
                        throw new System.ArgumentOutOfRangeException.$ctor4("milliseconds", System.String.format(System.Environment.GetResourceString("ArgumentOutOfRange_Range"), MinMilliseconds, MaxMilliseconds));
                    }

                    var ticks = milliseconds.mul(System.Int64(10000)).add(System.DateTimeOffset.UnixEpochTicks);
                    return new System.DateTimeOffset.$ctor5(ticks, System.TimeSpan.zero);
                },
                Parse: function (input) {
                    var offset = { };
                    var dateResult = System.DateTimeParse.Parse$1(input, System.Globalization.DateTimeFormatInfo.currentInfo, 0, offset);
                    return new System.DateTimeOffset.$ctor5(System.DateTime.getTicks(dateResult), offset.v);
                },
                Parse$1: function (input, formatProvider) {
                    return System.DateTimeOffset.Parse$2(input, formatProvider, 0);
                },
                Parse$2: function (input, formatProvider, styles) {
                    throw System.NotImplemented.ByDesign;
                },
                ParseExact: function (input, format, formatProvider) {
                    return System.DateTimeOffset.ParseExact$1(input, format, formatProvider, 0);
                },
                ParseExact$1: function (input, format, formatProvider, styles) {
                    throw System.NotImplemented.ByDesign;
                },
                TryParse: function (input, result) {
                    var offset = { };
                    var dateResult = { };
                    var parsed = System.DateTimeParse.TryParse$1(input, System.Globalization.DateTimeFormatInfo.currentInfo, 0, dateResult, offset);
                    result.v = new System.DateTimeOffset.$ctor5(System.DateTime.getTicks(dateResult.v), offset.v);
                    return parsed;
                },
                ValidateOffset: function (offset) {
                    var ticks = offset.getTicks();
                    if (ticks.mod(System.Int64(600000000)).ne(System.Int64(0))) {
                        throw new System.ArgumentException.$ctor3(System.Environment.GetResourceString("Argument_OffsetPrecision"), "offset");
                    }
                    if (ticks.lt(System.DateTimeOffset.MinOffset) || ticks.gt(System.DateTimeOffset.MaxOffset)) {
                        throw new System.ArgumentOutOfRangeException.$ctor4("offset", System.Environment.GetResourceString("Argument_OffsetOutOfRange"));
                    }
                    return System.Int64.clip16(offset.getTicks().div(System.Int64(600000000)));
                },
                ValidateDate: function (dateTime, offset) {
                    var utcTicks = System.DateTime.getTicks(dateTime).sub(offset.getTicks());
                    if (utcTicks.lt(System.DateTime.MinTicks) || utcTicks.gt(System.DateTime.MaxTicks)) {
                        throw new System.ArgumentOutOfRangeException.$ctor4("offset", System.Environment.GetResourceString("Argument_UTCOutOfRange"));
                    }
                    return System.DateTime.create$2(utcTicks, 0);
                },
                op_Implicit: function (dateTime) {
                    return new System.DateTimeOffset.$ctor1(dateTime);
                },
                op_Addition: function (dateTimeOffset, timeSpan) {
                    return new System.DateTimeOffset.$ctor2(System.DateTime.adddt(dateTimeOffset.ClockDateTime, timeSpan), dateTimeOffset.Offset);
                },
                op_Subtraction: function (dateTimeOffset, timeSpan) {
                    return new System.DateTimeOffset.$ctor2(System.DateTime.subdt(dateTimeOffset.ClockDateTime, timeSpan), dateTimeOffset.Offset);
                },
                op_Subtraction$1: function (left, right) {
                    return System.DateTime.subdd(left.UtcDateTime, right.UtcDateTime);
                },
                op_Equality: function (left, right) {
                    return Bridge.equals(left.UtcDateTime, right.UtcDateTime);
                },
                op_Inequality: function (left, right) {
                    return !Bridge.equals(left.UtcDateTime, right.UtcDateTime);
                },
                op_LessThan: function (left, right) {
                    return System.DateTime.lt(left.UtcDateTime, right.UtcDateTime);
                },
                op_LessThanOrEqual: function (left, right) {
                    return System.DateTime.lte(left.UtcDateTime, right.UtcDateTime);
                },
                op_GreaterThan: function (left, right) {
                    return System.DateTime.gt(left.UtcDateTime, right.UtcDateTime);
                },
                op_GreaterThanOrEqual: function (left, right) {
                    return System.DateTime.gte(left.UtcDateTime, right.UtcDateTime);
                },
                getDefaultValue: function () { return new System.DateTimeOffset(); }
            }
        },
        fields: {
            m_dateTime: null,
            m_offsetMinutes: 0
        },
        props: {
            DateTime: {
                get: function () {
                    return this.ClockDateTime;
                }
            },
            UtcDateTime: {
                get: function () {
                    return System.DateTime.specifyKind(this.m_dateTime, 1);
                }
            },
            LocalDateTime: {
                get: function () {
                    return System.DateTime.toLocalTime(this.UtcDateTime);
                }
            },
            ClockDateTime: {
                get: function () {
                    return System.DateTime.create$2(System.DateTime.getTicks((System.DateTime.adddt(this.m_dateTime, this.Offset))), 0);
                }
            },
            Date: {
                get: function () {
                    return System.DateTime.getDate(this.ClockDateTime);
                }
            },
            Day: {
                get: function () {
                    return System.DateTime.getDay(this.ClockDateTime);
                }
            },
            DayOfWeek: {
                get: function () {
                    return System.DateTime.getDayOfWeek(this.ClockDateTime);
                }
            },
            DayOfYear: {
                get: function () {
                    return System.DateTime.getDayOfYear(this.ClockDateTime);
                }
            },
            Hour: {
                get: function () {
                    return System.DateTime.getHour(this.ClockDateTime);
                }
            },
            Millisecond: {
                get: function () {
                    return System.DateTime.getMillisecond(this.ClockDateTime);
                }
            },
            Minute: {
                get: function () {
                    return System.DateTime.getMinute(this.ClockDateTime);
                }
            },
            Month: {
                get: function () {
                    return System.DateTime.getMonth(this.ClockDateTime);
                }
            },
            Offset: {
                get: function () {
                    return new System.TimeSpan(0, this.m_offsetMinutes, 0);
                }
            },
            Second: {
                get: function () {
                    return System.DateTime.getSecond(this.ClockDateTime);
                }
            },
            Ticks: {
                get: function () {
                    return System.DateTime.getTicks(this.ClockDateTime);
                }
            },
            UtcTicks: {
                get: function () {
                    return System.DateTime.getTicks(this.UtcDateTime);
                }
            },
            TimeOfDay: {
                get: function () {
                    return System.DateTime.getTimeOfDay(this.ClockDateTime);
                }
            },
            Year: {
                get: function () {
                    return System.DateTime.getYear(this.ClockDateTime);
                }
            }
        },
        alias: [
            "compareTo", ["System$IComparable$1$System$DateTimeOffset$compareTo", "System$IComparable$1$compareTo"],
            "equalsT", "System$IEquatable$1$System$DateTimeOffset$equalsT",
            "format", "System$IFormattable$format"
        ],
        ctors: {
            init: function () {
                this.m_dateTime = System.DateTime.getDefaultValue();
            },
            $ctor5: function (ticks, offset) {
                this.$initialize();
                this.m_offsetMinutes = System.DateTimeOffset.ValidateOffset(offset);
                var dateTime = System.DateTime.create$2(ticks);
                this.m_dateTime = System.DateTimeOffset.ValidateDate(dateTime, offset);
            },
            $ctor1: function (dateTime) {
                this.$initialize();
                var offset;

                offset = new System.TimeSpan(System.Int64(0));
                this.m_offsetMinutes = System.DateTimeOffset.ValidateOffset(offset);
                this.m_dateTime = System.DateTimeOffset.ValidateDate(dateTime, offset);
            },
            $ctor2: function (dateTime, offset) {
                this.$initialize();
                this.m_offsetMinutes = System.DateTimeOffset.ValidateOffset(offset);
                this.m_dateTime = System.DateTimeOffset.ValidateDate(dateTime, offset);
            },
            $ctor4: function (year, month, day, hour, minute, second, offset) {
                this.$initialize();
                this.m_offsetMinutes = System.DateTimeOffset.ValidateOffset(offset);
                this.m_dateTime = System.DateTimeOffset.ValidateDate(System.DateTime.create(year, month, day, hour, minute, second), offset);
            },
            $ctor3: function (year, month, day, hour, minute, second, millisecond, offset) {
                this.$initialize();
                this.m_offsetMinutes = System.DateTimeOffset.ValidateOffset(offset);
                this.m_dateTime = System.DateTimeOffset.ValidateDate(System.DateTime.create(year, month, day, hour, minute, second, millisecond), offset);
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            ToOffset: function (offset) {
                return new System.DateTimeOffset.$ctor5(System.DateTime.getTicks((System.DateTime.adddt(this.m_dateTime, offset))), offset);
            },
            Add: function (timeSpan) {
                return new System.DateTimeOffset.$ctor2(System.DateTime.add(this.ClockDateTime, timeSpan), this.Offset);
            },
            AddDays: function (days) {
                return new System.DateTimeOffset.$ctor2(System.DateTime.addDays(this.ClockDateTime, days), this.Offset);
            },
            AddHours: function (hours) {
                return new System.DateTimeOffset.$ctor2(System.DateTime.addHours(this.ClockDateTime, hours), this.Offset);
            },
            AddMilliseconds: function (milliseconds) {
                return new System.DateTimeOffset.$ctor2(System.DateTime.addMilliseconds(this.ClockDateTime, milliseconds), this.Offset);
            },
            AddMinutes: function (minutes) {
                return new System.DateTimeOffset.$ctor2(System.DateTime.addMinutes(this.ClockDateTime, minutes), this.Offset);
            },
            AddMonths: function (months) {
                return new System.DateTimeOffset.$ctor2(System.DateTime.addMonths(this.ClockDateTime, months), this.Offset);
            },
            AddSeconds: function (seconds) {
                return new System.DateTimeOffset.$ctor2(System.DateTime.addSeconds(this.ClockDateTime, seconds), this.Offset);
            },
            AddTicks: function (ticks) {
                return new System.DateTimeOffset.$ctor2(System.DateTime.addTicks(this.ClockDateTime, ticks), this.Offset);
            },
            AddYears: function (years) {
                return new System.DateTimeOffset.$ctor2(System.DateTime.addYears(this.ClockDateTime, years), this.Offset);
            },
            System$IComparable$compareTo: function (obj) {
                if (obj == null) {
                    return 1;
                }
                if (!(Bridge.is(obj, System.DateTimeOffset))) {
                    throw new System.ArgumentException.$ctor1(System.Environment.GetResourceString("Arg_MustBeDateTimeOffset"));
                }

                var objUtc = System.Nullable.getValue(Bridge.cast(Bridge.unbox(obj, System.DateTimeOffset), System.DateTimeOffset)).UtcDateTime;
                var utc = this.UtcDateTime;
                if (System.DateTime.gt(utc, objUtc)) {
                    return 1;
                }
                if (System.DateTime.lt(utc, objUtc)) {
                    return -1;
                }
                return 0;
            },
            compareTo: function (other) {
                var otherUtc = other.UtcDateTime;
                var utc = this.UtcDateTime;
                if (System.DateTime.gt(utc, otherUtc)) {
                    return 1;
                }
                if (System.DateTime.lt(utc, otherUtc)) {
                    return -1;
                }
                return 0;
            },
            equals: function (obj) {
                if (Bridge.is(obj, System.DateTimeOffset)) {
                    return Bridge.equalsT(this.UtcDateTime, System.Nullable.getValue(Bridge.cast(Bridge.unbox(obj, System.DateTimeOffset), System.DateTimeOffset)).UtcDateTime);
                }
                return false;
            },
            equalsT: function (other) {
                return Bridge.equalsT(this.UtcDateTime, other.UtcDateTime);
            },
            EqualsExact: function (other) {
                return (Bridge.equals(this.ClockDateTime, other.ClockDateTime) && System.TimeSpan.eq(this.Offset, other.Offset) && System.DateTime.getKind(this.ClockDateTime) === System.DateTime.getKind(other.ClockDateTime));
            },
            System$Runtime$Serialization$IDeserializationCallback$OnDeserialization: function (sender) {
                try {
                    this.m_offsetMinutes = System.DateTimeOffset.ValidateOffset(this.Offset);
                    this.m_dateTime = System.DateTimeOffset.ValidateDate(this.ClockDateTime, this.Offset);
                } catch ($e1) {
                    $e1 = System.Exception.create($e1);
                    var e;
                    if (Bridge.is($e1, System.ArgumentException)) {
                        e = $e1;
                        throw new System.Runtime.Serialization.SerializationException.$ctor2(System.Environment.GetResourceString("Serialization_InvalidData"), e);
                    } else {
                        throw $e1;
                    }
                }
            },
            getHashCode: function () {
                return Bridge.getHashCode(this.UtcDateTime);
            },
            Subtract$1: function (value) {
                return System.DateTime.subdd(this.UtcDateTime, value.UtcDateTime);
            },
            Subtract: function (value) {
                return new System.DateTimeOffset.$ctor2(System.DateTime.subtract(this.ClockDateTime, value), this.Offset);
            },
            ToFileTime: function () {
                return System.DateTime.ToFileTime(this.UtcDateTime);
            },
            ToUnixTimeSeconds: function () {
                var seconds = System.DateTime.getTicks(this.UtcDateTime).div(System.Int64(10000000));
                return seconds.sub(System.DateTimeOffset.UnixEpochSeconds);
            },
            ToUnixTimeMilliseconds: function () {
                var milliseconds = System.DateTime.getTicks(this.UtcDateTime).div(System.Int64(10000));
                return milliseconds.sub(System.DateTimeOffset.UnixEpochMilliseconds);
            },
            ToLocalTime: function () {
                return this.ToLocalTime$1(false);
            },
            ToLocalTime$1: function (throwOnOverflow) {
                return new System.DateTimeOffset.$ctor1(System.DateTime.toLocalTime(this.UtcDateTime, throwOnOverflow));
            },
            toString: function () {
                return System.DateTime.format(System.DateTime.specifyKind(this.ClockDateTime, 2));

            },
            ToString$1: function (format) {
                return System.DateTime.format(System.DateTime.specifyKind(this.ClockDateTime, 2), format);

            },
            ToString: function (formatProvider) {
                return System.DateTime.format(System.DateTime.specifyKind(this.ClockDateTime, 2), null, formatProvider);

            },
            format: function (format, formatProvider) {
                return System.DateTime.format(System.DateTime.specifyKind(this.ClockDateTime, 2), format, formatProvider);

            },
            ToUniversalTime: function () {
                return new System.DateTimeOffset.$ctor1(this.UtcDateTime);
            },
            $clone: function (to) {
                var s = to || new System.DateTimeOffset();
                s.m_dateTime = this.m_dateTime;
                s.m_offsetMinutes = this.m_offsetMinutes;
                return s;
            }
        }
    });

    // @source DateTimeParse.js

    Bridge.define("System.DateTimeParse", {
        statics: {
            methods: {
                TryParseExact: function (s, format, dtfi, style, result) {
                    return System.DateTime.tryParseExact(s, format, null, result);

                },
                Parse: function (s, dtfi, styles) {
                    return System.DateTime.parse(s, dtfi);
                },
                Parse$1: function (s, dtfi, styles, offset) {
                    throw System.NotImplemented.ByDesign;

                },
                TryParse: function (s, dtfi, styles, result) {
                    return System.DateTime.tryParse(s, null, result);

                },
                TryParse$1: function (s, dtfi, styles, result, offset) {
                    throw System.NotImplemented.ByDesign;
                }
            }
        }
    });

    // @source DateTimeResult.js

    Bridge.define("System.DateTimeResult", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new System.DateTimeResult(); }
            }
        },
        fields: {
            Year: 0,
            Month: 0,
            Day: 0,
            Hour: 0,
            Minute: 0,
            Second: 0,
            fraction: 0,
            era: 0,
            flags: 0,
            timeZoneOffset: null,
            calendar: null,
            parsedDate: null,
            failure: 0,
            failureMessageID: null,
            failureMessageFormatArgument: null,
            failureArgumentName: null
        },
        ctors: {
            init: function () {
                this.timeZoneOffset = new System.TimeSpan();
                this.parsedDate = System.DateTime.getDefaultValue();
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            Init: function () {
                this.Year = -1;
                this.Month = -1;
                this.Day = -1;
                this.fraction = -1;
                this.era = -1;
            },
            SetDate: function (year, month, day) {
                this.Year = year;
                this.Month = month;
                this.Day = day;
            },
            SetFailure: function (failure, failureMessageID, failureMessageFormatArgument) {
                this.failure = failure;
                this.failureMessageID = failureMessageID;
                this.failureMessageFormatArgument = failureMessageFormatArgument;
            },
            SetFailure$1: function (failure, failureMessageID, failureMessageFormatArgument, failureArgumentName) {
                this.failure = failure;
                this.failureMessageID = failureMessageID;
                this.failureMessageFormatArgument = failureMessageFormatArgument;
                this.failureArgumentName = failureArgumentName;
            },
            getHashCode: function () {
                var h = Bridge.addHash([5374321750, this.Year, this.Month, this.Day, this.Hour, this.Minute, this.Second, this.fraction, this.era, this.flags, this.timeZoneOffset, this.calendar, this.parsedDate, this.failure, this.failureMessageID, this.failureMessageFormatArgument, this.failureArgumentName]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, System.DateTimeResult)) {
                    return false;
                }
                return Bridge.equals(this.Year, o.Year) && Bridge.equals(this.Month, o.Month) && Bridge.equals(this.Day, o.Day) && Bridge.equals(this.Hour, o.Hour) && Bridge.equals(this.Minute, o.Minute) && Bridge.equals(this.Second, o.Second) && Bridge.equals(this.fraction, o.fraction) && Bridge.equals(this.era, o.era) && Bridge.equals(this.flags, o.flags) && Bridge.equals(this.timeZoneOffset, o.timeZoneOffset) && Bridge.equals(this.calendar, o.calendar) && Bridge.equals(this.parsedDate, o.parsedDate) && Bridge.equals(this.failure, o.failure) && Bridge.equals(this.failureMessageID, o.failureMessageID) && Bridge.equals(this.failureMessageFormatArgument, o.failureMessageFormatArgument) && Bridge.equals(this.failureArgumentName, o.failureArgumentName);
            },
            $clone: function (to) {
                var s = to || new System.DateTimeResult();
                s.Year = this.Year;
                s.Month = this.Month;
                s.Day = this.Day;
                s.Hour = this.Hour;
                s.Minute = this.Minute;
                s.Second = this.Second;
                s.fraction = this.fraction;
                s.era = this.era;
                s.flags = this.flags;
                s.timeZoneOffset = this.timeZoneOffset;
                s.calendar = this.calendar;
                s.parsedDate = this.parsedDate;
                s.failure = this.failure;
                s.failureMessageID = this.failureMessageID;
                s.failureMessageFormatArgument = this.failureMessageFormatArgument;
                s.failureArgumentName = this.failureArgumentName;
                return s;
            }
        }
    });

    // @source DayOfWeek.js

    Bridge.define("System.DayOfWeek", {
        $kind: "enum",
        statics: {
            fields: {
                Sunday: 0,
                Monday: 1,
                Tuesday: 2,
                Wednesday: 3,
                Thursday: 4,
                Friday: 5,
                Saturday: 6
            }
        }
    });

    // @source DBNull.js

    Bridge.define("System.DBNull", {
        inherits: [System.Runtime.Serialization.ISerializable,System.IConvertible],
        statics: {
            fields: {
                Value: null
            },
            ctors: {
                init: function () {
                    this.Value = new System.DBNull();
                }
            }
        },
        alias: [
            "ToString", "System$IConvertible$ToString",
            "GetTypeCode", "System$IConvertible$GetTypeCode"
        ],
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            toString: function () {
                return "";
            },
            ToString: function (provider) {
                return "";
            },
            GetTypeCode: function () {
                return System.TypeCode.DBNull;
            },
            System$IConvertible$ToBoolean: function (provider) {
                throw new System.InvalidCastException.$ctor1("Object cannot be cast from DBNull to other types.");
            },
            System$IConvertible$ToChar: function (provider) {
                throw new System.InvalidCastException.$ctor1("Object cannot be cast from DBNull to other types.");
            },
            System$IConvertible$ToSByte: function (provider) {
                throw new System.InvalidCastException.$ctor1("Object cannot be cast from DBNull to other types.");
            },
            System$IConvertible$ToByte: function (provider) {
                throw new System.InvalidCastException.$ctor1("Object cannot be cast from DBNull to other types.");
            },
            System$IConvertible$ToInt16: function (provider) {
                throw new System.InvalidCastException.$ctor1("Object cannot be cast from DBNull to other types.");
            },
            System$IConvertible$ToUInt16: function (provider) {
                throw new System.InvalidCastException.$ctor1("Object cannot be cast from DBNull to other types.");
            },
            System$IConvertible$ToInt32: function (provider) {
                throw new System.InvalidCastException.$ctor1("Object cannot be cast from DBNull to other types.");
            },
            System$IConvertible$ToUInt32: function (provider) {
                throw new System.InvalidCastException.$ctor1("Object cannot be cast from DBNull to other types.");
            },
            System$IConvertible$ToInt64: function (provider) {
                throw new System.InvalidCastException.$ctor1("Object cannot be cast from DBNull to other types.");
            },
            System$IConvertible$ToUInt64: function (provider) {
                throw new System.InvalidCastException.$ctor1("Object cannot be cast from DBNull to other types.");
            },
            System$IConvertible$ToSingle: function (provider) {
                throw new System.InvalidCastException.$ctor1("Object cannot be cast from DBNull to other types.");
            },
            System$IConvertible$ToDouble: function (provider) {
                throw new System.InvalidCastException.$ctor1("Object cannot be cast from DBNull to other types.");
            },
            System$IConvertible$ToDecimal: function (provider) {
                throw new System.InvalidCastException.$ctor1("Object cannot be cast from DBNull to other types.");
            },
            System$IConvertible$ToDateTime: function (provider) {
                throw new System.InvalidCastException.$ctor1("Object cannot be cast from DBNull to other types.");
            },
            System$IConvertible$ToType: function (type, provider) {
                return System.Convert.defaultToType(Bridge.cast(this, System.IConvertible), type, provider);
            }
        }
    });

    // @source Empty.js

    Bridge.define("System.Empty", {
        statics: {
            fields: {
                Value: null
            },
            ctors: {
                init: function () {
                    this.Value = new System.Empty();
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            toString: function () {
                return "";
            }
        }
    });

    // @source ApplicationException.js

    Bridge.define("System.ApplicationException", {
        inherits: [System.Exception],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Exception.ctor.call(this, "Error in the application.");
                this.HResult = -2146232832;
            },
            $ctor1: function (message) {
                this.$initialize();
                System.Exception.ctor.call(this, message);
                this.HResult = -2146232832;
            },
            $ctor2: function (message, innerException) {
                this.$initialize();
                System.Exception.ctor.call(this, message, innerException);
                this.HResult = -2146232832;
            }
        }
    });

    // @source ArgumentException.js

    Bridge.define("System.ArgumentException", {
        inherits: [System.SystemException],
        fields: {
            _paramName: null
        },
        props: {
            Message: {
                get: function () {
                    var s = Bridge.ensureBaseProperty(this, "Message").$System$Exception$Message;
                    if (!System.String.isNullOrEmpty(this._paramName)) {
                        var resourceString = System.SR.Format("Parameter name: {0}", this._paramName);
                        return (s || "") + ("\n" || "") + (resourceString || "");
                    } else {
                        return s;
                    }
                }
            },
            ParamName: {
                get: function () {
                    return this._paramName;
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.SystemException.$ctor1.call(this, "Value does not fall within the expected range.");
                this.HResult = -2147024809;
            },
            $ctor1: function (message) {
                this.$initialize();
                System.SystemException.$ctor1.call(this, message);
                this.HResult = -2147024809;
            },
            $ctor2: function (message, innerException) {
                this.$initialize();
                System.SystemException.$ctor2.call(this, message, innerException);
                this.HResult = -2147024809;
            },
            $ctor4: function (message, paramName, innerException) {
                this.$initialize();
                System.SystemException.$ctor2.call(this, message, innerException);
                this._paramName = paramName;
                this.HResult = -2147024809;
            },
            $ctor3: function (message, paramName) {
                this.$initialize();
                System.SystemException.$ctor1.call(this, message);
                this._paramName = paramName;
                this.HResult = -2147024809;
            }
        }
    });

    // @source ArgumentNullException.js

    Bridge.define("System.ArgumentNullException", {
        inherits: [System.ArgumentException],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.ArgumentException.$ctor1.call(this, "Value cannot be null.");
                this.HResult = -2147467261;
            },
            $ctor1: function (paramName) {
                this.$initialize();
                System.ArgumentException.$ctor3.call(this, "Value cannot be null.", paramName);
                this.HResult = -2147467261;
            },
            $ctor2: function (message, innerException) {
                this.$initialize();
                System.ArgumentException.$ctor2.call(this, message, innerException);
                this.HResult = -2147467261;
            },
            $ctor3: function (paramName, message) {
                this.$initialize();
                System.ArgumentException.$ctor3.call(this, message, paramName);
                this.HResult = -2147467261;
            }
        }
    });

    // @source ArgumentOutOfRangeException.js

    Bridge.define("System.ArgumentOutOfRangeException", {
        inherits: [System.ArgumentException],
        fields: {
            _actualValue: null
        },
        props: {
            Message: {
                get: function () {
                    var s = Bridge.ensureBaseProperty(this, "Message").$System$ArgumentException$Message;
                    if (this._actualValue != null) {
                        var valueMessage = System.SR.Format("Actual value was {0}.", Bridge.toString(this._actualValue));
                        if (s == null) {
                            return valueMessage;
                        }
                        return (s || "") + ("\n" || "") + (valueMessage || "");
                    }
                    return s;
                }
            },
            ActualValue: {
                get: function () {
                    return this._actualValue;
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.ArgumentException.$ctor1.call(this, "Specified argument was out of the range of valid values.");
                this.HResult = -2146233086;
            },
            $ctor1: function (paramName) {
                this.$initialize();
                System.ArgumentException.$ctor3.call(this, "Specified argument was out of the range of valid values.", paramName);
                this.HResult = -2146233086;
            },
            $ctor4: function (paramName, message) {
                this.$initialize();
                System.ArgumentException.$ctor3.call(this, message, paramName);
                this.HResult = -2146233086;
            },
            $ctor2: function (message, innerException) {
                this.$initialize();
                System.ArgumentException.$ctor2.call(this, message, innerException);
                this.HResult = -2146233086;
            },
            $ctor3: function (paramName, actualValue, message) {
                this.$initialize();
                System.ArgumentException.$ctor3.call(this, message, paramName);
                this._actualValue = actualValue;
                this.HResult = -2146233086;
            }
        }
    });

    // @source ArithmeticException.js

    Bridge.define("System.ArithmeticException", {
        inherits: [System.SystemException],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.SystemException.$ctor1.call(this, "Overflow or underflow in the arithmetic operation.");
                this.HResult = -2147024362;
            },
            $ctor1: function (message) {
                this.$initialize();
                System.SystemException.$ctor1.call(this, message);
                this.HResult = -2147024362;
            },
            $ctor2: function (message, innerException) {
                this.$initialize();
                System.SystemException.$ctor2.call(this, message, innerException);
                this.HResult = -2147024362;
            }
        }
    });

    // @source Base64FormattingOptions.js

    Bridge.define("System.Base64FormattingOptions", {
        $kind: "enum",
        statics: {
            fields: {
                None: 0,
                InsertLineBreaks: 1
            }
        },
        $flags: true
    });

    // @source DivideByZeroException.js

    Bridge.define("System.DivideByZeroException", {
        inherits: [System.ArithmeticException],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.ArithmeticException.$ctor1.call(this, "Attempted to divide by zero.");
                this.HResult = -2147352558;
            },
            $ctor1: function (message) {
                this.$initialize();
                System.ArithmeticException.$ctor1.call(this, message);
                this.HResult = -2147352558;
            },
            $ctor2: function (message, innerException) {
                this.$initialize();
                System.ArithmeticException.$ctor2.call(this, message, innerException);
                this.HResult = -2147352558;
            }
        }
    });

    // @source ExceptionArgument.js

    Bridge.define("System.ExceptionArgument", {
        $kind: "enum",
        statics: {
            fields: {
                obj: 0,
                dictionary: 1,
                array: 2,
                info: 3,
                key: 4,
                collection: 5,
                list: 6,
                match: 7,
                converter: 8,
                capacity: 9,
                index: 10,
                startIndex: 11,
                value: 12,
                count: 13,
                arrayIndex: 14,
                $name: 15,
                item: 16,
                options: 17,
                view: 18,
                sourceBytesToCopy: 19,
                action: 20,
                comparison: 21,
                offset: 22,
                newSize: 23,
                elementType: 24,
                $length: 25,
                length1: 26,
                length2: 27,
                length3: 28,
                lengths: 29,
                len: 30,
                lowerBounds: 31,
                sourceArray: 32,
                destinationArray: 33,
                sourceIndex: 34,
                destinationIndex: 35,
                indices: 36,
                index1: 37,
                index2: 38,
                index3: 39,
                other: 40,
                comparer: 41,
                endIndex: 42,
                keys: 43,
                creationOptions: 44,
                timeout: 45,
                tasks: 46,
                scheduler: 47,
                continuationFunction: 48,
                millisecondsTimeout: 49,
                millisecondsDelay: 50,
                function: 51,
                exceptions: 52,
                exception: 53,
                cancellationToken: 54,
                delay: 55,
                asyncResult: 56,
                endMethod: 57,
                endFunction: 58,
                beginMethod: 59,
                continuationOptions: 60,
                continuationAction: 61,
                concurrencyLevel: 62,
                text: 63,
                callBack: 64,
                type: 65,
                stateMachine: 66,
                pHandle: 67,
                values: 68,
                task: 69,
                s: 70,
                keyValuePair: 71,
                input: 72,
                ownedMemory: 73,
                pointer: 74,
                start: 75,
                format: 76,
                culture: 77,
                comparable: 78,
                source: 79,
                state: 80
            }
        }
    });

    // @source ExceptionResource.js

    Bridge.define("System.ExceptionResource", {
        $kind: "enum",
        statics: {
            fields: {
                Argument_ImplementIComparable: 0,
                Argument_InvalidType: 1,
                Argument_InvalidArgumentForComparison: 2,
                Argument_InvalidRegistryKeyPermissionCheck: 3,
                ArgumentOutOfRange_NeedNonNegNum: 4,
                Arg_ArrayPlusOffTooSmall: 5,
                Arg_NonZeroLowerBound: 6,
                Arg_RankMultiDimNotSupported: 7,
                Arg_RegKeyDelHive: 8,
                Arg_RegKeyStrLenBug: 9,
                Arg_RegSetStrArrNull: 10,
                Arg_RegSetMismatchedKind: 11,
                Arg_RegSubKeyAbsent: 12,
                Arg_RegSubKeyValueAbsent: 13,
                Argument_AddingDuplicate: 14,
                Serialization_InvalidOnDeser: 15,
                Serialization_MissingKeys: 16,
                Serialization_NullKey: 17,
                Argument_InvalidArrayType: 18,
                NotSupported_KeyCollectionSet: 19,
                NotSupported_ValueCollectionSet: 20,
                ArgumentOutOfRange_SmallCapacity: 21,
                ArgumentOutOfRange_Index: 22,
                Argument_InvalidOffLen: 23,
                Argument_ItemNotExist: 24,
                ArgumentOutOfRange_Count: 25,
                ArgumentOutOfRange_InvalidThreshold: 26,
                ArgumentOutOfRange_ListInsert: 27,
                NotSupported_ReadOnlyCollection: 28,
                InvalidOperation_CannotRemoveFromStackOrQueue: 29,
                InvalidOperation_EmptyQueue: 30,
                InvalidOperation_EnumOpCantHappen: 31,
                InvalidOperation_EnumFailedVersion: 32,
                InvalidOperation_EmptyStack: 33,
                ArgumentOutOfRange_BiggerThanCollection: 34,
                InvalidOperation_EnumNotStarted: 35,
                InvalidOperation_EnumEnded: 36,
                NotSupported_SortedListNestedWrite: 37,
                InvalidOperation_NoValue: 38,
                InvalidOperation_RegRemoveSubKey: 39,
                Security_RegistryPermission: 40,
                UnauthorizedAccess_RegistryNoWrite: 41,
                ObjectDisposed_RegKeyClosed: 42,
                NotSupported_InComparableType: 43,
                Argument_InvalidRegistryOptionsCheck: 44,
                Argument_InvalidRegistryViewCheck: 45,
                InvalidOperation_NullArray: 46,
                Arg_MustBeType: 47,
                Arg_NeedAtLeast1Rank: 48,
                ArgumentOutOfRange_HugeArrayNotSupported: 49,
                Arg_RanksAndBounds: 50,
                Arg_RankIndices: 51,
                Arg_Need1DArray: 52,
                Arg_Need2DArray: 53,
                Arg_Need3DArray: 54,
                NotSupported_FixedSizeCollection: 55,
                ArgumentException_OtherNotArrayOfCorrectLength: 56,
                Rank_MultiDimNotSupported: 57,
                InvalidOperation_IComparerFailed: 58,
                ArgumentOutOfRange_EndIndexStartIndex: 59,
                Arg_LowerBoundsMustMatch: 60,
                Arg_BogusIComparer: 61,
                Task_WaitMulti_NullTask: 62,
                Task_ThrowIfDisposed: 63,
                Task_Start_TaskCompleted: 64,
                Task_Start_Promise: 65,
                Task_Start_ContinuationTask: 66,
                Task_Start_AlreadyStarted: 67,
                Task_RunSynchronously_TaskCompleted: 68,
                Task_RunSynchronously_Continuation: 69,
                Task_RunSynchronously_Promise: 70,
                Task_RunSynchronously_AlreadyStarted: 71,
                Task_MultiTaskContinuation_NullTask: 72,
                Task_MultiTaskContinuation_EmptyTaskList: 73,
                Task_Dispose_NotCompleted: 74,
                Task_Delay_InvalidMillisecondsDelay: 75,
                Task_Delay_InvalidDelay: 76,
                Task_ctor_LRandSR: 77,
                Task_ContinueWith_NotOnAnything: 78,
                Task_ContinueWith_ESandLR: 79,
                TaskT_TransitionToFinal_AlreadyCompleted: 80,
                TaskCompletionSourceT_TrySetException_NullException: 81,
                TaskCompletionSourceT_TrySetException_NoExceptions: 82,
                MemoryDisposed: 83,
                Memory_OutstandingReferences: 84,
                InvalidOperation_WrongAsyncResultOrEndCalledMultiple: 85,
                ConcurrentDictionary_ConcurrencyLevelMustBePositive: 86,
                ConcurrentDictionary_CapacityMustNotBeNegative: 87,
                ConcurrentDictionary_TypeOfValueIncorrect: 88,
                ConcurrentDictionary_TypeOfKeyIncorrect: 89,
                ConcurrentDictionary_KeyAlreadyExisted: 90,
                ConcurrentDictionary_ItemKeyIsNull: 91,
                ConcurrentDictionary_IndexIsNegative: 92,
                ConcurrentDictionary_ArrayNotLargeEnough: 93,
                ConcurrentDictionary_ArrayIncorrectType: 94,
                ConcurrentCollection_SyncRoot_NotSupported: 95,
                ArgumentOutOfRange_Enum: 96,
                InvalidOperation_HandleIsNotInitialized: 97,
                AsyncMethodBuilder_InstanceNotInitialized: 98,
                ArgumentNull_SafeHandle: 99
            }
        }
    });

    // @source FormatException.js

    Bridge.define("System.FormatException", {
        inherits: [System.SystemException],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.SystemException.$ctor1.call(this, "One of the identified items was in an invalid format.");
                this.HResult = -2146233033;
            },
            $ctor1: function (message) {
                this.$initialize();
                System.SystemException.$ctor1.call(this, message);
                this.HResult = -2146233033;
            },
            $ctor2: function (message, innerException) {
                this.$initialize();
                System.SystemException.$ctor2.call(this, message, innerException);
                this.HResult = -2146233033;
            }
        }
    });

    // @source FormattableString.js

    Bridge.define("System.FormattableString", {
        inherits: [System.IFormattable],
        statics: {
            methods: {
                Invariant: function (formattable) {
                    if (formattable == null) {
                        throw new System.ArgumentNullException.$ctor1("formattable");
                    }

                    return formattable.ToString(System.Globalization.CultureInfo.invariantCulture);
                }
            }
        },
        methods: {
            System$IFormattable$format: function (ignored, formatProvider) {
                return this.ToString(formatProvider);
            },
            toString: function () {
                return this.ToString(System.Globalization.CultureInfo.getCurrentCulture());
            }
        }
    });

    // @source ConcreteFormattableString.js

    Bridge.define("System.Runtime.CompilerServices.FormattableStringFactory.ConcreteFormattableString", {
        inherits: [System.FormattableString],
        $kind: "nested class",
        fields: {
            _format: null,
            _arguments: null
        },
        props: {
            Format: {
                get: function () {
                    return this._format;
                }
            },
            ArgumentCount: {
                get: function () {
                    return this._arguments.length;
                }
            }
        },
        ctors: {
            ctor: function (format, $arguments) {
                this.$initialize();
                System.FormattableString.ctor.call(this);
                this._format = format;
                this._arguments = $arguments;
            }
        },
        methods: {
            GetArguments: function () {
                return this._arguments;
            },
            GetArgument: function (index) {
                return this._arguments[System.Array.index(index, this._arguments)];
            },
            ToString: function (formatProvider) {
                return System.String.formatProvider.apply(System.String, [formatProvider, this._format].concat(this._arguments));
            }
        }
    });

    // @source FormattableStringFactory.js

    Bridge.define("System.Runtime.CompilerServices.FormattableStringFactory", {
        statics: {
            methods: {
                Create: function (format, $arguments) {
                    if ($arguments === void 0) { $arguments = []; }
                    if (format == null) {
                        throw new System.ArgumentNullException.$ctor1("format");
                    }

                    if ($arguments == null) {
                        throw new System.ArgumentNullException.$ctor1("arguments");
                    }

                    return new System.Runtime.CompilerServices.FormattableStringFactory.ConcreteFormattableString(format, $arguments);
                }
            }
        }
    });

    // @source Guid.js

    Bridge.define("System.Guid", {
        inherits: function () { return [System.IEquatable$1(System.Guid),System.IComparable$1(System.Guid),System.IFormattable]; },
        $kind: "struct",
        statics: {
            fields: {
                error1: null,
                Valid: null,
                Split: null,
                NonFormat: null,
                Replace: null,
                Rnd: null,
                Empty: null
            },
            ctors: {
                init: function () {
                    this.Empty = new System.Guid();
                    this.error1 = "Byte array for GUID must be exactly {0} bytes long";
                    this.Valid = new System.Text.RegularExpressions.Regex.ctor("^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$", 1);
                    this.Split = new System.Text.RegularExpressions.Regex.ctor("^(.{8})(.{4})(.{4})(.{4})(.{12})$");
                    this.NonFormat = new System.Text.RegularExpressions.Regex.ctor("^[{(]?([0-9a-f]{8})-?([0-9a-f]{4})-?([0-9a-f]{4})-?([0-9a-f]{4})-?([0-9a-f]{12})[)}]?$", 1);
                    this.Replace = new System.Text.RegularExpressions.Regex.ctor("-");
                    this.Rnd = new System.Random.ctor();
                }
            },
            methods: {
                Parse: function (input) {
                    return System.Guid.ParseExact(input, null);
                },
                ParseExact: function (input, format) {
                    var r = new System.Guid.ctor();
                    r.ParseInternal(input, format, true);
                    return r;
                },
                TryParse: function (input, result) {
                    return System.Guid.TryParseExact(input, null, result);
                },
                TryParseExact: function (input, format, result) {
                    result.v = new System.Guid.ctor();
                    return result.v.ParseInternal(input, format, false);
                },
                NewGuid: function () {
                    var a = System.Array.init(16, 0, System.Byte);

                    System.Guid.Rnd.NextBytes(a);

                    a[System.Array.index(7, a)] = (a[System.Array.index(7, a)] & 15 | 64) & 255;
                    a[System.Array.index(8, a)] = (a[System.Array.index(8, a)] & 191 | 128) & 255;

                    return new System.Guid.$ctor1(a);
                },
                ToHex$1: function (x, precision) {
                    var result = x.toString(16);
                    precision = (precision - result.length) | 0;

                    for (var i = 0; i < precision; i = (i + 1) | 0) {
                        result = "0" + (result || "");
                    }

                    return result;
                },
                ToHex: function (x) {
                    var result = x.toString(16);

                    if (result.length === 1) {
                        result = "0" + (result || "");
                    }

                    return result;
                },
                op_Equality: function (a, b) {
                    if (Bridge.referenceEquals(a, null)) {
                        return Bridge.referenceEquals(b, null);
                    }

                    return a.equalsT(b);
                },
                op_Inequality: function (a, b) {
                    return !(System.Guid.op_Equality(a, b));
                },
                getDefaultValue: function () { return new System.Guid(); }
            }
        },
        fields: {
            _a: 0,
            _b: 0,
            _c: 0,
            _d: 0,
            _e: 0,
            _f: 0,
            _g: 0,
            _h: 0,
            _i: 0,
            _j: 0,
            _k: 0
        },
        alias: [
            "equalsT", "System$IEquatable$1$System$Guid$equalsT",
            "compareTo", ["System$IComparable$1$System$Guid$compareTo", "System$IComparable$1$compareTo"],
            "format", "System$IFormattable$format"
        ],
        ctors: {
            $ctor4: function (uuid) {
                this.$initialize();
                (new System.Guid.ctor()).$clone(this);

                this.ParseInternal(uuid, null, true);
            },
            $ctor1: function (b) {
                this.$initialize();
                if (b == null) {
                    throw new System.ArgumentNullException.$ctor1("b");
                }

                if (b.length !== 16) {
                    throw new System.ArgumentException.$ctor1(System.String.format(System.Guid.error1, [Bridge.box(16, System.Int32)]));
                }

                this._a = (b[System.Array.index(3, b)] << 24) | (b[System.Array.index(2, b)] << 16) | (b[System.Array.index(1, b)] << 8) | b[System.Array.index(0, b)];
                this._b = Bridge.Int.sxs(((b[System.Array.index(5, b)] << 8) | b[System.Array.index(4, b)]) & 65535);
                this._c = Bridge.Int.sxs(((b[System.Array.index(7, b)] << 8) | b[System.Array.index(6, b)]) & 65535);
                this._d = b[System.Array.index(8, b)];
                this._e = b[System.Array.index(9, b)];
                this._f = b[System.Array.index(10, b)];
                this._g = b[System.Array.index(11, b)];
                this._h = b[System.Array.index(12, b)];
                this._i = b[System.Array.index(13, b)];
                this._j = b[System.Array.index(14, b)];
                this._k = b[System.Array.index(15, b)];
            },
            $ctor5: function (a, b, c, d, e, f, g, h, i, j, k) {
                this.$initialize();
                this._a = a | 0;
                this._b = Bridge.Int.sxs(b & 65535);
                this._c = Bridge.Int.sxs(c & 65535);
                this._d = d;
                this._e = e;
                this._f = f;
                this._g = g;
                this._h = h;
                this._i = i;
                this._j = j;
                this._k = k;
            },
            $ctor3: function (a, b, c, d) {
                this.$initialize();
                if (d == null) {
                    throw new System.ArgumentNullException.$ctor1("d");
                }

                if (d.length !== 8) {
                    throw new System.ArgumentException.$ctor1(System.String.format(System.Guid.error1, [Bridge.box(8, System.Int32)]));
                }

                this._a = a;
                this._b = b;
                this._c = c;
                this._d = d[System.Array.index(0, d)];
                this._e = d[System.Array.index(1, d)];
                this._f = d[System.Array.index(2, d)];
                this._g = d[System.Array.index(3, d)];
                this._h = d[System.Array.index(4, d)];
                this._i = d[System.Array.index(5, d)];
                this._j = d[System.Array.index(6, d)];
                this._k = d[System.Array.index(7, d)];
            },
            $ctor2: function (a, b, c, d, e, f, g, h, i, j, k) {
                this.$initialize();
                this._a = a;
                this._b = b;
                this._c = c;
                this._d = d;
                this._e = e;
                this._f = f;
                this._g = g;
                this._h = h;
                this._i = i;
                this._j = j;
                this._k = k;
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
                return this._a ^ ((this._b << 16) | (this._c & 65535)) ^ ((this._f << 24) | this._k);
            },
            equals: function (o) {
                if (!(Bridge.is(o, System.Guid))) {
                    return false;
                }

                return this.equalsT(System.Nullable.getValue(Bridge.cast(Bridge.unbox(o, System.Guid), System.Guid)));
            },
            equalsT: function (o) {
                if ((this._a !== o._a) || (this._b !== o._b) || (this._c !== o._c) || (this._d !== o._d) || (this._e !== o._e) || (this._f !== o._f) || (this._g !== o._g) || (this._h !== o._h) || (this._i !== o._i) || (this._j !== o._j) || (this._k !== o._k)) {
                    return false;
                }

                return true;
            },
            compareTo: function (value) {
                return System.String.compare(this.toString(), value.toString());
            },
            toString: function () {
                return this.Format(null);
            },
            ToString: function (format) {
                return this.Format(format);
            },
            format: function (format, formatProvider) {
                return this.Format(format);
            },
            ToByteArray: function () {
                var g = System.Array.init(16, 0, System.Byte);

                g[System.Array.index(0, g)] = this._a & 255;
                g[System.Array.index(1, g)] = (this._a >> 8) & 255;
                g[System.Array.index(2, g)] = (this._a >> 16) & 255;
                g[System.Array.index(3, g)] = (this._a >> 24) & 255;
                g[System.Array.index(4, g)] = this._b & 255;
                g[System.Array.index(5, g)] = (this._b >> 8) & 255;
                g[System.Array.index(6, g)] = this._c & 255;
                g[System.Array.index(7, g)] = (this._c >> 8) & 255;
                g[System.Array.index(8, g)] = this._d;
                g[System.Array.index(9, g)] = this._e;
                g[System.Array.index(10, g)] = this._f;
                g[System.Array.index(11, g)] = this._g;
                g[System.Array.index(12, g)] = this._h;
                g[System.Array.index(13, g)] = this._i;
                g[System.Array.index(14, g)] = this._j;
                g[System.Array.index(15, g)] = this._k;

                return g;
            },
            ParseInternal: function (input, format, check) {
                var r = null;

                if (System.String.isNullOrEmpty(input)) {
                    if (check) {
                        throw new System.ArgumentNullException.$ctor1("input");
                    }
                    return false;
                }

                if (System.String.isNullOrEmpty(format)) {
                    var m = System.Guid.NonFormat.match(input);

                    if (m.getSuccess()) {
                        var list = new (System.Collections.Generic.List$1(System.String)).ctor();
                        for (var i = 1; i <= m.getGroups().getCount(); i = (i + 1) | 0) {
                            if (m.getGroups().get(i).getSuccess()) {
                                list.add(m.getGroups().get(i).getValue());
                            }
                        }

                        r = list.ToArray().join("-").toLowerCase();
                    }
                } else {
                    format = format.toUpperCase();

                    var p = false;

                    if (Bridge.referenceEquals(format, "N")) {
                        var m1 = System.Guid.Split.match(input);

                        if (m1.getSuccess()) {
                            var list1 = new (System.Collections.Generic.List$1(System.String)).ctor();
                            for (var i1 = 1; i1 <= m1.getGroups().getCount(); i1 = (i1 + 1) | 0) {
                                if (m1.getGroups().get(i1).getSuccess()) {
                                    list1.add(m1.getGroups().get(i1).getValue());
                                }
                            }

                            p = true;
                            input = list1.ToArray().join("-");
                        }
                    } else if (Bridge.referenceEquals(format, "B") || Bridge.referenceEquals(format, "P")) {
                        var b = Bridge.referenceEquals(format, "B") ? System.Array.init([123, 125], System.Char) : System.Array.init([40, 41], System.Char);

                        if ((input.charCodeAt(0) === b[System.Array.index(0, b)]) && (input.charCodeAt(((input.length - 1) | 0)) === b[System.Array.index(1, b)])) {
                            p = true;
                            input = input.substr(1, ((input.length - 2) | 0));
                        }
                    } else {
                        p = true;
                    }

                    if (p && System.Guid.Valid.isMatch(input)) {
                        r = input.toLowerCase();
                    }
                }

                if (r != null) {
                    this.FromString(r);
                    return true;
                }

                if (check) {
                    throw new System.FormatException.$ctor1("input is not in a recognized format");
                }

                return false;
            },
            Format: function (format) {
                var s = (System.Guid.ToHex$1((this._a >>> 0), 8) || "") + (System.Guid.ToHex$1((this._b & 65535), 4) || "") + (System.Guid.ToHex$1((this._c & 65535), 4) || "");
                s = (s || "") + ((System.Array.init([this._d, this._e, this._f, this._g, this._h, this._i, this._j, this._k], System.Byte)).map(System.Guid.ToHex).join("") || "");

                var m = /^(.{8})(.{4})(.{4})(.{4})(.{12})$/.exec(s);
                var list = System.Array.init(0, null, System.String);
                for (var i = 1; i < m.length; i = (i + 1) | 0) {
                    if (m[System.Array.index(i, m)] != null) {
                        list.push(m[System.Array.index(i, m)]);
                    }
                }
                s = list.join("-");

                switch (format) {
                    case "n": 
                    case "N": 
                        return System.Guid.Replace.replace(s, "");
                    case "b": 
                    case "B": 
                        return String.fromCharCode(123) + (s || "") + String.fromCharCode(125);
                    case "p": 
                    case "P": 
                        return String.fromCharCode(40) + (s || "") + String.fromCharCode(41);
                    default: 
                        return s;
                }
            },
            FromString: function (s) {
                if (System.String.isNullOrEmpty(s)) {
                    return;
                }

                s = System.Guid.Replace.replace(s, "");

                var r = System.Array.init(8, 0, System.Byte);

                this._a = (System.UInt32.parse(s.substr(0, 8), 16)) | 0;
                this._b = Bridge.Int.sxs((System.UInt16.parse(s.substr(8, 4), 16)) & 65535);
                this._c = Bridge.Int.sxs((System.UInt16.parse(s.substr(12, 4), 16)) & 65535);
                for (var i = 8; i < 16; i = (i + 1) | 0) {
                    r[System.Array.index(((i - 8) | 0), r)] = System.Byte.parse(s.substr(Bridge.Int.mul(i, 2), 2), 16);
                }

                this._d = r[System.Array.index(0, r)];
                this._e = r[System.Array.index(1, r)];
                this._f = r[System.Array.index(2, r)];
                this._g = r[System.Array.index(3, r)];
                this._h = r[System.Array.index(4, r)];
                this._i = r[System.Array.index(5, r)];
                this._j = r[System.Array.index(6, r)];
                this._k = r[System.Array.index(7, r)];
            },
            toJSON: function () {
                return this.toString();
            },
            $clone: function (to) { return this; }
        }
    });

    // @source ITupleInternal.js

    Bridge.define("System.ITupleInternal", {
        $kind: "interface"
    });

    // @source Tuple.js

    Bridge.define("System.Tuple");

    Bridge.define("System.Tuple$1", function (T1) { return {

    }; });

    Bridge.define("System.Tuple$2", function (T1, T2) { return {

    }; });

    Bridge.define("System.Tuple$3", function (T1, T2, T3) { return {

    }; });

    Bridge.define("System.Tuple$4", function (T1, T2, T3, T4) { return {

    }; });

    Bridge.define("System.Tuple$5", function (T1, T2, T3, T4, T5) { return {

    }; });

    Bridge.define("System.Tuple$6", function (T1, T2, T3, T4, T5, T6) { return {

    }; });

    Bridge.define("System.Tuple$7", function (T1, T2, T3, T4, T5, T6, T7) { return {

    }; });

    Bridge.define("System.Tuple$8", function (T1, T2, T3, T4, T5, T6, T7, TRest) { return {

    }; });

    // @source ValueTuple.js

    Bridge.define("System.ValueTuple", {
        inherits: function () { return [System.IEquatable$1(System.ValueTuple),System.Collections.IStructuralEquatable,System.Collections.IStructuralComparable,System.IComparable,System.IComparable$1(System.ValueTuple)]; },
        $kind: "struct",
        statics: {
            methods: {
                Create: function () {
                    return new System.ValueTuple();
                },
                Create$1: function (T1, item1) {
                    return new (System.ValueTuple$1(T1)).$ctor1(item1);
                },
                Create$2: function (T1, T2, item1, item2) {
                    return new (System.ValueTuple$2(T1,T2)).$ctor1(item1, item2);
                },
                Create$3: function (T1, T2, T3, item1, item2, item3) {
                    return new (System.ValueTuple$3(T1,T2,T3)).$ctor1(item1, item2, item3);
                },
                Create$4: function (T1, T2, T3, T4, item1, item2, item3, item4) {
                    return new (System.ValueTuple$4(T1,T2,T3,T4)).$ctor1(item1, item2, item3, item4);
                },
                Create$5: function (T1, T2, T3, T4, T5, item1, item2, item3, item4, item5) {
                    return new (System.ValueTuple$5(T1,T2,T3,T4,T5)).$ctor1(item1, item2, item3, item4, item5);
                },
                Create$6: function (T1, T2, T3, T4, T5, T6, item1, item2, item3, item4, item5, item6) {
                    return new (System.ValueTuple$6(T1,T2,T3,T4,T5,T6)).$ctor1(item1, item2, item3, item4, item5, item6);
                },
                Create$7: function (T1, T2, T3, T4, T5, T6, T7, item1, item2, item3, item4, item5, item6, item7) {
                    return new (System.ValueTuple$7(T1,T2,T3,T4,T5,T6,T7)).$ctor1(item1, item2, item3, item4, item5, item6, item7);
                },
                Create$8: function (T1, T2, T3, T4, T5, T6, T7, T8, item1, item2, item3, item4, item5, item6, item7, item8) {
                    return new (System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,System.ValueTuple$1(T8))).$ctor1(item1, item2, item3, item4, item5, item6, item7, System.ValueTuple.Create$1(T8, item8));
                },
                CombineHashCodes: function (h1, h2) {
                    return System.Collections.HashHelpers.Combine(System.Collections.HashHelpers.Combine(System.Collections.HashHelpers.RandomSeed, h1), h2);
                },
                CombineHashCodes$1: function (h1, h2, h3) {
                    return System.Collections.HashHelpers.Combine(System.ValueTuple.CombineHashCodes(h1, h2), h3);
                },
                CombineHashCodes$2: function (h1, h2, h3, h4) {
                    return System.Collections.HashHelpers.Combine(System.ValueTuple.CombineHashCodes$1(h1, h2, h3), h4);
                },
                CombineHashCodes$3: function (h1, h2, h3, h4, h5) {
                    return System.Collections.HashHelpers.Combine(System.ValueTuple.CombineHashCodes$2(h1, h2, h3, h4), h5);
                },
                CombineHashCodes$4: function (h1, h2, h3, h4, h5, h6) {
                    return System.Collections.HashHelpers.Combine(System.ValueTuple.CombineHashCodes$3(h1, h2, h3, h4, h5), h6);
                },
                CombineHashCodes$5: function (h1, h2, h3, h4, h5, h6, h7) {
                    return System.Collections.HashHelpers.Combine(System.ValueTuple.CombineHashCodes$4(h1, h2, h3, h4, h5, h6), h7);
                },
                CombineHashCodes$6: function (h1, h2, h3, h4, h5, h6, h7, h8) {
                    return System.Collections.HashHelpers.Combine(System.ValueTuple.CombineHashCodes$5(h1, h2, h3, h4, h5, h6, h7), h8);
                },
                getDefaultValue: function () { return new System.ValueTuple(); }
            }
        },
        alias: [
            "equalsT", "System$IEquatable$1$System$ValueTuple$equalsT",
            "compareTo", ["System$IComparable$1$System$ValueTuple$compareTo", "System$IComparable$1$compareTo"]
        ],
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            equals: function (obj) {
                return Bridge.is(obj, System.ValueTuple);
            },
            equalsT: function (other) {
                return true;
            },
            System$Collections$IStructuralEquatable$Equals: function (other, comparer) {
                return Bridge.is(other, System.ValueTuple);
            },
            System$IComparable$compareTo: function (other) {
                if (other == null) {
                    return 1;
                }

                if (!(Bridge.is(other, System.ValueTuple))) {
                    throw new System.ArgumentException.$ctor3(System.SR.ArgumentException_ValueTupleIncorrectType, "other");
                }

                return 0;
            },
            compareTo: function (other) {
                return 0;
            },
            System$Collections$IStructuralComparable$CompareTo: function (other, comparer) {
                if (other == null) {
                    return 1;
                }

                if (!(Bridge.is(other, System.ValueTuple))) {
                    throw new System.ArgumentException.$ctor3(System.SR.ArgumentException_ValueTupleIncorrectType, "other");
                }

                return 0;
            },
            getHashCode: function () {
                return 0;
            },
            System$Collections$IStructuralEquatable$GetHashCode: function (comparer) {
                return 0;
            },
            toString: function () {
                return "()";
            },
            $clone: function (to) { return this; }
        }
    });

    Bridge.define("System.ValueTuple$1", function (T1) { return {
        inherits: function () { return [System.IEquatable$1(System.ValueTuple$1(T1)),System.Collections.IStructuralEquatable,System.Collections.IStructuralComparable,System.IComparable,System.IComparable$1(System.ValueTuple$1(T1)),System.ITupleInternal]; },
        $kind: "struct",
        statics: {
            fields: {
                s_t1Comparer: null
            },
            ctors: {
                init: function () {
                    this.s_t1Comparer = System.Collections.Generic.EqualityComparer$1(T1).def;
                }
            },
            methods: {
                getDefaultValue: function () { return new (System.ValueTuple$1(T1))(); }
            }
        },
        fields: {
            Item1: Bridge.getDefaultValue(T1)
        },
        props: {
            System$ITupleInternal$Size: {
                get: function () {
                    return 1;
                }
            }
        },
        alias: [
            "equalsT", "System$IEquatable$1$System$ValueTuple$1$" + Bridge.getTypeAlias(T1) + "$equalsT",
            "compareTo", ["System$IComparable$1$System$ValueTuple$1$" + Bridge.getTypeAlias(T1) + "$compareTo", "System$IComparable$1$compareTo"]
        ],
        ctors: {
            $ctor1: function (item1) {
                this.$initialize();
                this.Item1 = item1;
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            equals: function (obj) {
                return Bridge.is(obj, System.ValueTuple$1(T1)) && this.equalsT(System.Nullable.getValue(Bridge.cast(Bridge.unbox(obj, System.ValueTuple$1(T1)), System.ValueTuple$1(T1))));
            },
            equalsT: function (other) {
                return System.ValueTuple$1(T1).s_t1Comparer.equals2(this.Item1, other.Item1);
            },
            System$Collections$IStructuralEquatable$Equals: function (other, comparer) {
                if (other == null || !(Bridge.is(other, System.ValueTuple$1(T1)))) {
                    return false;
                }

                var objTuple = System.Nullable.getValue(Bridge.cast(Bridge.unbox(other, System.ValueTuple$1(T1)), System.ValueTuple$1(T1)));

                return comparer.System$Collections$IEqualityComparer$equals(this.Item1, objTuple.Item1);
            },
            System$IComparable$compareTo: function (other) {
                if (other == null) {
                    return 1;
                }

                if (!(Bridge.is(other, System.ValueTuple$1(T1)))) {
                    throw new System.ArgumentException.$ctor3(System.SR.ArgumentException_ValueTupleIncorrectType, "other");
                }

                var objTuple = System.Nullable.getValue(Bridge.cast(Bridge.unbox(other, System.ValueTuple$1(T1)), System.ValueTuple$1(T1)));

                return new (System.Collections.Generic.Comparer$1(T1))(System.Collections.Generic.Comparer$1.$default.fn).compare(this.Item1, objTuple.Item1);
            },
            compareTo: function (other) {
                return new (System.Collections.Generic.Comparer$1(T1))(System.Collections.Generic.Comparer$1.$default.fn).compare(this.Item1, other.Item1);
            },
            System$Collections$IStructuralComparable$CompareTo: function (other, comparer) {
                if (other == null) {
                    return 1;
                }

                if (!(Bridge.is(other, System.ValueTuple$1(T1)))) {
                    throw new System.ArgumentException.$ctor3(System.SR.ArgumentException_ValueTupleIncorrectType, "other");
                }

                var objTuple = System.Nullable.getValue(Bridge.cast(Bridge.unbox(other, System.ValueTuple$1(T1)), System.ValueTuple$1(T1)));

                return comparer.System$Collections$IComparer$compare(this.Item1, objTuple.Item1);
            },
            getHashCode: function () {
                return System.ValueTuple$1(T1).s_t1Comparer.getHashCode2(this.Item1);
            },
            System$Collections$IStructuralEquatable$GetHashCode: function (comparer) {
                return comparer.System$Collections$IEqualityComparer$getHashCode(this.Item1);
            },
            System$ITupleInternal$GetHashCode: function (comparer) {
                return comparer.System$Collections$IEqualityComparer$getHashCode(this.Item1);
            },
            toString: function () {
                return "(" + ((this.Item1 != null ? Bridge.toString(this.Item1) : null) || "") + ")";
            },
            System$ITupleInternal$ToStringEnd: function () {
                return ((this.Item1 != null ? Bridge.toString(this.Item1) : null) || "") + ")";
            },
            $clone: function (to) {
                var s = to || new (System.ValueTuple$1(T1))();
                s.Item1 = this.Item1;
                return s;
            }
        }
    }; });

    Bridge.define("System.ValueTuple$2", function (T1, T2) { return {
        inherits: function () { return [System.IEquatable$1(System.ValueTuple$2(T1,T2)),System.Collections.IStructuralEquatable,System.Collections.IStructuralComparable,System.IComparable,System.IComparable$1(System.ValueTuple$2(T1,T2)),System.ITupleInternal]; },
        $kind: "struct",
        statics: {
            fields: {
                s_t1Comparer: null,
                s_t2Comparer: null
            },
            ctors: {
                init: function () {
                    this.s_t1Comparer = System.Collections.Generic.EqualityComparer$1(T1).def;
                    this.s_t2Comparer = System.Collections.Generic.EqualityComparer$1(T2).def;
                }
            },
            methods: {
                getDefaultValue: function () { return new (System.ValueTuple$2(T1,T2))(); }
            }
        },
        fields: {
            Item1: Bridge.getDefaultValue(T1),
            Item2: Bridge.getDefaultValue(T2)
        },
        props: {
            System$ITupleInternal$Size: {
                get: function () {
                    return 2;
                }
            }
        },
        alias: [
            "equalsT", "System$IEquatable$1$System$ValueTuple$2$" + Bridge.getTypeAlias(T1) + "$" + Bridge.getTypeAlias(T2) + "$equalsT",
            "compareTo", ["System$IComparable$1$System$ValueTuple$2$" + Bridge.getTypeAlias(T1) + "$" + Bridge.getTypeAlias(T2) + "$compareTo", "System$IComparable$1$compareTo"]
        ],
        ctors: {
            $ctor1: function (item1, item2) {
                this.$initialize();
                this.Item1 = item1;
                this.Item2 = item2;
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            equals: function (obj) {
                return Bridge.is(obj, System.ValueTuple$2(T1,T2)) && this.equalsT(System.Nullable.getValue(Bridge.cast(Bridge.unbox(obj, System.ValueTuple$2(T1,T2)), System.ValueTuple$2(T1,T2))));
            },
            equalsT: function (other) {
                return System.ValueTuple$2(T1,T2).s_t1Comparer.equals2(this.Item1, other.Item1) && System.ValueTuple$2(T1,T2).s_t2Comparer.equals2(this.Item2, other.Item2);
            },
            System$Collections$IStructuralEquatable$Equals: function (other, comparer) {
                if (other == null || !(Bridge.is(other, System.ValueTuple$2(T1,T2)))) {
                    return false;
                }

                var objTuple = System.Nullable.getValue(Bridge.cast(Bridge.unbox(other, System.ValueTuple$2(T1,T2)), System.ValueTuple$2(T1,T2)));

                return comparer.System$Collections$IEqualityComparer$equals(this.Item1, objTuple.Item1) && comparer.System$Collections$IEqualityComparer$equals(this.Item2, objTuple.Item2);
            },
            System$IComparable$compareTo: function (other) {
                if (other == null) {
                    return 1;
                }

                if (!(Bridge.is(other, System.ValueTuple$2(T1,T2)))) {
                    throw new System.ArgumentException.$ctor3(System.SR.ArgumentException_ValueTupleIncorrectType, "other");
                }

                return this.compareTo(System.Nullable.getValue(Bridge.cast(Bridge.unbox(other, System.ValueTuple$2(T1,T2)), System.ValueTuple$2(T1,T2))));
            },
            compareTo: function (other) {
                var c = new (System.Collections.Generic.Comparer$1(T1))(System.Collections.Generic.Comparer$1.$default.fn).compare(this.Item1, other.Item1);
                if (c !== 0) {
                    return c;
                }

                return new (System.Collections.Generic.Comparer$1(T2))(System.Collections.Generic.Comparer$1.$default.fn).compare(this.Item2, other.Item2);
            },
            System$Collections$IStructuralComparable$CompareTo: function (other, comparer) {
                if (other == null) {
                    return 1;
                }

                if (!(Bridge.is(other, System.ValueTuple$2(T1,T2)))) {
                    throw new System.ArgumentException.$ctor3(System.SR.ArgumentException_ValueTupleIncorrectType, "other");
                }

                var objTuple = System.Nullable.getValue(Bridge.cast(Bridge.unbox(other, System.ValueTuple$2(T1,T2)), System.ValueTuple$2(T1,T2)));

                var c = comparer.System$Collections$IComparer$compare(this.Item1, objTuple.Item1);
                if (c !== 0) {
                    return c;
                }

                return comparer.System$Collections$IComparer$compare(this.Item2, objTuple.Item2);
            },
            getHashCode: function () {
                return System.ValueTuple.CombineHashCodes(System.ValueTuple$2(T1,T2).s_t1Comparer.getHashCode2(this.Item1), System.ValueTuple$2(T1,T2).s_t2Comparer.getHashCode2(this.Item2));
            },
            System$Collections$IStructuralEquatable$GetHashCode: function (comparer) {
                return this.GetHashCodeCore(comparer);
            },
            System$ITupleInternal$GetHashCode: function (comparer) {
                return this.GetHashCodeCore(comparer);
            },
            GetHashCodeCore: function (comparer) {
                return System.ValueTuple.CombineHashCodes(comparer.System$Collections$IEqualityComparer$getHashCode(this.Item1), comparer.System$Collections$IEqualityComparer$getHashCode(this.Item2));
            },
            toString: function () {
                return "(" + ((this.Item1 != null ? Bridge.toString(this.Item1) : null) || "") + ", " + ((this.Item2 != null ? Bridge.toString(this.Item2) : null) || "") + ")";
            },
            System$ITupleInternal$ToStringEnd: function () {
                return ((this.Item1 != null ? Bridge.toString(this.Item1) : null) || "") + ", " + ((this.Item2 != null ? Bridge.toString(this.Item2) : null) || "") + ")";
            },
            $clone: function (to) {
                var s = to || new (System.ValueTuple$2(T1,T2))();
                s.Item1 = this.Item1;
                s.Item2 = this.Item2;
                return s;
            }
        }
    }; });

    Bridge.define("System.ValueTuple$3", function (T1, T2, T3) { return {
        inherits: function () { return [System.IEquatable$1(System.ValueTuple$3(T1,T2,T3)),System.Collections.IStructuralEquatable,System.Collections.IStructuralComparable,System.IComparable,System.IComparable$1(System.ValueTuple$3(T1,T2,T3)),System.ITupleInternal]; },
        $kind: "struct",
        statics: {
            fields: {
                s_t1Comparer: null,
                s_t2Comparer: null,
                s_t3Comparer: null
            },
            ctors: {
                init: function () {
                    this.s_t1Comparer = System.Collections.Generic.EqualityComparer$1(T1).def;
                    this.s_t2Comparer = System.Collections.Generic.EqualityComparer$1(T2).def;
                    this.s_t3Comparer = System.Collections.Generic.EqualityComparer$1(T3).def;
                }
            },
            methods: {
                getDefaultValue: function () { return new (System.ValueTuple$3(T1,T2,T3))(); }
            }
        },
        fields: {
            Item1: Bridge.getDefaultValue(T1),
            Item2: Bridge.getDefaultValue(T2),
            Item3: Bridge.getDefaultValue(T3)
        },
        props: {
            System$ITupleInternal$Size: {
                get: function () {
                    return 3;
                }
            }
        },
        alias: [
            "equalsT", "System$IEquatable$1$System$ValueTuple$3$" + Bridge.getTypeAlias(T1) + "$" + Bridge.getTypeAlias(T2) + "$" + Bridge.getTypeAlias(T3) + "$equalsT",
            "compareTo", ["System$IComparable$1$System$ValueTuple$3$" + Bridge.getTypeAlias(T1) + "$" + Bridge.getTypeAlias(T2) + "$" + Bridge.getTypeAlias(T3) + "$compareTo", "System$IComparable$1$compareTo"]
        ],
        ctors: {
            $ctor1: function (item1, item2, item3) {
                this.$initialize();
                this.Item1 = item1;
                this.Item2 = item2;
                this.Item3 = item3;
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            equals: function (obj) {
                return Bridge.is(obj, System.ValueTuple$3(T1,T2,T3)) && this.equalsT(System.Nullable.getValue(Bridge.cast(Bridge.unbox(obj, System.ValueTuple$3(T1,T2,T3)), System.ValueTuple$3(T1,T2,T3))));
            },
            equalsT: function (other) {
                return System.ValueTuple$3(T1,T2,T3).s_t1Comparer.equals2(this.Item1, other.Item1) && System.ValueTuple$3(T1,T2,T3).s_t2Comparer.equals2(this.Item2, other.Item2) && System.ValueTuple$3(T1,T2,T3).s_t3Comparer.equals2(this.Item3, other.Item3);
            },
            System$Collections$IStructuralEquatable$Equals: function (other, comparer) {
                if (other == null || !(Bridge.is(other, System.ValueTuple$3(T1,T2,T3)))) {
                    return false;
                }

                var objTuple = System.Nullable.getValue(Bridge.cast(Bridge.unbox(other, System.ValueTuple$3(T1,T2,T3)), System.ValueTuple$3(T1,T2,T3)));

                return comparer.System$Collections$IEqualityComparer$equals(this.Item1, objTuple.Item1) && comparer.System$Collections$IEqualityComparer$equals(this.Item2, objTuple.Item2) && comparer.System$Collections$IEqualityComparer$equals(this.Item3, objTuple.Item3);
            },
            System$IComparable$compareTo: function (other) {
                if (other == null) {
                    return 1;
                }

                if (!(Bridge.is(other, System.ValueTuple$3(T1,T2,T3)))) {
                    throw new System.ArgumentException.$ctor3(System.SR.ArgumentException_ValueTupleIncorrectType, "other");
                }

                return this.compareTo(System.Nullable.getValue(Bridge.cast(Bridge.unbox(other, System.ValueTuple$3(T1,T2,T3)), System.ValueTuple$3(T1,T2,T3))));
            },
            compareTo: function (other) {
                var c = new (System.Collections.Generic.Comparer$1(T1))(System.Collections.Generic.Comparer$1.$default.fn).compare(this.Item1, other.Item1);
                if (c !== 0) {
                    return c;
                }

                c = new (System.Collections.Generic.Comparer$1(T2))(System.Collections.Generic.Comparer$1.$default.fn).compare(this.Item2, other.Item2);
                if (c !== 0) {
                    return c;
                }

                return new (System.Collections.Generic.Comparer$1(T3))(System.Collections.Generic.Comparer$1.$default.fn).compare(this.Item3, other.Item3);
            },
            System$Collections$IStructuralComparable$CompareTo: function (other, comparer) {
                if (other == null) {
                    return 1;
                }

                if (!(Bridge.is(other, System.ValueTuple$3(T1,T2,T3)))) {
                    throw new System.ArgumentException.$ctor3(System.SR.ArgumentException_ValueTupleIncorrectType, "other");
                }

                var objTuple = System.Nullable.getValue(Bridge.cast(Bridge.unbox(other, System.ValueTuple$3(T1,T2,T3)), System.ValueTuple$3(T1,T2,T3)));

                var c = comparer.System$Collections$IComparer$compare(this.Item1, objTuple.Item1);
                if (c !== 0) {
                    return c;
                }

                c = comparer.System$Collections$IComparer$compare(this.Item2, objTuple.Item2);
                if (c !== 0) {
                    return c;
                }

                return comparer.System$Collections$IComparer$compare(this.Item3, objTuple.Item3);
            },
            getHashCode: function () {
                return System.ValueTuple.CombineHashCodes$1(System.ValueTuple$3(T1,T2,T3).s_t1Comparer.getHashCode2(this.Item1), System.ValueTuple$3(T1,T2,T3).s_t2Comparer.getHashCode2(this.Item2), System.ValueTuple$3(T1,T2,T3).s_t3Comparer.getHashCode2(this.Item3));
            },
            System$Collections$IStructuralEquatable$GetHashCode: function (comparer) {
                return this.GetHashCodeCore(comparer);
            },
            System$ITupleInternal$GetHashCode: function (comparer) {
                return this.GetHashCodeCore(comparer);
            },
            GetHashCodeCore: function (comparer) {
                return System.ValueTuple.CombineHashCodes$1(comparer.System$Collections$IEqualityComparer$getHashCode(this.Item1), comparer.System$Collections$IEqualityComparer$getHashCode(this.Item2), comparer.System$Collections$IEqualityComparer$getHashCode(this.Item3));
            },
            toString: function () {
                return "(" + ((this.Item1 != null ? Bridge.toString(this.Item1) : null) || "") + ", " + ((this.Item2 != null ? Bridge.toString(this.Item2) : null) || "") + ", " + ((this.Item3 != null ? Bridge.toString(this.Item3) : null) || "") + ")";
            },
            System$ITupleInternal$ToStringEnd: function () {
                return ((this.Item1 != null ? Bridge.toString(this.Item1) : null) || "") + ", " + ((this.Item2 != null ? Bridge.toString(this.Item2) : null) || "") + ", " + ((this.Item3 != null ? Bridge.toString(this.Item3) : null) || "") + ")";
            },
            $clone: function (to) {
                var s = to || new (System.ValueTuple$3(T1,T2,T3))();
                s.Item1 = this.Item1;
                s.Item2 = this.Item2;
                s.Item3 = this.Item3;
                return s;
            }
        }
    }; });

    Bridge.define("System.ValueTuple$4", function (T1, T2, T3, T4) { return {
        inherits: function () { return [System.IEquatable$1(System.ValueTuple$4(T1,T2,T3,T4)),System.Collections.IStructuralEquatable,System.Collections.IStructuralComparable,System.IComparable,System.IComparable$1(System.ValueTuple$4(T1,T2,T3,T4)),System.ITupleInternal]; },
        $kind: "struct",
        statics: {
            fields: {
                s_t1Comparer: null,
                s_t2Comparer: null,
                s_t3Comparer: null,
                s_t4Comparer: null
            },
            ctors: {
                init: function () {
                    this.s_t1Comparer = System.Collections.Generic.EqualityComparer$1(T1).def;
                    this.s_t2Comparer = System.Collections.Generic.EqualityComparer$1(T2).def;
                    this.s_t3Comparer = System.Collections.Generic.EqualityComparer$1(T3).def;
                    this.s_t4Comparer = System.Collections.Generic.EqualityComparer$1(T4).def;
                }
            },
            methods: {
                getDefaultValue: function () { return new (System.ValueTuple$4(T1,T2,T3,T4))(); }
            }
        },
        fields: {
            Item1: Bridge.getDefaultValue(T1),
            Item2: Bridge.getDefaultValue(T2),
            Item3: Bridge.getDefaultValue(T3),
            Item4: Bridge.getDefaultValue(T4)
        },
        props: {
            System$ITupleInternal$Size: {
                get: function () {
                    return 4;
                }
            }
        },
        alias: [
            "equalsT", "System$IEquatable$1$System$ValueTuple$4$" + Bridge.getTypeAlias(T1) + "$" + Bridge.getTypeAlias(T2) + "$" + Bridge.getTypeAlias(T3) + "$" + Bridge.getTypeAlias(T4) + "$equalsT",
            "compareTo", ["System$IComparable$1$System$ValueTuple$4$" + Bridge.getTypeAlias(T1) + "$" + Bridge.getTypeAlias(T2) + "$" + Bridge.getTypeAlias(T3) + "$" + Bridge.getTypeAlias(T4) + "$compareTo", "System$IComparable$1$compareTo"]
        ],
        ctors: {
            $ctor1: function (item1, item2, item3, item4) {
                this.$initialize();
                this.Item1 = item1;
                this.Item2 = item2;
                this.Item3 = item3;
                this.Item4 = item4;
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            equals: function (obj) {
                return Bridge.is(obj, System.ValueTuple$4(T1,T2,T3,T4)) && this.equalsT(System.Nullable.getValue(Bridge.cast(Bridge.unbox(obj, System.ValueTuple$4(T1,T2,T3,T4)), System.ValueTuple$4(T1,T2,T3,T4))));
            },
            equalsT: function (other) {
                return System.ValueTuple$4(T1,T2,T3,T4).s_t1Comparer.equals2(this.Item1, other.Item1) && System.ValueTuple$4(T1,T2,T3,T4).s_t2Comparer.equals2(this.Item2, other.Item2) && System.ValueTuple$4(T1,T2,T3,T4).s_t3Comparer.equals2(this.Item3, other.Item3) && System.ValueTuple$4(T1,T2,T3,T4).s_t4Comparer.equals2(this.Item4, other.Item4);
            },
            System$Collections$IStructuralEquatable$Equals: function (other, comparer) {
                if (other == null || !(Bridge.is(other, System.ValueTuple$4(T1,T2,T3,T4)))) {
                    return false;
                }

                var objTuple = System.Nullable.getValue(Bridge.cast(Bridge.unbox(other, System.ValueTuple$4(T1,T2,T3,T4)), System.ValueTuple$4(T1,T2,T3,T4)));

                return comparer.System$Collections$IEqualityComparer$equals(this.Item1, objTuple.Item1) && comparer.System$Collections$IEqualityComparer$equals(this.Item2, objTuple.Item2) && comparer.System$Collections$IEqualityComparer$equals(this.Item3, objTuple.Item3) && comparer.System$Collections$IEqualityComparer$equals(this.Item4, objTuple.Item4);
            },
            System$IComparable$compareTo: function (other) {
                if (other == null) {
                    return 1;
                }

                if (!(Bridge.is(other, System.ValueTuple$4(T1,T2,T3,T4)))) {
                    throw new System.ArgumentException.$ctor3(System.SR.ArgumentException_ValueTupleIncorrectType, "other");
                }

                return this.compareTo(System.Nullable.getValue(Bridge.cast(Bridge.unbox(other, System.ValueTuple$4(T1,T2,T3,T4)), System.ValueTuple$4(T1,T2,T3,T4))));
            },
            compareTo: function (other) {
                var c = new (System.Collections.Generic.Comparer$1(T1))(System.Collections.Generic.Comparer$1.$default.fn).compare(this.Item1, other.Item1);
                if (c !== 0) {
                    return c;
                }

                c = new (System.Collections.Generic.Comparer$1(T2))(System.Collections.Generic.Comparer$1.$default.fn).compare(this.Item2, other.Item2);
                if (c !== 0) {
                    return c;
                }

                c = new (System.Collections.Generic.Comparer$1(T3))(System.Collections.Generic.Comparer$1.$default.fn).compare(this.Item3, other.Item3);
                if (c !== 0) {
                    return c;
                }

                return new (System.Collections.Generic.Comparer$1(T4))(System.Collections.Generic.Comparer$1.$default.fn).compare(this.Item4, other.Item4);
            },
            System$Collections$IStructuralComparable$CompareTo: function (other, comparer) {
                if (other == null) {
                    return 1;
                }

                if (!(Bridge.is(other, System.ValueTuple$4(T1,T2,T3,T4)))) {
                    throw new System.ArgumentException.$ctor3(System.SR.ArgumentException_ValueTupleIncorrectType, "other");
                }

                var objTuple = System.Nullable.getValue(Bridge.cast(Bridge.unbox(other, System.ValueTuple$4(T1,T2,T3,T4)), System.ValueTuple$4(T1,T2,T3,T4)));

                var c = comparer.System$Collections$IComparer$compare(this.Item1, objTuple.Item1);
                if (c !== 0) {
                    return c;
                }

                c = comparer.System$Collections$IComparer$compare(this.Item2, objTuple.Item2);
                if (c !== 0) {
                    return c;
                }

                c = comparer.System$Collections$IComparer$compare(this.Item3, objTuple.Item3);
                if (c !== 0) {
                    return c;
                }

                return comparer.System$Collections$IComparer$compare(this.Item4, objTuple.Item4);
            },
            getHashCode: function () {
                return System.ValueTuple.CombineHashCodes$2(System.ValueTuple$4(T1,T2,T3,T4).s_t1Comparer.getHashCode2(this.Item1), System.ValueTuple$4(T1,T2,T3,T4).s_t2Comparer.getHashCode2(this.Item2), System.ValueTuple$4(T1,T2,T3,T4).s_t3Comparer.getHashCode2(this.Item3), System.ValueTuple$4(T1,T2,T3,T4).s_t4Comparer.getHashCode2(this.Item4));
            },
            System$Collections$IStructuralEquatable$GetHashCode: function (comparer) {
                return this.GetHashCodeCore(comparer);
            },
            System$ITupleInternal$GetHashCode: function (comparer) {
                return this.GetHashCodeCore(comparer);
            },
            GetHashCodeCore: function (comparer) {
                return System.ValueTuple.CombineHashCodes$2(comparer.System$Collections$IEqualityComparer$getHashCode(this.Item1), comparer.System$Collections$IEqualityComparer$getHashCode(this.Item2), comparer.System$Collections$IEqualityComparer$getHashCode(this.Item3), comparer.System$Collections$IEqualityComparer$getHashCode(this.Item4));
            },
            toString: function () {
                return "(" + ((this.Item1 != null ? Bridge.toString(this.Item1) : null) || "") + ", " + ((this.Item2 != null ? Bridge.toString(this.Item2) : null) || "") + ", " + ((this.Item3 != null ? Bridge.toString(this.Item3) : null) || "") + ", " + ((this.Item4 != null ? Bridge.toString(this.Item4) : null) || "") + ")";
            },
            System$ITupleInternal$ToStringEnd: function () {
                return ((this.Item1 != null ? Bridge.toString(this.Item1) : null) || "") + ", " + ((this.Item2 != null ? Bridge.toString(this.Item2) : null) || "") + ", " + ((this.Item3 != null ? Bridge.toString(this.Item3) : null) || "") + ", " + ((this.Item4 != null ? Bridge.toString(this.Item4) : null) || "") + ")";
            },
            $clone: function (to) {
                var s = to || new (System.ValueTuple$4(T1,T2,T3,T4))();
                s.Item1 = this.Item1;
                s.Item2 = this.Item2;
                s.Item3 = this.Item3;
                s.Item4 = this.Item4;
                return s;
            }
        }
    }; });

    Bridge.define("System.ValueTuple$5", function (T1, T2, T3, T4, T5) { return {
        inherits: function () { return [System.IEquatable$1(System.ValueTuple$5(T1,T2,T3,T4,T5)),System.Collections.IStructuralEquatable,System.Collections.IStructuralComparable,System.IComparable,System.IComparable$1(System.ValueTuple$5(T1,T2,T3,T4,T5)),System.ITupleInternal]; },
        $kind: "struct",
        statics: {
            fields: {
                s_t1Comparer: null,
                s_t2Comparer: null,
                s_t3Comparer: null,
                s_t4Comparer: null,
                s_t5Comparer: null
            },
            ctors: {
                init: function () {
                    this.s_t1Comparer = System.Collections.Generic.EqualityComparer$1(T1).def;
                    this.s_t2Comparer = System.Collections.Generic.EqualityComparer$1(T2).def;
                    this.s_t3Comparer = System.Collections.Generic.EqualityComparer$1(T3).def;
                    this.s_t4Comparer = System.Collections.Generic.EqualityComparer$1(T4).def;
                    this.s_t5Comparer = System.Collections.Generic.EqualityComparer$1(T5).def;
                }
            },
            methods: {
                getDefaultValue: function () { return new (System.ValueTuple$5(T1,T2,T3,T4,T5))(); }
            }
        },
        fields: {
            Item1: Bridge.getDefaultValue(T1),
            Item2: Bridge.getDefaultValue(T2),
            Item3: Bridge.getDefaultValue(T3),
            Item4: Bridge.getDefaultValue(T4),
            Item5: Bridge.getDefaultValue(T5)
        },
        props: {
            System$ITupleInternal$Size: {
                get: function () {
                    return 5;
                }
            }
        },
        alias: [
            "equalsT", "System$IEquatable$1$System$ValueTuple$5$" + Bridge.getTypeAlias(T1) + "$" + Bridge.getTypeAlias(T2) + "$" + Bridge.getTypeAlias(T3) + "$" + Bridge.getTypeAlias(T4) + "$" + Bridge.getTypeAlias(T5) + "$equalsT",
            "compareTo", ["System$IComparable$1$System$ValueTuple$5$" + Bridge.getTypeAlias(T1) + "$" + Bridge.getTypeAlias(T2) + "$" + Bridge.getTypeAlias(T3) + "$" + Bridge.getTypeAlias(T4) + "$" + Bridge.getTypeAlias(T5) + "$compareTo", "System$IComparable$1$compareTo"]
        ],
        ctors: {
            $ctor1: function (item1, item2, item3, item4, item5) {
                this.$initialize();
                this.Item1 = item1;
                this.Item2 = item2;
                this.Item3 = item3;
                this.Item4 = item4;
                this.Item5 = item5;
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            equals: function (obj) {
                return Bridge.is(obj, System.ValueTuple$5(T1,T2,T3,T4,T5)) && this.equalsT(System.Nullable.getValue(Bridge.cast(Bridge.unbox(obj, System.ValueTuple$5(T1,T2,T3,T4,T5)), System.ValueTuple$5(T1,T2,T3,T4,T5))));
            },
            equalsT: function (other) {
                return System.ValueTuple$5(T1,T2,T3,T4,T5).s_t1Comparer.equals2(this.Item1, other.Item1) && System.ValueTuple$5(T1,T2,T3,T4,T5).s_t2Comparer.equals2(this.Item2, other.Item2) && System.ValueTuple$5(T1,T2,T3,T4,T5).s_t3Comparer.equals2(this.Item3, other.Item3) && System.ValueTuple$5(T1,T2,T3,T4,T5).s_t4Comparer.equals2(this.Item4, other.Item4) && System.ValueTuple$5(T1,T2,T3,T4,T5).s_t5Comparer.equals2(this.Item5, other.Item5);
            },
            System$Collections$IStructuralEquatable$Equals: function (other, comparer) {
                if (other == null || !(Bridge.is(other, System.ValueTuple$5(T1,T2,T3,T4,T5)))) {
                    return false;
                }

                var objTuple = System.Nullable.getValue(Bridge.cast(Bridge.unbox(other, System.ValueTuple$5(T1,T2,T3,T4,T5)), System.ValueTuple$5(T1,T2,T3,T4,T5)));

                return comparer.System$Collections$IEqualityComparer$equals(this.Item1, objTuple.Item1) && comparer.System$Collections$IEqualityComparer$equals(this.Item2, objTuple.Item2) && comparer.System$Collections$IEqualityComparer$equals(this.Item3, objTuple.Item3) && comparer.System$Collections$IEqualityComparer$equals(this.Item4, objTuple.Item4) && comparer.System$Collections$IEqualityComparer$equals(this.Item5, objTuple.Item5);
            },
            System$IComparable$compareTo: function (other) {
                if (other == null) {
                    return 1;
                }

                if (!(Bridge.is(other, System.ValueTuple$5(T1,T2,T3,T4,T5)))) {
                    throw new System.ArgumentException.$ctor3(System.SR.ArgumentException_ValueTupleIncorrectType, "other");
                }

                return this.compareTo(System.Nullable.getValue(Bridge.cast(Bridge.unbox(other, System.ValueTuple$5(T1,T2,T3,T4,T5)), System.ValueTuple$5(T1,T2,T3,T4,T5))));
            },
            compareTo: function (other) {
                var c = new (System.Collections.Generic.Comparer$1(T1))(System.Collections.Generic.Comparer$1.$default.fn).compare(this.Item1, other.Item1);
                if (c !== 0) {
                    return c;
                }

                c = new (System.Collections.Generic.Comparer$1(T2))(System.Collections.Generic.Comparer$1.$default.fn).compare(this.Item2, other.Item2);
                if (c !== 0) {
                    return c;
                }

                c = new (System.Collections.Generic.Comparer$1(T3))(System.Collections.Generic.Comparer$1.$default.fn).compare(this.Item3, other.Item3);
                if (c !== 0) {
                    return c;
                }

                c = new (System.Collections.Generic.Comparer$1(T4))(System.Collections.Generic.Comparer$1.$default.fn).compare(this.Item4, other.Item4);
                if (c !== 0) {
                    return c;
                }

                return new (System.Collections.Generic.Comparer$1(T5))(System.Collections.Generic.Comparer$1.$default.fn).compare(this.Item5, other.Item5);
            },
            System$Collections$IStructuralComparable$CompareTo: function (other, comparer) {
                if (other == null) {
                    return 1;
                }

                if (!(Bridge.is(other, System.ValueTuple$5(T1,T2,T3,T4,T5)))) {
                    throw new System.ArgumentException.$ctor3(System.SR.ArgumentException_ValueTupleIncorrectType, "other");
                }

                var objTuple = System.Nullable.getValue(Bridge.cast(Bridge.unbox(other, System.ValueTuple$5(T1,T2,T3,T4,T5)), System.ValueTuple$5(T1,T2,T3,T4,T5)));

                var c = comparer.System$Collections$IComparer$compare(this.Item1, objTuple.Item1);
                if (c !== 0) {
                    return c;
                }

                c = comparer.System$Collections$IComparer$compare(this.Item2, objTuple.Item2);
                if (c !== 0) {
                    return c;
                }

                c = comparer.System$Collections$IComparer$compare(this.Item3, objTuple.Item3);
                if (c !== 0) {
                    return c;
                }

                c = comparer.System$Collections$IComparer$compare(this.Item4, objTuple.Item4);
                if (c !== 0) {
                    return c;
                }

                return comparer.System$Collections$IComparer$compare(this.Item5, objTuple.Item5);
            },
            getHashCode: function () {
                return System.ValueTuple.CombineHashCodes$3(System.ValueTuple$5(T1,T2,T3,T4,T5).s_t1Comparer.getHashCode2(this.Item1), System.ValueTuple$5(T1,T2,T3,T4,T5).s_t2Comparer.getHashCode2(this.Item2), System.ValueTuple$5(T1,T2,T3,T4,T5).s_t3Comparer.getHashCode2(this.Item3), System.ValueTuple$5(T1,T2,T3,T4,T5).s_t4Comparer.getHashCode2(this.Item4), System.ValueTuple$5(T1,T2,T3,T4,T5).s_t5Comparer.getHashCode2(this.Item5));
            },
            System$Collections$IStructuralEquatable$GetHashCode: function (comparer) {
                return this.GetHashCodeCore(comparer);
            },
            System$ITupleInternal$GetHashCode: function (comparer) {
                return this.GetHashCodeCore(comparer);
            },
            GetHashCodeCore: function (comparer) {
                return System.ValueTuple.CombineHashCodes$3(comparer.System$Collections$IEqualityComparer$getHashCode(this.Item1), comparer.System$Collections$IEqualityComparer$getHashCode(this.Item2), comparer.System$Collections$IEqualityComparer$getHashCode(this.Item3), comparer.System$Collections$IEqualityComparer$getHashCode(this.Item4), comparer.System$Collections$IEqualityComparer$getHashCode(this.Item5));
            },
            toString: function () {
                return "(" + ((this.Item1 != null ? Bridge.toString(this.Item1) : null) || "") + ", " + ((this.Item2 != null ? Bridge.toString(this.Item2) : null) || "") + ", " + ((this.Item3 != null ? Bridge.toString(this.Item3) : null) || "") + ", " + ((this.Item4 != null ? Bridge.toString(this.Item4) : null) || "") + ", " + ((this.Item5 != null ? Bridge.toString(this.Item5) : null) || "") + ")";
            },
            System$ITupleInternal$ToStringEnd: function () {
                return ((this.Item1 != null ? Bridge.toString(this.Item1) : null) || "") + ", " + ((this.Item2 != null ? Bridge.toString(this.Item2) : null) || "") + ", " + ((this.Item3 != null ? Bridge.toString(this.Item3) : null) || "") + ", " + ((this.Item4 != null ? Bridge.toString(this.Item4) : null) || "") + ", " + ((this.Item5 != null ? Bridge.toString(this.Item5) : null) || "") + ")";
            },
            $clone: function (to) {
                var s = to || new (System.ValueTuple$5(T1,T2,T3,T4,T5))();
                s.Item1 = this.Item1;
                s.Item2 = this.Item2;
                s.Item3 = this.Item3;
                s.Item4 = this.Item4;
                s.Item5 = this.Item5;
                return s;
            }
        }
    }; });

    Bridge.define("System.ValueTuple$6", function (T1, T2, T3, T4, T5, T6) { return {
        inherits: function () { return [System.IEquatable$1(System.ValueTuple$6(T1,T2,T3,T4,T5,T6)),System.Collections.IStructuralEquatable,System.Collections.IStructuralComparable,System.IComparable,System.IComparable$1(System.ValueTuple$6(T1,T2,T3,T4,T5,T6)),System.ITupleInternal]; },
        $kind: "struct",
        statics: {
            fields: {
                s_t1Comparer: null,
                s_t2Comparer: null,
                s_t3Comparer: null,
                s_t4Comparer: null,
                s_t5Comparer: null,
                s_t6Comparer: null
            },
            ctors: {
                init: function () {
                    this.s_t1Comparer = System.Collections.Generic.EqualityComparer$1(T1).def;
                    this.s_t2Comparer = System.Collections.Generic.EqualityComparer$1(T2).def;
                    this.s_t3Comparer = System.Collections.Generic.EqualityComparer$1(T3).def;
                    this.s_t4Comparer = System.Collections.Generic.EqualityComparer$1(T4).def;
                    this.s_t5Comparer = System.Collections.Generic.EqualityComparer$1(T5).def;
                    this.s_t6Comparer = System.Collections.Generic.EqualityComparer$1(T6).def;
                }
            },
            methods: {
                getDefaultValue: function () { return new (System.ValueTuple$6(T1,T2,T3,T4,T5,T6))(); }
            }
        },
        fields: {
            Item1: Bridge.getDefaultValue(T1),
            Item2: Bridge.getDefaultValue(T2),
            Item3: Bridge.getDefaultValue(T3),
            Item4: Bridge.getDefaultValue(T4),
            Item5: Bridge.getDefaultValue(T5),
            Item6: Bridge.getDefaultValue(T6)
        },
        props: {
            System$ITupleInternal$Size: {
                get: function () {
                    return 6;
                }
            }
        },
        alias: [
            "equalsT", "System$IEquatable$1$System$ValueTuple$6$" + Bridge.getTypeAlias(T1) + "$" + Bridge.getTypeAlias(T2) + "$" + Bridge.getTypeAlias(T3) + "$" + Bridge.getTypeAlias(T4) + "$" + Bridge.getTypeAlias(T5) + "$" + Bridge.getTypeAlias(T6) + "$equalsT",
            "compareTo", ["System$IComparable$1$System$ValueTuple$6$" + Bridge.getTypeAlias(T1) + "$" + Bridge.getTypeAlias(T2) + "$" + Bridge.getTypeAlias(T3) + "$" + Bridge.getTypeAlias(T4) + "$" + Bridge.getTypeAlias(T5) + "$" + Bridge.getTypeAlias(T6) + "$compareTo", "System$IComparable$1$compareTo"]
        ],
        ctors: {
            $ctor1: function (item1, item2, item3, item4, item5, item6) {
                this.$initialize();
                this.Item1 = item1;
                this.Item2 = item2;
                this.Item3 = item3;
                this.Item4 = item4;
                this.Item5 = item5;
                this.Item6 = item6;
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            equals: function (obj) {
                return Bridge.is(obj, System.ValueTuple$6(T1,T2,T3,T4,T5,T6)) && this.equalsT(System.Nullable.getValue(Bridge.cast(Bridge.unbox(obj, System.ValueTuple$6(T1,T2,T3,T4,T5,T6)), System.ValueTuple$6(T1,T2,T3,T4,T5,T6))));
            },
            equalsT: function (other) {
                return System.ValueTuple$6(T1,T2,T3,T4,T5,T6).s_t1Comparer.equals2(this.Item1, other.Item1) && System.ValueTuple$6(T1,T2,T3,T4,T5,T6).s_t2Comparer.equals2(this.Item2, other.Item2) && System.ValueTuple$6(T1,T2,T3,T4,T5,T6).s_t3Comparer.equals2(this.Item3, other.Item3) && System.ValueTuple$6(T1,T2,T3,T4,T5,T6).s_t4Comparer.equals2(this.Item4, other.Item4) && System.ValueTuple$6(T1,T2,T3,T4,T5,T6).s_t5Comparer.equals2(this.Item5, other.Item5) && System.ValueTuple$6(T1,T2,T3,T4,T5,T6).s_t6Comparer.equals2(this.Item6, other.Item6);
            },
            System$Collections$IStructuralEquatable$Equals: function (other, comparer) {
                if (other == null || !(Bridge.is(other, System.ValueTuple$6(T1,T2,T3,T4,T5,T6)))) {
                    return false;
                }

                var objTuple = System.Nullable.getValue(Bridge.cast(Bridge.unbox(other, System.ValueTuple$6(T1,T2,T3,T4,T5,T6)), System.ValueTuple$6(T1,T2,T3,T4,T5,T6)));

                return comparer.System$Collections$IEqualityComparer$equals(this.Item1, objTuple.Item1) && comparer.System$Collections$IEqualityComparer$equals(this.Item2, objTuple.Item2) && comparer.System$Collections$IEqualityComparer$equals(this.Item3, objTuple.Item3) && comparer.System$Collections$IEqualityComparer$equals(this.Item4, objTuple.Item4) && comparer.System$Collections$IEqualityComparer$equals(this.Item5, objTuple.Item5) && comparer.System$Collections$IEqualityComparer$equals(this.Item6, objTuple.Item6);
            },
            System$IComparable$compareTo: function (other) {
                if (other == null) {
                    return 1;
                }

                if (!(Bridge.is(other, System.ValueTuple$6(T1,T2,T3,T4,T5,T6)))) {
                    throw new System.ArgumentException.$ctor3(System.SR.ArgumentException_ValueTupleIncorrectType, "other");
                }

                return this.compareTo(System.Nullable.getValue(Bridge.cast(Bridge.unbox(other, System.ValueTuple$6(T1,T2,T3,T4,T5,T6)), System.ValueTuple$6(T1,T2,T3,T4,T5,T6))));
            },
            compareTo: function (other) {
                var c = new (System.Collections.Generic.Comparer$1(T1))(System.Collections.Generic.Comparer$1.$default.fn).compare(this.Item1, other.Item1);
                if (c !== 0) {
                    return c;
                }

                c = new (System.Collections.Generic.Comparer$1(T2))(System.Collections.Generic.Comparer$1.$default.fn).compare(this.Item2, other.Item2);
                if (c !== 0) {
                    return c;
                }

                c = new (System.Collections.Generic.Comparer$1(T3))(System.Collections.Generic.Comparer$1.$default.fn).compare(this.Item3, other.Item3);
                if (c !== 0) {
                    return c;
                }

                c = new (System.Collections.Generic.Comparer$1(T4))(System.Collections.Generic.Comparer$1.$default.fn).compare(this.Item4, other.Item4);
                if (c !== 0) {
                    return c;
                }

                c = new (System.Collections.Generic.Comparer$1(T5))(System.Collections.Generic.Comparer$1.$default.fn).compare(this.Item5, other.Item5);
                if (c !== 0) {
                    return c;
                }

                return new (System.Collections.Generic.Comparer$1(T6))(System.Collections.Generic.Comparer$1.$default.fn).compare(this.Item6, other.Item6);
            },
            System$Collections$IStructuralComparable$CompareTo: function (other, comparer) {
                if (other == null) {
                    return 1;
                }

                if (!(Bridge.is(other, System.ValueTuple$6(T1,T2,T3,T4,T5,T6)))) {
                    throw new System.ArgumentException.$ctor3(System.SR.ArgumentException_ValueTupleIncorrectType, "other");
                }

                var objTuple = System.Nullable.getValue(Bridge.cast(Bridge.unbox(other, System.ValueTuple$6(T1,T2,T3,T4,T5,T6)), System.ValueTuple$6(T1,T2,T3,T4,T5,T6)));

                var c = comparer.System$Collections$IComparer$compare(this.Item1, objTuple.Item1);
                if (c !== 0) {
                    return c;
                }

                c = comparer.System$Collections$IComparer$compare(this.Item2, objTuple.Item2);
                if (c !== 0) {
                    return c;
                }

                c = comparer.System$Collections$IComparer$compare(this.Item3, objTuple.Item3);
                if (c !== 0) {
                    return c;
                }

                c = comparer.System$Collections$IComparer$compare(this.Item4, objTuple.Item4);
                if (c !== 0) {
                    return c;
                }

                c = comparer.System$Collections$IComparer$compare(this.Item5, objTuple.Item5);
                if (c !== 0) {
                    return c;
                }

                return comparer.System$Collections$IComparer$compare(this.Item6, objTuple.Item6);
            },
            getHashCode: function () {
                return System.ValueTuple.CombineHashCodes$4(System.ValueTuple$6(T1,T2,T3,T4,T5,T6).s_t1Comparer.getHashCode2(this.Item1), System.ValueTuple$6(T1,T2,T3,T4,T5,T6).s_t2Comparer.getHashCode2(this.Item2), System.ValueTuple$6(T1,T2,T3,T4,T5,T6).s_t3Comparer.getHashCode2(this.Item3), System.ValueTuple$6(T1,T2,T3,T4,T5,T6).s_t4Comparer.getHashCode2(this.Item4), System.ValueTuple$6(T1,T2,T3,T4,T5,T6).s_t5Comparer.getHashCode2(this.Item5), System.ValueTuple$6(T1,T2,T3,T4,T5,T6).s_t6Comparer.getHashCode2(this.Item6));
            },
            System$Collections$IStructuralEquatable$GetHashCode: function (comparer) {
                return this.GetHashCodeCore(comparer);
            },
            System$ITupleInternal$GetHashCode: function (comparer) {
                return this.GetHashCodeCore(comparer);
            },
            GetHashCodeCore: function (comparer) {
                return System.ValueTuple.CombineHashCodes$4(comparer.System$Collections$IEqualityComparer$getHashCode(this.Item1), comparer.System$Collections$IEqualityComparer$getHashCode(this.Item2), comparer.System$Collections$IEqualityComparer$getHashCode(this.Item3), comparer.System$Collections$IEqualityComparer$getHashCode(this.Item4), comparer.System$Collections$IEqualityComparer$getHashCode(this.Item5), comparer.System$Collections$IEqualityComparer$getHashCode(this.Item6));
            },
            toString: function () {
                return "(" + ((this.Item1 != null ? Bridge.toString(this.Item1) : null) || "") + ", " + ((this.Item2 != null ? Bridge.toString(this.Item2) : null) || "") + ", " + ((this.Item3 != null ? Bridge.toString(this.Item3) : null) || "") + ", " + ((this.Item4 != null ? Bridge.toString(this.Item4) : null) || "") + ", " + ((this.Item5 != null ? Bridge.toString(this.Item5) : null) || "") + ", " + ((this.Item6 != null ? Bridge.toString(this.Item6) : null) || "") + ")";
            },
            System$ITupleInternal$ToStringEnd: function () {
                return ((this.Item1 != null ? Bridge.toString(this.Item1) : null) || "") + ", " + ((this.Item2 != null ? Bridge.toString(this.Item2) : null) || "") + ", " + ((this.Item3 != null ? Bridge.toString(this.Item3) : null) || "") + ", " + ((this.Item4 != null ? Bridge.toString(this.Item4) : null) || "") + ", " + ((this.Item5 != null ? Bridge.toString(this.Item5) : null) || "") + ", " + ((this.Item6 != null ? Bridge.toString(this.Item6) : null) || "") + ")";
            },
            $clone: function (to) {
                var s = to || new (System.ValueTuple$6(T1,T2,T3,T4,T5,T6))();
                s.Item1 = this.Item1;
                s.Item2 = this.Item2;
                s.Item3 = this.Item3;
                s.Item4 = this.Item4;
                s.Item5 = this.Item5;
                s.Item6 = this.Item6;
                return s;
            }
        }
    }; });

    Bridge.define("System.ValueTuple$7", function (T1, T2, T3, T4, T5, T6, T7) { return {
        inherits: function () { return [System.IEquatable$1(System.ValueTuple$7(T1,T2,T3,T4,T5,T6,T7)),System.Collections.IStructuralEquatable,System.Collections.IStructuralComparable,System.IComparable,System.IComparable$1(System.ValueTuple$7(T1,T2,T3,T4,T5,T6,T7)),System.ITupleInternal]; },
        $kind: "struct",
        statics: {
            fields: {
                s_t1Comparer: null,
                s_t2Comparer: null,
                s_t3Comparer: null,
                s_t4Comparer: null,
                s_t5Comparer: null,
                s_t6Comparer: null,
                s_t7Comparer: null
            },
            ctors: {
                init: function () {
                    this.s_t1Comparer = System.Collections.Generic.EqualityComparer$1(T1).def;
                    this.s_t2Comparer = System.Collections.Generic.EqualityComparer$1(T2).def;
                    this.s_t3Comparer = System.Collections.Generic.EqualityComparer$1(T3).def;
                    this.s_t4Comparer = System.Collections.Generic.EqualityComparer$1(T4).def;
                    this.s_t5Comparer = System.Collections.Generic.EqualityComparer$1(T5).def;
                    this.s_t6Comparer = System.Collections.Generic.EqualityComparer$1(T6).def;
                    this.s_t7Comparer = System.Collections.Generic.EqualityComparer$1(T7).def;
                }
            },
            methods: {
                getDefaultValue: function () { return new (System.ValueTuple$7(T1,T2,T3,T4,T5,T6,T7))(); }
            }
        },
        fields: {
            Item1: Bridge.getDefaultValue(T1),
            Item2: Bridge.getDefaultValue(T2),
            Item3: Bridge.getDefaultValue(T3),
            Item4: Bridge.getDefaultValue(T4),
            Item5: Bridge.getDefaultValue(T5),
            Item6: Bridge.getDefaultValue(T6),
            Item7: Bridge.getDefaultValue(T7)
        },
        props: {
            System$ITupleInternal$Size: {
                get: function () {
                    return 7;
                }
            }
        },
        alias: [
            "equalsT", "System$IEquatable$1$System$ValueTuple$7$" + Bridge.getTypeAlias(T1) + "$" + Bridge.getTypeAlias(T2) + "$" + Bridge.getTypeAlias(T3) + "$" + Bridge.getTypeAlias(T4) + "$" + Bridge.getTypeAlias(T5) + "$" + Bridge.getTypeAlias(T6) + "$" + Bridge.getTypeAlias(T7) + "$equalsT",
            "compareTo", ["System$IComparable$1$System$ValueTuple$7$" + Bridge.getTypeAlias(T1) + "$" + Bridge.getTypeAlias(T2) + "$" + Bridge.getTypeAlias(T3) + "$" + Bridge.getTypeAlias(T4) + "$" + Bridge.getTypeAlias(T5) + "$" + Bridge.getTypeAlias(T6) + "$" + Bridge.getTypeAlias(T7) + "$compareTo", "System$IComparable$1$compareTo"]
        ],
        ctors: {
            $ctor1: function (item1, item2, item3, item4, item5, item6, item7) {
                this.$initialize();
                this.Item1 = item1;
                this.Item2 = item2;
                this.Item3 = item3;
                this.Item4 = item4;
                this.Item5 = item5;
                this.Item6 = item6;
                this.Item7 = item7;
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            equals: function (obj) {
                return Bridge.is(obj, System.ValueTuple$7(T1,T2,T3,T4,T5,T6,T7)) && this.equalsT(System.Nullable.getValue(Bridge.cast(Bridge.unbox(obj, System.ValueTuple$7(T1,T2,T3,T4,T5,T6,T7)), System.ValueTuple$7(T1,T2,T3,T4,T5,T6,T7))));
            },
            equalsT: function (other) {
                return System.ValueTuple$7(T1,T2,T3,T4,T5,T6,T7).s_t1Comparer.equals2(this.Item1, other.Item1) && System.ValueTuple$7(T1,T2,T3,T4,T5,T6,T7).s_t2Comparer.equals2(this.Item2, other.Item2) && System.ValueTuple$7(T1,T2,T3,T4,T5,T6,T7).s_t3Comparer.equals2(this.Item3, other.Item3) && System.ValueTuple$7(T1,T2,T3,T4,T5,T6,T7).s_t4Comparer.equals2(this.Item4, other.Item4) && System.ValueTuple$7(T1,T2,T3,T4,T5,T6,T7).s_t5Comparer.equals2(this.Item5, other.Item5) && System.ValueTuple$7(T1,T2,T3,T4,T5,T6,T7).s_t6Comparer.equals2(this.Item6, other.Item6) && System.ValueTuple$7(T1,T2,T3,T4,T5,T6,T7).s_t7Comparer.equals2(this.Item7, other.Item7);
            },
            System$Collections$IStructuralEquatable$Equals: function (other, comparer) {
                if (other == null || !(Bridge.is(other, System.ValueTuple$7(T1,T2,T3,T4,T5,T6,T7)))) {
                    return false;
                }

                var objTuple = System.Nullable.getValue(Bridge.cast(Bridge.unbox(other, System.ValueTuple$7(T1,T2,T3,T4,T5,T6,T7)), System.ValueTuple$7(T1,T2,T3,T4,T5,T6,T7)));

                return comparer.System$Collections$IEqualityComparer$equals(this.Item1, objTuple.Item1) && comparer.System$Collections$IEqualityComparer$equals(this.Item2, objTuple.Item2) && comparer.System$Collections$IEqualityComparer$equals(this.Item3, objTuple.Item3) && comparer.System$Collections$IEqualityComparer$equals(this.Item4, objTuple.Item4) && comparer.System$Collections$IEqualityComparer$equals(this.Item5, objTuple.Item5) && comparer.System$Collections$IEqualityComparer$equals(this.Item6, objTuple.Item6) && comparer.System$Collections$IEqualityComparer$equals(this.Item7, objTuple.Item7);
            },
            System$IComparable$compareTo: function (other) {
                if (other == null) {
                    return 1;
                }

                if (!(Bridge.is(other, System.ValueTuple$7(T1,T2,T3,T4,T5,T6,T7)))) {
                    throw new System.ArgumentException.$ctor3(System.SR.ArgumentException_ValueTupleIncorrectType, "other");
                }

                return this.compareTo(System.Nullable.getValue(Bridge.cast(Bridge.unbox(other, System.ValueTuple$7(T1,T2,T3,T4,T5,T6,T7)), System.ValueTuple$7(T1,T2,T3,T4,T5,T6,T7))));
            },
            compareTo: function (other) {
                var c = new (System.Collections.Generic.Comparer$1(T1))(System.Collections.Generic.Comparer$1.$default.fn).compare(this.Item1, other.Item1);
                if (c !== 0) {
                    return c;
                }

                c = new (System.Collections.Generic.Comparer$1(T2))(System.Collections.Generic.Comparer$1.$default.fn).compare(this.Item2, other.Item2);
                if (c !== 0) {
                    return c;
                }

                c = new (System.Collections.Generic.Comparer$1(T3))(System.Collections.Generic.Comparer$1.$default.fn).compare(this.Item3, other.Item3);
                if (c !== 0) {
                    return c;
                }

                c = new (System.Collections.Generic.Comparer$1(T4))(System.Collections.Generic.Comparer$1.$default.fn).compare(this.Item4, other.Item4);
                if (c !== 0) {
                    return c;
                }

                c = new (System.Collections.Generic.Comparer$1(T5))(System.Collections.Generic.Comparer$1.$default.fn).compare(this.Item5, other.Item5);
                if (c !== 0) {
                    return c;
                }

                c = new (System.Collections.Generic.Comparer$1(T6))(System.Collections.Generic.Comparer$1.$default.fn).compare(this.Item6, other.Item6);
                if (c !== 0) {
                    return c;
                }

                return new (System.Collections.Generic.Comparer$1(T7))(System.Collections.Generic.Comparer$1.$default.fn).compare(this.Item7, other.Item7);
            },
            System$Collections$IStructuralComparable$CompareTo: function (other, comparer) {
                if (other == null) {
                    return 1;
                }

                if (!(Bridge.is(other, System.ValueTuple$7(T1,T2,T3,T4,T5,T6,T7)))) {
                    throw new System.ArgumentException.$ctor3(System.SR.ArgumentException_ValueTupleIncorrectType, "other");
                }

                var objTuple = System.Nullable.getValue(Bridge.cast(Bridge.unbox(other, System.ValueTuple$7(T1,T2,T3,T4,T5,T6,T7)), System.ValueTuple$7(T1,T2,T3,T4,T5,T6,T7)));

                var c = comparer.System$Collections$IComparer$compare(this.Item1, objTuple.Item1);
                if (c !== 0) {
                    return c;
                }

                c = comparer.System$Collections$IComparer$compare(this.Item2, objTuple.Item2);
                if (c !== 0) {
                    return c;
                }

                c = comparer.System$Collections$IComparer$compare(this.Item3, objTuple.Item3);
                if (c !== 0) {
                    return c;
                }

                c = comparer.System$Collections$IComparer$compare(this.Item4, objTuple.Item4);
                if (c !== 0) {
                    return c;
                }

                c = comparer.System$Collections$IComparer$compare(this.Item5, objTuple.Item5);
                if (c !== 0) {
                    return c;
                }

                c = comparer.System$Collections$IComparer$compare(this.Item6, objTuple.Item6);
                if (c !== 0) {
                    return c;
                }

                return comparer.System$Collections$IComparer$compare(this.Item7, objTuple.Item7);
            },
            getHashCode: function () {
                return System.ValueTuple.CombineHashCodes$5(System.ValueTuple$7(T1,T2,T3,T4,T5,T6,T7).s_t1Comparer.getHashCode2(this.Item1), System.ValueTuple$7(T1,T2,T3,T4,T5,T6,T7).s_t2Comparer.getHashCode2(this.Item2), System.ValueTuple$7(T1,T2,T3,T4,T5,T6,T7).s_t3Comparer.getHashCode2(this.Item3), System.ValueTuple$7(T1,T2,T3,T4,T5,T6,T7).s_t4Comparer.getHashCode2(this.Item4), System.ValueTuple$7(T1,T2,T3,T4,T5,T6,T7).s_t5Comparer.getHashCode2(this.Item5), System.ValueTuple$7(T1,T2,T3,T4,T5,T6,T7).s_t6Comparer.getHashCode2(this.Item6), System.ValueTuple$7(T1,T2,T3,T4,T5,T6,T7).s_t7Comparer.getHashCode2(this.Item7));
            },
            System$Collections$IStructuralEquatable$GetHashCode: function (comparer) {
                return this.GetHashCodeCore(comparer);
            },
            System$ITupleInternal$GetHashCode: function (comparer) {
                return this.GetHashCodeCore(comparer);
            },
            GetHashCodeCore: function (comparer) {
                return System.ValueTuple.CombineHashCodes$5(comparer.System$Collections$IEqualityComparer$getHashCode(this.Item1), comparer.System$Collections$IEqualityComparer$getHashCode(this.Item2), comparer.System$Collections$IEqualityComparer$getHashCode(this.Item3), comparer.System$Collections$IEqualityComparer$getHashCode(this.Item4), comparer.System$Collections$IEqualityComparer$getHashCode(this.Item5), comparer.System$Collections$IEqualityComparer$getHashCode(this.Item6), comparer.System$Collections$IEqualityComparer$getHashCode(this.Item7));
            },
            toString: function () {
                return "(" + ((this.Item1 != null ? Bridge.toString(this.Item1) : null) || "") + ", " + ((this.Item2 != null ? Bridge.toString(this.Item2) : null) || "") + ", " + ((this.Item3 != null ? Bridge.toString(this.Item3) : null) || "") + ", " + ((this.Item4 != null ? Bridge.toString(this.Item4) : null) || "") + ", " + ((this.Item5 != null ? Bridge.toString(this.Item5) : null) || "") + ", " + ((this.Item6 != null ? Bridge.toString(this.Item6) : null) || "") + ", " + ((this.Item7 != null ? Bridge.toString(this.Item7) : null) || "") + ")";
            },
            System$ITupleInternal$ToStringEnd: function () {
                return ((this.Item1 != null ? Bridge.toString(this.Item1) : null) || "") + ", " + ((this.Item2 != null ? Bridge.toString(this.Item2) : null) || "") + ", " + ((this.Item3 != null ? Bridge.toString(this.Item3) : null) || "") + ", " + ((this.Item4 != null ? Bridge.toString(this.Item4) : null) || "") + ", " + ((this.Item5 != null ? Bridge.toString(this.Item5) : null) || "") + ", " + ((this.Item6 != null ? Bridge.toString(this.Item6) : null) || "") + ", " + ((this.Item7 != null ? Bridge.toString(this.Item7) : null) || "") + ")";
            },
            $clone: function (to) {
                var s = to || new (System.ValueTuple$7(T1,T2,T3,T4,T5,T6,T7))();
                s.Item1 = this.Item1;
                s.Item2 = this.Item2;
                s.Item3 = this.Item3;
                s.Item4 = this.Item4;
                s.Item5 = this.Item5;
                s.Item6 = this.Item6;
                s.Item7 = this.Item7;
                return s;
            }
        }
    }; });

    Bridge.define("System.ValueTuple$8", function (T1, T2, T3, T4, T5, T6, T7, TRest) { return {
        inherits: function () { return [System.IEquatable$1(System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest)),System.Collections.IStructuralEquatable,System.Collections.IStructuralComparable,System.IComparable,System.IComparable$1(System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest)),System.ITupleInternal]; },
        $kind: "struct",
        statics: {
            fields: {
                s_t1Comparer: null,
                s_t2Comparer: null,
                s_t3Comparer: null,
                s_t4Comparer: null,
                s_t5Comparer: null,
                s_t6Comparer: null,
                s_t7Comparer: null,
                s_tRestComparer: null
            },
            ctors: {
                init: function () {
                    this.s_t1Comparer = System.Collections.Generic.EqualityComparer$1(T1).def;
                    this.s_t2Comparer = System.Collections.Generic.EqualityComparer$1(T2).def;
                    this.s_t3Comparer = System.Collections.Generic.EqualityComparer$1(T3).def;
                    this.s_t4Comparer = System.Collections.Generic.EqualityComparer$1(T4).def;
                    this.s_t5Comparer = System.Collections.Generic.EqualityComparer$1(T5).def;
                    this.s_t6Comparer = System.Collections.Generic.EqualityComparer$1(T6).def;
                    this.s_t7Comparer = System.Collections.Generic.EqualityComparer$1(T7).def;
                    this.s_tRestComparer = System.Collections.Generic.EqualityComparer$1(TRest).def;
                }
            },
            methods: {
                getDefaultValue: function () { return new (System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest))(); }
            }
        },
        fields: {
            Item1: Bridge.getDefaultValue(T1),
            Item2: Bridge.getDefaultValue(T2),
            Item3: Bridge.getDefaultValue(T3),
            Item4: Bridge.getDefaultValue(T4),
            Item5: Bridge.getDefaultValue(T5),
            Item6: Bridge.getDefaultValue(T6),
            Item7: Bridge.getDefaultValue(T7),
            Rest: Bridge.getDefaultValue(TRest)
        },
        props: {
            System$ITupleInternal$Size: {
                get: function () {
                    var rest = Bridge.as(this.Rest, System.ITupleInternal);
                    return rest == null ? 8 : ((7 + rest.System$ITupleInternal$Size) | 0);
                }
            }
        },
        alias: [
            "equalsT", "System$IEquatable$1$System$ValueTuple$8$" + Bridge.getTypeAlias(T1) + "$" + Bridge.getTypeAlias(T2) + "$" + Bridge.getTypeAlias(T3) + "$" + Bridge.getTypeAlias(T4) + "$" + Bridge.getTypeAlias(T5) + "$" + Bridge.getTypeAlias(T6) + "$" + Bridge.getTypeAlias(T7) + "$" + Bridge.getTypeAlias(TRest) + "$equalsT",
            "compareTo", ["System$IComparable$1$System$ValueTuple$8$" + Bridge.getTypeAlias(T1) + "$" + Bridge.getTypeAlias(T2) + "$" + Bridge.getTypeAlias(T3) + "$" + Bridge.getTypeAlias(T4) + "$" + Bridge.getTypeAlias(T5) + "$" + Bridge.getTypeAlias(T6) + "$" + Bridge.getTypeAlias(T7) + "$" + Bridge.getTypeAlias(TRest) + "$compareTo", "System$IComparable$1$compareTo"]
        ],
        ctors: {
            $ctor1: function (item1, item2, item3, item4, item5, item6, item7, rest) {
                this.$initialize();
                if (!(Bridge.is(rest, System.ITupleInternal))) {
                    throw new System.ArgumentException.$ctor1(System.SR.ArgumentException_ValueTupleLastArgumentNotAValueTuple);
                }

                this.Item1 = item1;
                this.Item2 = item2;
                this.Item3 = item3;
                this.Item4 = item4;
                this.Item5 = item5;
                this.Item6 = item6;
                this.Item7 = item7;
                this.Rest = rest;
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            equals: function (obj) {
                return Bridge.is(obj, System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest)) && this.equalsT(System.Nullable.getValue(Bridge.cast(Bridge.unbox(obj, System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest)), System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest))));
            },
            equalsT: function (other) {
                return System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest).s_t1Comparer.equals2(this.Item1, other.Item1) && System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest).s_t2Comparer.equals2(this.Item2, other.Item2) && System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest).s_t3Comparer.equals2(this.Item3, other.Item3) && System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest).s_t4Comparer.equals2(this.Item4, other.Item4) && System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest).s_t5Comparer.equals2(this.Item5, other.Item5) && System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest).s_t6Comparer.equals2(this.Item6, other.Item6) && System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest).s_t7Comparer.equals2(this.Item7, other.Item7) && System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest).s_tRestComparer.equals2(this.Rest, other.Rest);
            },
            System$Collections$IStructuralEquatable$Equals: function (other, comparer) {
                if (other == null || !(Bridge.is(other, System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest)))) {
                    return false;
                }

                var objTuple = System.Nullable.getValue(Bridge.cast(Bridge.unbox(other, System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest)), System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest)));

                return comparer.System$Collections$IEqualityComparer$equals(this.Item1, objTuple.Item1) && comparer.System$Collections$IEqualityComparer$equals(this.Item2, objTuple.Item2) && comparer.System$Collections$IEqualityComparer$equals(this.Item3, objTuple.Item3) && comparer.System$Collections$IEqualityComparer$equals(this.Item4, objTuple.Item4) && comparer.System$Collections$IEqualityComparer$equals(this.Item5, objTuple.Item5) && comparer.System$Collections$IEqualityComparer$equals(this.Item6, objTuple.Item6) && comparer.System$Collections$IEqualityComparer$equals(this.Item7, objTuple.Item7) && comparer.System$Collections$IEqualityComparer$equals(this.Rest, objTuple.Rest);
            },
            System$IComparable$compareTo: function (other) {
                if (other == null) {
                    return 1;
                }

                if (!(Bridge.is(other, System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest)))) {
                    throw new System.ArgumentException.$ctor3(System.SR.ArgumentException_ValueTupleIncorrectType, "other");
                }

                return this.compareTo(System.Nullable.getValue(Bridge.cast(Bridge.unbox(other, System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest)), System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest))));
            },
            compareTo: function (other) {
                var c = new (System.Collections.Generic.Comparer$1(T1))(System.Collections.Generic.Comparer$1.$default.fn).compare(this.Item1, other.Item1);
                if (c !== 0) {
                    return c;
                }

                c = new (System.Collections.Generic.Comparer$1(T2))(System.Collections.Generic.Comparer$1.$default.fn).compare(this.Item2, other.Item2);
                if (c !== 0) {
                    return c;
                }

                c = new (System.Collections.Generic.Comparer$1(T3))(System.Collections.Generic.Comparer$1.$default.fn).compare(this.Item3, other.Item3);
                if (c !== 0) {
                    return c;
                }

                c = new (System.Collections.Generic.Comparer$1(T4))(System.Collections.Generic.Comparer$1.$default.fn).compare(this.Item4, other.Item4);
                if (c !== 0) {
                    return c;
                }

                c = new (System.Collections.Generic.Comparer$1(T5))(System.Collections.Generic.Comparer$1.$default.fn).compare(this.Item5, other.Item5);
                if (c !== 0) {
                    return c;
                }

                c = new (System.Collections.Generic.Comparer$1(T6))(System.Collections.Generic.Comparer$1.$default.fn).compare(this.Item6, other.Item6);
                if (c !== 0) {
                    return c;
                }

                c = new (System.Collections.Generic.Comparer$1(T7))(System.Collections.Generic.Comparer$1.$default.fn).compare(this.Item7, other.Item7);
                if (c !== 0) {
                    return c;
                }

                return new (System.Collections.Generic.Comparer$1(TRest))(System.Collections.Generic.Comparer$1.$default.fn).compare(this.Rest, other.Rest);
            },
            System$Collections$IStructuralComparable$CompareTo: function (other, comparer) {
                if (other == null) {
                    return 1;
                }

                if (!(Bridge.is(other, System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest)))) {
                    throw new System.ArgumentException.$ctor3(System.SR.ArgumentException_ValueTupleIncorrectType, "other");
                }

                var objTuple = System.Nullable.getValue(Bridge.cast(Bridge.unbox(other, System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest)), System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest)));

                var c = comparer.System$Collections$IComparer$compare(this.Item1, objTuple.Item1);
                if (c !== 0) {
                    return c;
                }

                c = comparer.System$Collections$IComparer$compare(this.Item2, objTuple.Item2);
                if (c !== 0) {
                    return c;
                }

                c = comparer.System$Collections$IComparer$compare(this.Item3, objTuple.Item3);
                if (c !== 0) {
                    return c;
                }

                c = comparer.System$Collections$IComparer$compare(this.Item4, objTuple.Item4);
                if (c !== 0) {
                    return c;
                }

                c = comparer.System$Collections$IComparer$compare(this.Item5, objTuple.Item5);
                if (c !== 0) {
                    return c;
                }

                c = comparer.System$Collections$IComparer$compare(this.Item6, objTuple.Item6);
                if (c !== 0) {
                    return c;
                }

                c = comparer.System$Collections$IComparer$compare(this.Item7, objTuple.Item7);
                if (c !== 0) {
                    return c;
                }

                return comparer.System$Collections$IComparer$compare(this.Rest, objTuple.Rest);
            },
            getHashCode: function () {
                var rest = Bridge.as(this.Rest, System.ITupleInternal);
                if (rest == null) {
                    return System.ValueTuple.CombineHashCodes$5(System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest).s_t1Comparer.getHashCode2(this.Item1), System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest).s_t2Comparer.getHashCode2(this.Item2), System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest).s_t3Comparer.getHashCode2(this.Item3), System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest).s_t4Comparer.getHashCode2(this.Item4), System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest).s_t5Comparer.getHashCode2(this.Item5), System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest).s_t6Comparer.getHashCode2(this.Item6), System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest).s_t7Comparer.getHashCode2(this.Item7));
                }

                var size = rest.System$ITupleInternal$Size;
                if (size >= 8) {
                    return Bridge.getHashCode(rest);
                }

                var k = (8 - size) | 0;
                switch (k) {
                    case 1: 
                        return System.ValueTuple.CombineHashCodes(System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest).s_t7Comparer.getHashCode2(this.Item7), Bridge.getHashCode(rest));
                    case 2: 
                        return System.ValueTuple.CombineHashCodes$1(System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest).s_t6Comparer.getHashCode2(this.Item6), System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest).s_t7Comparer.getHashCode2(this.Item7), Bridge.getHashCode(rest));
                    case 3: 
                        return System.ValueTuple.CombineHashCodes$2(System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest).s_t5Comparer.getHashCode2(this.Item5), System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest).s_t6Comparer.getHashCode2(this.Item6), System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest).s_t7Comparer.getHashCode2(this.Item7), Bridge.getHashCode(rest));
                    case 4: 
                        return System.ValueTuple.CombineHashCodes$3(System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest).s_t4Comparer.getHashCode2(this.Item4), System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest).s_t5Comparer.getHashCode2(this.Item5), System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest).s_t6Comparer.getHashCode2(this.Item6), System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest).s_t7Comparer.getHashCode2(this.Item7), Bridge.getHashCode(rest));
                    case 5: 
                        return System.ValueTuple.CombineHashCodes$4(System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest).s_t3Comparer.getHashCode2(this.Item3), System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest).s_t4Comparer.getHashCode2(this.Item4), System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest).s_t5Comparer.getHashCode2(this.Item5), System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest).s_t6Comparer.getHashCode2(this.Item6), System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest).s_t7Comparer.getHashCode2(this.Item7), Bridge.getHashCode(rest));
                    case 6: 
                        return System.ValueTuple.CombineHashCodes$5(System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest).s_t2Comparer.getHashCode2(this.Item2), System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest).s_t3Comparer.getHashCode2(this.Item3), System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest).s_t4Comparer.getHashCode2(this.Item4), System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest).s_t5Comparer.getHashCode2(this.Item5), System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest).s_t6Comparer.getHashCode2(this.Item6), System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest).s_t7Comparer.getHashCode2(this.Item7), Bridge.getHashCode(rest));
                    case 7: 
                    case 8: 
                        return System.ValueTuple.CombineHashCodes$6(System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest).s_t1Comparer.getHashCode2(this.Item1), System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest).s_t2Comparer.getHashCode2(this.Item2), System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest).s_t3Comparer.getHashCode2(this.Item3), System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest).s_t4Comparer.getHashCode2(this.Item4), System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest).s_t5Comparer.getHashCode2(this.Item5), System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest).s_t6Comparer.getHashCode2(this.Item6), System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest).s_t7Comparer.getHashCode2(this.Item7), Bridge.getHashCode(rest));
                }

                return -1;
            },
            System$Collections$IStructuralEquatable$GetHashCode: function (comparer) {
                return this.GetHashCodeCore(comparer);
            },
            System$ITupleInternal$GetHashCode: function (comparer) {
                return this.GetHashCodeCore(comparer);
            },
            GetHashCodeCore: function (comparer) {
                var rest = Bridge.as(this.Rest, System.ITupleInternal);
                if (rest == null) {
                    return System.ValueTuple.CombineHashCodes$5(comparer.System$Collections$IEqualityComparer$getHashCode(this.Item1), comparer.System$Collections$IEqualityComparer$getHashCode(this.Item2), comparer.System$Collections$IEqualityComparer$getHashCode(this.Item3), comparer.System$Collections$IEqualityComparer$getHashCode(this.Item4), comparer.System$Collections$IEqualityComparer$getHashCode(this.Item5), comparer.System$Collections$IEqualityComparer$getHashCode(this.Item6), comparer.System$Collections$IEqualityComparer$getHashCode(this.Item7));
                }

                var size = rest.System$ITupleInternal$Size;
                if (size >= 8) {
                    return rest.System$ITupleInternal$GetHashCode(comparer);
                }

                var k = (8 - size) | 0;
                switch (k) {
                    case 1: 
                        return System.ValueTuple.CombineHashCodes(comparer.System$Collections$IEqualityComparer$getHashCode(this.Item7), rest.System$ITupleInternal$GetHashCode(comparer));
                    case 2: 
                        return System.ValueTuple.CombineHashCodes$1(comparer.System$Collections$IEqualityComparer$getHashCode(this.Item6), comparer.System$Collections$IEqualityComparer$getHashCode(this.Item7), rest.System$ITupleInternal$GetHashCode(comparer));
                    case 3: 
                        return System.ValueTuple.CombineHashCodes$2(comparer.System$Collections$IEqualityComparer$getHashCode(this.Item5), comparer.System$Collections$IEqualityComparer$getHashCode(this.Item6), comparer.System$Collections$IEqualityComparer$getHashCode(this.Item7), rest.System$ITupleInternal$GetHashCode(comparer));
                    case 4: 
                        return System.ValueTuple.CombineHashCodes$3(comparer.System$Collections$IEqualityComparer$getHashCode(this.Item4), comparer.System$Collections$IEqualityComparer$getHashCode(this.Item5), comparer.System$Collections$IEqualityComparer$getHashCode(this.Item6), comparer.System$Collections$IEqualityComparer$getHashCode(this.Item7), rest.System$ITupleInternal$GetHashCode(comparer));
                    case 5: 
                        return System.ValueTuple.CombineHashCodes$4(comparer.System$Collections$IEqualityComparer$getHashCode(this.Item3), comparer.System$Collections$IEqualityComparer$getHashCode(this.Item4), comparer.System$Collections$IEqualityComparer$getHashCode(this.Item5), comparer.System$Collections$IEqualityComparer$getHashCode(this.Item6), comparer.System$Collections$IEqualityComparer$getHashCode(this.Item7), rest.System$ITupleInternal$GetHashCode(comparer));
                    case 6: 
                        return System.ValueTuple.CombineHashCodes$5(comparer.System$Collections$IEqualityComparer$getHashCode(this.Item2), comparer.System$Collections$IEqualityComparer$getHashCode(this.Item3), comparer.System$Collections$IEqualityComparer$getHashCode(this.Item4), comparer.System$Collections$IEqualityComparer$getHashCode(this.Item5), comparer.System$Collections$IEqualityComparer$getHashCode(this.Item6), comparer.System$Collections$IEqualityComparer$getHashCode(this.Item7), rest.System$ITupleInternal$GetHashCode(comparer));
                    case 7: 
                    case 8: 
                        return System.ValueTuple.CombineHashCodes$6(comparer.System$Collections$IEqualityComparer$getHashCode(this.Item1), comparer.System$Collections$IEqualityComparer$getHashCode(this.Item2), comparer.System$Collections$IEqualityComparer$getHashCode(this.Item3), comparer.System$Collections$IEqualityComparer$getHashCode(this.Item4), comparer.System$Collections$IEqualityComparer$getHashCode(this.Item5), comparer.System$Collections$IEqualityComparer$getHashCode(this.Item6), comparer.System$Collections$IEqualityComparer$getHashCode(this.Item7), rest.System$ITupleInternal$GetHashCode(comparer));
                }

                return -1;
            },
            toString: function () {
                var rest = Bridge.as(this.Rest, System.ITupleInternal);
                if (rest == null) {
                    return "(" + ((this.Item1 != null ? Bridge.toString(this.Item1) : null) || "") + ", " + ((this.Item2 != null ? Bridge.toString(this.Item2) : null) || "") + ", " + ((this.Item3 != null ? Bridge.toString(this.Item3) : null) || "") + ", " + ((this.Item4 != null ? Bridge.toString(this.Item4) : null) || "") + ", " + ((this.Item5 != null ? Bridge.toString(this.Item5) : null) || "") + ", " + ((this.Item6 != null ? Bridge.toString(this.Item6) : null) || "") + ", " + ((this.Item7 != null ? Bridge.toString(this.Item7) : null) || "") + ", " + (Bridge.toString(this.Rest) || "") + ")";
                } else {
                    return "(" + ((this.Item1 != null ? Bridge.toString(this.Item1) : null) || "") + ", " + ((this.Item2 != null ? Bridge.toString(this.Item2) : null) || "") + ", " + ((this.Item3 != null ? Bridge.toString(this.Item3) : null) || "") + ", " + ((this.Item4 != null ? Bridge.toString(this.Item4) : null) || "") + ", " + ((this.Item5 != null ? Bridge.toString(this.Item5) : null) || "") + ", " + ((this.Item6 != null ? Bridge.toString(this.Item6) : null) || "") + ", " + ((this.Item7 != null ? Bridge.toString(this.Item7) : null) || "") + ", " + (rest.System$ITupleInternal$ToStringEnd() || "");
                }
            },
            System$ITupleInternal$ToStringEnd: function () {
                var rest = Bridge.as(this.Rest, System.ITupleInternal);
                if (rest == null) {
                    return ((this.Item1 != null ? Bridge.toString(this.Item1) : null) || "") + ", " + ((this.Item2 != null ? Bridge.toString(this.Item2) : null) || "") + ", " + ((this.Item3 != null ? Bridge.toString(this.Item3) : null) || "") + ", " + ((this.Item4 != null ? Bridge.toString(this.Item4) : null) || "") + ", " + ((this.Item5 != null ? Bridge.toString(this.Item5) : null) || "") + ", " + ((this.Item6 != null ? Bridge.toString(this.Item6) : null) || "") + ", " + ((this.Item7 != null ? Bridge.toString(this.Item7) : null) || "") + ", " + (Bridge.toString(this.Rest) || "") + ")";
                } else {
                    return ((this.Item1 != null ? Bridge.toString(this.Item1) : null) || "") + ", " + ((this.Item2 != null ? Bridge.toString(this.Item2) : null) || "") + ", " + ((this.Item3 != null ? Bridge.toString(this.Item3) : null) || "") + ", " + ((this.Item4 != null ? Bridge.toString(this.Item4) : null) || "") + ", " + ((this.Item5 != null ? Bridge.toString(this.Item5) : null) || "") + ", " + ((this.Item6 != null ? Bridge.toString(this.Item6) : null) || "") + ", " + ((this.Item7 != null ? Bridge.toString(this.Item7) : null) || "") + ", " + (rest.System$ITupleInternal$ToStringEnd() || "");
                }
            },
            $clone: function (to) {
                var s = to || new (System.ValueTuple$8(T1,T2,T3,T4,T5,T6,T7,TRest))();
                s.Item1 = this.Item1;
                s.Item2 = this.Item2;
                s.Item3 = this.Item3;
                s.Item4 = this.Item4;
                s.Item5 = this.Item5;
                s.Item6 = this.Item6;
                s.Item7 = this.Item7;
                s.Rest = this.Rest;
                return s;
            }
        }
    }; });

    // @source IndexOutOfRangeException.js

    Bridge.define("System.IndexOutOfRangeException", {
        inherits: [System.SystemException],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.SystemException.$ctor1.call(this, "Index was outside the bounds of the array.");
                this.HResult = -2146233080;
            },
            $ctor1: function (message) {
                this.$initialize();
                System.SystemException.$ctor1.call(this, message);
                this.HResult = -2146233080;
            },
            $ctor2: function (message, innerException) {
                this.$initialize();
                System.SystemException.$ctor2.call(this, message, innerException);
                this.HResult = -2146233080;
            }
        }
    });

    // @source InvalidCastException.js

    Bridge.define("System.InvalidCastException", {
        inherits: [System.SystemException],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.SystemException.$ctor1.call(this, "Specified cast is not valid.");
                this.HResult = -2147467262;
            },
            $ctor1: function (message) {
                this.$initialize();
                System.SystemException.$ctor1.call(this, message);
                this.HResult = -2147467262;
            },
            $ctor2: function (message, innerException) {
                this.$initialize();
                System.SystemException.$ctor2.call(this, message, innerException);
                this.HResult = -2147467262;
            },
            $ctor3: function (message, errorCode) {
                this.$initialize();
                System.SystemException.$ctor1.call(this, message);
                this.HResult = errorCode;
            }
        }
    });

    // @source InvalidOperationException.js

    Bridge.define("System.InvalidOperationException", {
        inherits: [System.SystemException],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.SystemException.$ctor1.call(this, "Operation is not valid due to the current state of the object.");
                this.HResult = -2146233079;
            },
            $ctor1: function (message) {
                this.$initialize();
                System.SystemException.$ctor1.call(this, message);
                this.HResult = -2146233079;
            },
            $ctor2: function (message, innerException) {
                this.$initialize();
                System.SystemException.$ctor2.call(this, message, innerException);
                this.HResult = -2146233079;
            }
        }
    });

    // @source ObjectDisposedException.js

    Bridge.define("System.ObjectDisposedException", {
        inherits: [System.InvalidOperationException],
        fields: {
            _objectName: null
        },
        props: {
            Message: {
                get: function () {
                    var name = this.ObjectName;
                    if (name == null || name.length === 0) {
                        return Bridge.ensureBaseProperty(this, "Message").$System$Exception$Message;
                    }

                    var objectDisposed = System.SR.Format("Object name: '{0}'.", name);
                    return (Bridge.ensureBaseProperty(this, "Message").$System$Exception$Message || "") + ("\n" || "") + (objectDisposed || "");
                }
            },
            ObjectName: {
                get: function () {
                    if (this._objectName == null) {
                        return "";
                    }
                    return this._objectName;
                }
            }
        },
        ctors: {
            ctor: function () {
                System.ObjectDisposedException.$ctor3.call(this, null, "Cannot access a disposed object.");
            },
            $ctor1: function (objectName) {
                System.ObjectDisposedException.$ctor3.call(this, objectName, "Cannot access a disposed object.");
            },
            $ctor3: function (objectName, message) {
                this.$initialize();
                System.InvalidOperationException.$ctor1.call(this, message);
                this.HResult = -2146232798;
                this._objectName = objectName;
            },
            $ctor2: function (message, innerException) {
                this.$initialize();
                System.InvalidOperationException.$ctor2.call(this, message, innerException);
                this.HResult = -2146232798;
            }
        }
    });

    // @source InvalidProgramException.js

    Bridge.define("System.InvalidProgramException", {
        inherits: [System.SystemException],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.SystemException.$ctor1.call(this, "Common Language Runtime detected an invalid program.");
                this.HResult = -2146233030;
            },
            $ctor1: function (message) {
                this.$initialize();
                System.SystemException.$ctor1.call(this, message);
                this.HResult = -2146233030;
            },
            $ctor2: function (message, inner) {
                this.$initialize();
                System.SystemException.$ctor2.call(this, message, inner);
                this.HResult = -2146233030;
            }
        }
    });

    // @source MissingMethodException.js

    Bridge.define("System.MissingMethodException", {
        inherits: [System.Exception],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Exception.ctor.call(this, "Attempted to access a missing method.");
            },
            $ctor1: function (message) {
                this.$initialize();
                System.Exception.ctor.call(this, message);
            },
            $ctor2: function (message, inner) {
                this.$initialize();
                System.Exception.ctor.call(this, message, inner);
            },
            $ctor3: function (className, methodName) {
                this.$initialize();
                System.Exception.ctor.call(this, (className || "") + "." + (methodName || "") + " Due to: Attempted to access a missing member.");
            }
        }
    });

    // @source Calendar.js

    Bridge.define("System.Globalization.Calendar", {
        inherits: [System.ICloneable],
        statics: {
            fields: {
                TicksPerMillisecond: System.Int64(0),
                TicksPerSecond: System.Int64(0),
                TicksPerMinute: System.Int64(0),
                TicksPerHour: System.Int64(0),
                TicksPerDay: System.Int64(0),
                MillisPerSecond: 0,
                MillisPerMinute: 0,
                MillisPerHour: 0,
                MillisPerDay: 0,
                DaysPerYear: 0,
                DaysPer4Years: 0,
                DaysPer100Years: 0,
                DaysPer400Years: 0,
                DaysTo10000: 0,
                MaxMillis: System.Int64(0),
                CurrentEra: 0
            },
            ctors: {
                init: function () {
                    this.TicksPerMillisecond = System.Int64(10000);
                    this.TicksPerSecond = System.Int64(10000000);
                    this.TicksPerMinute = System.Int64(600000000);
                    this.TicksPerHour = System.Int64([1640261632,8]);
                    this.TicksPerDay = System.Int64([711573504,201]);
                    this.MillisPerSecond = 1000;
                    this.MillisPerMinute = 60000;
                    this.MillisPerHour = 3600000;
                    this.MillisPerDay = 86400000;
                    this.DaysPerYear = 365;
                    this.DaysPer4Years = 1461;
                    this.DaysPer100Years = 36524;
                    this.DaysPer400Years = 146097;
                    this.DaysTo10000 = 3652059;
                    this.MaxMillis = System.Int64([-464735232,73466]);
                    this.CurrentEra = 0;
                }
            },
            methods: {
                ReadOnly: function (calendar) {
                    if (calendar == null) {
                        throw new System.ArgumentNullException.$ctor1("calendar");
                    }
                    if (calendar.IsReadOnly) {
                        return (calendar);
                    }

                    var clonedCalendar = Bridge.cast((Bridge.clone(calendar)), System.Globalization.Calendar);
                    clonedCalendar.SetReadOnlyState(true);

                    return (clonedCalendar);
                },
                CheckAddResult: function (ticks, minValue, maxValue) {
                    if (ticks.lt(System.DateTime.getTicks(minValue)) || ticks.gt(System.DateTime.getTicks(maxValue))) {
                        throw new System.ArgumentException.$ctor1(System.String.formatProvider(System.Globalization.CultureInfo.invariantCulture, System.SR.Format$1("The result is out of the supported range for this calendar. The result should be between {0} (Gregorian date) and {1} (Gregorian date), inclusive.", Bridge.box(minValue, System.DateTime, System.DateTime.format), Bridge.box(maxValue, System.DateTime, System.DateTime.format)), null));
                    }
                },
                GetSystemTwoDigitYearSetting: function (CalID, defaultYearValue) {
                    var twoDigitYearMax = 2029;
                    if (twoDigitYearMax < 0) {
                        twoDigitYearMax = defaultYearValue;
                    }
                    return (twoDigitYearMax);
                }
            }
        },
        fields: {
            _isReadOnly: false,
            twoDigitYearMax: 0
        },
        props: {
            MinSupportedDateTime: {
                get: function () {
                    return (System.DateTime.getMinValue());
                }
            },
            MaxSupportedDateTime: {
                get: function () {
                    return (System.DateTime.getMaxValue());
                }
            },
            AlgorithmType: {
                get: function () {
                    return 0;
                }
            },
            ID: {
                get: function () {
                    return 0;
                }
            },
            BaseCalendarID: {
                get: function () {
                    return this.ID;
                }
            },
            IsReadOnly: {
                get: function () {
                    return (this._isReadOnly);
                }
            },
            CurrentEraValue: {
                get: function () {
                    throw System.NotImplemented.ByDesign;
                }
            },
            DaysInYearBeforeMinSupportedYear: {
                get: function () {
                    return 365;
                }
            },
            TwoDigitYearMax: {
                get: function () {
                    return (this.twoDigitYearMax);
                },
                set: function (value) {
                    this.VerifyWritable();
                    this.twoDigitYearMax = value;
                }
            }
        },
        alias: ["clone", "System$ICloneable$clone"],
        ctors: {
            init: function () {
                this._isReadOnly = false;
                this.twoDigitYearMax = -1;
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            clone: function () {
                var o = Bridge.clone(this);
                Bridge.cast(o, System.Globalization.Calendar).SetReadOnlyState(false);
                return (o);
            },
            VerifyWritable: function () {
                if (this._isReadOnly) {
                    throw new System.InvalidOperationException.$ctor1("Instance is read-only.");
                }
            },
            SetReadOnlyState: function (readOnly) {
                this._isReadOnly = readOnly;
            },
            Add: function (time, value, scale) {
                var tempMillis = (value * scale + (value >= 0 ? 0.5 : -0.5));
                if (!((tempMillis > -315537897600000.0) && (tempMillis < 315537897600000.0))) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("value", "Value to add was out of range.");
                }

                var millis = Bridge.Int.clip64(tempMillis);
                var ticks = System.DateTime.getTicks(time).add(millis.mul(System.Globalization.Calendar.TicksPerMillisecond));
                System.Globalization.Calendar.CheckAddResult(ticks, this.MinSupportedDateTime, this.MaxSupportedDateTime);
                return (System.DateTime.create$2(ticks));
            },
            AddMilliseconds: function (time, milliseconds) {
                return (this.Add(time, milliseconds, 1));
            },
            AddDays: function (time, days) {
                return (this.Add(time, days, System.Globalization.Calendar.MillisPerDay));
            },
            AddHours: function (time, hours) {
                return (this.Add(time, hours, System.Globalization.Calendar.MillisPerHour));
            },
            AddMinutes: function (time, minutes) {
                return (this.Add(time, minutes, System.Globalization.Calendar.MillisPerMinute));
            },
            AddSeconds: function (time, seconds) {
                return this.Add(time, seconds, System.Globalization.Calendar.MillisPerSecond);
            },
            AddWeeks: function (time, weeks) {
                return (this.AddDays(time, Bridge.Int.mul(weeks, 7)));
            },
            GetDaysInMonth: function (year, month) {
                return (this.GetDaysInMonth$1(year, month, System.Globalization.Calendar.CurrentEra));
            },
            GetDaysInYear: function (year) {
                return (this.GetDaysInYear$1(year, System.Globalization.Calendar.CurrentEra));
            },
            GetHour: function (time) {
                return (System.Int64.clip32((System.DateTime.getTicks(time).div(System.Globalization.Calendar.TicksPerHour)).mod(System.Int64(24))));
            },
            GetMilliseconds: function (time) {
                return System.Int64.toNumber((System.DateTime.getTicks(time).div(System.Globalization.Calendar.TicksPerMillisecond)).mod(System.Int64(1000)));
            },
            GetMinute: function (time) {
                return (System.Int64.clip32((System.DateTime.getTicks(time).div(System.Globalization.Calendar.TicksPerMinute)).mod(System.Int64(60))));
            },
            GetMonthsInYear: function (year) {
                return (this.GetMonthsInYear$1(year, System.Globalization.Calendar.CurrentEra));
            },
            GetSecond: function (time) {
                return (System.Int64.clip32((System.DateTime.getTicks(time).div(System.Globalization.Calendar.TicksPerSecond)).mod(System.Int64(60))));
            },
            GetFirstDayWeekOfYear: function (time, firstDayOfWeek) {
                var dayOfYear = (this.GetDayOfYear(time) - 1) | 0;
                var dayForJan1 = (this.GetDayOfWeek(time) - (dayOfYear % 7)) | 0;
                var offset = (((((dayForJan1 - firstDayOfWeek) | 0) + 14) | 0)) % 7;
                return (((((Bridge.Int.div((((dayOfYear + offset) | 0)), 7)) | 0) + 1) | 0));
            },
            GetWeekOfYearFullDays: function (time, firstDayOfWeek, fullDays) {
                var dayForJan1;
                var offset;
                var day;

                var dayOfYear = (this.GetDayOfYear(time) - 1) | 0;



                dayForJan1 = (this.GetDayOfWeek(time) - (dayOfYear % 7)) | 0;

                offset = (((((firstDayOfWeek - dayForJan1) | 0) + 14) | 0)) % 7;
                if (offset !== 0 && offset >= fullDays) {
                    offset = (offset - 7) | 0;
                }
                day = (dayOfYear - offset) | 0;
                if (day >= 0) {
                    return (((((Bridge.Int.div(day, 7)) | 0) + 1) | 0));
                }
                if (System.DateTime.lte(time, System.DateTime.addDays(this.MinSupportedDateTime, dayOfYear))) {
                    return this.GetWeekOfYearOfMinSupportedDateTime(firstDayOfWeek, fullDays);
                }
                return (this.GetWeekOfYearFullDays(System.DateTime.addDays(time, ((-(((dayOfYear + 1) | 0))) | 0)), firstDayOfWeek, fullDays));
            },
            GetWeekOfYearOfMinSupportedDateTime: function (firstDayOfWeek, minimumDaysInFirstWeek) {
                var dayOfYear = (this.GetDayOfYear(this.MinSupportedDateTime) - 1) | 0;
                var dayOfWeekOfFirstOfYear = (this.GetDayOfWeek(this.MinSupportedDateTime) - dayOfYear % 7) | 0;

                var offset = (((((firstDayOfWeek + 7) | 0) - dayOfWeekOfFirstOfYear) | 0)) % 7;
                if (offset === 0 || offset >= minimumDaysInFirstWeek) {
                    return 1;
                }

                var daysInYearBeforeMinSupportedYear = (this.DaysInYearBeforeMinSupportedYear - 1) | 0;
                var dayOfWeekOfFirstOfPreviousYear = (((dayOfWeekOfFirstOfYear - 1) | 0) - (daysInYearBeforeMinSupportedYear % 7)) | 0;

                var daysInInitialPartialWeek = (((((firstDayOfWeek - dayOfWeekOfFirstOfPreviousYear) | 0) + 14) | 0)) % 7;
                var day = (daysInYearBeforeMinSupportedYear - daysInInitialPartialWeek) | 0;
                if (daysInInitialPartialWeek >= minimumDaysInFirstWeek) {
                    day = (day + 7) | 0;
                }

                return (((((Bridge.Int.div(day, 7)) | 0) + 1) | 0));
            },
            GetWeekOfYear: function (time, rule, firstDayOfWeek) {
                if (firstDayOfWeek < 0 || firstDayOfWeek > 6) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("firstDayOfWeek", System.SR.Format$1("Valid values are between {0} and {1}, inclusive.", Bridge.box(System.DayOfWeek.Sunday, System.DayOfWeek, System.Enum.toStringFn(System.DayOfWeek)), Bridge.box(System.DayOfWeek.Saturday, System.DayOfWeek, System.Enum.toStringFn(System.DayOfWeek))));
                }
                switch (rule) {
                    case 0: 
                        return (this.GetFirstDayWeekOfYear(time, firstDayOfWeek));
                    case 1: 
                        return (this.GetWeekOfYearFullDays(time, firstDayOfWeek, 7));
                    case 2: 
                        return (this.GetWeekOfYearFullDays(time, firstDayOfWeek, 4));
                }
                throw new System.ArgumentOutOfRangeException.$ctor4("rule", System.SR.Format$1("Valid values are between {0} and {1}, inclusive.", Bridge.box(0, System.Globalization.CalendarWeekRule, System.Enum.toStringFn(System.Globalization.CalendarWeekRule)), Bridge.box(2, System.Globalization.CalendarWeekRule, System.Enum.toStringFn(System.Globalization.CalendarWeekRule))));
            },
            IsLeapDay: function (year, month, day) {
                return (this.IsLeapDay$1(year, month, day, System.Globalization.Calendar.CurrentEra));
            },
            IsLeapMonth: function (year, month) {
                return (this.IsLeapMonth$1(year, month, System.Globalization.Calendar.CurrentEra));
            },
            GetLeapMonth: function (year) {
                return (this.GetLeapMonth$1(year, System.Globalization.Calendar.CurrentEra));
            },
            GetLeapMonth$1: function (year, era) {
                if (!this.IsLeapYear$1(year, era)) {
                    return 0;
                }

                var monthsCount = this.GetMonthsInYear$1(year, era);
                for (var month = 1; month <= monthsCount; month = (month + 1) | 0) {
                    if (this.IsLeapMonth$1(year, month, era)) {
                        return month;
                    }
                }

                return 0;
            },
            IsLeapYear: function (year) {
                return (this.IsLeapYear$1(year, System.Globalization.Calendar.CurrentEra));
            },
            ToDateTime: function (year, month, day, hour, minute, second, millisecond) {
                return (this.ToDateTime$1(year, month, day, hour, minute, second, millisecond, System.Globalization.Calendar.CurrentEra));
            },
            TryToDateTime: function (year, month, day, hour, minute, second, millisecond, era, result) {
                result.v = System.DateTime.getMinValue();
                try {
                    result.v = this.ToDateTime$1(year, month, day, hour, minute, second, millisecond, era);
                    return true;
                } catch ($e1) {
                    $e1 = System.Exception.create($e1);
                    if (Bridge.is($e1, System.ArgumentException)) {
                        return false;
                    } else {
                        throw $e1;
                    }
                }
            },
            IsValidYear: function (year, era) {
                return (year >= this.GetYear(this.MinSupportedDateTime) && year <= this.GetYear(this.MaxSupportedDateTime));
            },
            IsValidMonth: function (year, month, era) {
                return (this.IsValidYear(year, era) && month >= 1 && month <= this.GetMonthsInYear$1(year, era));
            },
            IsValidDay: function (year, month, day, era) {
                return (this.IsValidMonth(year, month, era) && day >= 1 && day <= this.GetDaysInMonth$1(year, month, era));
            },
            ToFourDigitYear: function (year) {
                if (year < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("year", "Non-negative number required.");
                }
                if (year < 100) {
                    return (((Bridge.Int.mul((((((Bridge.Int.div(this.TwoDigitYearMax, 100)) | 0) - (year > this.TwoDigitYearMax % 100 ? 1 : 0)) | 0)), 100) + year) | 0));
                }
                return (year);
            }
        }
    });

    // @source CalendarAlgorithmType.js

    Bridge.define("System.Globalization.CalendarAlgorithmType", {
        $kind: "enum",
        statics: {
            fields: {
                Unknown: 0,
                SolarCalendar: 1,
                LunarCalendar: 2,
                LunisolarCalendar: 3
            }
        }
    });

    // @source CalendarId.js

    Bridge.define("System.Globalization.CalendarId", {
        $kind: "enum",
        statics: {
            fields: {
                UNINITIALIZED_VALUE: 0,
                GREGORIAN: 1,
                GREGORIAN_US: 2,
                JAPAN: 3,
                TAIWAN: 4,
                KOREA: 5,
                HIJRI: 6,
                THAI: 7,
                HEBREW: 8,
                GREGORIAN_ME_FRENCH: 9,
                GREGORIAN_ARABIC: 10,
                GREGORIAN_XLIT_ENGLISH: 11,
                GREGORIAN_XLIT_FRENCH: 12,
                JULIAN: 13,
                JAPANESELUNISOLAR: 14,
                CHINESELUNISOLAR: 15,
                SAKA: 16,
                LUNAR_ETO_CHN: 17,
                LUNAR_ETO_KOR: 18,
                LUNAR_ETO_ROKUYOU: 19,
                KOREANLUNISOLAR: 20,
                TAIWANLUNISOLAR: 21,
                PERSIAN: 22,
                UMALQURA: 23,
                LAST_CALENDAR: 23
            }
        },
        $utype: System.UInt16
    });

    // @source CalendarWeekRule.js

    Bridge.define("System.Globalization.CalendarWeekRule", {
        $kind: "enum",
        statics: {
            fields: {
                FirstDay: 0,
                FirstFullWeek: 1,
                FirstFourDayWeek: 2
            }
        }
    });

    // @source CultureNotFoundException.js

    Bridge.define("System.Globalization.CultureNotFoundException", {
        inherits: [System.ArgumentException],
        statics: {
            props: {
                DefaultMessage: {
                    get: function () {
                        return "Culture is not supported.";
                    }
                }
            }
        },
        fields: {
            _invalidCultureName: null,
            _invalidCultureId: null
        },
        props: {
            InvalidCultureId: {
                get: function () {
                    return this._invalidCultureId;
                }
            },
            InvalidCultureName: {
                get: function () {
                    return this._invalidCultureName;
                }
            },
            FormatedInvalidCultureId: {
                get: function () {
                    return this.InvalidCultureId != null ? System.String.formatProvider(System.Globalization.CultureInfo.invariantCulture, "{0} (0x{0:x4})", [Bridge.box(System.Nullable.getValue(this.InvalidCultureId), System.Int32)]) : this.InvalidCultureName;
                }
            },
            Message: {
                get: function () {
                    var s = Bridge.ensureBaseProperty(this, "Message").$System$ArgumentException$Message;
                    if (this._invalidCultureId != null || this._invalidCultureName != null) {
                        var valueMessage = System.SR.Format("{0} is an invalid culture identifier.", this.FormatedInvalidCultureId);
                        if (s == null) {
                            return valueMessage;
                        }

                        return (s || "") + ("\n" || "") + (valueMessage || "");
                    }
                    return s;
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.ArgumentException.$ctor1.call(this, System.Globalization.CultureNotFoundException.DefaultMessage);
            },
            $ctor1: function (message) {
                this.$initialize();
                System.ArgumentException.$ctor1.call(this, message);
            },
            $ctor5: function (paramName, message) {
                this.$initialize();
                System.ArgumentException.$ctor3.call(this, message, paramName);
            },
            $ctor2: function (message, innerException) {
                this.$initialize();
                System.ArgumentException.$ctor2.call(this, message, innerException);
            },
            $ctor7: function (paramName, invalidCultureName, message) {
                this.$initialize();
                System.ArgumentException.$ctor3.call(this, message, paramName);
                this._invalidCultureName = invalidCultureName;
            },
            $ctor6: function (message, invalidCultureName, innerException) {
                this.$initialize();
                System.ArgumentException.$ctor2.call(this, message, innerException);
                this._invalidCultureName = invalidCultureName;
            },
            $ctor3: function (message, invalidCultureId, innerException) {
                this.$initialize();
                System.ArgumentException.$ctor2.call(this, message, innerException);
                this._invalidCultureId = invalidCultureId;
            },
            $ctor4: function (paramName, invalidCultureId, message) {
                this.$initialize();
                System.ArgumentException.$ctor3.call(this, message, paramName);
                this._invalidCultureId = invalidCultureId;
            }
        }
    });

    // @source DateTimeFormatInfoScanner.js

    Bridge.define("System.Globalization.DateTimeFormatInfoScanner", {
        statics: {
            fields: {
                MonthPostfixChar: 0,
                IgnorableSymbolChar: 0,
                CJKYearSuff: null,
                CJKMonthSuff: null,
                CJKDaySuff: null,
                KoreanYearSuff: null,
                KoreanMonthSuff: null,
                KoreanDaySuff: null,
                KoreanHourSuff: null,
                KoreanMinuteSuff: null,
                KoreanSecondSuff: null,
                CJKHourSuff: null,
                ChineseHourSuff: null,
                CJKMinuteSuff: null,
                CJKSecondSuff: null,
                s_knownWords: null
            },
            props: {
                KnownWords: {
                    get: function () {
                        if (System.Globalization.DateTimeFormatInfoScanner.s_knownWords == null) {
                            var temp = new (System.Collections.Generic.Dictionary$2(System.String,System.String))();

                            temp.add("/", "");
                            temp.add("-", "");
                            temp.add(".", "");
                            temp.add(System.Globalization.DateTimeFormatInfoScanner.CJKYearSuff, "");
                            temp.add(System.Globalization.DateTimeFormatInfoScanner.CJKMonthSuff, "");
                            temp.add(System.Globalization.DateTimeFormatInfoScanner.CJKDaySuff, "");
                            temp.add(System.Globalization.DateTimeFormatInfoScanner.KoreanYearSuff, "");
                            temp.add(System.Globalization.DateTimeFormatInfoScanner.KoreanMonthSuff, "");
                            temp.add(System.Globalization.DateTimeFormatInfoScanner.KoreanDaySuff, "");
                            temp.add(System.Globalization.DateTimeFormatInfoScanner.KoreanHourSuff, "");
                            temp.add(System.Globalization.DateTimeFormatInfoScanner.KoreanMinuteSuff, "");
                            temp.add(System.Globalization.DateTimeFormatInfoScanner.KoreanSecondSuff, "");
                            temp.add(System.Globalization.DateTimeFormatInfoScanner.CJKHourSuff, "");
                            temp.add(System.Globalization.DateTimeFormatInfoScanner.ChineseHourSuff, "");
                            temp.add(System.Globalization.DateTimeFormatInfoScanner.CJKMinuteSuff, "");
                            temp.add(System.Globalization.DateTimeFormatInfoScanner.CJKSecondSuff, "");

                            System.Globalization.DateTimeFormatInfoScanner.s_knownWords = temp;
                        }
                        return (System.Globalization.DateTimeFormatInfoScanner.s_knownWords);
                    }
                }
            },
            ctors: {
                init: function () {
                    this.MonthPostfixChar = 57344;
                    this.IgnorableSymbolChar = 57345;
                    this.CJKYearSuff = "";
                    this.CJKMonthSuff = "";
                    this.CJKDaySuff = "";
                    this.KoreanYearSuff = "";
                    this.KoreanMonthSuff = "";
                    this.KoreanDaySuff = "";
                    this.KoreanHourSuff = "";
                    this.KoreanMinuteSuff = "";
                    this.KoreanSecondSuff = "";
                    this.CJKHourSuff = "";
                    this.ChineseHourSuff = "";
                    this.CJKMinuteSuff = "";
                    this.CJKSecondSuff = "";
                }
            },
            methods: {
                SkipWhiteSpacesAndNonLetter: function (pattern, currentIndex) {
                    while (currentIndex < pattern.length) {
                        var ch = pattern.charCodeAt(currentIndex);
                        if (ch === 92) {
                            currentIndex = (currentIndex + 1) | 0;
                            if (currentIndex < pattern.length) {
                                ch = pattern.charCodeAt(currentIndex);
                                if (ch === 39) {
                                    continue;
                                }
                            } else {
                                break;
                            }
                        }
                        if (System.Char.isLetter(ch) || ch === 39 || ch === 46) {
                            break;
                        }
                        currentIndex = (currentIndex + 1) | 0;
                    }
                    return (currentIndex);
                },
                ScanRepeatChar: function (pattern, ch, index, count) {
                    count.v = 1;
                    while (((index = (index + 1) | 0)) < pattern.length && pattern.charCodeAt(index) === ch) {
                        count.v = (count.v + 1) | 0;
                    }
                    return (index);
                },
                GetFormatFlagGenitiveMonth: function (monthNames, genitveMonthNames, abbrevMonthNames, genetiveAbbrevMonthNames) {
                    return ((!System.Globalization.DateTimeFormatInfoScanner.EqualStringArrays(monthNames, genitveMonthNames) || !System.Globalization.DateTimeFormatInfoScanner.EqualStringArrays(abbrevMonthNames, genetiveAbbrevMonthNames)) ? 1 : 0);
                },
                GetFormatFlagUseSpaceInMonthNames: function (monthNames, genitveMonthNames, abbrevMonthNames, genetiveAbbrevMonthNames) {
                    var formatFlags = 0;
                    formatFlags |= (System.Globalization.DateTimeFormatInfoScanner.ArrayElementsBeginWithDigit(monthNames) || System.Globalization.DateTimeFormatInfoScanner.ArrayElementsBeginWithDigit(genitveMonthNames) || System.Globalization.DateTimeFormatInfoScanner.ArrayElementsBeginWithDigit(abbrevMonthNames) || System.Globalization.DateTimeFormatInfoScanner.ArrayElementsBeginWithDigit(genetiveAbbrevMonthNames) ? 32 : 0);

                    formatFlags |= (System.Globalization.DateTimeFormatInfoScanner.ArrayElementsHaveSpace(monthNames) || System.Globalization.DateTimeFormatInfoScanner.ArrayElementsHaveSpace(genitveMonthNames) || System.Globalization.DateTimeFormatInfoScanner.ArrayElementsHaveSpace(abbrevMonthNames) || System.Globalization.DateTimeFormatInfoScanner.ArrayElementsHaveSpace(genetiveAbbrevMonthNames) ? 4 : 0);
                    return (formatFlags);
                },
                GetFormatFlagUseSpaceInDayNames: function (dayNames, abbrevDayNames) {
                    return ((System.Globalization.DateTimeFormatInfoScanner.ArrayElementsHaveSpace(dayNames) || System.Globalization.DateTimeFormatInfoScanner.ArrayElementsHaveSpace(abbrevDayNames)) ? 16 : 0);
                },
                GetFormatFlagUseHebrewCalendar: function (calID) {
                    return (calID === 8 ? 10 : 0);
                },
                EqualStringArrays: function (array1, array2) {
                    if (Bridge.referenceEquals(array1, array2)) {
                        return true;
                    }

                    if (array1.length !== array2.length) {
                        return false;
                    }

                    for (var i = 0; i < array1.length; i = (i + 1) | 0) {
                        if (!System.String.equals(array1[System.Array.index(i, array1)], array2[System.Array.index(i, array2)])) {
                            return false;
                        }
                    }

                    return true;
                },
                ArrayElementsHaveSpace: function (array) {
                    for (var i = 0; i < array.length; i = (i + 1) | 0) {
                        for (var j = 0; j < array[System.Array.index(i, array)].length; j = (j + 1) | 0) {
                            if (System.Char.isWhiteSpace(String.fromCharCode(array[System.Array.index(i, array)].charCodeAt(j)))) {
                                return true;
                            }
                        }
                    }

                    return false;
                },
                ArrayElementsBeginWithDigit: function (array) {
                    for (var i = 0; i < array.length; i = (i + 1) | 0) {
                        if (array[System.Array.index(i, array)].length > 0 && array[System.Array.index(i, array)].charCodeAt(0) >= 48 && array[System.Array.index(i, array)].charCodeAt(0) <= 57) {
                            var index = 1;
                            while (index < array[System.Array.index(i, array)].length && array[System.Array.index(i, array)].charCodeAt(index) >= 48 && array[System.Array.index(i, array)].charCodeAt(index) <= 57) {
                                index = (index + 1) | 0;
                            }
                            if (index === array[System.Array.index(i, array)].length) {
                                return (false);
                            }

                            if (index === ((array[System.Array.index(i, array)].length - 1) | 0)) {
                                switch (array[System.Array.index(i, array)].charCodeAt(index)) {
                                    case 26376: 
                                    case 50900: 
                                        return (false);
                                }
                            }

                            if (index === ((array[System.Array.index(i, array)].length - 4) | 0)) {
                                if (array[System.Array.index(i, array)].charCodeAt(index) === 39 && array[System.Array.index(i, array)].charCodeAt(((index + 1) | 0)) === 32 && array[System.Array.index(i, array)].charCodeAt(((index + 2) | 0)) === 26376 && array[System.Array.index(i, array)].charCodeAt(((index + 3) | 0)) === 39) {
                                    return (false);
                                }
                            }
                            return (true);
                        }
                    }

                    return false;
                }
            }
        },
        fields: {
            m_dateWords: null,
            _ymdFlags: 0
        },
        ctors: {
            init: function () {
                this.m_dateWords = new (System.Collections.Generic.List$1(System.String)).ctor();
                this._ymdFlags = System.Globalization.DateTimeFormatInfoScanner.FoundDatePattern.None;
            }
        },
        methods: {
            AddDateWordOrPostfix: function (formatPostfix, str) {
                if (str.length > 0) {
                    if (System.String.equals(str, ".")) {
                        this.AddIgnorableSymbols(".");
                        return;
                    }
                    var words = { };
                    if (System.Globalization.DateTimeFormatInfoScanner.KnownWords.tryGetValue(str, words) === false) {
                        if (this.m_dateWords == null) {
                            this.m_dateWords = new (System.Collections.Generic.List$1(System.String)).ctor();
                        }
                        if (Bridge.referenceEquals(formatPostfix, "MMMM")) {
                            var temp = String.fromCharCode(System.Globalization.DateTimeFormatInfoScanner.MonthPostfixChar) + (str || "");
                            if (!this.m_dateWords.contains(temp)) {
                                this.m_dateWords.add(temp);
                            }
                        } else {
                            if (!this.m_dateWords.contains(str)) {
                                this.m_dateWords.add(str);
                            }
                            if (str.charCodeAt(((str.length - 1) | 0)) === 46) {
                                var strWithoutDot = str.substr(0, ((str.length - 1) | 0));
                                if (!this.m_dateWords.contains(strWithoutDot)) {
                                    this.m_dateWords.add(strWithoutDot);
                                }
                            }
                        }
                    }
                }
            },
            AddDateWords: function (pattern, index, formatPostfix) {
                var newIndex = System.Globalization.DateTimeFormatInfoScanner.SkipWhiteSpacesAndNonLetter(pattern, index);
                if (newIndex !== index && formatPostfix != null) {
                    formatPostfix = null;
                }
                index = newIndex;

                var dateWord = new System.Text.StringBuilder();

                while (index < pattern.length) {
                    var ch = pattern.charCodeAt(index);
                    if (ch === 39) {
                        this.AddDateWordOrPostfix(formatPostfix, dateWord.toString());
                        index = (index + 1) | 0;
                        break;
                    } else if (ch === 92) {

                        index = (index + 1) | 0;
                        if (index < pattern.length) {
                            dateWord.append(String.fromCharCode(pattern.charCodeAt(index)));
                            index = (index + 1) | 0;
                        }
                    } else if (System.Char.isWhiteSpace(String.fromCharCode(ch))) {
                        this.AddDateWordOrPostfix(formatPostfix, dateWord.toString());
                        if (formatPostfix != null) {
                            formatPostfix = null;
                        }
                        dateWord.setLength(0);
                        index = (index + 1) | 0;
                    } else {
                        dateWord.append(String.fromCharCode(ch));
                        index = (index + 1) | 0;
                    }
                }
                return (index);
            },
            AddIgnorableSymbols: function (text) {
                if (this.m_dateWords == null) {
                    this.m_dateWords = new (System.Collections.Generic.List$1(System.String)).ctor();
                }
                var temp = String.fromCharCode(System.Globalization.DateTimeFormatInfoScanner.IgnorableSymbolChar) + (text || "");
                if (!this.m_dateWords.contains(temp)) {
                    this.m_dateWords.add(temp);
                }
            },
            ScanDateWord: function (pattern) {
                this._ymdFlags = System.Globalization.DateTimeFormatInfoScanner.FoundDatePattern.None;

                var i = 0;
                while (i < pattern.length) {
                    var ch = pattern.charCodeAt(i);
                    var chCount = { };

                    switch (ch) {
                        case 39: 
                            i = this.AddDateWords(pattern, ((i + 1) | 0), null);
                            break;
                        case 77: 
                            i = System.Globalization.DateTimeFormatInfoScanner.ScanRepeatChar(pattern, 77, i, chCount);
                            if (chCount.v >= 4) {
                                if (i < pattern.length && pattern.charCodeAt(i) === 39) {
                                    i = this.AddDateWords(pattern, ((i + 1) | 0), "MMMM");
                                }
                            }
                            this._ymdFlags |= System.Globalization.DateTimeFormatInfoScanner.FoundDatePattern.FoundMonthPatternFlag;
                            break;
                        case 121: 
                            i = System.Globalization.DateTimeFormatInfoScanner.ScanRepeatChar(pattern, 121, i, chCount);
                            this._ymdFlags |= System.Globalization.DateTimeFormatInfoScanner.FoundDatePattern.FoundYearPatternFlag;
                            break;
                        case 100: 
                            i = System.Globalization.DateTimeFormatInfoScanner.ScanRepeatChar(pattern, 100, i, chCount);
                            if (chCount.v <= 2) {
                                this._ymdFlags |= System.Globalization.DateTimeFormatInfoScanner.FoundDatePattern.FoundDayPatternFlag;
                            }
                            break;
                        case 92: 
                            i = (i + 2) | 0;
                            break;
                        case 46: 
                            if (this._ymdFlags === System.Globalization.DateTimeFormatInfoScanner.FoundDatePattern.FoundYMDPatternFlag) {
                                this.AddIgnorableSymbols(".");
                                this._ymdFlags = System.Globalization.DateTimeFormatInfoScanner.FoundDatePattern.None;
                            }
                            i = (i + 1) | 0;
                            break;
                        default: 
                            if (this._ymdFlags === System.Globalization.DateTimeFormatInfoScanner.FoundDatePattern.FoundYMDPatternFlag && !System.Char.isWhiteSpace(String.fromCharCode(ch))) {
                                this._ymdFlags = System.Globalization.DateTimeFormatInfoScanner.FoundDatePattern.None;
                            }
                            i = (i + 1) | 0;
                            break;
                    }
                }
            },
            GetDateWordsOfDTFI: function (dtfi) {
                var datePatterns = dtfi.getAllDateTimePatterns(68);
                var i;

                for (i = 0; i < datePatterns.length; i = (i + 1) | 0) {
                    this.ScanDateWord(datePatterns[System.Array.index(i, datePatterns)]);
                }

                datePatterns = dtfi.getAllDateTimePatterns(100);
                for (i = 0; i < datePatterns.length; i = (i + 1) | 0) {
                    this.ScanDateWord(datePatterns[System.Array.index(i, datePatterns)]);
                }
                datePatterns = dtfi.getAllDateTimePatterns(121);
                for (i = 0; i < datePatterns.length; i = (i + 1) | 0) {
                    this.ScanDateWord(datePatterns[System.Array.index(i, datePatterns)]);
                }

                this.ScanDateWord(dtfi.monthDayPattern);

                datePatterns = dtfi.getAllDateTimePatterns(84);
                for (i = 0; i < datePatterns.length; i = (i + 1) | 0) {
                    this.ScanDateWord(datePatterns[System.Array.index(i, datePatterns)]);
                }

                datePatterns = dtfi.getAllDateTimePatterns(116);
                for (i = 0; i < datePatterns.length; i = (i + 1) | 0) {
                    this.ScanDateWord(datePatterns[System.Array.index(i, datePatterns)]);
                }

                var result = null;
                if (this.m_dateWords != null && this.m_dateWords.Count > 0) {
                    result = System.Array.init(this.m_dateWords.Count, null, System.String);
                    for (i = 0; i < this.m_dateWords.Count; i = (i + 1) | 0) {
                        result[System.Array.index(i, result)] = this.m_dateWords.getItem(i);
                    }
                }
                return (result);
            }
        }
    });

    // @source DateTimeStyles.js

    Bridge.define("System.Globalization.DateTimeStyles", {
        $kind: "enum",
        statics: {
            fields: {
                None: 0,
                AllowLeadingWhite: 1,
                AllowTrailingWhite: 2,
                AllowInnerWhite: 4,
                AllowWhiteSpaces: 7,
                NoCurrentDateDefault: 8,
                AdjustToUniversal: 16,
                AssumeLocal: 32,
                AssumeUniversal: 64,
                RoundtripKind: 128
            }
        },
        $flags: true
    });

    // @source FORMATFLAGS.js

    Bridge.define("System.Globalization.FORMATFLAGS", {
        $kind: "enum",
        statics: {
            fields: {
                None: 0,
                UseGenitiveMonth: 1,
                UseLeapYearMonth: 2,
                UseSpacesInMonthNames: 4,
                UseHebrewParsing: 8,
                UseSpacesInDayNames: 16,
                UseDigitPrefixInTokens: 32
            }
        }
    });

    // @source GlobalizationMode.js

    Bridge.define("System.Globalization.GlobalizationMode", {
        statics: {
            props: {
                Invariant: false
            },
            ctors: {
                init: function () {
                    this.Invariant = System.Globalization.GlobalizationMode.GetGlobalizationInvariantMode();
                }
            },
            methods: {
                GetInvariantSwitchValue: function () {
                    return true;


                },
                GetGlobalizationInvariantMode: function () {
                    return System.Globalization.GlobalizationMode.GetInvariantSwitchValue();
                }
            }
        }
    });

    // @source FoundDatePattern.js

    Bridge.define("System.Globalization.DateTimeFormatInfoScanner.FoundDatePattern", {
        $kind: "nested enum",
        statics: {
            fields: {
                None: 0,
                FoundYearPatternFlag: 1,
                FoundMonthPatternFlag: 2,
                FoundDayPatternFlag: 4,
                FoundYMDPatternFlag: 7
            }
        }
    });

    // @source NotImplemented.js

    Bridge.define("System.NotImplemented", {
        statics: {
            props: {
                ByDesign: {
                    get: function () {
                        return new System.NotImplementedException.ctor();
                    }
                }
            },
            methods: {
                ByDesignWithMessage: function (message) {
                    return new System.NotImplementedException.$ctor1(message);
                }
            }
        }
    });

    // @source NotImplementedException.js

    Bridge.define("System.NotImplementedException", {
        inherits: [System.SystemException],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.SystemException.$ctor1.call(this, "The method or operation is not implemented.");
                this.HResult = -2147467263;
            },
            $ctor1: function (message) {
                this.$initialize();
                System.SystemException.$ctor1.call(this, message);
                this.HResult = -2147467263;
            },
            $ctor2: function (message, inner) {
                this.$initialize();
                System.SystemException.$ctor2.call(this, message, inner);
                this.HResult = -2147467263;
            }
        }
    });

    // @source NotSupportedException.js

    Bridge.define("System.NotSupportedException", {
        inherits: [System.SystemException],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.SystemException.$ctor1.call(this, "Specified method is not supported.");
                this.HResult = -2146233067;
            },
            $ctor1: function (message) {
                this.$initialize();
                System.SystemException.$ctor1.call(this, message);
                this.HResult = -2146233067;
            },
            $ctor2: function (message, innerException) {
                this.$initialize();
                System.SystemException.$ctor2.call(this, message, innerException);
                this.HResult = -2146233067;
            }
        }
    });

    // @source NullReferenceException.js

    Bridge.define("System.NullReferenceException", {
        inherits: [System.SystemException],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.SystemException.$ctor1.call(this, "Object reference not set to an instance of an object.");
                this.HResult = -2147467261;
            },
            $ctor1: function (message) {
                this.$initialize();
                System.SystemException.$ctor1.call(this, message);
                this.HResult = -2147467261;
            },
            $ctor2: function (message, innerException) {
                this.$initialize();
                System.SystemException.$ctor2.call(this, message, innerException);
                this.HResult = -2147467261;
            }
        }
    });

    // @source OperationCanceledException.js

    Bridge.define("System.OperationCanceledException", {
        inherits: [System.SystemException],
        fields: {
            _cancellationToken: null
        },
        props: {
            CancellationToken: {
                get: function () {
                    return this._cancellationToken;
                },
                set: function (value) {
                    this._cancellationToken = value;
                }
            }
        },
        ctors: {
            init: function () {
                this._cancellationToken = new System.Threading.CancellationToken();
            },
            ctor: function () {
                this.$initialize();
                System.SystemException.$ctor1.call(this, "The operation was canceled.");
                this.HResult = -2146233029;
            },
            $ctor1: function (message) {
                this.$initialize();
                System.SystemException.$ctor1.call(this, message);
                this.HResult = -2146233029;
            },
            $ctor2: function (message, innerException) {
                this.$initialize();
                System.SystemException.$ctor2.call(this, message, innerException);
                this.HResult = -2146233029;
            },
            $ctor5: function (token) {
                System.OperationCanceledException.ctor.call(this);
                this.CancellationToken = token;
            },
            $ctor4: function (message, token) {
                System.OperationCanceledException.$ctor1.call(this, message);
                this.CancellationToken = token;
            },
            $ctor3: function (message, innerException, token) {
                System.OperationCanceledException.$ctor2.call(this, message, innerException);
                this.CancellationToken = token;
            }
        }
    });

    // @source OverflowException.js

    Bridge.define("System.OverflowException", {
        inherits: [System.ArithmeticException],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.ArithmeticException.$ctor1.call(this, "Arithmetic operation resulted in an overflow.");
                this.HResult = -2146233066;
            },
            $ctor1: function (message) {
                this.$initialize();
                System.ArithmeticException.$ctor1.call(this, message);
                this.HResult = -2146233066;
            },
            $ctor2: function (message, innerException) {
                this.$initialize();
                System.ArithmeticException.$ctor2.call(this, message, innerException);
                this.HResult = -2146233066;
            }
        }
    });

    // @source ParseFailureKind.js

    Bridge.define("System.ParseFailureKind", {
        $kind: "enum",
        statics: {
            fields: {
                None: 0,
                ArgumentNull: 1,
                Format: 2,
                FormatWithParameter: 3,
                FormatBadDateTimeCalendar: 4
            }
        }
    });

    // @source ParseFlags.js

    Bridge.define("System.ParseFlags", {
        $kind: "enum",
        statics: {
            fields: {
                HaveYear: 1,
                HaveMonth: 2,
                HaveDay: 4,
                HaveHour: 8,
                HaveMinute: 16,
                HaveSecond: 32,
                HaveTime: 64,
                HaveDate: 128,
                TimeZoneUsed: 256,
                TimeZoneUtc: 512,
                ParsedMonthName: 1024,
                CaptureOffset: 2048,
                YearDefault: 4096,
                Rfc1123Pattern: 8192,
                UtcSortPattern: 16384
            }
        },
        $flags: true
    });

    // @source StringBuilderCache.js

    Bridge.define("System.Text.StringBuilderCache", {
        statics: {
            fields: {
                MAX_BUILDER_SIZE: 0,
                DEFAULT_CAPACITY: 0,
                t_cachedInstance: null
            },
            ctors: {
                init: function () {
                    this.MAX_BUILDER_SIZE = 260;
                    this.DEFAULT_CAPACITY = 16;
                }
            },
            methods: {
                Acquire: function (capacity) {
                    if (capacity === void 0) { capacity = 16; }
                    if (capacity <= System.Text.StringBuilderCache.MAX_BUILDER_SIZE) {
                        var sb = System.Text.StringBuilderCache.t_cachedInstance;
                        if (sb != null) {
                            if (capacity <= sb.getCapacity()) {
                                System.Text.StringBuilderCache.t_cachedInstance = null;
                                sb.clear();
                                return sb;
                            }
                        }
                    }
                    return new System.Text.StringBuilder("", capacity);
                },
                Release: function (sb) {
                    if (sb.getCapacity() <= System.Text.StringBuilderCache.MAX_BUILDER_SIZE) {
                        System.Text.StringBuilderCache.t_cachedInstance = sb;
                    }
                },
                GetStringAndRelease: function (sb) {
                    var result = sb.toString();
                    System.Text.StringBuilderCache.Release(sb);
                    return result;
                }
            }
        }
    });

    // @source BinaryReader.js

    Bridge.define("System.IO.BinaryReader", {
        inherits: [System.IDisposable],
        statics: {
            fields: {
                MaxCharBytesSize: 0
            },
            ctors: {
                init: function () {
                    this.MaxCharBytesSize = 128;
                }
            }
        },
        fields: {
            m_stream: null,
            m_buffer: null,
            m_encoding: null,
            m_charBytes: null,
            m_singleChar: null,
            m_charBuffer: null,
            m_maxCharsSize: 0,
            m_2BytesPerChar: false,
            m_isMemoryStream: false,
            m_leaveOpen: false,
            lastCharsRead: 0
        },
        props: {
            BaseStream: {
                get: function () {
                    return this.m_stream;
                }
            }
        },
        alias: ["Dispose", "System$IDisposable$Dispose"],
        ctors: {
            init: function () {
                this.lastCharsRead = 0;
            },
            ctor: function (input) {
                System.IO.BinaryReader.$ctor2.call(this, input, new System.Text.UTF8Encoding.ctor(), false);
            },
            $ctor1: function (input, encoding) {
                System.IO.BinaryReader.$ctor2.call(this, input, encoding, false);
            },
            $ctor2: function (input, encoding, leaveOpen) {
                this.$initialize();
                if (input == null) {
                    throw new System.ArgumentNullException.$ctor1("input");
                }
                if (encoding == null) {
                    throw new System.ArgumentNullException.$ctor1("encoding");
                }
                if (!input.CanRead) {
                    throw new System.ArgumentException.$ctor1("Argument_StreamNotReadable");
                }
                this.m_stream = input;
                this.m_encoding = encoding;
                this.m_maxCharsSize = encoding.GetMaxCharCount(System.IO.BinaryReader.MaxCharBytesSize);
                var minBufferSize = encoding.GetMaxByteCount(1);
                if (minBufferSize < 23) {
                    minBufferSize = 23;
                }
                this.m_buffer = System.Array.init(minBufferSize, 0, System.Byte);

                this.m_2BytesPerChar = Bridge.is(encoding, System.Text.UnicodeEncoding);
                this.m_isMemoryStream = (Bridge.referenceEquals(Bridge.getType(this.m_stream), System.IO.MemoryStream));
                this.m_leaveOpen = leaveOpen;

            }
        },
        methods: {
            Close: function () {
                this.Dispose$1(true);
            },
            Dispose$1: function (disposing) {
                if (disposing) {
                    var copyOfStream = this.m_stream;
                    this.m_stream = null;
                    if (copyOfStream != null && !this.m_leaveOpen) {
                        copyOfStream.Close();
                    }
                }
                this.m_stream = null;
                this.m_buffer = null;
                this.m_encoding = null;
                this.m_charBytes = null;
                this.m_singleChar = null;
                this.m_charBuffer = null;
            },
            Dispose: function () {
                this.Dispose$1(true);
            },
            PeekChar: function () {

                if (this.m_stream == null) {
                    System.IO.__Error.FileNotOpen();
                }

                if (!this.m_stream.CanSeek) {
                    return -1;
                }
                var origPos = this.m_stream.Position;
                var ch = this.Read();
                this.m_stream.Position = origPos;
                return ch;
            },
            Read: function () {

                if (this.m_stream == null) {
                    System.IO.__Error.FileNotOpen();
                }
                return this.InternalReadOneChar();
            },
            Read$2: function (buffer, index, count) {
                if (buffer == null) {
                    throw new System.ArgumentNullException.$ctor3("buffer", "ArgumentNull_Buffer");
                }
                if (index < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("index", "ArgumentOutOfRange_NeedNonNegNum");
                }
                if (count < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("count", "ArgumentOutOfRange_NeedNonNegNum");
                }
                if (((buffer.length - index) | 0) < count) {
                    throw new System.ArgumentException.$ctor1("Argument_InvalidOffLen");
                }

                if (this.m_stream == null) {
                    System.IO.__Error.FileNotOpen();
                }

                return this.InternalReadChars(buffer, index, count);
            },
            Read$1: function (buffer, index, count) {
                if (buffer == null) {
                    throw new System.ArgumentNullException.$ctor3("buffer", "ArgumentNull_Buffer");
                }
                if (index < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("index", "ArgumentOutOfRange_NeedNonNegNum");
                }
                if (count < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("count", "ArgumentOutOfRange_NeedNonNegNum");
                }
                if (((buffer.length - index) | 0) < count) {
                    throw new System.ArgumentException.$ctor1("Argument_InvalidOffLen");
                }

                if (this.m_stream == null) {
                    System.IO.__Error.FileNotOpen();
                }
                return this.m_stream.Read(buffer, index, count);
            },
            ReadBoolean: function () {
                this.FillBuffer(1);
                return (this.m_buffer[System.Array.index(0, this.m_buffer)] !== 0);
            },
            ReadByte: function () {
                if (this.m_stream == null) {
                    System.IO.__Error.FileNotOpen();
                }

                var b = this.m_stream.ReadByte();
                if (b === -1) {
                    System.IO.__Error.EndOfFile();
                }
                return (b & 255);
            },
            ReadSByte: function () {
                this.FillBuffer(1);
                return Bridge.Int.sxb((this.m_buffer[System.Array.index(0, this.m_buffer)]) & 255);
            },
            ReadChar: function () {
                var value = this.Read();
                if (value === -1) {
                    System.IO.__Error.EndOfFile();
                }
                return (value & 65535);
            },
            ReadInt16: function () {
                this.FillBuffer(2);
                return Bridge.Int.sxs((this.m_buffer[System.Array.index(0, this.m_buffer)] | this.m_buffer[System.Array.index(1, this.m_buffer)] << 8) & 65535);
            },
            ReadUInt16: function () {
                this.FillBuffer(2);
                return ((this.m_buffer[System.Array.index(0, this.m_buffer)] | this.m_buffer[System.Array.index(1, this.m_buffer)] << 8) & 65535);
            },
            ReadInt32: function () {
                if (this.m_isMemoryStream) {
                    if (this.m_stream == null) {
                        System.IO.__Error.FileNotOpen();
                    }
                    var mStream = Bridge.as(this.m_stream, System.IO.MemoryStream);

                    return mStream.InternalReadInt32();
                } else {
                    this.FillBuffer(4);
                    return this.m_buffer[System.Array.index(0, this.m_buffer)] | this.m_buffer[System.Array.index(1, this.m_buffer)] << 8 | this.m_buffer[System.Array.index(2, this.m_buffer)] << 16 | this.m_buffer[System.Array.index(3, this.m_buffer)] << 24;
                }
            },
            ReadUInt32: function () {
                this.FillBuffer(4);
                return ((this.m_buffer[System.Array.index(0, this.m_buffer)] | this.m_buffer[System.Array.index(1, this.m_buffer)] << 8 | this.m_buffer[System.Array.index(2, this.m_buffer)] << 16 | this.m_buffer[System.Array.index(3, this.m_buffer)] << 24) >>> 0);
            },
            ReadInt64: function () {
                this.FillBuffer(8);
                var lo = (this.m_buffer[System.Array.index(0, this.m_buffer)] | this.m_buffer[System.Array.index(1, this.m_buffer)] << 8 | this.m_buffer[System.Array.index(2, this.m_buffer)] << 16 | this.m_buffer[System.Array.index(3, this.m_buffer)] << 24) >>> 0;
                var hi = (this.m_buffer[System.Array.index(4, this.m_buffer)] | this.m_buffer[System.Array.index(5, this.m_buffer)] << 8 | this.m_buffer[System.Array.index(6, this.m_buffer)] << 16 | this.m_buffer[System.Array.index(7, this.m_buffer)] << 24) >>> 0;
                return System.Int64.clip64(System.UInt64(hi)).shl(32).or(System.Int64(lo));
            },
            ReadUInt64: function () {
                this.FillBuffer(8);
                var lo = (this.m_buffer[System.Array.index(0, this.m_buffer)] | this.m_buffer[System.Array.index(1, this.m_buffer)] << 8 | this.m_buffer[System.Array.index(2, this.m_buffer)] << 16 | this.m_buffer[System.Array.index(3, this.m_buffer)] << 24) >>> 0;
                var hi = (this.m_buffer[System.Array.index(4, this.m_buffer)] | this.m_buffer[System.Array.index(5, this.m_buffer)] << 8 | this.m_buffer[System.Array.index(6, this.m_buffer)] << 16 | this.m_buffer[System.Array.index(7, this.m_buffer)] << 24) >>> 0;
                return System.UInt64(hi).shl(32).or(System.UInt64(lo));
            },
            ReadSingle: function () {
                this.FillBuffer(4);
                var tmpBuffer = (this.m_buffer[System.Array.index(0, this.m_buffer)] | this.m_buffer[System.Array.index(1, this.m_buffer)] << 8 | this.m_buffer[System.Array.index(2, this.m_buffer)] << 16 | this.m_buffer[System.Array.index(3, this.m_buffer)] << 24) >>> 0;
                return System.BitConverter.toSingle(System.BitConverter.getBytes$8(tmpBuffer), 0);
            },
            ReadDouble: function () {
                this.FillBuffer(8);
                var lo = (this.m_buffer[System.Array.index(0, this.m_buffer)] | this.m_buffer[System.Array.index(1, this.m_buffer)] << 8 | this.m_buffer[System.Array.index(2, this.m_buffer)] << 16 | this.m_buffer[System.Array.index(3, this.m_buffer)] << 24) >>> 0;
                var hi = (this.m_buffer[System.Array.index(4, this.m_buffer)] | this.m_buffer[System.Array.index(5, this.m_buffer)] << 8 | this.m_buffer[System.Array.index(6, this.m_buffer)] << 16 | this.m_buffer[System.Array.index(7, this.m_buffer)] << 24) >>> 0;

                var tmpBuffer = System.UInt64(hi).shl(32).or(System.UInt64(lo));
                return System.BitConverter.toDouble(System.BitConverter.getBytes$9(tmpBuffer), 0);
            },
            ReadDecimal: function () {
                this.FillBuffer(23);
                try {
                    return System.Decimal.fromBytes(this.m_buffer);
                } catch ($e1) {
                    $e1 = System.Exception.create($e1);
                    var e;
                    if (Bridge.is($e1, System.ArgumentException)) {
                        e = $e1;
                        throw new System.IO.IOException.$ctor2("Arg_DecBitCtor", e);
                    } else {
                        throw $e1;
                    }
                }
            },
            ReadString: function () {

                if (this.m_stream == null) {
                    System.IO.__Error.FileNotOpen();
                }

                var currPos = 0;
                var n;
                var stringLength;
                var readLength;
                var charsRead;

                stringLength = this.Read7BitEncodedInt();
                if (stringLength < 0) {
                    throw new System.IO.IOException.$ctor1("IO.IO_InvalidStringLen_Len");
                }

                if (stringLength === 0) {
                    return "";
                }

                if (this.m_charBytes == null) {
                    this.m_charBytes = System.Array.init(System.IO.BinaryReader.MaxCharBytesSize, 0, System.Byte);
                }

                if (this.m_charBuffer == null) {
                    this.m_charBuffer = System.Array.init(this.m_maxCharsSize, 0, System.Char);
                }

                var sb = null;
                do {
                    readLength = ((((stringLength - currPos) | 0)) > System.IO.BinaryReader.MaxCharBytesSize) ? System.IO.BinaryReader.MaxCharBytesSize : (((stringLength - currPos) | 0));

                    n = this.m_stream.Read(this.m_charBytes, 0, readLength);
                    if (n === 0) {
                        System.IO.__Error.EndOfFile();
                    }

                    charsRead = this.m_encoding.GetChars$2(this.m_charBytes, 0, n, this.m_charBuffer, 0);

                    if (currPos === 0 && n === stringLength) {
                        return System.String.fromCharArray(this.m_charBuffer, 0, charsRead);
                    }

                    if (sb == null) {
                        sb = new System.Text.StringBuilder("", stringLength);
                    }

                    for (var i = 0; i < charsRead; i = (i + 1) | 0) {
                        sb.append(String.fromCharCode(this.m_charBuffer[System.Array.index(i, this.m_charBuffer)]));
                    }

                    currPos = (currPos + n) | 0;

                } while (currPos < stringLength);

                return sb.toString();
            },
            InternalReadChars: function (buffer, index, count) {

                var charsRemaining = count;

                if (this.m_charBytes == null) {
                    this.m_charBytes = System.Array.init(System.IO.BinaryReader.MaxCharBytesSize, 0, System.Byte);
                }

                if (index < 0 || charsRemaining < 0 || ((index + charsRemaining) | 0) > buffer.length) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("charsRemaining");
                }

                while (charsRemaining > 0) {

                    var ch = this.InternalReadOneChar(true);

                    if (ch === -1) {
                        break;
                    }

                    buffer[System.Array.index(index, buffer)] = ch & 65535;

                    if (this.lastCharsRead === 2) {
                        buffer[System.Array.index(((index = (index + 1) | 0)), buffer)] = this.m_singleChar[System.Array.index(1, this.m_singleChar)];
                        charsRemaining = (charsRemaining - 1) | 0;
                    }

                    charsRemaining = (charsRemaining - 1) | 0;
                    index = (index + 1) | 0;
                }


                return (((count - charsRemaining) | 0));
            },
            InternalReadOneChar: function (allowSurrogate) {
                if (allowSurrogate === void 0) { allowSurrogate = false; }
                var charsRead = 0;
                var numBytes = 0;
                var posSav = System.Int64(0);

                if (this.m_stream.CanSeek) {
                    posSav = this.m_stream.Position;
                }

                if (this.m_charBytes == null) {
                    this.m_charBytes = System.Array.init(System.IO.BinaryReader.MaxCharBytesSize, 0, System.Byte);
                }
                if (this.m_singleChar == null) {
                    this.m_singleChar = System.Array.init(2, 0, System.Char);
                }

                var addByte = false;
                var internalPos = 0;
                while (charsRead === 0) {
                    numBytes = this.m_2BytesPerChar ? 2 : 1;

                    if (Bridge.is(this.m_encoding, System.Text.UTF32Encoding)) {
                        numBytes = 4;
                    }

                    if (addByte) {
                        var r = this.m_stream.ReadByte();
                        this.m_charBytes[System.Array.index(((internalPos = (internalPos + 1) | 0)), this.m_charBytes)] = r & 255;
                        if (r === -1) {
                            numBytes = 0;
                        }

                        if (numBytes === 2) {
                            r = this.m_stream.ReadByte();
                            this.m_charBytes[System.Array.index(((internalPos = (internalPos + 1) | 0)), this.m_charBytes)] = r & 255;
                            if (r === -1) {
                                numBytes = 1;
                            }
                        }
                    } else {
                        var r1 = this.m_stream.ReadByte();
                        this.m_charBytes[System.Array.index(0, this.m_charBytes)] = r1 & 255;
                        internalPos = 0;
                        if (r1 === -1) {
                            numBytes = 0;
                        }

                        if (numBytes === 2) {
                            r1 = this.m_stream.ReadByte();
                            this.m_charBytes[System.Array.index(1, this.m_charBytes)] = r1 & 255;
                            if (r1 === -1) {
                                numBytes = 1;
                            }
                            internalPos = 1;
                        } else if (numBytes === 4) {
                            r1 = this.m_stream.ReadByte();
                            this.m_charBytes[System.Array.index(1, this.m_charBytes)] = r1 & 255;
                            if (r1 === -1) {
                                return -1;
                            }

                            r1 = this.m_stream.ReadByte();
                            this.m_charBytes[System.Array.index(2, this.m_charBytes)] = r1 & 255;
                            if (r1 === -1) {
                                return -1;
                            }

                            r1 = this.m_stream.ReadByte();
                            this.m_charBytes[System.Array.index(3, this.m_charBytes)] = r1 & 255;
                            if (r1 === -1) {
                                return -1;
                            }

                            internalPos = 3;
                        }
                    }


                    if (numBytes === 0) {
                        return -1;
                    }

                    addByte = false;
                    try {
                        charsRead = this.m_encoding.GetChars$2(this.m_charBytes, 0, ((internalPos + 1) | 0), this.m_singleChar, 0);

                        if (!allowSurrogate && charsRead === 2) {
                            throw new System.ArgumentException.ctor();
                        }
                    } catch ($e1) {
                        $e1 = System.Exception.create($e1);

                        if (this.m_stream.CanSeek) {
                            this.m_stream.Seek((posSav.sub(this.m_stream.Position)), 1);
                        }

                        throw $e1;
                    }

                    if (this.m_encoding._hasError) {
                        charsRead = 0;
                        addByte = true;
                    }

                    if (!allowSurrogate) {
                    }
                }

                this.lastCharsRead = charsRead;

                if (charsRead === 0) {
                    return -1;
                }

                return this.m_singleChar[System.Array.index(0, this.m_singleChar)];
            },
            ReadChars: function (count) {
                if (count < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("count", "ArgumentOutOfRange_NeedNonNegNum");
                }
                if (this.m_stream == null) {
                    System.IO.__Error.FileNotOpen();
                }

                if (count === 0) {
                    return System.Array.init(0, 0, System.Char);
                }

                var chars = System.Array.init(count, 0, System.Char);
                var n = this.InternalReadChars(chars, 0, count);
                if (n !== count) {
                    var copy = System.Array.init(n, 0, System.Char);
                    System.Array.copy(chars, 0, copy, 0, Bridge.Int.mul(2, n));
                    chars = copy;
                }

                return chars;
            },
            ReadBytes: function (count) {
                if (count < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("count", "ArgumentOutOfRange_NeedNonNegNum");
                }
                if (this.m_stream == null) {
                    System.IO.__Error.FileNotOpen();
                }

                if (count === 0) {
                    return System.Array.init(0, 0, System.Byte);
                }

                var result = System.Array.init(count, 0, System.Byte);

                var numRead = 0;
                do {
                    var n = this.m_stream.Read(result, numRead, count);
                    if (n === 0) {
                        break;
                    }
                    numRead = (numRead + n) | 0;
                    count = (count - n) | 0;
                } while (count > 0);

                if (numRead !== result.length) {
                    var copy = System.Array.init(numRead, 0, System.Byte);
                    System.Array.copy(result, 0, copy, 0, numRead);
                    result = copy;
                }

                return result;
            },
            FillBuffer: function (numBytes) {
                if (this.m_buffer != null && (numBytes < 0 || numBytes > this.m_buffer.length)) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("numBytes", "ArgumentOutOfRange_BinaryReaderFillBuffer");
                }
                var bytesRead = 0;
                var n = 0;

                if (this.m_stream == null) {
                    System.IO.__Error.FileNotOpen();
                }

                if (numBytes === 1) {
                    n = this.m_stream.ReadByte();
                    if (n === -1) {
                        System.IO.__Error.EndOfFile();
                    }
                    this.m_buffer[System.Array.index(0, this.m_buffer)] = n & 255;
                    return;
                }

                do {
                    n = this.m_stream.Read(this.m_buffer, bytesRead, ((numBytes - bytesRead) | 0));
                    if (n === 0) {
                        System.IO.__Error.EndOfFile();
                    }
                    bytesRead = (bytesRead + n) | 0;
                } while (bytesRead < numBytes);
            },
            Read7BitEncodedInt: function () {
                var count = 0;
                var shift = 0;
                var b;
                do {
                    if (shift === 35) {
                        throw new System.FormatException.$ctor1("Format_Bad7BitInt32");
                    }

                    b = this.ReadByte();
                    count = count | ((b & 127) << shift);
                    shift = (shift + 7) | 0;
                } while ((b & 128) !== 0);
                return count;
            }
        }
    });

    // @source BinaryWriter.js

    Bridge.define("System.IO.BinaryWriter", {
        inherits: [System.IDisposable],
        statics: {
            fields: {
                Null: null,
                LargeByteBufferSize: 0
            },
            ctors: {
                init: function () {
                    this.Null = new System.IO.BinaryWriter.ctor();
                    this.LargeByteBufferSize = 256;
                }
            }
        },
        fields: {
            OutStream: null,
            _buffer: null,
            _encoding: null,
            _leaveOpen: false,
            _tmpOneCharBuffer: null
        },
        props: {
            BaseStream: {
                get: function () {
                    this.Flush();
                    return this.OutStream;
                }
            }
        },
        alias: ["Dispose", "System$IDisposable$Dispose"],
        ctors: {
            ctor: function () {
                this.$initialize();
                this.OutStream = System.IO.Stream.Null;
                this._buffer = System.Array.init(16, 0, System.Byte);
                this._encoding = new System.Text.UTF8Encoding.$ctor2(false, true);
            },
            $ctor1: function (output) {
                System.IO.BinaryWriter.$ctor3.call(this, output, new System.Text.UTF8Encoding.$ctor2(false, true), false);
            },
            $ctor2: function (output, encoding) {
                System.IO.BinaryWriter.$ctor3.call(this, output, encoding, false);
            },
            $ctor3: function (output, encoding, leaveOpen) {
                this.$initialize();
                if (output == null) {
                    throw new System.ArgumentNullException.$ctor1("output");
                }
                if (encoding == null) {
                    throw new System.ArgumentNullException.$ctor1("encoding");
                }
                if (!output.CanWrite) {
                    throw new System.ArgumentException.$ctor1("Argument_StreamNotWritable");
                }

                this.OutStream = output;
                this._buffer = System.Array.init(16, 0, System.Byte);
                this._encoding = encoding;
                this._leaveOpen = leaveOpen;
            }
        },
        methods: {
            Close: function () {
                this.Dispose$1(true);
            },
            Dispose$1: function (disposing) {
                if (disposing) {
                    if (this._leaveOpen) {
                        this.OutStream.Flush();
                    } else {
                        this.OutStream.Close();
                    }
                }
            },
            Dispose: function () {
                this.Dispose$1(true);
            },
            Flush: function () {
                this.OutStream.Flush();
            },
            Seek: function (offset, origin) {
                return this.OutStream.Seek(System.Int64(offset), origin);
            },
            Write: function (value) {
                this._buffer[System.Array.index(0, this._buffer)] = (value ? 1 : 0) & 255;
                this.OutStream.Write(this._buffer, 0, 1);
            },
            Write$1: function (value) {
                this.OutStream.WriteByte(value);
            },
            Write$12: function (value) {
                this.OutStream.WriteByte((value & 255));
            },
            Write$2: function (buffer) {
                if (buffer == null) {
                    throw new System.ArgumentNullException.$ctor1("buffer");
                }
                this.OutStream.Write(buffer, 0, buffer.length);
            },
            Write$3: function (buffer, index, count) {
                this.OutStream.Write(buffer, index, count);
            },
            Write$4: function (ch) {
                if (System.Char.isSurrogate(ch)) {
                    throw new System.ArgumentException.$ctor1("Arg_SurrogatesNotAllowedAsSingleChar");
                }

                var numBytes = 0;
                numBytes = this._encoding.GetBytes$3(System.Array.init([ch], System.Char), 0, 1, this._buffer, 0);

                this.OutStream.Write(this._buffer, 0, numBytes);
            },
            Write$5: function (chars) {
                if (chars == null) {
                    throw new System.ArgumentNullException.$ctor1("chars");
                }

                var bytes = this._encoding.GetBytes$1(chars, 0, chars.length);
                this.OutStream.Write(bytes, 0, bytes.length);
            },
            Write$6: function (chars, index, count) {
                var bytes = this._encoding.GetBytes$1(chars, index, count);
                this.OutStream.Write(bytes, 0, bytes.length);
            },
            Write$8: function (value) {
                var TmpValue = System.Int64.clipu64(System.BitConverter.doubleToInt64Bits(value));
                this._buffer[System.Array.index(0, this._buffer)] = System.Int64.clipu8(TmpValue);
                this._buffer[System.Array.index(1, this._buffer)] = System.Int64.clipu8(TmpValue.shru(8));
                this._buffer[System.Array.index(2, this._buffer)] = System.Int64.clipu8(TmpValue.shru(16));
                this._buffer[System.Array.index(3, this._buffer)] = System.Int64.clipu8(TmpValue.shru(24));
                this._buffer[System.Array.index(4, this._buffer)] = System.Int64.clipu8(TmpValue.shru(32));
                this._buffer[System.Array.index(5, this._buffer)] = System.Int64.clipu8(TmpValue.shru(40));
                this._buffer[System.Array.index(6, this._buffer)] = System.Int64.clipu8(TmpValue.shru(48));
                this._buffer[System.Array.index(7, this._buffer)] = System.Int64.clipu8(TmpValue.shru(56));
                this.OutStream.Write(this._buffer, 0, 8);
            },
            Write$7: function (value) {
                var buf = value.getBytes();
                this.OutStream.Write(buf, 0, 23);
            },
            Write$9: function (value) {
                this._buffer[System.Array.index(0, this._buffer)] = value & 255;
                this._buffer[System.Array.index(1, this._buffer)] = (value >> 8) & 255;
                this.OutStream.Write(this._buffer, 0, 2);
            },
            Write$15: function (value) {
                this._buffer[System.Array.index(0, this._buffer)] = value & 255;
                this._buffer[System.Array.index(1, this._buffer)] = (value >> 8) & 255;
                this.OutStream.Write(this._buffer, 0, 2);
            },
            Write$10: function (value) {
                this._buffer[System.Array.index(0, this._buffer)] = value & 255;
                this._buffer[System.Array.index(1, this._buffer)] = (value >> 8) & 255;
                this._buffer[System.Array.index(2, this._buffer)] = (value >> 16) & 255;
                this._buffer[System.Array.index(3, this._buffer)] = (value >> 24) & 255;
                this.OutStream.Write(this._buffer, 0, 4);
            },
            Write$16: function (value) {
                this._buffer[System.Array.index(0, this._buffer)] = value & 255;
                this._buffer[System.Array.index(1, this._buffer)] = (value >>> 8) & 255;
                this._buffer[System.Array.index(2, this._buffer)] = (value >>> 16) & 255;
                this._buffer[System.Array.index(3, this._buffer)] = (value >>> 24) & 255;
                this.OutStream.Write(this._buffer, 0, 4);
            },
            Write$11: function (value) {
                this._buffer[System.Array.index(0, this._buffer)] = System.Int64.clipu8(value);
                this._buffer[System.Array.index(1, this._buffer)] = System.Int64.clipu8(value.shr(8));
                this._buffer[System.Array.index(2, this._buffer)] = System.Int64.clipu8(value.shr(16));
                this._buffer[System.Array.index(3, this._buffer)] = System.Int64.clipu8(value.shr(24));
                this._buffer[System.Array.index(4, this._buffer)] = System.Int64.clipu8(value.shr(32));
                this._buffer[System.Array.index(5, this._buffer)] = System.Int64.clipu8(value.shr(40));
                this._buffer[System.Array.index(6, this._buffer)] = System.Int64.clipu8(value.shr(48));
                this._buffer[System.Array.index(7, this._buffer)] = System.Int64.clipu8(value.shr(56));
                this.OutStream.Write(this._buffer, 0, 8);
            },
            Write$17: function (value) {
                this._buffer[System.Array.index(0, this._buffer)] = System.Int64.clipu8(value);
                this._buffer[System.Array.index(1, this._buffer)] = System.Int64.clipu8(value.shru(8));
                this._buffer[System.Array.index(2, this._buffer)] = System.Int64.clipu8(value.shru(16));
                this._buffer[System.Array.index(3, this._buffer)] = System.Int64.clipu8(value.shru(24));
                this._buffer[System.Array.index(4, this._buffer)] = System.Int64.clipu8(value.shru(32));
                this._buffer[System.Array.index(5, this._buffer)] = System.Int64.clipu8(value.shru(40));
                this._buffer[System.Array.index(6, this._buffer)] = System.Int64.clipu8(value.shru(48));
                this._buffer[System.Array.index(7, this._buffer)] = System.Int64.clipu8(value.shru(56));
                this.OutStream.Write(this._buffer, 0, 8);
            },
            Write$13: function (value) {
                var TmpValue = System.BitConverter.toUInt32(System.BitConverter.getBytes$6(value), 0);
                this._buffer[System.Array.index(0, this._buffer)] = TmpValue & 255;
                this._buffer[System.Array.index(1, this._buffer)] = (TmpValue >>> 8) & 255;
                this._buffer[System.Array.index(2, this._buffer)] = (TmpValue >>> 16) & 255;
                this._buffer[System.Array.index(3, this._buffer)] = (TmpValue >>> 24) & 255;
                this.OutStream.Write(this._buffer, 0, 4);
            },
            Write$14: function (value) {
                if (value == null) {
                    throw new System.ArgumentNullException.$ctor1("value");
                }

                var buffer = this._encoding.GetBytes$2(value);
                var len = buffer.length;
                this.Write7BitEncodedInt(len);
                this.OutStream.Write(buffer, 0, len);
            },
            Write7BitEncodedInt: function (value) {
                var v = value >>> 0;
                while (v >= 128) {
                    this.Write$1(((((v | 128) >>> 0)) & 255));
                    v = v >>> 7;
                }
                this.Write$1((v & 255));
            }
        }
    });

    // @source Stream.js

    Bridge.define("System.IO.Stream", {
        inherits: [System.IDisposable],
        statics: {
            fields: {
                Null: null,
                _DefaultCopyBufferSize: 0
            },
            ctors: {
                init: function () {
                    this.Null = new System.IO.Stream.NullStream();
                    this._DefaultCopyBufferSize = 81920;
                }
            },
            methods: {
                Synchronized: function (stream) {
                    if (stream == null) {
                        throw new System.ArgumentNullException.$ctor1("stream");
                    }

                    return stream;
                },
                BlockingEndRead: function (asyncResult) {

                    return System.IO.Stream.SynchronousAsyncResult.EndRead(asyncResult);
                },
                BlockingEndWrite: function (asyncResult) {
                    System.IO.Stream.SynchronousAsyncResult.EndWrite(asyncResult);
                }
            }
        },
        props: {
            CanTimeout: {
                get: function () {
                    return false;
                }
            },
            ReadTimeout: {
                get: function () {
                    throw new System.InvalidOperationException.ctor();
                },
                set: function (value) {
                    throw new System.InvalidOperationException.ctor();
                }
            },
            WriteTimeout: {
                get: function () {
                    throw new System.InvalidOperationException.ctor();
                },
                set: function (value) {
                    throw new System.InvalidOperationException.ctor();
                }
            }
        },
        alias: ["Dispose", "System$IDisposable$Dispose"],
        methods: {
            CopyTo: function (destination) {
                if (destination == null) {
                    throw new System.ArgumentNullException.$ctor1("destination");
                }
                if (!this.CanRead && !this.CanWrite) {
                    throw new System.Exception();
                }
                if (!destination.CanRead && !destination.CanWrite) {
                    throw new System.Exception("destination");
                }
                if (!this.CanRead) {
                    throw new System.NotSupportedException.ctor();
                }
                if (!destination.CanWrite) {
                    throw new System.NotSupportedException.ctor();
                }

                this.InternalCopyTo(destination, System.IO.Stream._DefaultCopyBufferSize);
            },
            CopyTo$1: function (destination, bufferSize) {
                if (destination == null) {
                    throw new System.ArgumentNullException.$ctor1("destination");
                }
                if (bufferSize <= 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("bufferSize");
                }
                if (!this.CanRead && !this.CanWrite) {
                    throw new System.Exception();
                }
                if (!destination.CanRead && !destination.CanWrite) {
                    throw new System.Exception("destination");
                }
                if (!this.CanRead) {
                    throw new System.NotSupportedException.ctor();
                }
                if (!destination.CanWrite) {
                    throw new System.NotSupportedException.ctor();
                }

                this.InternalCopyTo(destination, bufferSize);
            },
            InternalCopyTo: function (destination, bufferSize) {

                var buffer = System.Array.init(bufferSize, 0, System.Byte);
                var read;
                while (((read = this.Read(buffer, 0, buffer.length))) !== 0) {
                    destination.Write(buffer, 0, read);
                }
            },
            Close: function () {
                /* These are correct, but we'd have to fix PipeStream & NetworkStream very carefully.
                Contract.Ensures(CanRead == false);
                Contract.Ensures(CanWrite == false);
                Contract.Ensures(CanSeek == false);
                */

                this.Dispose$1(true);
            },
            Dispose: function () {
                /* These are correct, but we'd have to fix PipeStream & NetworkStream very carefully.
                Contract.Ensures(CanRead == false);
                Contract.Ensures(CanWrite == false);
                Contract.Ensures(CanSeek == false);
                */

                this.Close();
            },
            Dispose$1: function (disposing) { },
            BeginRead: function (buffer, offset, count, callback, state) {
                return this.BeginReadInternal(buffer, offset, count, callback, state, false);
            },
            BeginReadInternal: function (buffer, offset, count, callback, state, serializeAsynchronously) {
                if (!this.CanRead) {
                    System.IO.__Error.ReadNotSupported();
                }

                return this.BlockingBeginRead(buffer, offset, count, callback, state);
            },
            EndRead: function (asyncResult) {
                if (asyncResult == null) {
                    throw new System.ArgumentNullException.$ctor1("asyncResult");
                }

                return System.IO.Stream.BlockingEndRead(asyncResult);
            },
            BeginWrite: function (buffer, offset, count, callback, state) {
                return this.BeginWriteInternal(buffer, offset, count, callback, state, false);
            },
            BeginWriteInternal: function (buffer, offset, count, callback, state, serializeAsynchronously) {
                if (!this.CanWrite) {
                    System.IO.__Error.WriteNotSupported();
                }
                return this.BlockingBeginWrite(buffer, offset, count, callback, state);
            },
            EndWrite: function (asyncResult) {
                if (asyncResult == null) {
                    throw new System.ArgumentNullException.$ctor1("asyncResult");
                }

                System.IO.Stream.BlockingEndWrite(asyncResult);
            },
            ReadByte: function () {

                var oneByteArray = System.Array.init(1, 0, System.Byte);
                var r = this.Read(oneByteArray, 0, 1);
                if (r === 0) {
                    return -1;
                }
                return oneByteArray[System.Array.index(0, oneByteArray)];
            },
            WriteByte: function (value) {
                var oneByteArray = System.Array.init(1, 0, System.Byte);
                oneByteArray[System.Array.index(0, oneByteArray)] = value;
                this.Write(oneByteArray, 0, 1);
            },
            BlockingBeginRead: function (buffer, offset, count, callback, state) {

                var asyncResult;
                try {
                    var numRead = this.Read(buffer, offset, count);
                    asyncResult = new System.IO.Stream.SynchronousAsyncResult.$ctor1(numRead, state);
                } catch ($e1) {
                    $e1 = System.Exception.create($e1);
                    var ex;
                    if (Bridge.is($e1, System.IO.IOException)) {
                        ex = $e1;
                        asyncResult = new System.IO.Stream.SynchronousAsyncResult.ctor(ex, state, false);
                    } else {
                        throw $e1;
                    }
                }

                if (!Bridge.staticEquals(callback, null)) {
                    callback(asyncResult);
                }

                return asyncResult;
            },
            BlockingBeginWrite: function (buffer, offset, count, callback, state) {

                var asyncResult;
                try {
                    this.Write(buffer, offset, count);
                    asyncResult = new System.IO.Stream.SynchronousAsyncResult.$ctor2(state);
                } catch ($e1) {
                    $e1 = System.Exception.create($e1);
                    var ex;
                    if (Bridge.is($e1, System.IO.IOException)) {
                        ex = $e1;
                        asyncResult = new System.IO.Stream.SynchronousAsyncResult.ctor(ex, state, true);
                    } else {
                        throw $e1;
                    }
                }

                if (!Bridge.staticEquals(callback, null)) {
                    callback(asyncResult);
                }

                return asyncResult;
            }
        }
    });

    // @source BufferedStream.js

    Bridge.define("System.IO.BufferedStream", {
        inherits: [System.IO.Stream],
        statics: {
            fields: {
                _DefaultBufferSize: 0,
                MaxShadowBufferSize: 0
            },
            ctors: {
                init: function () {
                    this._DefaultBufferSize = 4096;
                    this.MaxShadowBufferSize = 81920;
                }
            }
        },
        fields: {
            _stream: null,
            _buffer: null,
            _bufferSize: 0,
            _readPos: 0,
            _readLen: 0,
            _writePos: 0
        },
        props: {
            UnderlyingStream: {
                get: function () {
                    return this._stream;
                }
            },
            BufferSize: {
                get: function () {
                    return this._bufferSize;
                }
            },
            CanRead: {
                get: function () {
                    return this._stream != null && this._stream.CanRead;
                }
            },
            CanWrite: {
                get: function () {
                    return this._stream != null && this._stream.CanWrite;
                }
            },
            CanSeek: {
                get: function () {
                    return this._stream != null && this._stream.CanSeek;
                }
            },
            Length: {
                get: function () {
                    this.EnsureNotClosed();

                    if (this._writePos > 0) {
                        this.FlushWrite();
                    }

                    return this._stream.Length;
                }
            },
            Position: {
                get: function () {
                    this.EnsureNotClosed();
                    this.EnsureCanSeek();

                    return this._stream.Position.add(System.Int64((((((this._readPos - this._readLen) | 0) + this._writePos) | 0))));
                },
                set: function (value) {
                    if (value.lt(System.Int64(0))) {
                        throw new System.ArgumentOutOfRangeException.$ctor1("value");
                    }

                    this.EnsureNotClosed();
                    this.EnsureCanSeek();

                    if (this._writePos > 0) {
                        this.FlushWrite();
                    }

                    this._readPos = 0;
                    this._readLen = 0;
                    this._stream.Seek(value, 0);
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.IO.Stream.ctor.call(this);
            },
            $ctor1: function (stream) {
                System.IO.BufferedStream.$ctor2.call(this, stream, System.IO.BufferedStream._DefaultBufferSize);
            },
            $ctor2: function (stream, bufferSize) {
                this.$initialize();
                System.IO.Stream.ctor.call(this);

                if (stream == null) {
                    throw new System.ArgumentNullException.$ctor1("stream");
                }

                if (bufferSize <= 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("bufferSize");
                }

                this._stream = stream;
                this._bufferSize = bufferSize;


                if (!this._stream.CanRead && !this._stream.CanWrite) {
                    System.IO.__Error.StreamIsClosed();
                }
            }
        },
        methods: {
            EnsureNotClosed: function () {

                if (this._stream == null) {
                    System.IO.__Error.StreamIsClosed();
                }
            },
            EnsureCanSeek: function () {


                if (!this._stream.CanSeek) {
                    System.IO.__Error.SeekNotSupported();
                }
            },
            EnsureCanRead: function () {


                if (!this._stream.CanRead) {
                    System.IO.__Error.ReadNotSupported();
                }
            },
            EnsureCanWrite: function () {


                if (!this._stream.CanWrite) {
                    System.IO.__Error.WriteNotSupported();
                }
            },
            EnsureShadowBufferAllocated: function () {


                if (this._buffer.length !== this._bufferSize || this._bufferSize >= System.IO.BufferedStream.MaxShadowBufferSize) {
                    return;
                }

                var shadowBuffer = System.Array.init(Math.min(((this._bufferSize + this._bufferSize) | 0), System.IO.BufferedStream.MaxShadowBufferSize), 0, System.Byte);
                System.Array.copy(this._buffer, 0, shadowBuffer, 0, this._writePos);
                this._buffer = shadowBuffer;
            },
            EnsureBufferAllocated: function () {


                if (this._buffer == null) {
                    this._buffer = System.Array.init(this._bufferSize, 0, System.Byte);
                }
            },
            Dispose$1: function (disposing) {

                try {
                    if (disposing && this._stream != null) {
                        try {
                            this.Flush();
                        } finally {
                            this._stream.Close();
                        }
                    }
                } finally {
                    this._stream = null;
                    this._buffer = null;

                    System.IO.Stream.prototype.Dispose$1.call(this, disposing);
                }
            },
            Flush: function () {

                this.EnsureNotClosed();

                if (this._writePos > 0) {

                    this.FlushWrite();
                    return;
                }

                if (this._readPos < this._readLen) {

                    if (!this._stream.CanSeek) {
                        return;
                    }

                    this.FlushRead();

                    if (this._stream.CanWrite || Bridge.is(this._stream, System.IO.BufferedStream)) {
                        this._stream.Flush();
                    }

                    return;
                }

                if (this._stream.CanWrite || Bridge.is(this._stream, System.IO.BufferedStream)) {
                    this._stream.Flush();
                }

                this._writePos = (this._readPos = (this._readLen = 0));
            },
            FlushRead: function () {


                if (((this._readPos - this._readLen) | 0) !== 0) {
                    this._stream.Seek(System.Int64(this._readPos - this._readLen), 1);
                }

                this._readPos = 0;
                this._readLen = 0;
            },
            ClearReadBufferBeforeWrite: function () {



                if (this._readPos === this._readLen) {

                    this._readPos = (this._readLen = 0);
                    return;
                }


                if (!this._stream.CanSeek) {
                    throw new System.NotSupportedException.ctor();
                }

                this.FlushRead();
            },
            FlushWrite: function () {


                this._stream.Write(this._buffer, 0, this._writePos);
                this._writePos = 0;
                this._stream.Flush();
            },
            ReadFromBuffer: function (array, offset, count) {

                var readBytes = (this._readLen - this._readPos) | 0;

                if (readBytes === 0) {
                    return 0;
                }


                if (readBytes > count) {
                    readBytes = count;
                }

                System.Array.copy(this._buffer, this._readPos, array, offset, readBytes);
                this._readPos = (this._readPos + readBytes) | 0;

                return readBytes;
            },
            ReadFromBuffer$1: function (array, offset, count, error) {

                try {

                    error.v = null;
                    return this.ReadFromBuffer(array, offset, count);

                } catch (ex) {
                    ex = System.Exception.create(ex);
                    error.v = ex;
                    return 0;
                }
            },
            Read: function (array, offset, count) {

                if (array == null) {
                    throw new System.ArgumentNullException.$ctor1("array");
                }
                if (offset < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("offset");
                }
                if (count < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("count");
                }
                if (((array.length - offset) | 0) < count) {
                    throw new System.ArgumentException.ctor();
                }

                this.EnsureNotClosed();
                this.EnsureCanRead();

                var bytesFromBuffer = this.ReadFromBuffer(array, offset, count);


                if (bytesFromBuffer === count) {
                    return bytesFromBuffer;
                }

                var alreadySatisfied = bytesFromBuffer;
                if (bytesFromBuffer > 0) {
                    count = (count - bytesFromBuffer) | 0;
                    offset = (offset + bytesFromBuffer) | 0;
                }

                this._readPos = (this._readLen = 0);

                if (this._writePos > 0) {
                    this.FlushWrite();
                }

                if (count >= this._bufferSize) {

                    return ((this._stream.Read(array, offset, count) + alreadySatisfied) | 0);
                }

                this.EnsureBufferAllocated();
                this._readLen = this._stream.Read(this._buffer, 0, this._bufferSize);

                bytesFromBuffer = this.ReadFromBuffer(array, offset, count);


                return ((bytesFromBuffer + alreadySatisfied) | 0);
            },
            ReadByte: function () {

                this.EnsureNotClosed();
                this.EnsureCanRead();

                if (this._readPos === this._readLen) {

                    if (this._writePos > 0) {
                        this.FlushWrite();
                    }

                    this.EnsureBufferAllocated();
                    this._readLen = this._stream.Read(this._buffer, 0, this._bufferSize);
                    this._readPos = 0;
                }

                if (this._readPos === this._readLen) {
                    return -1;
                }

                var b = this._buffer[System.Array.index(Bridge.identity(this._readPos, (this._readPos = (this._readPos + 1) | 0)), this._buffer)];
                return b;
            },
            WriteToBuffer: function (array, offset, count) {

                var bytesToWrite = Math.min(((this._bufferSize - this._writePos) | 0), count.v);

                if (bytesToWrite <= 0) {
                    return;
                }

                this.EnsureBufferAllocated();
                System.Array.copy(array, offset.v, this._buffer, this._writePos, bytesToWrite);

                this._writePos = (this._writePos + bytesToWrite) | 0;
                count.v = (count.v - bytesToWrite) | 0;
                offset.v = (offset.v + bytesToWrite) | 0;
            },
            WriteToBuffer$1: function (array, offset, count, error) {

                try {

                    error.v = null;
                    this.WriteToBuffer(array, offset, count);

                } catch (ex) {
                    ex = System.Exception.create(ex);
                    error.v = ex;
                }
            },
            Write: function (array, offset, count) {
                offset = {v:offset};
                count = {v:count};

                if (array == null) {
                    throw new System.ArgumentNullException.$ctor1("array");
                }
                if (offset.v < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("offset");
                }
                if (count.v < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("count");
                }
                if (((array.length - offset.v) | 0) < count.v) {
                    throw new System.ArgumentException.ctor();
                }

                this.EnsureNotClosed();
                this.EnsureCanWrite();

                if (this._writePos === 0) {
                    this.ClearReadBufferBeforeWrite();
                }



                var totalUserBytes;
                var useBuffer;
                totalUserBytes = Bridge.Int.check(this._writePos + count.v, System.Int32);
                useBuffer = (Bridge.Int.check(totalUserBytes + count.v, System.Int32) < (Bridge.Int.check(this._bufferSize + this._bufferSize, System.Int32)));

                if (useBuffer) {

                    this.WriteToBuffer(array, offset, count);

                    if (this._writePos < this._bufferSize) {

                        return;
                    }


                    this._stream.Write(this._buffer, 0, this._writePos);
                    this._writePos = 0;

                    this.WriteToBuffer(array, offset, count);


                } else {

                    if (this._writePos > 0) {


                        if (totalUserBytes <= (((this._bufferSize + this._bufferSize) | 0)) && totalUserBytes <= System.IO.BufferedStream.MaxShadowBufferSize) {

                            this.EnsureShadowBufferAllocated();
                            System.Array.copy(array, offset.v, this._buffer, this._writePos, count.v);
                            this._stream.Write(this._buffer, 0, totalUserBytes);
                            this._writePos = 0;
                            return;
                        }

                        this._stream.Write(this._buffer, 0, this._writePos);
                        this._writePos = 0;
                    }

                    this._stream.Write(array, offset.v, count.v);
                }
            },
            WriteByte: function (value) {

                this.EnsureNotClosed();

                if (this._writePos === 0) {

                    this.EnsureCanWrite();
                    this.ClearReadBufferBeforeWrite();
                    this.EnsureBufferAllocated();
                }

                if (this._writePos >= ((this._bufferSize - 1) | 0)) {
                    this.FlushWrite();
                }

                this._buffer[System.Array.index(Bridge.identity(this._writePos, (this._writePos = (this._writePos + 1) | 0)), this._buffer)] = value;

            },
            Seek: function (offset, origin) {

                this.EnsureNotClosed();
                this.EnsureCanSeek();

                if (this._writePos > 0) {

                    this.FlushWrite();
                    return this._stream.Seek(offset, origin);
                }


                if (((this._readLen - this._readPos) | 0) > 0 && origin === 1) {

                    offset = offset.sub(System.Int64((((this._readLen - this._readPos) | 0))));
                }

                var oldPos = this.Position;

                var newPos = this._stream.Seek(offset, origin);


                this._readPos = System.Int64.clip32(newPos.sub((oldPos.sub(System.Int64(this._readPos)))));

                if (0 <= this._readPos && this._readPos < this._readLen) {

                    this._stream.Seek(System.Int64(this._readLen - this._readPos), 1);

                } else {

                    this._readPos = (this._readLen = 0);
                }

                return newPos;
            },
            SetLength: function (value) {

                if (value.lt(System.Int64(0))) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("value");
                }

                this.EnsureNotClosed();
                this.EnsureCanSeek();
                this.EnsureCanWrite();

                this.Flush();
                this._stream.SetLength(value);
            }
        }
    });

    // @source IOException.js

    Bridge.define("System.IO.IOException", {
        inherits: [System.SystemException],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.SystemException.$ctor1.call(this, "I/O error occurred.");
                this.HResult = -2146232800;
            },
            $ctor1: function (message) {
                this.$initialize();
                System.SystemException.$ctor1.call(this, message);
                this.HResult = -2146232800;
            },
            $ctor3: function (message, hresult) {
                this.$initialize();
                System.SystemException.$ctor1.call(this, message);
                this.HResult = hresult;
            },
            $ctor2: function (message, innerException) {
                this.$initialize();
                System.SystemException.$ctor2.call(this, message, innerException);
                this.HResult = -2146232800;
            }
        }
    });

    // @source EndOfStreamException.js

    Bridge.define("System.IO.EndOfStreamException", {
        inherits: [System.IO.IOException],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.IO.IOException.$ctor1.call(this, "Arg_EndOfStreamException");
            },
            $ctor1: function (message) {
                this.$initialize();
                System.IO.IOException.$ctor1.call(this, message);
            },
            $ctor2: function (message, innerException) {
                this.$initialize();
                System.IO.IOException.$ctor2.call(this, message, innerException);
            }
        }
    });

    // @source File.js

    Bridge.define("System.IO.File", {
        statics: {
            methods: {
                OpenText: function (path) {
                    if (path == null) {
                        throw new System.ArgumentNullException.$ctor1("path");
                    }
                    return new System.IO.StreamReader.$ctor7(path);
                },
                OpenRead: function (path) {
                    return new System.IO.FileStream.$ctor1(path, 3);
                },
                ReadAllText: function (path) {
                    if (path == null) {
                        throw new System.ArgumentNullException.$ctor1("path");
                    }
                    if (path.length === 0) {
                        throw new System.ArgumentException.$ctor1("Argument_EmptyPath");
                    }

                    return System.IO.File.InternalReadAllText(path, System.Text.Encoding.UTF8, true);
                },
                ReadAllText$1: function (path, encoding) {
                    if (path == null) {
                        throw new System.ArgumentNullException.$ctor1("path");
                    }
                    if (encoding == null) {
                        throw new System.ArgumentNullException.$ctor1("encoding");
                    }
                    if (path.length === 0) {
                        throw new System.ArgumentException.$ctor1("Argument_EmptyPath");
                    }

                    return System.IO.File.InternalReadAllText(path, encoding, true);
                },
                InternalReadAllText: function (path, encoding, checkHost) {

                    var sr = new System.IO.StreamReader.$ctor12(path, encoding, true, System.IO.StreamReader.DefaultBufferSize, checkHost);
                    try {
                        return sr.ReadToEnd();
                    }
                    finally {
                        if (Bridge.hasValue(sr)) {
                            sr.System$IDisposable$Dispose();
                        }
                    }
                },
                ReadAllBytes: function (path) {
                    return System.IO.File.InternalReadAllBytes(path, true);
                },
                InternalReadAllBytes: function (path, checkHost) {
                    var bytes;
                    var fs = new System.IO.FileStream.$ctor1(path, 3);
                    try {
                        var index = 0;
                        var fileLength = fs.Length;
                        if (fileLength.gt(System.Int64(2147483647))) {
                            throw new System.IO.IOException.$ctor1("IO.IO_FileTooLong2GB");
                        }
                        var count = System.Int64.clip32(fileLength);
                        bytes = System.Array.init(count, 0, System.Byte);
                        while (count > 0) {
                            var n = fs.Read(bytes, index, count);
                            if (n === 0) {
                                System.IO.__Error.EndOfFile();
                            }
                            index = (index + n) | 0;
                            count = (count - n) | 0;
                        }
                    }
                    finally {
                        if (Bridge.hasValue(fs)) {
                            fs.System$IDisposable$Dispose();
                        }
                    }
                    return bytes;
                },
                ReadAllLines: function (path) {
                    if (path == null) {
                        throw new System.ArgumentNullException.$ctor1("path");
                    }
                    if (path.length === 0) {
                        throw new System.ArgumentException.$ctor1("Argument_EmptyPath");
                    }

                    return System.IO.File.InternalReadAllLines(path, System.Text.Encoding.UTF8);
                },
                ReadAllLines$1: function (path, encoding) {
                    if (path == null) {
                        throw new System.ArgumentNullException.$ctor1("path");
                    }
                    if (encoding == null) {
                        throw new System.ArgumentNullException.$ctor1("encoding");
                    }
                    if (path.length === 0) {
                        throw new System.ArgumentException.$ctor1("Argument_EmptyPath");
                    }

                    return System.IO.File.InternalReadAllLines(path, encoding);
                },
                InternalReadAllLines: function (path, encoding) {

                    var line;
                    var lines = new (System.Collections.Generic.List$1(System.String)).ctor();

                    var sr = new System.IO.StreamReader.$ctor9(path, encoding);
                    try {
                        while (((line = sr.ReadLine())) != null) {
                            lines.add(line);
                        }
                    }
                    finally {
                        if (Bridge.hasValue(sr)) {
                            sr.System$IDisposable$Dispose();
                        }
                    }

                    return lines.ToArray();
                },
                ReadLines: function (path) {
                    if (path == null) {
                        throw new System.ArgumentNullException.$ctor1("path");
                    }
                    if (path.length === 0) {
                        throw new System.ArgumentException.$ctor3("Argument_EmptyPath", "path");
                    }

                    return System.IO.ReadLinesIterator.CreateIterator(path, System.Text.Encoding.UTF8);
                },
                ReadLines$1: function (path, encoding) {
                    if (path == null) {
                        throw new System.ArgumentNullException.$ctor1("path");
                    }
                    if (encoding == null) {
                        throw new System.ArgumentNullException.$ctor1("encoding");
                    }
                    if (path.length === 0) {
                        throw new System.ArgumentException.$ctor3("Argument_EmptyPath", "path");
                    }

                    return System.IO.ReadLinesIterator.CreateIterator(path, encoding);
                }
            }
        }
    });

    // @source FileMode.js

    Bridge.define("System.IO.FileMode", {
        $kind: "enum",
        statics: {
            fields: {
                CreateNew: 1,
                Create: 2,
                Open: 3,
                OpenOrCreate: 4,
                Truncate: 5,
                Append: 6
            }
        }
    });

    // @source FileOptions.js

    Bridge.define("System.IO.FileOptions", {
        $kind: "enum",
        statics: {
            fields: {
                None: 0,
                WriteThrough: -2147483648,
                Asynchronous: 1073741824,
                RandomAccess: 268435456,
                DeleteOnClose: 67108864,
                SequentialScan: 134217728,
                Encrypted: 16384
            }
        },
        $flags: true
    });

    // @source FileShare.js

    Bridge.define("System.IO.FileShare", {
        $kind: "enum",
        statics: {
            fields: {
                None: 0,
                Read: 1,
                Write: 2,
                ReadWrite: 3,
                Delete: 4,
                Inheritable: 16
            }
        },
        $flags: true
    });

    // @source FileStream.js

    Bridge.define("System.IO.FileStream", {
        inherits: [System.IO.Stream],
        statics: {
            methods: {
                FromFile: function (file) {
                    var completer = new System.Threading.Tasks.TaskCompletionSource();
                    var fileReader = new FileReader();
                    fileReader.onload = function () {
                        completer.setResult(new System.IO.FileStream.ctor(fileReader.result, file.name));
                    };
                    fileReader.onerror = function (e) {
                        completer.setException(new System.SystemException.$ctor1(Bridge.unbox(e).target.error.As()));
                    };
                    fileReader.readAsArrayBuffer(file);

                    return completer.task;
                },
                ReadBytes: function (path) {
                    if (Bridge.isNode) {
                        var fs = require("fs");
                        return Bridge.cast(fs.readFileSync(path), ArrayBuffer);
                    } else {
                        var req = new XMLHttpRequest();
                        req.open("GET", path, false);
                        req.overrideMimeType("text/plain; charset=x-user-defined");
                        req.send(null);
                        if (req.status !== 200) {
                            throw new System.IO.IOException.$ctor1(System.String.concat("Status of request to " + (path || "") + " returned status: ", req.status));
                        }

                        var text = req.responseText;
                        var resultArray = new Uint8Array(text.length);
                        System.String.toCharArray(text, 0, text.length).forEach(function (v, index, array) {
                                var $t;
                                return ($t = (v & 255) & 255, resultArray[index] = $t, $t);
                            });
                        return resultArray.buffer;
                    }
                },
                ReadBytesAsync: function (path) {
                    var tcs = new System.Threading.Tasks.TaskCompletionSource();

                    if (Bridge.isNode) {
                        var fs = require("fs");
                        fs.readFile(path, function (err, data) {
                            if (err != null) {
                                throw new System.IO.IOException.ctor();
                            }

                            tcs.setResult(data);
                        });
                    } else {
                        var req = new XMLHttpRequest();
                        req.open("GET", path, true);
                        req.overrideMimeType("text/plain; charset=binary-data");
                        req.send(null);

                        req.onreadystatechange = function () {
                        if (req.readyState !== 4) {
                            return;
                        }

                        if (req.status !== 200) {
                            throw new System.IO.IOException.$ctor1(System.String.concat("Status of request to " + (path || "") + " returned status: ", req.status));
                        }

                        var text = req.responseText;
                        var resultArray = new Uint8Array(text.length);
                        System.String.toCharArray(text, 0, text.length).forEach(function (v, index, array) {
                                var $t;
                                return ($t = (v & 255) & 255, resultArray[index] = $t, $t);
                            });
                        tcs.setResult(resultArray.buffer);
                        };
                    }

                    return tcs.task;
                }
            }
        },
        fields: {
            name: null,
            _buffer: null
        },
        props: {
            CanRead: {
                get: function () {
                    return true;
                }
            },
            CanWrite: {
                get: function () {
                    return false;
                }
            },
            CanSeek: {
                get: function () {
                    return false;
                }
            },
            IsAsync: {
                get: function () {
                    return false;
                }
            },
            Name: {
                get: function () {
                    return this.name;
                }
            },
            Length: {
                get: function () {
                    return System.Int64(this.GetInternalBuffer().byteLength);
                }
            },
            Position: System.Int64(0)
        },
        ctors: {
            $ctor1: function (path, mode) {
                this.$initialize();
                System.IO.Stream.ctor.call(this);
                this.name = path;
            },
            ctor: function (buffer, name) {
                this.$initialize();
                System.IO.Stream.ctor.call(this);
                this._buffer = buffer;
                this.name = name;
            }
        },
        methods: {
            Flush: function () { },
            Seek: function (offset, origin) {
                throw new System.NotImplementedException.ctor();
            },
            SetLength: function (value) {
                throw new System.NotImplementedException.ctor();
            },
            Write: function (buffer, offset, count) {
                throw new System.NotImplementedException.ctor();
            },
            GetInternalBuffer: function () {
                if (this._buffer == null) {
                    this._buffer = System.IO.FileStream.ReadBytes(this.name);

                }

                return this._buffer;
            },
            EnsureBufferAsync: function () {
                var $step = 0,
                    $task1, 
                    $taskResult1, 
                    $jumpFromFinally, 
                    $tcs = new System.Threading.Tasks.TaskCompletionSource(), 
                    $returnValue, 
                    $async_e, 
                    $asyncBody = Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                $step = System.Array.min([0,1,2,3], $step);
                                switch ($step) {
                                    case 0: {
                                        if (this._buffer == null) {
                                            $step = 1;
                                            continue;
                                        } 
                                        $step = 3;
                                        continue;
                                    }
                                    case 1: {
                                        $task1 = System.IO.FileStream.ReadBytesAsync(this.name);
                                        $step = 2;
                                        $task1.continueWith($asyncBody);
                                        return;
                                    }
                                    case 2: {
                                        $taskResult1 = $task1.getAwaitedResult();
                                        this._buffer = $taskResult1;
                                        $step = 3;
                                        continue;
                                    }
                                    case 3: {
                                        $tcs.setResult(null);
                                        return;
                                    }
                                    default: {
                                        $tcs.setResult(null);
                                        return;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            $tcs.setException($async_e);
                        }
                    }, arguments);

                $asyncBody();
                return $tcs.task;
            },
            Read: function (buffer, offset, count) {
                if (buffer == null) {
                    throw new System.ArgumentNullException.$ctor1("buffer");
                }

                if (offset < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("offset");
                }

                if (count < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("count");
                }

                if ((((buffer.length - offset) | 0)) < count) {
                    throw new System.ArgumentException.ctor();
                }

                var num = this.Length.sub(this.Position);
                if (num.gt(System.Int64(count))) {
                    num = System.Int64(count);
                }

                if (num.lte(System.Int64(0))) {
                    return 0;
                }

                var byteBuffer = new Uint8Array(this.GetInternalBuffer());
                if (num.gt(System.Int64(8))) {
                    for (var n = 0; System.Int64(n).lt(num); n = (n + 1) | 0) {
                        buffer[System.Array.index(((n + offset) | 0), buffer)] = byteBuffer[this.Position.add(System.Int64(n))];
                    }
                } else {
                    var num1 = num;
                    while (true) {
                        var num2 = num1.sub(System.Int64(1));
                        num1 = num2;
                        if (num2.lt(System.Int64(0))) {
                            break;
                        }
                        buffer[System.Array.index(System.Int64.toNumber(System.Int64(offset).add(num1)), buffer)] = byteBuffer[this.Position.add(num1)];
                    }
                }
                this.Position = this.Position.add(num);
                return System.Int64.clip32(num);
            }
        }
    });

    // @source Iterator.js

    Bridge.define("System.IO.Iterator$1", function (TSource) { return {
        inherits: [System.Collections.Generic.IEnumerable$1(TSource),System.Collections.Generic.IEnumerator$1(TSource)],
        fields: {
            state: 0,
            current: Bridge.getDefaultValue(TSource)
        },
        props: {
            Current: {
                get: function () {
                    return this.current;
                }
            },
            System$Collections$IEnumerator$Current: {
                get: function () {
                    return this.Current;
                }
            }
        },
        alias: [
            "Current", ["System$Collections$Generic$IEnumerator$1$" + Bridge.getTypeAlias(TSource) + "$Current$1", "System$Collections$Generic$IEnumerator$1$Current$1"],
            "Dispose", "System$IDisposable$Dispose",
            "GetEnumerator", ["System$Collections$Generic$IEnumerable$1$" + Bridge.getTypeAlias(TSource) + "$GetEnumerator", "System$Collections$Generic$IEnumerable$1$GetEnumerator"]
        ],
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            Dispose: function () {
                this.Dispose$1(true);
            },
            Dispose$1: function (disposing) {
                this.current = Bridge.getDefaultValue(TSource);
                this.state = -1;
            },
            GetEnumerator: function () {
                if (this.state === 0) {
                    this.state = 1;
                    return this;
                }

                var duplicate = this.Clone();
                duplicate.state = 1;
                return duplicate;
            },
            System$Collections$IEnumerable$GetEnumerator: function () {
                return this.GetEnumerator();
            },
            System$Collections$IEnumerator$reset: function () {
                throw new System.NotSupportedException.ctor();
            }
        }
    }; });

    // @source MemoryStream.js

    Bridge.define("System.IO.MemoryStream", {
        inherits: [System.IO.Stream],
        statics: {
            fields: {
                MemStreamMaxLength: 0
            },
            ctors: {
                init: function () {
                    this.MemStreamMaxLength = 2147483647;
                }
            }
        },
        fields: {
            _buffer: null,
            _origin: 0,
            _position: 0,
            _length: 0,
            _capacity: 0,
            _expandable: false,
            _writable: false,
            _exposable: false,
            _isOpen: false
        },
        props: {
            CanRead: {
                get: function () {
                    return this._isOpen;
                }
            },
            CanSeek: {
                get: function () {
                    return this._isOpen;
                }
            },
            CanWrite: {
                get: function () {
                    return this._writable;
                }
            },
            Capacity: {
                get: function () {
                    if (!this._isOpen) {
                        System.IO.__Error.StreamIsClosed();
                    }
                    return ((this._capacity - this._origin) | 0);
                },
                set: function (value) {
                    if (System.Int64(value).lt(this.Length)) {
                        throw new System.ArgumentOutOfRangeException.$ctor4("value", "ArgumentOutOfRange_SmallCapacity");
                    }

                    if (!this._isOpen) {
                        System.IO.__Error.StreamIsClosed();
                    }
                    if (!this._expandable && (value !== this.Capacity)) {
                        System.IO.__Error.MemoryStreamNotExpandable();
                    }

                    if (this._expandable && value !== this._capacity) {
                        if (value > 0) {
                            var newBuffer = System.Array.init(value, 0, System.Byte);
                            if (this._length > 0) {
                                System.Array.copy(this._buffer, 0, newBuffer, 0, this._length);
                            }
                            this._buffer = newBuffer;
                        } else {
                            this._buffer = null;
                        }
                        this._capacity = value;
                    }
                }
            },
            Length: {
                get: function () {
                    if (!this._isOpen) {
                        System.IO.__Error.StreamIsClosed();
                    }
                    return System.Int64(this._length - this._origin);
                }
            },
            Position: {
                get: function () {
                    if (!this._isOpen) {
                        System.IO.__Error.StreamIsClosed();
                    }
                    return System.Int64(this._position - this._origin);
                },
                set: function (value) {
                    if (value.lt(System.Int64(0))) {
                        throw new System.ArgumentOutOfRangeException.$ctor4("value", "ArgumentOutOfRange_NeedNonNegNum");
                    }

                    if (!this._isOpen) {
                        System.IO.__Error.StreamIsClosed();
                    }

                    if (value.gt(System.Int64(System.IO.MemoryStream.MemStreamMaxLength))) {
                        throw new System.ArgumentOutOfRangeException.$ctor4("value", "ArgumentOutOfRange_StreamLength");
                    }
                    this._position = (this._origin + System.Int64.clip32(value)) | 0;
                }
            }
        },
        ctors: {
            ctor: function () {
                System.IO.MemoryStream.$ctor6.call(this, 0);
            },
            $ctor6: function (capacity) {
                this.$initialize();
                System.IO.Stream.ctor.call(this);
                if (capacity < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("capacity", "ArgumentOutOfRange_NegativeCapacity");
                }

                this._buffer = System.Array.init(capacity, 0, System.Byte);
                this._capacity = capacity;
                this._expandable = true;
                this._writable = true;
                this._exposable = true;
                this._origin = 0;
                this._isOpen = true;
            },
            $ctor1: function (buffer) {
                System.IO.MemoryStream.$ctor2.call(this, buffer, true);
            },
            $ctor2: function (buffer, writable) {
                this.$initialize();
                System.IO.Stream.ctor.call(this);
                if (buffer == null) {
                    throw new System.ArgumentNullException.$ctor3("buffer", "ArgumentNull_Buffer");
                }
                this._buffer = buffer;
                this._length = (this._capacity = buffer.length);
                this._writable = writable;
                this._exposable = false;
                this._origin = 0;
                this._isOpen = true;
            },
            $ctor3: function (buffer, index, count) {
                System.IO.MemoryStream.$ctor5.call(this, buffer, index, count, true, false);
            },
            $ctor4: function (buffer, index, count, writable) {
                System.IO.MemoryStream.$ctor5.call(this, buffer, index, count, writable, false);
            },
            $ctor5: function (buffer, index, count, writable, publiclyVisible) {
                this.$initialize();
                System.IO.Stream.ctor.call(this);
                if (buffer == null) {
                    throw new System.ArgumentNullException.$ctor3("buffer", "ArgumentNull_Buffer");
                }
                if (index < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("index", "ArgumentOutOfRange_NeedNonNegNum");
                }
                if (count < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("count", "ArgumentOutOfRange_NeedNonNegNum");
                }
                if (((buffer.length - index) | 0) < count) {
                    throw new System.ArgumentException.$ctor1("Argument_InvalidOffLen");
                }

                this._buffer = buffer;
                this._origin = (this._position = index);
                this._length = (this._capacity = (index + count) | 0);
                this._writable = writable;
                this._exposable = publiclyVisible;
                this._expandable = false;
                this._isOpen = true;
            }
        },
        methods: {
            EnsureWriteable: function () {
                if (!this.CanWrite) {
                    System.IO.__Error.WriteNotSupported();
                }
            },
            Dispose$1: function (disposing) {
                try {
                    if (disposing) {
                        this._isOpen = false;
                        this._writable = false;
                        this._expandable = false;
                    }
                } finally {
                    System.IO.Stream.prototype.Dispose$1.call(this, disposing);
                }
            },
            EnsureCapacity: function (value) {
                if (value < 0) {
                    throw new System.IO.IOException.$ctor1("IO.IO_StreamTooLong");
                }
                if (value > this._capacity) {
                    var newCapacity = value;
                    if (newCapacity < 256) {
                        newCapacity = 256;
                    }
                    if (newCapacity < Bridge.Int.mul(this._capacity, 2)) {
                        newCapacity = Bridge.Int.mul(this._capacity, 2);
                    }
                    if ((((Bridge.Int.mul(this._capacity, 2))) >>> 0) > 2147483591) {
                        newCapacity = value > 2147483591 ? value : 2147483591;
                    }

                    this.Capacity = newCapacity;
                    return true;
                }
                return false;
            },
            Flush: function () { },
            GetBuffer: function () {
                if (!this._exposable) {
                    throw new System.Exception("UnauthorizedAccess_MemStreamBuffer");
                }
                return this._buffer;
            },
            TryGetBuffer: function (buffer) {
                if (!this._exposable) {
                    buffer.v = Bridge.getDefaultValue(System.ArraySegment);
                    return false;
                }

                buffer.v = new System.ArraySegment(this._buffer, this._origin, (((this._length - this._origin) | 0)));
                return true;
            },
            InternalGetBuffer: function () {
                return this._buffer;
            },
            InternalGetPosition: function () {
                if (!this._isOpen) {
                    System.IO.__Error.StreamIsClosed();
                }
                return this._position;
            },
            InternalReadInt32: function () {
                if (!this._isOpen) {
                    System.IO.__Error.StreamIsClosed();
                }

                var pos = ((this._position = (this._position + 4) | 0));
                if (pos > this._length) {
                    this._position = this._length;
                    System.IO.__Error.EndOfFile();
                }
                return this._buffer[System.Array.index(((pos - 4) | 0), this._buffer)] | this._buffer[System.Array.index(((pos - 3) | 0), this._buffer)] << 8 | this._buffer[System.Array.index(((pos - 2) | 0), this._buffer)] << 16 | this._buffer[System.Array.index(((pos - 1) | 0), this._buffer)] << 24;
            },
            InternalEmulateRead: function (count) {
                if (!this._isOpen) {
                    System.IO.__Error.StreamIsClosed();
                }

                var n = (this._length - this._position) | 0;
                if (n > count) {
                    n = count;
                }
                if (n < 0) {
                    n = 0;
                }

                this._position = (this._position + n) | 0;
                return n;
            },
            Read: function (buffer, offset, count) {
                if (buffer == null) {
                    throw new System.ArgumentNullException.$ctor3("buffer", "ArgumentNull_Buffer");
                }
                if (offset < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("offset", "ArgumentOutOfRange_NeedNonNegNum");
                }
                if (count < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("count", "ArgumentOutOfRange_NeedNonNegNum");
                }
                if (((buffer.length - offset) | 0) < count) {
                    throw new System.ArgumentException.$ctor1("Argument_InvalidOffLen");
                }

                if (!this._isOpen) {
                    System.IO.__Error.StreamIsClosed();
                }

                var n = (this._length - this._position) | 0;
                if (n > count) {
                    n = count;
                }
                if (n <= 0) {
                    return 0;
                }


                if (n <= 8) {
                    var byteCount = n;
                    while (((byteCount = (byteCount - 1) | 0)) >= 0) {
                        buffer[System.Array.index(((offset + byteCount) | 0), buffer)] = this._buffer[System.Array.index(((this._position + byteCount) | 0), this._buffer)];
                    }
                } else {
                    System.Array.copy(this._buffer, this._position, buffer, offset, n);
                }
                this._position = (this._position + n) | 0;

                return n;
            },
            ReadByte: function () {
                if (!this._isOpen) {
                    System.IO.__Error.StreamIsClosed();
                }

                if (this._position >= this._length) {
                    return -1;
                }

                return this._buffer[System.Array.index(Bridge.identity(this._position, (this._position = (this._position + 1) | 0)), this._buffer)];
            },
            Seek: function (offset, loc) {
                if (!this._isOpen) {
                    System.IO.__Error.StreamIsClosed();
                }

                if (offset.gt(System.Int64(System.IO.MemoryStream.MemStreamMaxLength))) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("offset", "ArgumentOutOfRange_StreamLength");
                }
                switch (loc) {
                    case 0: 
                        {
                            var tempPosition = ((this._origin + System.Int64.clip32(offset)) | 0);
                            if (offset.lt(System.Int64(0)) || tempPosition < this._origin) {
                                throw new System.IO.IOException.$ctor1("IO.IO_SeekBeforeBegin");
                            }
                            this._position = tempPosition;
                            break;
                        }
                    case 1: 
                        {
                            var tempPosition1 = ((this._position + System.Int64.clip32(offset)) | 0);
                            if (System.Int64(this._position).add(offset).lt(System.Int64(this._origin)) || tempPosition1 < this._origin) {
                                throw new System.IO.IOException.$ctor1("IO.IO_SeekBeforeBegin");
                            }
                            this._position = tempPosition1;
                            break;
                        }
                    case 2: 
                        {
                            var tempPosition2 = ((this._length + System.Int64.clip32(offset)) | 0);
                            if (System.Int64(this._length).add(offset).lt(System.Int64(this._origin)) || tempPosition2 < this._origin) {
                                throw new System.IO.IOException.$ctor1("IO.IO_SeekBeforeBegin");
                            }
                            this._position = tempPosition2;
                            break;
                        }
                    default: 
                        throw new System.ArgumentException.$ctor1("Argument_InvalidSeekOrigin");
                }

                return System.Int64(this._position);
            },
            SetLength: function (value) {
                if (value.lt(System.Int64(0)) || value.gt(System.Int64(2147483647))) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("value", "ArgumentOutOfRange_StreamLength");
                }
                this.EnsureWriteable();

                if (value.gt(System.Int64((((2147483647 - this._origin) | 0))))) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("value", "ArgumentOutOfRange_StreamLength");
                }

                var newLength = (this._origin + System.Int64.clip32(value)) | 0;
                var allocatedNewArray = this.EnsureCapacity(newLength);
                if (!allocatedNewArray && newLength > this._length) {
                    System.Array.fill(this._buffer, 0, this._length, ((newLength - this._length) | 0));
                }
                this._length = newLength;
                if (this._position > newLength) {
                    this._position = newLength;
                }

            },
            ToArray: function () {
                var copy = System.Array.init(((this._length - this._origin) | 0), 0, System.Byte);
                System.Array.copy(this._buffer, this._origin, copy, 0, ((this._length - this._origin) | 0));
                return copy;
            },
            Write: function (buffer, offset, count) {
                if (buffer == null) {
                    throw new System.ArgumentNullException.$ctor3("buffer", "ArgumentNull_Buffer");
                }
                if (offset < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("offset", "ArgumentOutOfRange_NeedNonNegNum");
                }
                if (count < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("count", "ArgumentOutOfRange_NeedNonNegNum");
                }
                if (((buffer.length - offset) | 0) < count) {
                    throw new System.ArgumentException.$ctor1("Argument_InvalidOffLen");
                }

                if (!this._isOpen) {
                    System.IO.__Error.StreamIsClosed();
                }
                this.EnsureWriteable();

                var i = (this._position + count) | 0;
                if (i < 0) {
                    throw new System.IO.IOException.$ctor1("IO.IO_StreamTooLong");
                }

                if (i > this._length) {
                    var mustZero = this._position > this._length;
                    if (i > this._capacity) {
                        var allocatedNewArray = this.EnsureCapacity(i);
                        if (allocatedNewArray) {
                            mustZero = false;
                        }
                    }
                    if (mustZero) {
                        System.Array.fill(this._buffer, 0, this._length, ((i - this._length) | 0));
                    }
                    this._length = i;
                }
                if ((count <= 8) && (!Bridge.referenceEquals(buffer, this._buffer))) {
                    var byteCount = count;
                    while (((byteCount = (byteCount - 1) | 0)) >= 0) {
                        this._buffer[System.Array.index(((this._position + byteCount) | 0), this._buffer)] = buffer[System.Array.index(((offset + byteCount) | 0), buffer)];
                    }
                } else {
                    System.Array.copy(buffer, offset, this._buffer, this._position, count);
                }
                this._position = i;

            },
            WriteByte: function (value) {
                if (!this._isOpen) {
                    System.IO.__Error.StreamIsClosed();
                }
                this.EnsureWriteable();

                if (this._position >= this._length) {
                    var newLength = (this._position + 1) | 0;
                    var mustZero = this._position > this._length;
                    if (newLength >= this._capacity) {
                        var allocatedNewArray = this.EnsureCapacity(newLength);
                        if (allocatedNewArray) {
                            mustZero = false;
                        }
                    }
                    if (mustZero) {
                        System.Array.fill(this._buffer, 0, this._length, ((this._position - this._length) | 0));
                    }
                    this._length = newLength;
                }
                this._buffer[System.Array.index(Bridge.identity(this._position, (this._position = (this._position + 1) | 0)), this._buffer)] = value;

            },
            WriteTo: function (stream) {
                if (stream == null) {
                    throw new System.ArgumentNullException.$ctor3("stream", "ArgumentNull_Stream");
                }

                if (!this._isOpen) {
                    System.IO.__Error.StreamIsClosed();
                }
                stream.Write(this._buffer, this._origin, ((this._length - this._origin) | 0));
            }
        }
    });

    // @source ReadLinesIterator.js

    Bridge.define("System.IO.ReadLinesIterator", {
        inherits: [System.IO.Iterator$1(System.String)],
        statics: {
            methods: {
                CreateIterator: function (path, encoding) {
                    return System.IO.ReadLinesIterator.CreateIterator$1(path, encoding, null);
                },
                CreateIterator$1: function (path, encoding, reader) {
                    return new System.IO.ReadLinesIterator(path, encoding, reader || new System.IO.StreamReader.$ctor9(path, encoding));
                }
            }
        },
        fields: {
            _path: null,
            _encoding: null,
            _reader: null
        },
        alias: ["moveNext", "System$Collections$IEnumerator$moveNext"],
        ctors: {
            ctor: function (path, encoding, reader) {
                this.$initialize();
                System.IO.Iterator$1(System.String).ctor.call(this);

                this._path = path;
                this._encoding = encoding;
                this._reader = reader;
            }
        },
        methods: {
            moveNext: function () {
                if (this._reader != null) {
                    this.current = this._reader.ReadLine();
                    if (this.current != null) {
                        return true;
                    }

                    this.Dispose();
                }

                return false;
            },
            Clone: function () {
                return System.IO.ReadLinesIterator.CreateIterator$1(this._path, this._encoding, this._reader);
            },
            Dispose$1: function (disposing) {
                try {
                    if (disposing) {
                        if (this._reader != null) {
                            this._reader.Dispose();
                        }
                    }
                } finally {
                    this._reader = null;
                    System.IO.Iterator$1(System.String).prototype.Dispose$1.call(this, disposing);
                }
            }
        }
    });

    // @source SeekOrigin.js

    Bridge.define("System.IO.SeekOrigin", {
        $kind: "enum",
        statics: {
            fields: {
                Begin: 0,
                Current: 1,
                End: 2
            }
        }
    });

    // @source NullStream.js

    Bridge.define("System.IO.Stream.NullStream", {
        inherits: [System.IO.Stream],
        $kind: "nested class",
        props: {
            CanRead: {
                get: function () {
                    return true;
                }
            },
            CanWrite: {
                get: function () {
                    return true;
                }
            },
            CanSeek: {
                get: function () {
                    return true;
                }
            },
            Length: {
                get: function () {
                    return System.Int64(0);
                }
            },
            Position: {
                get: function () {
                    return System.Int64(0);
                },
                set: function (value) { }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.IO.Stream.ctor.call(this);
            }
        },
        methods: {
            Dispose$1: function (disposing) { },
            Flush: function () { },
            BeginRead: function (buffer, offset, count, callback, state) {
                if (!this.CanRead) {
                    System.IO.__Error.ReadNotSupported();
                }

                return this.BlockingBeginRead(buffer, offset, count, callback, state);
            },
            EndRead: function (asyncResult) {
                if (asyncResult == null) {
                    throw new System.ArgumentNullException.$ctor1("asyncResult");
                }

                return System.IO.Stream.BlockingEndRead(asyncResult);
            },
            BeginWrite: function (buffer, offset, count, callback, state) {
                if (!this.CanWrite) {
                    System.IO.__Error.WriteNotSupported();
                }

                return this.BlockingBeginWrite(buffer, offset, count, callback, state);
            },
            EndWrite: function (asyncResult) {
                if (asyncResult == null) {
                    throw new System.ArgumentNullException.$ctor1("asyncResult");
                }

                System.IO.Stream.BlockingEndWrite(asyncResult);
            },
            Read: function (buffer, offset, count) {
                return 0;
            },
            ReadByte: function () {
                return -1;
            },
            Write: function (buffer, offset, count) { },
            WriteByte: function (value) { },
            Seek: function (offset, origin) {
                return System.Int64(0);
            },
            SetLength: function (length) { }
        }
    });

    // @source SynchronousAsyncResult.js

    Bridge.define("System.IO.Stream.SynchronousAsyncResult", {
        inherits: [System.IAsyncResult],
        $kind: "nested class",
        statics: {
            methods: {
                EndRead: function (asyncResult) {

                    var ar = Bridge.as(asyncResult, System.IO.Stream.SynchronousAsyncResult);
                    if (ar == null || ar._isWrite) {
                        System.IO.__Error.WrongAsyncResult();
                    }

                    if (ar._endXxxCalled) {
                        System.IO.__Error.EndReadCalledTwice();
                    }

                    ar._endXxxCalled = true;

                    ar.ThrowIfError();
                    return ar._bytesRead;
                },
                EndWrite: function (asyncResult) {

                    var ar = Bridge.as(asyncResult, System.IO.Stream.SynchronousAsyncResult);
                    if (ar == null || !ar._isWrite) {
                        System.IO.__Error.WrongAsyncResult();
                    }

                    if (ar._endXxxCalled) {
                        System.IO.__Error.EndWriteCalledTwice();
                    }

                    ar._endXxxCalled = true;

                    ar.ThrowIfError();
                }
            }
        },
        fields: {
            _stateObject: null,
            _isWrite: false,
            _exceptionInfo: null,
            _endXxxCalled: false,
            _bytesRead: 0
        },
        props: {
            IsCompleted: {
                get: function () {
                    return true;
                }
            },
            AsyncState: {
                get: function () {
                    return this._stateObject;
                }
            },
            CompletedSynchronously: {
                get: function () {
                    return true;
                }
            }
        },
        alias: [
            "IsCompleted", "System$IAsyncResult$IsCompleted",
            "AsyncState", "System$IAsyncResult$AsyncState",
            "CompletedSynchronously", "System$IAsyncResult$CompletedSynchronously"
        ],
        ctors: {
            $ctor1: function (bytesRead, asyncStateObject) {
                this.$initialize();
                this._bytesRead = bytesRead;
                this._stateObject = asyncStateObject;
            },
            $ctor2: function (asyncStateObject) {
                this.$initialize();
                this._stateObject = asyncStateObject;
                this._isWrite = true;
            },
            ctor: function (ex, asyncStateObject, isWrite) {
                this.$initialize();
                this._exceptionInfo = ex;
                this._stateObject = asyncStateObject;
                this._isWrite = isWrite;
            }
        },
        methods: {
            ThrowIfError: function () {
                if (this._exceptionInfo != null) {
                    throw this._exceptionInfo;
                }
            }
        }
    });

    // @source TextReader.js

    Bridge.define("System.IO.TextReader", {
        inherits: [System.IDisposable],
        statics: {
            fields: {
                Null: null
            },
            ctors: {
                init: function () {
                    this.Null = new System.IO.TextReader.NullTextReader();
                }
            },
            methods: {
                Synchronized: function (reader) {
                    if (reader == null) {
                        throw new System.ArgumentNullException.$ctor1("reader");
                    }

                    return reader;
                }
            }
        },
        alias: ["Dispose", "System$IDisposable$Dispose"],
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            Close: function () {
                this.Dispose$1(true);
            },
            Dispose: function () {
                this.Dispose$1(true);
            },
            Dispose$1: function (disposing) { },
            Peek: function () {

                return -1;
            },
            Read: function () {
                return -1;
            },
            Read$1: function (buffer, index, count) {
                if (buffer == null) {
                    throw new System.ArgumentNullException.$ctor1("buffer");
                }
                if (index < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("index");
                }
                if (count < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("count");
                }
                if (((buffer.length - index) | 0) < count) {
                    throw new System.ArgumentException.ctor();
                }

                var n = 0;
                do {
                    var ch = this.Read();
                    if (ch === -1) {
                        break;
                    }
                    buffer[System.Array.index(((index + Bridge.identity(n, (n = (n + 1) | 0))) | 0), buffer)] = ch & 65535;
                } while (n < count);
                return n;
            },
            ReadToEndAsync: function () {
                return System.Threading.Tasks.Task.fromResult(this.ReadToEnd(), System.String);
            },
            ReadToEnd: function () {

                var chars = System.Array.init(4096, 0, System.Char);
                var len;
                var sb = new System.Text.StringBuilder("", 4096);
                while (((len = this.Read$1(chars, 0, chars.length))) !== 0) {
                    sb.append(System.String.fromCharArray(chars, 0, len));
                }
                return sb.toString();
            },
            ReadBlock: function (buffer, index, count) {

                var i, n = 0;
                do {
                    n = (n + ((i = this.Read$1(buffer, ((index + n) | 0), ((count - n) | 0))))) | 0;
                } while (i > 0 && n < count);
                return n;
            },
            ReadLine: function () {
                var sb = new System.Text.StringBuilder();
                while (true) {
                    var ch = this.Read();
                    if (ch === -1) {
                        break;
                    }
                    if (ch === 13 || ch === 10) {
                        if (ch === 13 && this.Peek() === 10) {
                            this.Read();
                        }
                        return sb.toString();
                    }
                    sb.append(String.fromCharCode((ch & 65535)));
                }
                if (sb.getLength() > 0) {
                    return sb.toString();
                }
                return null;
            }
        }
    });

    // @source StreamReader.js

    Bridge.define("System.IO.StreamReader", {
        inherits: [System.IO.TextReader],
        statics: {
            fields: {
                Null: null,
                DefaultFileStreamBufferSize: 0,
                MinBufferSize: 0
            },
            props: {
                DefaultBufferSize: {
                    get: function () {
                        return 1024;
                    }
                }
            },
            ctors: {
                init: function () {
                    this.Null = new System.IO.StreamReader.NullStreamReader();
                    this.DefaultFileStreamBufferSize = 4096;
                    this.MinBufferSize = 128;
                }
            }
        },
        fields: {
            stream: null,
            encoding: null,
            byteBuffer: null,
            charBuffer: null,
            charPos: 0,
            charLen: 0,
            byteLen: 0,
            bytePos: 0,
            _maxCharsPerBuffer: 0,
            _detectEncoding: false,
            _isBlocked: false,
            _closable: false
        },
        props: {
            CurrentEncoding: {
                get: function () {
                    return this.encoding;
                }
            },
            BaseStream: {
                get: function () {
                    return this.stream;
                }
            },
            LeaveOpen: {
                get: function () {
                    return !this._closable;
                }
            },
            EndOfStream: {
                get: function () {
                    if (this.stream == null) {
                        System.IO.__Error.ReaderClosed();
                    }


                    if (this.charPos < this.charLen) {
                        return false;
                    }

                    var numRead = this.ReadBuffer();
                    return numRead === 0;
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.IO.TextReader.ctor.call(this);
            },
            $ctor1: function (stream) {
                System.IO.StreamReader.$ctor2.call(this, stream, true);
            },
            $ctor2: function (stream, detectEncodingFromByteOrderMarks) {
                System.IO.StreamReader.$ctor6.call(this, stream, System.Text.Encoding.UTF8, detectEncodingFromByteOrderMarks, System.IO.StreamReader.DefaultBufferSize, false);
            },
            $ctor3: function (stream, encoding) {
                System.IO.StreamReader.$ctor6.call(this, stream, encoding, true, System.IO.StreamReader.DefaultBufferSize, false);
            },
            $ctor4: function (stream, encoding, detectEncodingFromByteOrderMarks) {
                System.IO.StreamReader.$ctor6.call(this, stream, encoding, detectEncodingFromByteOrderMarks, System.IO.StreamReader.DefaultBufferSize, false);
            },
            $ctor5: function (stream, encoding, detectEncodingFromByteOrderMarks, bufferSize) {
                System.IO.StreamReader.$ctor6.call(this, stream, encoding, detectEncodingFromByteOrderMarks, bufferSize, false);
            },
            $ctor6: function (stream, encoding, detectEncodingFromByteOrderMarks, bufferSize, leaveOpen) {
                this.$initialize();
                System.IO.TextReader.ctor.call(this);
                if (stream == null || encoding == null) {
                    throw new System.ArgumentNullException.$ctor1((stream == null ? "stream" : "encoding"));
                }
                if (!stream.CanRead) {
                    throw new System.ArgumentException.ctor();
                }
                if (bufferSize <= 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("bufferSize");
                }

                this.Init$1(stream, encoding, detectEncodingFromByteOrderMarks, bufferSize, leaveOpen);
            },
            $ctor7: function (path) {
                System.IO.StreamReader.$ctor8.call(this, path, true);
            },
            $ctor8: function (path, detectEncodingFromByteOrderMarks) {
                System.IO.StreamReader.$ctor11.call(this, path, System.Text.Encoding.UTF8, detectEncodingFromByteOrderMarks, System.IO.StreamReader.DefaultBufferSize);
            },
            $ctor9: function (path, encoding) {
                System.IO.StreamReader.$ctor11.call(this, path, encoding, true, System.IO.StreamReader.DefaultBufferSize);
            },
            $ctor10: function (path, encoding, detectEncodingFromByteOrderMarks) {
                System.IO.StreamReader.$ctor11.call(this, path, encoding, detectEncodingFromByteOrderMarks, System.IO.StreamReader.DefaultBufferSize);
            },
            $ctor11: function (path, encoding, detectEncodingFromByteOrderMarks, bufferSize) {
                System.IO.StreamReader.$ctor12.call(this, path, encoding, detectEncodingFromByteOrderMarks, bufferSize, true);
            },
            $ctor12: function (path, encoding, detectEncodingFromByteOrderMarks, bufferSize, checkHost) {
                this.$initialize();
                System.IO.TextReader.ctor.call(this);
                if (path == null || encoding == null) {
                    throw new System.ArgumentNullException.$ctor1((path == null ? "path" : "encoding"));
                }
                if (path.length === 0) {
                    throw new System.ArgumentException.ctor();
                }
                if (bufferSize <= 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("bufferSize");
                }

                var stream = new System.IO.FileStream.$ctor1(path, 3);
                this.Init$1(stream, encoding, detectEncodingFromByteOrderMarks, bufferSize, false);
            }
        },
        methods: {
            Init$1: function (stream, encoding, detectEncodingFromByteOrderMarks, bufferSize, leaveOpen) {
                this.stream = stream;
                this.encoding = encoding;
                if (bufferSize < System.IO.StreamReader.MinBufferSize) {
                    bufferSize = System.IO.StreamReader.MinBufferSize;
                }
                this.byteBuffer = System.Array.init(bufferSize, 0, System.Byte);
                this._maxCharsPerBuffer = encoding.GetMaxCharCount(bufferSize);
                this.charBuffer = System.Array.init(this._maxCharsPerBuffer, 0, System.Char);
                this.byteLen = 0;
                this.bytePos = 0;
                this._detectEncoding = detectEncodingFromByteOrderMarks;
                this._isBlocked = false;
                this._closable = !leaveOpen;
            },
            Init: function (stream) {
                this.stream = stream;
                this._closable = true;
            },
            Close: function () {
                this.Dispose$1(true);
            },
            Dispose$1: function (disposing) {
                try {
                    if (!this.LeaveOpen && disposing && (this.stream != null)) {
                        this.stream.Close();
                    }
                } finally {
                    if (!this.LeaveOpen && (this.stream != null)) {
                        this.stream = null;
                        this.encoding = null;
                        this.byteBuffer = null;
                        this.charBuffer = null;
                        this.charPos = 0;
                        this.charLen = 0;
                        System.IO.TextReader.prototype.Dispose$1.call(this, disposing);
                    }
                }
            },
            DiscardBufferedData: function () {

                this.byteLen = 0;
                this.charLen = 0;
                this.charPos = 0;
                this._isBlocked = false;
            },
            Peek: function () {
                if (this.stream == null) {
                    System.IO.__Error.ReaderClosed();
                }

                if (this.charPos === this.charLen) {
                    if (this._isBlocked || this.ReadBuffer() === 0) {
                        return -1;
                    }
                }
                return this.charBuffer[System.Array.index(this.charPos, this.charBuffer)];
            },
            Read: function () {
                if (this.stream == null) {
                    System.IO.__Error.ReaderClosed();
                }


                if (this.charPos === this.charLen) {
                    if (this.ReadBuffer() === 0) {
                        return -1;
                    }
                }
                var result = this.charBuffer[System.Array.index(this.charPos, this.charBuffer)];
                this.charPos = (this.charPos + 1) | 0;
                return result;
            },
            Read$1: function (buffer, index, count) {
                if (buffer == null) {
                    throw new System.ArgumentNullException.$ctor1("buffer");
                }
                if (index < 0 || count < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1((index < 0 ? "index" : "count"));
                }
                if (((buffer.length - index) | 0) < count) {
                    throw new System.ArgumentException.ctor();
                }

                if (this.stream == null) {
                    System.IO.__Error.ReaderClosed();
                }


                var charsRead = 0;
                var readToUserBuffer = { v : false };
                while (count > 0) {
                    var n = (this.charLen - this.charPos) | 0;
                    if (n === 0) {
                        n = this.ReadBuffer$1(buffer, ((index + charsRead) | 0), count, readToUserBuffer);
                    }
                    if (n === 0) {
                        break;
                    }
                    if (n > count) {
                        n = count;
                    }
                    if (!readToUserBuffer.v) {
                        System.Array.copy(this.charBuffer, this.charPos, buffer, (((index + charsRead) | 0)), n);
                        this.charPos = (this.charPos + n) | 0;
                    }
                    charsRead = (charsRead + n) | 0;
                    count = (count - n) | 0;
                    if (this._isBlocked) {
                        break;
                    }
                }

                return charsRead;
            },
            ReadToEndAsync: function () {
                var $step = 0,
                    $task1, 
                    $task2, 
                    $taskResult2, 
                    $jumpFromFinally, 
                    $tcs = new System.Threading.Tasks.TaskCompletionSource(), 
                    $returnValue, 
                    $async_e, 
                    $asyncBody = Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                $step = System.Array.min([0,1,2,3,4], $step);
                                switch ($step) {
                                    case 0: {
                                        if (Bridge.is(this.stream, System.IO.FileStream)) {
                                            $step = 1;
                                            continue;
                                        } 
                                        $step = 3;
                                        continue;
                                    }
                                    case 1: {
                                        $task1 = this.stream.EnsureBufferAsync();
                                        $step = 2;
                                        $task1.continueWith($asyncBody);
                                        return;
                                    }
                                    case 2: {
                                        $task1.getAwaitedResult();
                                        $step = 3;
                                        continue;
                                    }
                                    case 3: {
                                        $task2 = System.IO.TextReader.prototype.ReadToEndAsync.call(this);
                                        $step = 4;
                                        $task2.continueWith($asyncBody);
                                        return;
                                    }
                                    case 4: {
                                        $taskResult2 = $task2.getAwaitedResult();
                                        $tcs.setResult($taskResult2);
                                        return;
                                    }
                                    default: {
                                        $tcs.setResult(null);
                                        return;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            $tcs.setException($async_e);
                        }
                    }, arguments);

                $asyncBody();
                return $tcs.task;
            },
            ReadToEnd: function () {
                if (this.stream == null) {
                    System.IO.__Error.ReaderClosed();
                }

                var sb = new System.Text.StringBuilder("", ((this.charLen - this.charPos) | 0));
                do {
                    sb.append(System.String.fromCharArray(this.charBuffer, this.charPos, ((this.charLen - this.charPos) | 0)));
                    this.charPos = this.charLen;
                    this.ReadBuffer();
                } while (this.charLen > 0);
                return sb.toString();
            },
            ReadBlock: function (buffer, index, count) {
                if (buffer == null) {
                    throw new System.ArgumentNullException.$ctor1("buffer");
                }
                if (index < 0 || count < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1((index < 0 ? "index" : "count"));
                }
                if (((buffer.length - index) | 0) < count) {
                    throw new System.ArgumentException.ctor();
                }

                if (this.stream == null) {
                    System.IO.__Error.ReaderClosed();
                }

                return System.IO.TextReader.prototype.ReadBlock.call(this, buffer, index, count);
            },
            CompressBuffer: function (n) {
                System.Array.copy(this.byteBuffer, n, this.byteBuffer, 0, ((this.byteLen - n) | 0));
                this.byteLen = (this.byteLen - n) | 0;
            },
            DetectEncoding: function () {
                if (this.byteLen < 2) {
                    return;
                }
                this._detectEncoding = false;
                var changedEncoding = false;
                if (this.byteBuffer[System.Array.index(0, this.byteBuffer)] === 254 && this.byteBuffer[System.Array.index(1, this.byteBuffer)] === 255) {

                    this.encoding = new System.Text.UnicodeEncoding.$ctor1(true, true);
                    this.CompressBuffer(2);
                    changedEncoding = true;
                } else if (this.byteBuffer[System.Array.index(0, this.byteBuffer)] === 255 && this.byteBuffer[System.Array.index(1, this.byteBuffer)] === 254) {
                    if (this.byteLen < 4 || this.byteBuffer[System.Array.index(2, this.byteBuffer)] !== 0 || this.byteBuffer[System.Array.index(3, this.byteBuffer)] !== 0) {
                        this.encoding = new System.Text.UnicodeEncoding.$ctor1(false, true);
                        this.CompressBuffer(2);
                        changedEncoding = true;
                    } else {
                        this.encoding = new System.Text.UTF32Encoding.$ctor1(false, true);
                        this.CompressBuffer(4);
                        changedEncoding = true;
                    }
                } else if (this.byteLen >= 3 && this.byteBuffer[System.Array.index(0, this.byteBuffer)] === 239 && this.byteBuffer[System.Array.index(1, this.byteBuffer)] === 187 && this.byteBuffer[System.Array.index(2, this.byteBuffer)] === 191) {
                    this.encoding = System.Text.Encoding.UTF8;
                    this.CompressBuffer(3);
                    changedEncoding = true;
                } else if (this.byteLen >= 4 && this.byteBuffer[System.Array.index(0, this.byteBuffer)] === 0 && this.byteBuffer[System.Array.index(1, this.byteBuffer)] === 0 && this.byteBuffer[System.Array.index(2, this.byteBuffer)] === 254 && this.byteBuffer[System.Array.index(3, this.byteBuffer)] === 255) {
                    this.encoding = new System.Text.UTF32Encoding.$ctor1(true, true);
                    this.CompressBuffer(4);
                    changedEncoding = true;
                } else if (this.byteLen === 2) {
                    this._detectEncoding = true;
                }

                if (changedEncoding) {
                    this._maxCharsPerBuffer = this.encoding.GetMaxCharCount(this.byteBuffer.length);
                    this.charBuffer = System.Array.init(this._maxCharsPerBuffer, 0, System.Char);
                }
            },
            IsPreamble: function () {
                return false;
            },
            ReadBuffer: function () {
                this.charLen = 0;
                this.charPos = 0;

                this.byteLen = 0;
                do {
                    this.byteLen = this.stream.Read(this.byteBuffer, 0, this.byteBuffer.length);

                    if (this.byteLen === 0) {
                        return this.charLen;
                    }

                    this._isBlocked = (this.byteLen < this.byteBuffer.length);

                    if (this.IsPreamble()) {
                        continue;
                    }

                    if (this._detectEncoding && this.byteLen >= 2) {
                        this.DetectEncoding();
                    }

                    this.charLen = (this.charLen + (this.encoding.GetChars$2(this.byteBuffer, 0, this.byteLen, this.charBuffer, this.charLen))) | 0;
                } while (this.charLen === 0);
                return this.charLen;
            },
            ReadBuffer$1: function (userBuffer, userOffset, desiredChars, readToUserBuffer) {
                this.charLen = 0;
                this.charPos = 0;

                this.byteLen = 0;

                var charsRead = 0;

                readToUserBuffer.v = desiredChars >= this._maxCharsPerBuffer;

                do {


                    this.byteLen = this.stream.Read(this.byteBuffer, 0, this.byteBuffer.length);


                    if (this.byteLen === 0) {
                        break;
                    }

                    this._isBlocked = (this.byteLen < this.byteBuffer.length);

                    if (this.IsPreamble()) {
                        continue;
                    }

                    if (this._detectEncoding && this.byteLen >= 2) {
                        this.DetectEncoding();
                        readToUserBuffer.v = desiredChars >= this._maxCharsPerBuffer;
                    }

                    this.charPos = 0;
                    if (readToUserBuffer.v) {
                        charsRead = (charsRead + (this.encoding.GetChars$2(this.byteBuffer, 0, this.byteLen, userBuffer, ((userOffset + charsRead) | 0)))) | 0;
                        this.charLen = 0;
                    } else {
                        charsRead = this.encoding.GetChars$2(this.byteBuffer, 0, this.byteLen, this.charBuffer, charsRead);
                        this.charLen = (this.charLen + charsRead) | 0;
                    }
                } while (charsRead === 0);

                this._isBlocked = !!(this._isBlocked & charsRead < desiredChars);

                return charsRead;
            },
            ReadLine: function () {
                if (this.stream == null) {
                    System.IO.__Error.ReaderClosed();
                }

                if (this.charPos === this.charLen) {
                    if (this.ReadBuffer() === 0) {
                        return null;
                    }
                }

                var sb = null;
                do {
                    var i = this.charPos;
                    do {
                        var ch = this.charBuffer[System.Array.index(i, this.charBuffer)];
                        if (ch === 13 || ch === 10) {
                            var s;
                            if (sb != null) {
                                sb.append(System.String.fromCharArray(this.charBuffer, this.charPos, ((i - this.charPos) | 0)));
                                s = sb.toString();
                            } else {
                                s = System.String.fromCharArray(this.charBuffer, this.charPos, ((i - this.charPos) | 0));
                            }
                            this.charPos = (i + 1) | 0;
                            if (ch === 13 && (this.charPos < this.charLen || this.ReadBuffer() > 0)) {
                                if (this.charBuffer[System.Array.index(this.charPos, this.charBuffer)] === 10) {
                                    this.charPos = (this.charPos + 1) | 0;
                                }
                            }
                            return s;
                        }
                        i = (i + 1) | 0;
                    } while (i < this.charLen);
                    i = (this.charLen - this.charPos) | 0;
                    if (sb == null) {
                        sb = new System.Text.StringBuilder("", ((i + 80) | 0));
                    }
                    sb.append(System.String.fromCharArray(this.charBuffer, this.charPos, i));
                } while (this.ReadBuffer() > 0);
                return sb.toString();
            }
        }
    });

    // @source NullStreamReader.js

    Bridge.define("System.IO.StreamReader.NullStreamReader", {
        inherits: [System.IO.StreamReader],
        $kind: "nested class",
        props: {
            BaseStream: {
                get: function () {
                    return System.IO.Stream.Null;
                }
            },
            CurrentEncoding: {
                get: function () {
                    return System.Text.Encoding.Unicode;
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.IO.StreamReader.ctor.call(this);
                this.Init(System.IO.Stream.Null);
            }
        },
        methods: {
            Dispose$1: function (disposing) { },
            Peek: function () {
                return -1;
            },
            Read: function () {
                return -1;
            },
            Read$1: function (buffer, index, count) {
                return 0;
            },
            ReadLine: function () {
                return null;
            },
            ReadToEnd: function () {
                return "";
            },
            ReadBuffer: function () {
                return 0;
            }
        }
    });

    // @source TextWriter.js

    Bridge.define("System.IO.TextWriter", {
        inherits: [System.IDisposable],
        statics: {
            fields: {
                Null: null,
                InitialNewLine: null
            },
            ctors: {
                init: function () {
                    this.Null = new System.IO.TextWriter.NullTextWriter();
                    this.InitialNewLine = "\r\n";
                }
            },
            methods: {
                Synchronized: function (writer) {
                    if (writer == null) {
                        throw new System.ArgumentNullException.$ctor1("writer");
                    }

                    return writer;
                }
            }
        },
        fields: {
            CoreNewLine: null,
            InternalFormatProvider: null
        },
        props: {
            FormatProvider: {
                get: function () {
                    if (this.InternalFormatProvider == null) {
                        return System.Globalization.CultureInfo.getCurrentCulture();
                    } else {
                        return this.InternalFormatProvider;
                    }
                }
            },
            NewLine: {
                get: function () {
                    return System.String.fromCharArray(this.CoreNewLine);
                },
                set: function (value) {
                    if (value == null) {
                        value = System.IO.TextWriter.InitialNewLine;
                    }
                    this.CoreNewLine = System.String.toCharArray(value, 0, value.length);
                }
            }
        },
        alias: ["Dispose", "System$IDisposable$Dispose"],
        ctors: {
            init: function () {
                this.CoreNewLine = System.Array.init([13, 10], System.Char);
            },
            ctor: function () {
                this.$initialize();
                this.InternalFormatProvider = null;
            },
            $ctor1: function (formatProvider) {
                this.$initialize();
                this.InternalFormatProvider = formatProvider;
            }
        },
        methods: {
            Close: function () {
                this.Dispose$1(true);
            },
            Dispose$1: function (disposing) { },
            Dispose: function () {
                this.Dispose$1(true);
            },
            Flush: function () { },
            Write$1: function (value) { },
            Write$2: function (buffer) {
                if (buffer != null) {
                    this.Write$3(buffer, 0, buffer.length);
                }
            },
            Write$3: function (buffer, index, count) {
                if (buffer == null) {
                    throw new System.ArgumentNullException.$ctor1("buffer");
                }
                if (index < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("index");
                }
                if (count < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("count");
                }
                if (((buffer.length - index) | 0) < count) {
                    throw new System.ArgumentException.ctor();
                }

                for (var i = 0; i < count; i = (i + 1) | 0) {
                    this.Write$1(buffer[System.Array.index(((index + i) | 0), buffer)]);
                }
            },
            Write: function (value) {
                this.Write$10(value ? System.Boolean.trueString : System.Boolean.falseString);
            },
            Write$6: function (value) {
                this.Write$10(System.Int32.format(value, "G", this.FormatProvider));
            },
            Write$15: function (value) {
                this.Write$10(System.UInt32.format(value, "G", this.FormatProvider));
            },
            Write$7: function (value) {
                this.Write$10(value.format("G", this.FormatProvider));
            },
            Write$16: function (value) {
                this.Write$10(value.format("G", this.FormatProvider));
            },
            Write$9: function (value) {
                this.Write$10(System.Single.format(value, "G", this.FormatProvider));
            },
            Write$5: function (value) {
                this.Write$10(System.Double.format(value, "G", this.FormatProvider));
            },
            Write$4: function (value) {
                this.Write$10(Bridge.Int.format(value, "G", this.FormatProvider));
            },
            Write$10: function (value) {
                if (value != null) {
                    this.Write$2(System.String.toCharArray(value, 0, value.length));
                }
            },
            Write$8: function (value) {
                if (value != null) {
                    var f = Bridge.as(value, System.IFormattable);
                    if (f != null) {
                        this.Write$10(Bridge.format(f, null, this.FormatProvider));
                    } else {
                        this.Write$10(Bridge.toString(value));
                    }
                }
            },
            Write$11: function (format, arg0) {
                this.Write$10(System.String.formatProvider(this.FormatProvider, format, [arg0]));
            },
            Write$12: function (format, arg0, arg1) {
                this.Write$10(System.String.formatProvider(this.FormatProvider, format, arg0, arg1));
            },
            Write$13: function (format, arg0, arg1, arg2) {
                this.Write$10(System.String.formatProvider(this.FormatProvider, format, arg0, arg1, arg2));
            },
            Write$14: function (format, arg) {
                if (arg === void 0) { arg = []; }
                this.Write$10(System.String.formatProvider.apply(System.String, [this.FormatProvider, format].concat(arg)));
            },
            WriteLine: function () {
                this.Write$2(this.CoreNewLine);
            },
            WriteLine$2: function (value) {
                this.Write$1(value);
                this.WriteLine();
            },
            WriteLine$3: function (buffer) {
                this.Write$2(buffer);
                this.WriteLine();
            },
            WriteLine$4: function (buffer, index, count) {
                this.Write$3(buffer, index, count);
                this.WriteLine();
            },
            WriteLine$1: function (value) {
                this.Write(value);
                this.WriteLine();
            },
            WriteLine$7: function (value) {
                this.Write$6(value);
                this.WriteLine();
            },
            WriteLine$16: function (value) {
                this.Write$15(value);
                this.WriteLine();
            },
            WriteLine$8: function (value) {
                this.Write$7(value);
                this.WriteLine();
            },
            WriteLine$17: function (value) {
                this.Write$16(value);
                this.WriteLine();
            },
            WriteLine$10: function (value) {
                this.Write$9(value);
                this.WriteLine();
            },
            WriteLine$6: function (value) {
                this.Write$5(value);
                this.WriteLine();
            },
            WriteLine$5: function (value) {
                this.Write$4(value);
                this.WriteLine();
            },
            WriteLine$11: function (value) {

                if (value == null) {
                    this.WriteLine();
                } else {
                    var vLen = value.length;
                    var nlLen = this.CoreNewLine.length;
                    var chars = System.Array.init(((vLen + nlLen) | 0), 0, System.Char);
                    System.String.copyTo(value, 0, chars, 0, vLen);
                    if (nlLen === 2) {
                        chars[System.Array.index(vLen, chars)] = this.CoreNewLine[System.Array.index(0, this.CoreNewLine)];
                        chars[System.Array.index(((vLen + 1) | 0), chars)] = this.CoreNewLine[System.Array.index(1, this.CoreNewLine)];
                    } else if (nlLen === 1) {
                        chars[System.Array.index(vLen, chars)] = this.CoreNewLine[System.Array.index(0, this.CoreNewLine)];
                    } else {
                        System.Array.copy(this.CoreNewLine, 0, chars, Bridge.Int.mul(vLen, 2), Bridge.Int.mul(nlLen, 2));
                    }
                    this.Write$3(chars, 0, ((vLen + nlLen) | 0));
                }
                /* 
                Write(value);  // We could call Write(String) on StreamWriter...
                WriteLine();
                */
            },
            WriteLine$9: function (value) {
                if (value == null) {
                    this.WriteLine();
                } else {
                    var f = Bridge.as(value, System.IFormattable);
                    if (f != null) {
                        this.WriteLine$11(Bridge.format(f, null, this.FormatProvider));
                    } else {
                        this.WriteLine$11(Bridge.toString(value));
                    }
                }
            },
            WriteLine$12: function (format, arg0) {
                this.WriteLine$11(System.String.formatProvider(this.FormatProvider, format, [arg0]));
            },
            WriteLine$13: function (format, arg0, arg1) {
                this.WriteLine$11(System.String.formatProvider(this.FormatProvider, format, arg0, arg1));
            },
            WriteLine$14: function (format, arg0, arg1, arg2) {
                this.WriteLine$11(System.String.formatProvider(this.FormatProvider, format, arg0, arg1, arg2));
            },
            WriteLine$15: function (format, arg) {
                if (arg === void 0) { arg = []; }
                this.WriteLine$11(System.String.formatProvider.apply(System.String, [this.FormatProvider, format].concat(arg)));
            }
        }
    });

    // @source StreamWriter.js

    Bridge.define("System.IO.StreamWriter", {
        inherits: [System.IO.TextWriter],
        statics: {
            fields: {
                DefaultBufferSize: 0,
                DefaultFileStreamBufferSize: 0,
                MinBufferSize: 0,
                Null: null,
                _UTF8NoBOM: null
            },
            props: {
                UTF8NoBOM: {
                    get: function () {
                        if (System.IO.StreamWriter._UTF8NoBOM == null) {
                            var noBOM = new System.Text.UTF8Encoding.$ctor2(false, true);
                            System.IO.StreamWriter._UTF8NoBOM = noBOM;
                        }
                        return System.IO.StreamWriter._UTF8NoBOM;
                    }
                }
            },
            ctors: {
                init: function () {
                    this.DefaultBufferSize = 1024;
                    this.DefaultFileStreamBufferSize = 4096;
                    this.MinBufferSize = 128;
                    this.Null = new System.IO.StreamWriter.$ctor4(System.IO.Stream.Null, new System.Text.UTF8Encoding.$ctor2(false, true), System.IO.StreamWriter.MinBufferSize, true);
                }
            }
        },
        fields: {
            stream: null,
            encoding: null,
            byteBuffer: null,
            charBuffer: null,
            charPos: 0,
            charLen: 0,
            autoFlush: false,
            haveWrittenPreamble: false,
            closable: false
        },
        props: {
            AutoFlush: {
                get: function () {
                    return this.autoFlush;
                },
                set: function (value) {
                    this.autoFlush = value;
                    if (value) {
                        this.Flush$1(true, false);
                    }
                }
            },
            BaseStream: {
                get: function () {
                    return this.stream;
                }
            },
            LeaveOpen: {
                get: function () {
                    return !this.closable;
                }
            },
            HaveWrittenPreamble: {
                set: function (value) {
                    this.haveWrittenPreamble = value;
                }
            },
            Encoding: {
                get: function () {
                    return this.encoding;
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.IO.TextWriter.$ctor1.call(this, null);
            },
            $ctor1: function (stream) {
                System.IO.StreamWriter.$ctor4.call(this, stream, System.IO.StreamWriter.UTF8NoBOM, System.IO.StreamWriter.DefaultBufferSize, false);
            },
            $ctor2: function (stream, encoding) {
                System.IO.StreamWriter.$ctor4.call(this, stream, encoding, System.IO.StreamWriter.DefaultBufferSize, false);
            },
            $ctor3: function (stream, encoding, bufferSize) {
                System.IO.StreamWriter.$ctor4.call(this, stream, encoding, bufferSize, false);
            },
            $ctor4: function (stream, encoding, bufferSize, leaveOpen) {
                this.$initialize();
                System.IO.TextWriter.$ctor1.call(this, null);
                if (stream == null || encoding == null) {
                    throw new System.ArgumentNullException.$ctor1((stream == null ? "stream" : "encoding"));
                }
                if (!stream.CanWrite) {
                    throw new System.ArgumentException.$ctor1("Argument_StreamNotWritable");
                }
                if (bufferSize <= 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("bufferSize", "ArgumentOutOfRange_NeedPosNum");
                }

                this.Init(stream, encoding, bufferSize, leaveOpen);
            },
            $ctor5: function (path) {
                System.IO.StreamWriter.$ctor8.call(this, path, false, System.IO.StreamWriter.UTF8NoBOM, System.IO.StreamWriter.DefaultBufferSize);
            },
            $ctor6: function (path, append) {
                System.IO.StreamWriter.$ctor8.call(this, path, append, System.IO.StreamWriter.UTF8NoBOM, System.IO.StreamWriter.DefaultBufferSize);
            },
            $ctor7: function (path, append, encoding) {
                System.IO.StreamWriter.$ctor8.call(this, path, append, encoding, System.IO.StreamWriter.DefaultBufferSize);
            },
            $ctor8: function (path, append, encoding, bufferSize) {
                System.IO.StreamWriter.$ctor9.call(this, path, append, encoding, bufferSize, true);
            },
            $ctor9: function (path, append, encoding, bufferSize, checkHost) {
                this.$initialize();
                System.IO.TextWriter.$ctor1.call(this, null);
                throw new System.NotSupportedException.ctor();
            }
        },
        methods: {
            Init: function (streamArg, encodingArg, bufferSize, shouldLeaveOpen) {
                this.stream = streamArg;
                this.encoding = encodingArg;
                if (bufferSize < System.IO.StreamWriter.MinBufferSize) {
                    bufferSize = System.IO.StreamWriter.MinBufferSize;
                }
                this.charBuffer = System.Array.init(bufferSize, 0, System.Char);
                this.byteBuffer = System.Array.init(this.encoding.GetMaxByteCount(bufferSize), 0, System.Byte);
                this.charLen = bufferSize;
                if (this.stream.CanSeek && this.stream.Position.gt(System.Int64(0))) {
                    this.haveWrittenPreamble = true;
                }
                this.closable = !shouldLeaveOpen;
            },
            Close: function () {
                this.Dispose$1(true);
            },
            Dispose$1: function (disposing) {
                try {
                    if (this.stream != null) {
                        if (disposing) {
                            this.Flush$1(true, true);
                        }
                    }
                } finally {
                    if (!this.LeaveOpen && this.stream != null) {
                        try {
                            if (disposing) {
                                this.stream.Close();
                            }
                        } finally {
                            this.stream = null;
                            this.byteBuffer = null;
                            this.charBuffer = null;
                            this.encoding = null;
                            this.charLen = 0;
                            System.IO.TextWriter.prototype.Dispose$1.call(this, disposing);
                        }
                    }
                }
            },
            Flush: function () {
                this.Flush$1(true, true);
            },
            Flush$1: function (flushStream, flushEncoder) {
                if (this.stream == null) {
                    System.IO.__Error.WriterClosed();
                }

                if (this.charPos === 0 && (!flushStream && !flushEncoder)) {
                    return;
                }

                /* if (!haveWrittenPreamble) {
                   haveWrittenPreamble = true;
                   byte[] preamble = encoding.GetPreamble();
                   if (preamble.Length > 0)
                       stream.Write(preamble, 0, preamble.Length);
                }*/

                var count = this.encoding.GetBytes$3(this.charBuffer, 0, this.charPos, this.byteBuffer, 0);
                this.charPos = 0;
                if (count > 0) {
                    this.stream.Write(this.byteBuffer, 0, count);
                }
                if (flushStream) {
                    this.stream.Flush();
                }
            },
            Write$1: function (value) {
                if (this.charPos === this.charLen) {
                    this.Flush$1(false, false);
                }
                this.charBuffer[System.Array.index(this.charPos, this.charBuffer)] = value;
                this.charPos = (this.charPos + 1) | 0;
                if (this.autoFlush) {
                    this.Flush$1(true, false);
                }
            },
            Write$2: function (buffer) {
                if (buffer == null) {
                    return;
                }

                var index = 0;
                var count = buffer.length;
                while (count > 0) {
                    if (this.charPos === this.charLen) {
                        this.Flush$1(false, false);
                    }
                    var n = (this.charLen - this.charPos) | 0;
                    if (n > count) {
                        n = count;
                    }
                    System.Array.copy(buffer, index, this.charBuffer, this.charPos, n);
                    this.charPos = (this.charPos + n) | 0;
                    index = (index + n) | 0;
                    count = (count - n) | 0;
                }
                if (this.autoFlush) {
                    this.Flush$1(true, false);
                }
            },
            Write$3: function (buffer, index, count) {
                if (buffer == null) {
                    throw new System.ArgumentNullException.$ctor3("buffer", "ArgumentNull_Buffer");
                }
                if (index < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("index", "ArgumentOutOfRange_NeedNonNegNum");
                }
                if (count < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("count", "ArgumentOutOfRange_NeedNonNegNum");
                }
                if (((buffer.length - index) | 0) < count) {
                    throw new System.ArgumentException.$ctor1("Argument_InvalidOffLen");
                }

                while (count > 0) {
                    if (this.charPos === this.charLen) {
                        this.Flush$1(false, false);
                    }
                    var n = (this.charLen - this.charPos) | 0;
                    if (n > count) {
                        n = count;
                    }
                    System.Array.copy(buffer, index, this.charBuffer, this.charPos, n);
                    this.charPos = (this.charPos + n) | 0;
                    index = (index + n) | 0;
                    count = (count - n) | 0;
                }
                if (this.autoFlush) {
                    this.Flush$1(true, false);
                }
            },
            Write$10: function (value) {
                if (value != null) {
                    var count = value.length;
                    var index = 0;
                    while (count > 0) {
                        if (this.charPos === this.charLen) {
                            this.Flush$1(false, false);
                        }
                        var n = (this.charLen - this.charPos) | 0;
                        if (n > count) {
                            n = count;
                        }
                        System.String.copyTo(value, index, this.charBuffer, this.charPos, n);
                        this.charPos = (this.charPos + n) | 0;
                        index = (index + n) | 0;
                        count = (count - n) | 0;
                    }
                    if (this.autoFlush) {
                        this.Flush$1(true, false);
                    }
                }
            }
        }
    });

    // @source StringReader.js

    Bridge.define("System.IO.StringReader", {
        inherits: [System.IO.TextReader],
        fields: {
            _s: null,
            _pos: 0,
            _length: 0
        },
        ctors: {
            ctor: function (s) {
                this.$initialize();
                System.IO.TextReader.ctor.call(this);
                if (s == null) {
                    throw new System.ArgumentNullException.$ctor1("s");
                }
                this._s = s;
                this._length = s == null ? 0 : s.length;
            }
        },
        methods: {
            Close: function () {
                this.Dispose$1(true);
            },
            Dispose$1: function (disposing) {
                this._s = null;
                this._pos = 0;
                this._length = 0;
                System.IO.TextReader.prototype.Dispose$1.call(this, disposing);
            },
            Peek: function () {
                if (this._s == null) {
                    System.IO.__Error.ReaderClosed();
                }
                if (this._pos === this._length) {
                    return -1;
                }
                return this._s.charCodeAt(this._pos);
            },
            Read: function () {
                if (this._s == null) {
                    System.IO.__Error.ReaderClosed();
                }
                if (this._pos === this._length) {
                    return -1;
                }
                return this._s.charCodeAt(Bridge.identity(this._pos, (this._pos = (this._pos + 1) | 0)));
            },
            Read$1: function (buffer, index, count) {
                if (buffer == null) {
                    throw new System.ArgumentNullException.$ctor1("buffer");
                }
                if (index < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("index");
                }
                if (count < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("count");
                }
                if (((buffer.length - index) | 0) < count) {
                    throw new System.ArgumentException.ctor();
                }
                if (this._s == null) {
                    System.IO.__Error.ReaderClosed();
                }

                var n = (this._length - this._pos) | 0;
                if (n > 0) {
                    if (n > count) {
                        n = count;
                    }
                    System.String.copyTo(this._s, this._pos, buffer, index, n);
                    this._pos = (this._pos + n) | 0;
                }
                return n;
            },
            ReadToEnd: function () {
                if (this._s == null) {
                    System.IO.__Error.ReaderClosed();
                }
                var s;
                if (this._pos === 0) {
                    s = this._s;
                } else {
                    s = this._s.substr(this._pos, ((this._length - this._pos) | 0));
                }
                this._pos = this._length;
                return s;
            },
            ReadLine: function () {
                if (this._s == null) {
                    System.IO.__Error.ReaderClosed();
                }
                var i = this._pos;
                while (i < this._length) {
                    var ch = this._s.charCodeAt(i);
                    if (ch === 13 || ch === 10) {
                        var result = this._s.substr(this._pos, ((i - this._pos) | 0));
                        this._pos = (i + 1) | 0;
                        if (ch === 13 && this._pos < this._length && this._s.charCodeAt(this._pos) === 10) {
                            this._pos = (this._pos + 1) | 0;
                        }
                        return result;
                    }
                    i = (i + 1) | 0;
                }
                if (i > this._pos) {
                    var result1 = this._s.substr(this._pos, ((i - this._pos) | 0));
                    this._pos = i;
                    return result1;
                }
                return null;
            }
        }
    });

    // @source StringWriter.js

    Bridge.define("System.IO.StringWriter", {
        inherits: [System.IO.TextWriter],
        statics: {
            fields: {
                m_encoding: null
            }
        },
        fields: {
            _sb: null,
            _isOpen: false
        },
        props: {
            Encoding: {
                get: function () {
                    if (System.IO.StringWriter.m_encoding == null) {
                        System.IO.StringWriter.m_encoding = new System.Text.UnicodeEncoding.$ctor1(false, false);
                    }
                    return System.IO.StringWriter.m_encoding;
                }
            }
        },
        ctors: {
            ctor: function () {
                System.IO.StringWriter.$ctor3.call(this, new System.Text.StringBuilder(), System.Globalization.CultureInfo.getCurrentCulture());
            },
            $ctor1: function (formatProvider) {
                System.IO.StringWriter.$ctor3.call(this, new System.Text.StringBuilder(), formatProvider);
            },
            $ctor2: function (sb) {
                System.IO.StringWriter.$ctor3.call(this, sb, System.Globalization.CultureInfo.getCurrentCulture());
            },
            $ctor3: function (sb, formatProvider) {
                this.$initialize();
                System.IO.TextWriter.$ctor1.call(this, formatProvider);
                if (sb == null) {
                    throw new System.ArgumentNullException.$ctor1("sb");
                }
                this._sb = sb;
                this._isOpen = true;
            }
        },
        methods: {
            Close: function () {
                this.Dispose$1(true);
            },
            Dispose$1: function (disposing) {
                this._isOpen = false;
                System.IO.TextWriter.prototype.Dispose$1.call(this, disposing);
            },
            GetStringBuilder: function () {
                return this._sb;
            },
            Write$1: function (value) {
                if (!this._isOpen) {
                    System.IO.__Error.WriterClosed();
                }
                this._sb.append(String.fromCharCode(value));
            },
            Write$3: function (buffer, index, count) {
                if (buffer == null) {
                    throw new System.ArgumentNullException.$ctor1("buffer");
                }
                if (index < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("index");
                }
                if (count < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("count");
                }
                if (((buffer.length - index) | 0) < count) {
                    throw new System.ArgumentException.ctor();
                }

                if (!this._isOpen) {
                    System.IO.__Error.WriterClosed();
                }

                this._sb.append(System.String.fromCharArray(buffer, index, count));
            },
            Write$10: function (value) {
                if (!this._isOpen) {
                    System.IO.__Error.WriterClosed();
                }
                if (value != null) {
                    this._sb.append(value);
                }
            },
            toString: function () {
                return this._sb.toString();
            }
        }
    });

    // @source NullTextReader.js

    Bridge.define("System.IO.TextReader.NullTextReader", {
        inherits: [System.IO.TextReader],
        $kind: "nested class",
        ctors: {
            ctor: function () {
                this.$initialize();
                System.IO.TextReader.ctor.call(this);
            }
        },
        methods: {
            Read$1: function (buffer, index, count) {
                return 0;
            },
            ReadLine: function () {
                return null;
            }
        }
    });

    // @source NullTextWriter.js

    Bridge.define("System.IO.TextWriter.NullTextWriter", {
        inherits: [System.IO.TextWriter],
        $kind: "nested class",
        props: {
            Encoding: {
                get: function () {
                    return System.Text.Encoding.Default;
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.IO.TextWriter.$ctor1.call(this, System.Globalization.CultureInfo.invariantCulture);
            }
        },
        methods: {
            Write$3: function (buffer, index, count) { },
            Write$10: function (value) { },
            WriteLine: function () { },
            WriteLine$11: function (value) { },
            WriteLine$9: function (value) { }
        }
    });

    // @source __Error.js

    Bridge.define("System.IO.__Error", {
        statics: {
            methods: {
                EndOfFile: function () {
                    throw new System.IO.EndOfStreamException.$ctor1("IO.EOF_ReadBeyondEOF");
                },
                FileNotOpen: function () {
                    throw new System.Exception("ObjectDisposed_FileClosed");
                },
                StreamIsClosed: function () {
                    throw new System.Exception("ObjectDisposed_StreamClosed");
                },
                MemoryStreamNotExpandable: function () {
                    throw new System.NotSupportedException.$ctor1("NotSupported_MemStreamNotExpandable");
                },
                ReaderClosed: function () {
                    throw new System.Exception("ObjectDisposed_ReaderClosed");
                },
                ReadNotSupported: function () {
                    throw new System.NotSupportedException.$ctor1("NotSupported_UnreadableStream");
                },
                SeekNotSupported: function () {
                    throw new System.NotSupportedException.$ctor1("NotSupported_UnseekableStream");
                },
                WrongAsyncResult: function () {
                    throw new System.ArgumentException.$ctor1("Arg_WrongAsyncResult");
                },
                EndReadCalledTwice: function () {
                    throw new System.ArgumentException.$ctor1("InvalidOperation_EndReadCalledMultiple");
                },
                EndWriteCalledTwice: function () {
                    throw new System.ArgumentException.$ctor1("InvalidOperation_EndWriteCalledMultiple");
                },
                WriteNotSupported: function () {
                    throw new System.NotSupportedException.$ctor1("NotSupported_UnwritableStream");
                },
                WriterClosed: function () {
                    throw new System.Exception("ObjectDisposed_WriterClosed");
                }
            }
        }
    });

    // @source AmbiguousMatchException.js

    Bridge.define("System.Reflection.AmbiguousMatchException", {
        inherits: [System.SystemException],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.SystemException.$ctor1.call(this, "Ambiguous match found.");
                this.HResult = -2147475171;
            },
            $ctor1: function (message) {
                this.$initialize();
                System.SystemException.$ctor1.call(this, message);
                this.HResult = -2147475171;
            },
            $ctor2: function (message, inner) {
                this.$initialize();
                System.SystemException.$ctor2.call(this, message, inner);
                this.HResult = -2147475171;
            }
        }
    });

    // @source Binder.js

    Bridge.define("System.Reflection.Binder", {
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        }
    });

    // @source BindingFlags.js

    Bridge.define("System.Reflection.BindingFlags", {
        $kind: "enum",
        statics: {
            fields: {
                Default: 0,
                IgnoreCase: 1,
                DeclaredOnly: 2,
                Instance: 4,
                Static: 8,
                Public: 16,
                NonPublic: 32,
                FlattenHierarchy: 64,
                InvokeMethod: 256,
                CreateInstance: 512,
                GetField: 1024,
                SetField: 2048,
                GetProperty: 4096,
                SetProperty: 8192,
                PutDispProperty: 16384,
                PutRefDispProperty: 32768,
                ExactBinding: 65536,
                SuppressChangeType: 131072,
                OptionalParamBinding: 262144,
                IgnoreReturn: 16777216,
                DoNotWrapExceptions: 33554432
            }
        },
        $flags: true
    });

    // @source CallingConventions.js

    Bridge.define("System.Reflection.CallingConventions", {
        $kind: "enum",
        statics: {
            fields: {
                Standard: 1,
                VarArgs: 2,
                Any: 3,
                HasThis: 32,
                ExplicitThis: 64
            }
        },
        $flags: true
    });

    // @source ICustomAttributeProvider.js

    Bridge.define("System.Reflection.ICustomAttributeProvider", {
        $kind: "interface"
    });

    // @source InvalidFilterCriteriaException.js

    Bridge.define("System.Reflection.InvalidFilterCriteriaException", {
        inherits: [System.ApplicationException],
        ctors: {
            ctor: function () {
                System.Reflection.InvalidFilterCriteriaException.$ctor1.call(this, "Specified filter criteria was invalid.");
            },
            $ctor1: function (message) {
                System.Reflection.InvalidFilterCriteriaException.$ctor2.call(this, message, null);
            },
            $ctor2: function (message, inner) {
                this.$initialize();
                System.ApplicationException.$ctor2.call(this, message, inner);
                this.HResult = -2146232831;
            }
        }
    });

    // @source IReflect.js

    Bridge.define("System.Reflection.IReflect", {
        $kind: "interface"
    });

    // @source MemberTypes.js

    Bridge.define("System.Reflection.MemberTypes", {
        $kind: "enum",
        statics: {
            fields: {
                Constructor: 1,
                Event: 2,
                Field: 4,
                Method: 8,
                Property: 16,
                TypeInfo: 32,
                Custom: 64,
                NestedType: 128,
                All: 191
            }
        },
        $flags: true
    });

    // @source Module.js

    Bridge.define("System.Reflection.Module", {
        inherits: [System.Reflection.ICustomAttributeProvider,System.Runtime.Serialization.ISerializable],
        statics: {
            fields: {
                FilterTypeName: null,
                FilterTypeNameIgnoreCase: null,
                DefaultLookup: 0
            },
            ctors: {
                init: function () {
                    this.FilterTypeName = System.Reflection.Module.FilterTypeNameImpl;
                    this.FilterTypeNameIgnoreCase = System.Reflection.Module.FilterTypeNameIgnoreCaseImpl;
                    this.DefaultLookup = 28;
                }
            },
            methods: {
                FilterTypeNameImpl: function (cls, filterCriteria) {
                    if (filterCriteria == null || !(Bridge.is(filterCriteria, System.String))) {
                        throw new System.Reflection.InvalidFilterCriteriaException.$ctor1("A String must be provided for the filter criteria.");
                    }

                    var str = Bridge.cast(filterCriteria, System.String);

                    if (str.length > 0 && str.charCodeAt(((str.length - 1) | 0)) === 42) {
                        str = str.substr(0, ((str.length - 1) | 0));
                        return System.String.startsWith(Bridge.Reflection.getTypeName(cls), str, 4);
                    }

                    return System.String.equals(Bridge.Reflection.getTypeName(cls), str);
                },
                FilterTypeNameIgnoreCaseImpl: function (cls, filterCriteria) {
                    var $t;
                    if (filterCriteria == null || !(Bridge.is(filterCriteria, System.String))) {
                        throw new System.Reflection.InvalidFilterCriteriaException.$ctor1("A String must be provided for the filter criteria.");
                    }

                    var str = Bridge.cast(filterCriteria, System.String);

                    if (str.length > 0 && str.charCodeAt(((str.length - 1) | 0)) === 42) {
                        str = str.substr(0, ((str.length - 1) | 0));
                        var name = Bridge.Reflection.getTypeName(cls);
                        if (name.length >= str.length) {
                            return (($t = str.length, System.String.compare(name.substr(0, $t), str.substr(0, $t), 5)) === 0);
                        } else {
                            return false;
                        }
                    }
                    return (System.String.compare(str, Bridge.Reflection.getTypeName(cls), 5) === 0);
                },
                op_Equality: function (left, right) {
                    if (Bridge.referenceEquals(left, right)) {
                        return true;
                    }

                    if (left == null || right == null) {
                        return false;
                    }

                    return left.equals(right);
                },
                op_Inequality: function (left, right) {
                    return !(System.Reflection.Module.op_Equality(left, right));
                }
            }
        },
        props: {
            Assembly: {
                get: function () {
                    throw System.NotImplemented.ByDesign;
                }
            },
            FullyQualifiedName: {
                get: function () {
                    throw System.NotImplemented.ByDesign;
                }
            },
            Name: {
                get: function () {
                    throw System.NotImplemented.ByDesign;
                }
            },
            MDStreamVersion: {
                get: function () {
                    throw System.NotImplemented.ByDesign;
                }
            },
            ModuleVersionId: {
                get: function () {
                    throw System.NotImplemented.ByDesign;
                }
            },
            ScopeName: {
                get: function () {
                    throw System.NotImplemented.ByDesign;
                }
            },
            MetadataToken: {
                get: function () {
                    throw System.NotImplemented.ByDesign;
                }
            }
        },
        alias: [
            "IsDefined", "System$Reflection$ICustomAttributeProvider$IsDefined",
            "GetCustomAttributes", "System$Reflection$ICustomAttributeProvider$GetCustomAttributes",
            "GetCustomAttributes$1", "System$Reflection$ICustomAttributeProvider$GetCustomAttributes$1"
        ],
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            IsResource: function () {
                throw System.NotImplemented.ByDesign;
            },
            IsDefined: function (attributeType, inherit) {
                throw System.NotImplemented.ByDesign;
            },
            GetCustomAttributes: function (inherit) {
                throw System.NotImplemented.ByDesign;
            },
            GetCustomAttributes$1: function (attributeType, inherit) {
                throw System.NotImplemented.ByDesign;
            },
            GetMethod: function (name) {
                if (name == null) {
                    throw new System.ArgumentNullException.$ctor1("name");
                }

                return this.GetMethodImpl(name, System.Reflection.Module.DefaultLookup, null, 3, null, null);
            },
            GetMethod$2: function (name, types) {
                return this.GetMethod$1(name, System.Reflection.Module.DefaultLookup, null, 3, types, null);
            },
            GetMethod$1: function (name, bindingAttr, binder, callConvention, types, modifiers) {
                if (name == null) {
                    throw new System.ArgumentNullException.$ctor1("name");
                }
                if (types == null) {
                    throw new System.ArgumentNullException.$ctor1("types");
                }
                for (var i = 0; i < types.length; i = (i + 1) | 0) {
                    if (types[System.Array.index(i, types)] == null) {
                        throw new System.ArgumentNullException.$ctor1("types");
                    }
                }
                return this.GetMethodImpl(name, bindingAttr, binder, callConvention, types, modifiers);
            },
            GetMethodImpl: function (name, bindingAttr, binder, callConvention, types, modifiers) {
                throw System.NotImplemented.ByDesign;
            },
            GetMethods: function () {
                return this.GetMethods$1(System.Reflection.Module.DefaultLookup);
            },
            GetMethods$1: function (bindingFlags) {
                throw System.NotImplemented.ByDesign;
            },
            GetField: function (name) {
                return this.GetField$1(name, System.Reflection.Module.DefaultLookup);
            },
            GetField$1: function (name, bindingAttr) {
                throw System.NotImplemented.ByDesign;
            },
            GetFields: function () {
                return this.GetFields$1(System.Reflection.Module.DefaultLookup);
            },
            GetFields$1: function (bindingFlags) {
                throw System.NotImplemented.ByDesign;
            },
            GetTypes: function () {
                throw System.NotImplemented.ByDesign;
            },
            GetType: function (className) {
                return this.GetType$2(className, false, false);
            },
            GetType$1: function (className, ignoreCase) {
                return this.GetType$2(className, false, ignoreCase);
            },
            GetType$2: function (className, throwOnError, ignoreCase) {
                throw System.NotImplemented.ByDesign;
            },
            FindTypes: function (filter, filterCriteria) {
                var c = this.GetTypes();
                var cnt = 0;
                for (var i = 0; i < c.length; i = (i + 1) | 0) {
                    if (!Bridge.staticEquals(filter, null) && !filter(c[System.Array.index(i, c)], filterCriteria)) {
                        c[System.Array.index(i, c)] = null;
                    } else {
                        cnt = (cnt + 1) | 0;
                    }
                }
                if (cnt === c.length) {
                    return c;
                }

                var ret = System.Array.init(cnt, null, Function);
                cnt = 0;
                for (var i1 = 0; i1 < c.length; i1 = (i1 + 1) | 0) {
                    if (c[System.Array.index(i1, c)] != null) {
                        ret[System.Array.index(Bridge.identity(cnt, (cnt = (cnt + 1) | 0)), ret)] = c[System.Array.index(i1, c)];
                    }
                }
                return ret;
            },
            ResolveField: function (metadataToken) {
                return this.ResolveField$1(metadataToken, null, null);
            },
            ResolveField$1: function (metadataToken, genericTypeArguments, genericMethodArguments) {
                throw System.NotImplemented.ByDesign;
            },
            ResolveMember: function (metadataToken) {
                return this.ResolveMember$1(metadataToken, null, null);
            },
            ResolveMember$1: function (metadataToken, genericTypeArguments, genericMethodArguments) {
                throw System.NotImplemented.ByDesign;
            },
            ResolveMethod: function (metadataToken) {
                return this.ResolveMethod$1(metadataToken, null, null);
            },
            ResolveMethod$1: function (metadataToken, genericTypeArguments, genericMethodArguments) {
                throw System.NotImplemented.ByDesign;
            },
            ResolveSignature: function (metadataToken) {
                throw System.NotImplemented.ByDesign;
            },
            ResolveString: function (metadataToken) {
                throw System.NotImplemented.ByDesign;
            },
            ResolveType: function (metadataToken) {
                return this.ResolveType$1(metadataToken, null, null);
            },
            ResolveType$1: function (metadataToken, genericTypeArguments, genericMethodArguments) {
                throw System.NotImplemented.ByDesign;
            },
            equals: function (o) {
                return Bridge.equals(this, o);
            },
            getHashCode: function () {
                return Bridge.getHashCode(this);
            },
            toString: function () {
                return this.ScopeName;
            }
        }
    });

    // @source ParameterModifier.js

    Bridge.define("System.Reflection.ParameterModifier", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new System.Reflection.ParameterModifier(); }
            }
        },
        fields: {
            _byRef: null
        },
        ctors: {
            $ctor1: function (parameterCount) {
                this.$initialize();
                if (parameterCount <= 0) {
                    throw new System.ArgumentException.$ctor1("Must specify one or more parameters.");
                }

                this._byRef = System.Array.init(parameterCount, false, System.Boolean);
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getItem: function (index) {
                return this._byRef[System.Array.index(index, this._byRef)];
            },
            setItem: function (index, value) {
                this._byRef[System.Array.index(index, this._byRef)] = value;
            },
            getHashCode: function () {
                var h = Bridge.addHash([6723435274, this._byRef]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, System.Reflection.ParameterModifier)) {
                    return false;
                }
                return Bridge.equals(this._byRef, o._byRef);
            },
            $clone: function (to) {
                var s = to || new System.Reflection.ParameterModifier();
                s._byRef = this._byRef;
                return s;
            }
        }
    });

    // @source TypeAttributes.js

    Bridge.define("System.Reflection.TypeAttributes", {
        $kind: "enum",
        statics: {
            fields: {
                VisibilityMask: 7,
                NotPublic: 0,
                Public: 1,
                NestedPublic: 2,
                NestedPrivate: 3,
                NestedFamily: 4,
                NestedAssembly: 5,
                NestedFamANDAssem: 6,
                NestedFamORAssem: 7,
                LayoutMask: 24,
                AutoLayout: 0,
                SequentialLayout: 8,
                ExplicitLayout: 16,
                ClassSemanticsMask: 32,
                Class: 0,
                Interface: 32,
                Abstract: 128,
                Sealed: 256,
                SpecialName: 1024,
                Import: 4096,
                Serializable: 8192,
                WindowsRuntime: 16384,
                StringFormatMask: 196608,
                AnsiClass: 0,
                UnicodeClass: 65536,
                AutoClass: 131072,
                CustomFormatClass: 196608,
                CustomFormatMask: 12582912,
                BeforeFieldInit: 1048576,
                RTSpecialName: 2048,
                HasSecurity: 262144,
                ReservedMask: 264192
            }
        },
        $flags: true
    });

    // @source Random.js

    Bridge.define("System.Random", {
        statics: {
            fields: {
                MBIG: 0,
                MSEED: 0,
                MZ: 0
            },
            ctors: {
                init: function () {
                    this.MBIG = 2147483647;
                    this.MSEED = 161803398;
                    this.MZ = 0;
                }
            }
        },
        fields: {
            inext: 0,
            inextp: 0,
            SeedArray: null
        },
        ctors: {
            init: function () {
                this.SeedArray = System.Array.init(56, 0, System.Int32);
            },
            ctor: function () {
                System.Random.$ctor1.call(this, System.Int64.clip32(System.DateTime.getTicks(System.DateTime.getNow())));
            },
            $ctor1: function (seed) {
                this.$initialize();
                var ii;
                var mj, mk;

                var subtraction = (seed === -2147483648) ? 2147483647 : Math.abs(seed);
                mj = (System.Random.MSEED - subtraction) | 0;
                this.SeedArray[System.Array.index(55, this.SeedArray)] = mj;
                mk = 1;
                for (var i = 1; i < 55; i = (i + 1) | 0) {
                    ii = (Bridge.Int.mul(21, i)) % 55;
                    this.SeedArray[System.Array.index(ii, this.SeedArray)] = mk;
                    mk = (mj - mk) | 0;
                    if (mk < 0) {
                        mk = (mk + System.Random.MBIG) | 0;
                    }
                    mj = this.SeedArray[System.Array.index(ii, this.SeedArray)];
                }
                for (var k = 1; k < 5; k = (k + 1) | 0) {
                    for (var i1 = 1; i1 < 56; i1 = (i1 + 1) | 0) {
                        this.SeedArray[System.Array.index(i1, this.SeedArray)] = (this.SeedArray[System.Array.index(i1, this.SeedArray)] - this.SeedArray[System.Array.index(((1 + (((i1 + 30) | 0)) % 55) | 0), this.SeedArray)]) | 0;
                        if (this.SeedArray[System.Array.index(i1, this.SeedArray)] < 0) {
                            this.SeedArray[System.Array.index(i1, this.SeedArray)] = (this.SeedArray[System.Array.index(i1, this.SeedArray)] + System.Random.MBIG) | 0;
                        }
                    }
                }
                this.inext = 0;
                this.inextp = 21;
                seed = 1;
            }
        },
        methods: {
            Sample: function () {
                return (this.InternalSample() * (4.6566128752457969E-10));
            },
            InternalSample: function () {
                var retVal;
                var locINext = this.inext;
                var locINextp = this.inextp;

                if (((locINext = (locINext + 1) | 0)) >= 56) {
                    locINext = 1;
                }

                if (((locINextp = (locINextp + 1) | 0)) >= 56) {
                    locINextp = 1;
                }

                retVal = (this.SeedArray[System.Array.index(locINext, this.SeedArray)] - this.SeedArray[System.Array.index(locINextp, this.SeedArray)]) | 0;

                if (retVal === System.Random.MBIG) {
                    retVal = (retVal - 1) | 0;
                }

                if (retVal < 0) {
                    retVal = (retVal + System.Random.MBIG) | 0;
                }

                this.SeedArray[System.Array.index(locINext, this.SeedArray)] = retVal;

                this.inext = locINext;
                this.inextp = locINextp;

                return retVal;
            },
            Next: function () {
                return this.InternalSample();
            },
            Next$2: function (minValue, maxValue) {
                if (minValue > maxValue) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("minValue", "'minValue' cannot be greater than maxValue.");
                }

                var range = System.Int64(maxValue).sub(System.Int64(minValue));
                if (range.lte(System.Int64(2147483647))) {
                    return (((Bridge.Int.clip32((this.Sample() * System.Int64.toNumber(range))) + minValue) | 0));
                } else {
                    return System.Int64.clip32(Bridge.Int.clip64((this.GetSampleForLargeRange() * System.Int64.toNumber(range))).add(System.Int64(minValue)));
                }
            },
            Next$1: function (maxValue) {
                if (maxValue < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("maxValue", "'maxValue' must be greater than zero.");
                }
                return Bridge.Int.clip32(this.Sample() * maxValue);
            },
            GetSampleForLargeRange: function () {

                var result = this.InternalSample();
                var negative = (this.InternalSample() % 2 === 0) ? true : false;
                if (negative) {
                    result = (-result) | 0;
                }
                var d = result;
                d += (2147483646);
                d /= 4294967293;
                return d;
            },
            NextDouble: function () {
                return this.Sample();
            },
            NextBytes: function (buffer) {
                if (buffer == null) {
                    throw new System.ArgumentNullException.$ctor1("buffer");
                }
                for (var i = 0; i < buffer.length; i = (i + 1) | 0) {
                    buffer[System.Array.index(i, buffer)] = (this.InternalSample() % (256)) & 255;
                }
            }
        }
    });

    // @source RankException.js

    Bridge.define("System.RankException", {
        inherits: [System.SystemException],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.SystemException.$ctor1.call(this, "Attempted to operate on an array with the incorrect number of dimensions.");
                this.HResult = -2146233065;
            },
            $ctor1: function (message) {
                this.$initialize();
                System.SystemException.$ctor1.call(this, message);
                this.HResult = -2146233065;
            },
            $ctor2: function (message, innerException) {
                this.$initialize();
                System.SystemException.$ctor2.call(this, message, innerException);
                this.HResult = -2146233065;
            }
        }
    });

    // @source SR.js

    Bridge.define("System.SR", {
        statics: {
            fields: {
                ArgumentException_ValueTupleIncorrectType: null,
                ArgumentException_ValueTupleLastArgumentNotAValueTuple: null,
                _lock: null
            },
            props: {
                ResourceManager: null
            },
            ctors: {
                init: function () {
                    this.ArgumentException_ValueTupleIncorrectType = "Argument must be of type {0}.";
                    this.ArgumentException_ValueTupleLastArgumentNotAValueTuple = "The last element of an eight element ValueTuple must be a ValueTuple.";
                    this._lock = { };
                }
            },
            methods: {
                UsingResourceKeys: function () {
                    return false;
                },
                GetResourceString: function (resourceKey) {
                    return System.SR.GetResourceString$1(resourceKey, "");
                },
                GetResourceString$1: function (resourceKey, defaultString) {
                    var resourceString = null;
                    try {
                        resourceString = System.SR.InternalGetResourceString(resourceKey);
                    } catch ($e1) {
                        $e1 = System.Exception.create($e1);
                        if (Bridge.is($e1, System.Resources.MissingManifestResourceException)) {
                        } else {
                            throw $e1;
                        }
                    }

                    if (defaultString != null && System.String.equals(resourceKey, resourceString, 4)) {
                        return defaultString;
                    }

                    return resourceString;
                },
                InternalGetResourceString: function (key) {
                    if (key == null || key.length === 0) {
                        return key;
                    }

                    return key;










                },
                Format$3: function (resourceFormat, args) {
                    if (args === void 0) { args = []; }
                    if (args != null) {
                        if (System.SR.UsingResourceKeys()) {
                            return (resourceFormat || "") + (args.join(", ") || "");
                        }

                        return System.String.format.apply(System.String, [resourceFormat].concat(args));
                    }

                    return resourceFormat;
                },
                Format: function (resourceFormat, p1) {
                    if (System.SR.UsingResourceKeys()) {
                        return [resourceFormat, p1].join(", ");
                    }

                    return System.String.format(resourceFormat, [p1]);
                },
                Format$1: function (resourceFormat, p1, p2) {
                    if (System.SR.UsingResourceKeys()) {
                        return [resourceFormat, p1, p2].join(", ");
                    }

                    return System.String.format(resourceFormat, p1, p2);
                },
                Format$2: function (resourceFormat, p1, p2, p3) {
                    if (System.SR.UsingResourceKeys()) {
                        return [resourceFormat, p1, p2, p3].join(", ");
                    }
                    return System.String.format(resourceFormat, p1, p2, p3);
                }
            }
        }
    });

    // @source StringComparison.js

    Bridge.define("System.StringComparison", {
        $kind: "enum",
        statics: {
            fields: {
                CurrentCulture: 0,
                CurrentCultureIgnoreCase: 1,
                InvariantCulture: 2,
                InvariantCultureIgnoreCase: 3,
                Ordinal: 4,
                OrdinalIgnoreCase: 5
            }
        }
    });

    // @source AggregateException.js

    Bridge.define("System.AggregateException", {
        inherits: [System.Exception],

        ctor: function (message, innerExceptions) {
            this.$initialize();
            this.innerExceptions = new(System.Collections.ObjectModel.ReadOnlyCollection$1(System.Exception))(Bridge.hasValue(innerExceptions) ? Bridge.toArray(innerExceptions) : []);
            System.Exception.ctor.call(this, message || 'One or more errors occurred.', this.innerExceptions.Count > 0 ? this.innerExceptions.getItem(0) : null);
        },

        handle: function (predicate) {
            if (!Bridge.hasValue(predicate)) {
                throw new System.ArgumentNullException.$ctor1("predicate");
            }

            var count = this.innerExceptions.Count,
                unhandledExceptions = [];

            for (var i = 0; i < count; i++) {
                if (!predicate(this.innerExceptions.get(i))) {
                    unhandledExceptions.push(this.innerExceptions.getItem(i));
                }
            }

            if (unhandledExceptions.length > 0) {
                throw new System.AggregateException(this.Message, unhandledExceptions);
            }
        },

        getBaseException: function () {
            var back = this;
            var backAsAggregate = this;

            while (backAsAggregate != null && backAsAggregate.innerExceptions.Count === 1)
            {
                back = back.InnerException;
                backAsAggregate = Bridge.as(back, System.AggregateException);
            }

            return back;
        },

        flatten: function () {
            // Initialize a collection to contain the flattened exceptions.
            var flattenedExceptions = new(System.Collections.Generic.List$1(System.Exception))();

            // Create a list to remember all aggregates to be flattened, this will be accessed like a FIFO queue
            var exceptionsToFlatten = new(System.Collections.Generic.List$1(System.AggregateException))();
            exceptionsToFlatten.add(this);
            var nDequeueIndex = 0;

            // Continue removing and recursively flattening exceptions, until there are no more.
            while (exceptionsToFlatten.Count > nDequeueIndex) {
                // dequeue one from exceptionsToFlatten
                var currentInnerExceptions = exceptionsToFlatten.getItem(nDequeueIndex++).innerExceptions,
                    count = currentInnerExceptions.Count;

                for (var i = 0; i < count; i++) {
                    var currentInnerException = currentInnerExceptions.getItem(i);

                    if (!Bridge.hasValue(currentInnerException)) {
                        continue;
                    }

                    var currentInnerAsAggregate = Bridge.as(currentInnerException, System.AggregateException);

                    // If this exception is an aggregate, keep it around for later.  Otherwise,
                    // simply add it to the list of flattened exceptions to be returned.
                    if (Bridge.hasValue(currentInnerAsAggregate)) {
                        exceptionsToFlatten.add(currentInnerAsAggregate);
                    } else {
                        flattenedExceptions.add(currentInnerException);
                    }
                }
            }

            return new System.AggregateException(this.Message, flattenedExceptions);
        }
    });


    // @source PromiseException.js

    Bridge.define("Bridge.PromiseException", {
        inherits: [System.Exception],

        ctor: function (args, message, innerException) {
            this.$initialize();
            this.arguments = System.Array.clone(args);

            if (message == null) {
                message = "Promise exception: [";
                message += this.arguments.map(function (item) { return item == null ? "null" : item.toString(); }).join(", ");
                message += "]";
            }

            System.Exception.ctor.call(this, message, innerException);
        },

        getArguments: function () {
            return this.arguments;
        }
    });

    // @source ThrowHelper.js

    Bridge.define("System.ThrowHelper", {
        statics: {
            methods: {
                ThrowArrayTypeMismatchException: function () {
                    throw new System.ArrayTypeMismatchException.ctor();
                },
                ThrowInvalidTypeWithPointersNotSupported: function (targetType) {
                    throw new System.ArgumentException.$ctor1(System.SR.Format("Cannot use type '{0}'. Only value types without pointers or references are supported.", targetType));
                },
                ThrowIndexOutOfRangeException: function () {
                    throw new System.IndexOutOfRangeException.ctor();
                },
                ThrowArgumentOutOfRangeException: function () {
                    throw new System.ArgumentOutOfRangeException.ctor();
                },
                ThrowArgumentOutOfRangeException$1: function (argument) {
                    throw new System.ArgumentOutOfRangeException.$ctor1(System.ThrowHelper.GetArgumentName(argument));
                },
                ThrowArgumentOutOfRangeException$2: function (argument, resource) {
                    throw System.ThrowHelper.GetArgumentOutOfRangeException(argument, resource);
                },
                ThrowArgumentOutOfRangeException$3: function (argument, paramNumber, resource) {
                    throw System.ThrowHelper.GetArgumentOutOfRangeException$1(argument, paramNumber, resource);
                },
                ThrowArgumentException_DestinationTooShort: function () {
                    throw new System.ArgumentException.$ctor1("Destination is too short.");
                },
                ThrowArgumentException_OverlapAlignmentMismatch: function () {
                    throw new System.ArgumentException.$ctor1("Overlapping spans have mismatching alignment.");
                },
                ThrowArgumentOutOfRange_IndexException: function () {
                    throw System.ThrowHelper.GetArgumentOutOfRangeException(System.ExceptionArgument.index, System.ExceptionResource.ArgumentOutOfRange_Index);
                },
                ThrowIndexArgumentOutOfRange_NeedNonNegNumException: function () {
                    throw System.ThrowHelper.GetArgumentOutOfRangeException(System.ExceptionArgument.index, System.ExceptionResource.ArgumentOutOfRange_NeedNonNegNum);
                },
                ThrowLengthArgumentOutOfRange_ArgumentOutOfRange_NeedNonNegNum: function () {
                    throw System.ThrowHelper.GetArgumentOutOfRangeException(System.ExceptionArgument.$length, System.ExceptionResource.ArgumentOutOfRange_NeedNonNegNum);
                },
                ThrowStartIndexArgumentOutOfRange_ArgumentOutOfRange_Index: function () {
                    throw System.ThrowHelper.GetArgumentOutOfRangeException(System.ExceptionArgument.startIndex, System.ExceptionResource.ArgumentOutOfRange_Index);
                },
                ThrowCountArgumentOutOfRange_ArgumentOutOfRange_Count: function () {
                    throw System.ThrowHelper.GetArgumentOutOfRangeException(System.ExceptionArgument.count, System.ExceptionResource.ArgumentOutOfRange_Count);
                },
                ThrowWrongKeyTypeArgumentException: function (T, key, targetType) {
                    throw System.ThrowHelper.GetWrongKeyTypeArgumentException(key, targetType);
                },
                ThrowWrongValueTypeArgumentException: function (T, value, targetType) {
                    throw System.ThrowHelper.GetWrongValueTypeArgumentException(value, targetType);
                },
                GetAddingDuplicateWithKeyArgumentException: function (key) {
                    return new System.ArgumentException.$ctor1(System.SR.Format("An item with the same key has already been added. Key: {0}", key));
                },
                ThrowAddingDuplicateWithKeyArgumentException: function (T, key) {
                    throw System.ThrowHelper.GetAddingDuplicateWithKeyArgumentException(key);
                },
                ThrowKeyNotFoundException: function (T, key) {
                    throw System.ThrowHelper.GetKeyNotFoundException(key);
                },
                ThrowArgumentException: function (resource) {
                    throw System.ThrowHelper.GetArgumentException(resource);
                },
                ThrowArgumentException$1: function (resource, argument) {
                    throw System.ThrowHelper.GetArgumentException$1(resource, argument);
                },
                GetArgumentNullException: function (argument) {
                    return new System.ArgumentNullException.$ctor1(System.ThrowHelper.GetArgumentName(argument));
                },
                ThrowArgumentNullException: function (argument) {
                    throw System.ThrowHelper.GetArgumentNullException(argument);
                },
                ThrowArgumentNullException$2: function (resource) {
                    throw new System.ArgumentNullException.$ctor1(System.ThrowHelper.GetResourceString(resource));
                },
                ThrowArgumentNullException$1: function (argument, resource) {
                    throw new System.ArgumentNullException.$ctor3(System.ThrowHelper.GetArgumentName(argument), System.ThrowHelper.GetResourceString(resource));
                },
                ThrowInvalidOperationException: function (resource) {
                    throw System.ThrowHelper.GetInvalidOperationException(resource);
                },
                ThrowInvalidOperationException$1: function (resource, e) {
                    throw new System.InvalidOperationException.$ctor2(System.ThrowHelper.GetResourceString(resource), e);
                },
                ThrowInvalidOperationException_OutstandingReferences: function () {
                    System.ThrowHelper.ThrowInvalidOperationException(System.ExceptionResource.Memory_OutstandingReferences);
                },
                ThrowSerializationException: function (resource) {
                    throw new System.Runtime.Serialization.SerializationException.$ctor1(System.ThrowHelper.GetResourceString(resource));
                },
                ThrowSecurityException: function (resource) {
                    throw new System.Security.SecurityException.$ctor1(System.ThrowHelper.GetResourceString(resource));
                },
                ThrowRankException: function (resource) {
                    throw new System.RankException.$ctor1(System.ThrowHelper.GetResourceString(resource));
                },
                ThrowNotSupportedException$1: function (resource) {
                    throw new System.NotSupportedException.$ctor1(System.ThrowHelper.GetResourceString(resource));
                },
                ThrowNotSupportedException: function () {
                    throw new System.NotSupportedException.ctor();
                },
                ThrowUnauthorizedAccessException: function (resource) {
                    throw new System.UnauthorizedAccessException.$ctor1(System.ThrowHelper.GetResourceString(resource));
                },
                ThrowObjectDisposedException$1: function (objectName, resource) {
                    throw new System.ObjectDisposedException.$ctor3(objectName, System.ThrowHelper.GetResourceString(resource));
                },
                ThrowObjectDisposedException: function (resource) {
                    throw new System.ObjectDisposedException.$ctor3(null, System.ThrowHelper.GetResourceString(resource));
                },
                ThrowObjectDisposedException_MemoryDisposed: function () {
                    throw new System.ObjectDisposedException.$ctor3("OwnedMemory<T>", System.ThrowHelper.GetResourceString(System.ExceptionResource.MemoryDisposed));
                },
                ThrowAggregateException: function (exceptions) {
                    throw new System.AggregateException(null, exceptions);
                },
                ThrowOutOfMemoryException: function () {
                    throw new System.OutOfMemoryException.ctor();
                },
                ThrowArgumentException_Argument_InvalidArrayType: function () {
                    throw System.ThrowHelper.GetArgumentException(System.ExceptionResource.Argument_InvalidArrayType);
                },
                ThrowInvalidOperationException_InvalidOperation_EnumNotStarted: function () {
                    throw System.ThrowHelper.GetInvalidOperationException(System.ExceptionResource.InvalidOperation_EnumNotStarted);
                },
                ThrowInvalidOperationException_InvalidOperation_EnumEnded: function () {
                    throw System.ThrowHelper.GetInvalidOperationException(System.ExceptionResource.InvalidOperation_EnumEnded);
                },
                ThrowInvalidOperationException_EnumCurrent: function (index) {
                    throw System.ThrowHelper.GetInvalidOperationException_EnumCurrent(index);
                },
                ThrowInvalidOperationException_InvalidOperation_EnumFailedVersion: function () {
                    throw System.ThrowHelper.GetInvalidOperationException(System.ExceptionResource.InvalidOperation_EnumFailedVersion);
                },
                ThrowInvalidOperationException_InvalidOperation_EnumOpCantHappen: function () {
                    throw System.ThrowHelper.GetInvalidOperationException(System.ExceptionResource.InvalidOperation_EnumOpCantHappen);
                },
                ThrowInvalidOperationException_InvalidOperation_NoValue: function () {
                    throw System.ThrowHelper.GetInvalidOperationException(System.ExceptionResource.InvalidOperation_NoValue);
                },
                ThrowArraySegmentCtorValidationFailedExceptions: function (array, offset, count) {
                    throw System.ThrowHelper.GetArraySegmentCtorValidationFailedException(array, offset, count);
                },
                GetArraySegmentCtorValidationFailedException: function (array, offset, count) {
                    if (array == null) {
                        return System.ThrowHelper.GetArgumentNullException(System.ExceptionArgument.array);
                    }
                    if (offset < 0) {
                        return System.ThrowHelper.GetArgumentOutOfRangeException(System.ExceptionArgument.offset, System.ExceptionResource.ArgumentOutOfRange_NeedNonNegNum);
                    }
                    if (count < 0) {
                        return System.ThrowHelper.GetArgumentOutOfRangeException(System.ExceptionArgument.count, System.ExceptionResource.ArgumentOutOfRange_NeedNonNegNum);
                    }

                    return System.ThrowHelper.GetArgumentException(System.ExceptionResource.Argument_InvalidOffLen);
                },
                GetArgumentException: function (resource) {
                    return new System.ArgumentException.$ctor1(System.ThrowHelper.GetResourceString(resource));
                },
                GetArgumentException$1: function (resource, argument) {
                    return new System.ArgumentException.$ctor3(System.ThrowHelper.GetResourceString(resource), System.ThrowHelper.GetArgumentName(argument));
                },
                GetInvalidOperationException: function (resource) {
                    return new System.InvalidOperationException.$ctor1(System.ThrowHelper.GetResourceString(resource));
                },
                GetWrongKeyTypeArgumentException: function (key, targetType) {
                    return new System.ArgumentException.$ctor3(System.SR.Format$1("The value \"{0}\" is not of type \"{1}\" and cannot be used in this generic collection.", key, targetType), "key");
                },
                GetWrongValueTypeArgumentException: function (value, targetType) {
                    return new System.ArgumentException.$ctor3(System.SR.Format$1("The value \"{0}\" is not of type \"{1}\" and cannot be used in this generic collection.", value, targetType), "value");
                },
                GetKeyNotFoundException: function (key) {
                    return new System.Collections.Generic.KeyNotFoundException.$ctor1(System.SR.Format("The given key '{0}' was not present in the dictionary.", Bridge.toString(key)));
                },
                GetArgumentOutOfRangeException: function (argument, resource) {
                    return new System.ArgumentOutOfRangeException.$ctor4(System.ThrowHelper.GetArgumentName(argument), System.ThrowHelper.GetResourceString(resource));
                },
                GetArgumentOutOfRangeException$1: function (argument, paramNumber, resource) {
                    return new System.ArgumentOutOfRangeException.$ctor4((System.ThrowHelper.GetArgumentName(argument) || "") + "[" + (Bridge.toString(paramNumber) || "") + "]", System.ThrowHelper.GetResourceString(resource));
                },
                GetInvalidOperationException_EnumCurrent: function (index) {
                    return System.ThrowHelper.GetInvalidOperationException(index < 0 ? System.ExceptionResource.InvalidOperation_EnumNotStarted : System.ExceptionResource.InvalidOperation_EnumEnded);
                },
                IfNullAndNullsAreIllegalThenThrow: function (T, value, argName) {
                    if (!(Bridge.getDefaultValue(T) == null) && value == null) {
                        System.ThrowHelper.ThrowArgumentNullException(argName);
                    }
                },
                GetArgumentName: function (argument) {

                    return System.Enum.toString(System.ExceptionArgument, argument);
                },
                GetResourceString: function (resource) {

                    return System.SR.GetResourceString(System.Enum.toString(System.ExceptionResource, resource));
                },
                ThrowNotSupportedExceptionIfNonNumericType: function (T) {
                    if (!Bridge.referenceEquals(T, System.Byte) && !Bridge.referenceEquals(T, System.SByte) && !Bridge.referenceEquals(T, System.Int16) && !Bridge.referenceEquals(T, System.UInt16) && !Bridge.referenceEquals(T, System.Int32) && !Bridge.referenceEquals(T, System.UInt32) && !Bridge.referenceEquals(T, System.Int64) && !Bridge.referenceEquals(T, System.UInt64) && !Bridge.referenceEquals(T, System.Single) && !Bridge.referenceEquals(T, System.Double)) {
                        throw new System.NotSupportedException.$ctor1("Specified type is not supported");
                    }
                }
            }
        }
    });

    // @source TimeoutException.js

    Bridge.define("System.TimeoutException", {
        inherits: [System.SystemException],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.SystemException.$ctor1.call(this, "The operation has timed out.");
                this.HResult = -2146233083;
            },
            $ctor1: function (message) {
                this.$initialize();
                System.SystemException.$ctor1.call(this, message);
                this.HResult = -2146233083;
            },
            $ctor2: function (message, innerException) {
                this.$initialize();
                System.SystemException.$ctor2.call(this, message, innerException);
                this.HResult = -2146233083;
            }
        }
    });

    // @source RegexMatchTimeoutException.js

    Bridge.define("System.RegexMatchTimeoutException", {
        inherits: [System.TimeoutException],

        _regexInput: "",

        _regexPattern: "",

        _matchTimeout: null,

        config: {
            init: function () {
                this._matchTimeout = System.TimeSpan.fromTicks(-1);
            }
        },

        ctor: function (message, innerException, matchTimeout) {
            this.$initialize();

            if (arguments.length == 3) {
                this._regexInput = message;
                this._regexPattern = innerException;
                this._matchTimeout = matchTimeout;

                message = "The RegEx engine has timed out while trying to match a pattern to an input string. This can occur for many reasons, including very large inputs or excessive backtracking caused by nested quantifiers, back-references and other factors.";
                innerException = null;
            }

            System.TimeoutException.ctor.call(this, message, innerException);
        },

        getPattern: function () {
            return this._regexPattern;
        },

        getInput: function () {
            return this._regexInput;
        },

        getMatchTimeout: function () {
            return this._matchTimeout;
        }
    });

    // @source Encoding.js

    Bridge.define("System.Text.Encoding", {
        statics: {
            fields: {
                _encodings: null
            },
            props: {
                Default: null,
                Unicode: null,
                ASCII: null,
                BigEndianUnicode: null,
                UTF7: null,
                UTF8: null,
                UTF32: null
            },
            ctors: {
                init: function () {
                    this.Default = new System.Text.UnicodeEncoding.$ctor1(false, true);
                    this.Unicode = new System.Text.UnicodeEncoding.$ctor1(false, true);
                    this.ASCII = new System.Text.ASCIIEncoding();
                    this.BigEndianUnicode = new System.Text.UnicodeEncoding.$ctor1(true, true);
                    this.UTF7 = new System.Text.UTF7Encoding.ctor();
                    this.UTF8 = new System.Text.UTF8Encoding.ctor();
                    this.UTF32 = new System.Text.UTF32Encoding.$ctor1(false, true);
                }
            },
            methods: {
                Convert: function (srcEncoding, dstEncoding, bytes) {
                    return System.Text.Encoding.Convert$1(srcEncoding, dstEncoding, bytes, 0, bytes.length);
                },
                Convert$1: function (srcEncoding, dstEncoding, bytes, index, count) {
                    if (srcEncoding == null || dstEncoding == null) {
                        throw new System.ArgumentNullException.$ctor1(srcEncoding == null ? "srcEncoding" : "dstEncoding");
                    }

                    if (bytes == null) {
                        throw new System.ArgumentNullException.$ctor1("bytes");
                    }

                    return dstEncoding.GetBytes(srcEncoding.GetChars$1(bytes, index, count));
                },
                GetEncoding: function (codepage) {
                    switch (codepage) {
                        case 1200: 
                            return System.Text.Encoding.Unicode;
                        case 20127: 
                            return System.Text.Encoding.ASCII;
                        case 1201: 
                            return System.Text.Encoding.BigEndianUnicode;
                        case 65000: 
                            return System.Text.Encoding.UTF7;
                        case 65001: 
                            return System.Text.Encoding.UTF8;
                        case 12000: 
                            return System.Text.Encoding.UTF32;
                    }
                    throw new System.NotSupportedException.ctor();
                },
                GetEncoding$1: function (codepage) {
                    switch (codepage) {
                        case "utf-16": 
                            return System.Text.Encoding.Unicode;
                        case "us-ascii": 
                            return System.Text.Encoding.ASCII;
                        case "utf-16BE": 
                            return System.Text.Encoding.BigEndianUnicode;
                        case "utf-7": 
                            return System.Text.Encoding.UTF7;
                        case "utf-8": 
                            return System.Text.Encoding.UTF8;
                        case "utf-32": 
                            return System.Text.Encoding.UTF32;
                    }
                    throw new System.NotSupportedException.ctor();
                },
                GetEncodings: function () {
                    if (System.Text.Encoding._encodings != null) {
                        return System.Text.Encoding._encodings;
                    }
                    System.Text.Encoding._encodings = System.Array.init(6, null, System.Text.EncodingInfo);
                    var result = System.Text.Encoding._encodings;

                    result[System.Array.index(0, result)] = new System.Text.EncodingInfo(20127, "us-ascii", "US-ASCII");
                    result[System.Array.index(1, result)] = new System.Text.EncodingInfo(1200, "utf-16", "Unicode");
                    result[System.Array.index(2, result)] = new System.Text.EncodingInfo(1201, "utf-16BE", "Unicode (Big-Endian)");
                    result[System.Array.index(3, result)] = new System.Text.EncodingInfo(65000, "utf-7", "Unicode (UTF-7)");
                    result[System.Array.index(4, result)] = new System.Text.EncodingInfo(65001, "utf-8", "Unicode (UTF-8)");
                    result[System.Array.index(5, result)] = new System.Text.EncodingInfo(1200, "utf-32", "Unicode (UTF-32)");
                    return result;
                }
            }
        },
        fields: {
            _hasError: false,
            fallbackCharacter: 0
        },
        props: {
            CodePage: {
                get: function () {
                    return 0;
                }
            },
            EncodingName: {
                get: function () {
                    return null;
                }
            }
        },
        ctors: {
            init: function () {
                this.fallbackCharacter = 63;
            }
        },
        methods: {
            Encode$1: function (chars, index, count) {
                var writtenCount = { };
                return this.Encode$3(System.String.fromCharArray(chars, index, count), null, 0, writtenCount);
            },
            Encode$5: function (s, index, count, outputBytes, outputIndex) {
                var writtenBytes = { };
                this.Encode$3(s.substr(index, count), outputBytes, outputIndex, writtenBytes);
                return writtenBytes.v;
            },
            Encode$4: function (chars, index, count, outputBytes, outputIndex) {
                var writtenBytes = { };
                this.Encode$3(System.String.fromCharArray(chars, index, count), outputBytes, outputIndex, writtenBytes);
                return writtenBytes.v;
            },
            Encode: function (chars) {
                var count = { };
                return this.Encode$3(System.String.fromCharArray(chars), null, 0, count);
            },
            Encode$2: function (str) {
                var count = { };
                return this.Encode$3(str, null, 0, count);
            },
            Decode$1: function (bytes, index, count) {
                return this.Decode$2(bytes, index, count, null, 0);
            },
            Decode: function (bytes) {
                return this.Decode$2(bytes, 0, bytes.length, null, 0);
            },
            GetByteCount: function (chars) {
                return this.GetByteCount$1(chars, 0, chars.length);
            },
            GetByteCount$2: function (s) {
                return this.Encode$2(s).length;
            },
            GetByteCount$1: function (chars, index, count) {
                return this.Encode$1(chars, index, count).length;
            },
            GetBytes: function (chars) {
                return this.GetBytes$1(chars, 0, chars.length);
            },
            GetBytes$1: function (chars, index, count) {
                return this.Encode$2(System.String.fromCharArray(chars, index, count));
            },
            GetBytes$3: function (chars, charIndex, charCount, bytes, byteIndex) {
                return this.Encode$4(chars, charIndex, charCount, bytes, byteIndex);
            },
            GetBytes$2: function (s) {
                return this.Encode$2(s);
            },
            GetBytes$4: function (s, charIndex, charCount, bytes, byteIndex) {
                return this.Encode$5(s, charIndex, charCount, bytes, byteIndex);
            },
            GetCharCount: function (bytes) {
                return this.Decode(bytes).length;
            },
            GetCharCount$1: function (bytes, index, count) {
                return this.Decode$1(bytes, index, count).length;
            },
            GetChars: function (bytes) {
                var $t;
                return ($t = this.Decode(bytes), System.String.toCharArray($t, 0, $t.length));
            },
            GetChars$1: function (bytes, index, count) {
                var $t;
                return ($t = this.Decode$1(bytes, index, count), System.String.toCharArray($t, 0, $t.length));
            },
            GetChars$2: function (bytes, byteIndex, byteCount, chars, charIndex) {
                var s = this.Decode$1(bytes, byteIndex, byteCount);
                var arr = System.String.toCharArray(s, 0, s.length);

                if (chars.length < (((arr.length + charIndex) | 0))) {
                    throw new System.ArgumentException.$ctor3(null, "chars");
                }

                for (var i = 0; i < arr.length; i = (i + 1) | 0) {
                    chars[System.Array.index(((charIndex + i) | 0), chars)] = arr[System.Array.index(i, arr)];
                }

                return arr.length;
            },
            GetString: function (bytes) {
                return this.Decode(bytes);
            },
            GetString$1: function (bytes, index, count) {
                return this.Decode$1(bytes, index, count);
            }
        }
    });

    // @source ASCIIEncoding.js

    Bridge.define("System.Text.ASCIIEncoding", {
        inherits: [System.Text.Encoding],
        props: {
            CodePage: {
                get: function () {
                    return 20127;
                }
            },
            EncodingName: {
                get: function () {
                    return "US-ASCII";
                }
            }
        },
        methods: {
            Encode$3: function (s, outputBytes, outputIndex, writtenBytes) {
                var hasBuffer = outputBytes != null;

                if (!hasBuffer) {
                    outputBytes = System.Array.init(0, 0, System.Byte);
                }

                var recorded = 0;
                for (var i = 0; i < s.length; i = (i + 1) | 0) {
                    var ch = s.charCodeAt(i);
                    var byteCode = (ch <= 127 ? ch : this.fallbackCharacter) & 255;

                    if (hasBuffer) {
                        if ((((i + outputIndex) | 0)) >= outputBytes.length) {
                            throw new System.ArgumentException.$ctor1("bytes");
                        }
                        outputBytes[System.Array.index(((i + outputIndex) | 0), outputBytes)] = byteCode;
                    } else {
                        outputBytes.push(byteCode);
                    }
                    recorded = (recorded + 1) | 0;
                }

                writtenBytes.v = recorded;

                if (hasBuffer) {
                    return null;
                }

                return outputBytes;
            },
            Decode$2: function (bytes, index, count, chars, charIndex) {
                var position = index;
                var result = "";
                var endpoint = (position + count) | 0;

                for (; position < endpoint; position = (position + 1) | 0) {
                    var byteCode = bytes[System.Array.index(position, bytes)];

                    if (byteCode > 127) {
                        result = (result || "") + String.fromCharCode(this.fallbackCharacter);
                    } else {
                        result = (result || "") + ((String.fromCharCode(byteCode)) || "");
                    }
                }

                return result;
            },
            GetMaxByteCount: function (charCount) {
                if (charCount < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("charCount");
                }

                var byteCount = System.Int64(charCount).add(System.Int64(1));

                if (byteCount.gt(System.Int64(2147483647))) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("charCount");
                }

                return System.Int64.clip32(byteCount);
            },
            GetMaxCharCount: function (byteCount) {
                if (byteCount < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("byteCount");
                }

                var charCount = System.Int64(byteCount);

                if (charCount.gt(System.Int64(2147483647))) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("byteCount");
                }

                return System.Int64.clip32(charCount);
            }
        }
    });

    // @source EncodingInfo.js

    Bridge.define("System.Text.EncodingInfo", {
        props: {
            CodePage: 0,
            Name: null,
            DisplayName: null
        },
        ctors: {
            ctor: function (codePage, name, displayName) {
                var $t;
                this.$initialize();
                this.CodePage = codePage;
                this.Name = name;
                this.DisplayName = ($t = displayName, $t != null ? $t : name);
            }
        },
        methods: {
            GetEncoding: function () {
                return System.Text.Encoding.GetEncoding(this.CodePage);
            },
            getHashCode: function () {
                return this.CodePage;
            },
            equals: function (o) {
                var that = Bridge.as(o, System.Text.EncodingInfo);
                return System.Nullable.eq(this.CodePage, (that != null ? that.CodePage : null));
            }
        }
    });

    // @source UnicodeEncoding.js

    Bridge.define("System.Text.UnicodeEncoding", {
        inherits: [System.Text.Encoding],
        fields: {
            bigEndian: false,
            byteOrderMark: false,
            throwOnInvalid: false
        },
        props: {
            CodePage: {
                get: function () {
                    return this.bigEndian ? 1201 : 1200;
                }
            },
            EncodingName: {
                get: function () {
                    return this.bigEndian ? "Unicode (Big-Endian)" : "Unicode";
                }
            }
        },
        ctors: {
            ctor: function () {
                System.Text.UnicodeEncoding.$ctor1.call(this, false, true);
            },
            $ctor1: function (bigEndian, byteOrderMark) {
                System.Text.UnicodeEncoding.$ctor2.call(this, bigEndian, byteOrderMark, false);
            },
            $ctor2: function (bigEndian, byteOrderMark, throwOnInvalidBytes) {
                this.$initialize();
                System.Text.Encoding.ctor.call(this);
                this.bigEndian = bigEndian;
                this.byteOrderMark = byteOrderMark;
                this.throwOnInvalid = throwOnInvalidBytes;
                this.fallbackCharacter = 65533;
            }
        },
        methods: {
            Encode$3: function (s, outputBytes, outputIndex, writtenBytes) {
                var hasBuffer = outputBytes != null;
                var recorded = 0;
                var surrogate_1st = 0;
                var fallbackCharacterCode = this.fallbackCharacter;

                var write = function (ch) {
                    if (hasBuffer) {
                        if (outputIndex >= outputBytes.length) {
                            throw new System.ArgumentException.$ctor1("bytes");
                        }

                        outputBytes[System.Array.index(Bridge.identity(outputIndex, (outputIndex = (outputIndex + 1) | 0)), outputBytes)] = ch;
                    } else {
                        outputBytes.push(ch);
                    }
                    recorded = (recorded + 1) | 0;
                };

                var writePair = function (a, b) {
                    write(a);
                    write(b);
                };

                var swap = $asm.$.System.Text.UnicodeEncoding.f1;

                var fallback = Bridge.fn.bind(this, function () {
                    if (this.throwOnInvalid) {
                        throw new System.Exception("Invalid character in UTF16 text");
                    }

                    writePair((fallbackCharacterCode & 255), ((fallbackCharacterCode >> 8) & 255));
                });

                if (!hasBuffer) {
                    outputBytes = System.Array.init(0, 0, System.Byte);
                }

                if (this.bigEndian) {
                    fallbackCharacterCode = swap(fallbackCharacterCode);
                }

                for (var i = 0; i < s.length; i = (i + 1) | 0) {
                    var ch = s.charCodeAt(i);

                    if (surrogate_1st !== 0) {
                        if (ch >= 56320 && ch <= 57343) {
                            if (this.bigEndian) {
                                surrogate_1st = swap(surrogate_1st);
                                ch = swap(ch);
                            }
                            writePair((surrogate_1st & 255), ((surrogate_1st >> 8) & 255));
                            writePair((ch & 255), ((ch >> 8) & 255));
                            surrogate_1st = 0;
                            continue;
                        }
                        fallback();
                        surrogate_1st = 0;
                    }

                    if (55296 <= ch && ch <= 56319) {
                        surrogate_1st = ch;
                        continue;
                    } else if (56320 <= ch && ch <= 57343) {
                        fallback();
                        surrogate_1st = 0;
                        continue;
                    }

                    if (ch < 65536) {
                        if (this.bigEndian) {
                            ch = swap(ch);
                        }
                        writePair((ch & 255), ((ch >> 8) & 255));
                    } else if (ch <= 1114111) {
                        ch = ch - 0x10000;

                        var lowBits = ((ch & 1023) | 56320) & 65535;
                        var highBits = (((ch >> 10) & 1023) | 55296) & 65535;

                        if (this.bigEndian) {
                            highBits = swap(highBits);
                            lowBits = swap(lowBits);
                        }
                        writePair((highBits & 255), ((highBits >> 8) & 255));
                        writePair((lowBits & 255), ((lowBits >> 8) & 255));
                    } else {
                        fallback();
                    }
                }

                if (surrogate_1st !== 0) {
                    fallback();
                }

                writtenBytes.v = recorded;

                if (hasBuffer) {
                    return null;
                }

                return outputBytes;
            },
            Decode$2: function (bytes, index, count, chars, charIndex) {
                var position = index;
                var result = "";
                var endpoint = (position + count) | 0;
                this._hasError = false;

                var fallback = Bridge.fn.bind(this, function () {
                    if (this.throwOnInvalid) {
                        throw new System.Exception("Invalid character in UTF16 text");
                    }

                    result = (result || "") + String.fromCharCode(this.fallbackCharacter);
                });

                var swap = $asm.$.System.Text.UnicodeEncoding.f2;

                var readPair = Bridge.fn.bind(this, function () {
                    if ((((position + 2) | 0)) > endpoint) {
                        position = (position + 2) | 0;
                        return null;
                    }

                    var a = bytes[System.Array.index(Bridge.identity(position, (position = (position + 1) | 0)), bytes)];
                    var b = bytes[System.Array.index(Bridge.identity(position, (position = (position + 1) | 0)), bytes)];

                    var point = ((a << 8) | b) & 65535;
                    if (!this.bigEndian) {
                        point = swap(point);
                    }

                    return point;
                });

                while (position < endpoint) {
                    var firstWord = readPair();

                    if (!System.Nullable.hasValue(firstWord)) {
                        fallback();
                        this._hasError = true;
                    } else if ((System.Nullable.lt(firstWord, 55296)) || (System.Nullable.gt(firstWord, 57343))) {
                        result = (result || "") + ((System.String.fromCharCode(System.Nullable.getValue(firstWord))) || "");
                    } else if ((System.Nullable.gte(firstWord, 55296)) && (System.Nullable.lte(firstWord, 56319))) {
                        var end = position >= endpoint;
                        var secondWord = readPair();
                        if (end) {
                            fallback();
                            this._hasError = true;
                        } else if (!System.Nullable.hasValue(secondWord)) {
                            fallback();
                            fallback();
                        } else if ((System.Nullable.gte(secondWord, 56320)) && (System.Nullable.lte(secondWord, 57343))) {
                            var highBits = System.Nullable.band(firstWord, 1023);
                            var lowBits = System.Nullable.band(secondWord, 1023);

                            var charCode = Bridge.Int.clip32(System.Nullable.add((System.Nullable.bor((System.Nullable.sl(highBits, 10)), lowBits)), 65536));

                            result = (result || "") + ((System.String.fromCharCode(System.Nullable.getValue(charCode))) || "");
                        } else {
                            fallback();
                            position = (position - 2) | 0;
                        }
                    } else {
                        fallback();
                    }
                }

                return result;
            },
            GetMaxByteCount: function (charCount) {
                if (charCount < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("charCount");
                }

                var byteCount = System.Int64(charCount).add(System.Int64(1));
                byteCount = byteCount.shl(1);

                if (byteCount.gt(System.Int64(2147483647))) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("charCount");
                }

                return System.Int64.clip32(byteCount);
            },
            GetMaxCharCount: function (byteCount) {
                if (byteCount < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("byteCount");
                }

                var charCount = System.Int64((byteCount >> 1)).add(System.Int64((byteCount & 1))).add(System.Int64(1));

                if (charCount.gt(System.Int64(2147483647))) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("byteCount");
                }

                return System.Int64.clip32(charCount);
            }
        }
    });

    Bridge.ns("System.Text.UnicodeEncoding", $asm.$);

    Bridge.apply($asm.$.System.Text.UnicodeEncoding, {
        f1: function (ch) {
            return ((((ch & 255) << 8) | ((ch >> 8) & 255)) & 65535);
        },
        f2: function (ch) {
            return ((((ch & 255) << 8) | (((ch >> 8)) & 255)) & 65535);
        }
    });

    // @source UTF32Encoding.js

    Bridge.define("System.Text.UTF32Encoding", {
        inherits: [System.Text.Encoding],
        fields: {
            bigEndian: false,
            byteOrderMark: false,
            throwOnInvalid: false
        },
        props: {
            CodePage: {
                get: function () {
                    return this.bigEndian ? 1201 : 1200;
                }
            },
            EncodingName: {
                get: function () {
                    return this.bigEndian ? "Unicode (UTF-32 Big-Endian)" : "Unicode (UTF-32)";
                }
            }
        },
        ctors: {
            ctor: function () {
                System.Text.UTF32Encoding.$ctor2.call(this, false, true, false);
            },
            $ctor1: function (bigEndian, byteOrderMark) {
                System.Text.UTF32Encoding.$ctor2.call(this, bigEndian, byteOrderMark, false);
            },
            $ctor2: function (bigEndian, byteOrderMark, throwOnInvalidBytes) {
                this.$initialize();
                System.Text.Encoding.ctor.call(this);
                this.bigEndian = bigEndian;
                this.byteOrderMark = byteOrderMark;
                this.throwOnInvalid = throwOnInvalidBytes;
                this.fallbackCharacter = 65533;
            }
        },
        methods: {
            ToCodePoints: function (str) {
                var surrogate_1st = 0;
                var unicode_codes = System.Array.init(0, 0, System.Char);
                var fallback = Bridge.fn.bind(this, function () {
                    if (this.throwOnInvalid) {
                        throw new System.Exception("Invalid character in UTF32 text");
                    }
                    unicode_codes.push(this.fallbackCharacter);
                });

                for (var i = 0; i < str.length; i = (i + 1) | 0) {
                    var utf16_code = str.charCodeAt(i);

                    if (surrogate_1st !== 0) {
                        if (utf16_code >= 56320 && utf16_code <= 57343) {
                            var surrogate_2nd = utf16_code;
                            var unicode_code = (((Bridge.Int.mul((((surrogate_1st - 55296) | 0)), (1024)) + (65536)) | 0) + (((surrogate_2nd - 56320) | 0))) | 0;
                            unicode_codes.push(unicode_code);
                        } else {
                            fallback();
                            i = (i - 1) | 0;
                        }
                        surrogate_1st = 0;
                    } else if (utf16_code >= 55296 && utf16_code <= 56319) {
                        surrogate_1st = utf16_code;
                    } else if ((utf16_code >= 56320) && (utf16_code <= 57343)) {
                        fallback();
                    } else {
                        unicode_codes.push(utf16_code);
                    }
                }

                if (surrogate_1st !== 0) {
                    fallback();
                }

                return unicode_codes;
            },
            Encode$3: function (s, outputBytes, outputIndex, writtenBytes) {
                var hasBuffer = outputBytes != null;
                var recorded = 0;

                var write = function (ch) {
                    if (hasBuffer) {
                        if (outputIndex >= outputBytes.length) {
                            throw new System.ArgumentException.$ctor1("bytes");
                        }

                        outputBytes[System.Array.index(Bridge.identity(outputIndex, (outputIndex = (outputIndex + 1) | 0)), outputBytes)] = ch;
                    } else {
                        outputBytes.push(ch);
                    }
                    recorded = (recorded + 1) | 0;
                };

                var write32 = Bridge.fn.bind(this, function (a) {
                    var r = System.Array.init(4, 0, System.Byte);
                    r[System.Array.index(0, r)] = (((a & 255) >>> 0));
                    r[System.Array.index(1, r)] = ((((a & 65280) >>> 0)) >>> 8);
                    r[System.Array.index(2, r)] = ((((a & 16711680) >>> 0)) >>> 16);
                    r[System.Array.index(3, r)] = ((((a & 4278190080) >>> 0)) >>> 24);

                    if (this.bigEndian) {
                        r.reverse();
                    }

                    write(r[System.Array.index(0, r)]);
                    write(r[System.Array.index(1, r)]);
                    write(r[System.Array.index(2, r)]);
                    write(r[System.Array.index(3, r)]);
                });

                if (!hasBuffer) {
                    outputBytes = System.Array.init(0, 0, System.Byte);
                }

                var unicode_codes = this.ToCodePoints(s);
                for (var i = 0; i < unicode_codes.length; i = (i + 1) | 0) {
                    write32(unicode_codes[System.Array.index(i, unicode_codes)]);
                }

                writtenBytes.v = recorded;

                if (hasBuffer) {
                    return null;
                }

                return outputBytes;
            },
            Decode$2: function (bytes, index, count, chars, charIndex) {
                var position = index;
                var result = "";
                var endpoint = (position + count) | 0;
                this._hasError = false;

                var fallback = Bridge.fn.bind(this, function () {
                    if (this.throwOnInvalid) {
                        throw new System.Exception("Invalid character in UTF32 text");
                    }

                    result = (result || "") + ((String.fromCharCode(this.fallbackCharacter)) || "");
                });

                var read32 = Bridge.fn.bind(this, function () {
                    if ((((position + 4) | 0)) > endpoint) {
                        position = (position + 4) | 0;
                        return null;
                    }

                    var a = bytes[System.Array.index(Bridge.identity(position, (position = (position + 1) | 0)), bytes)];
                    var b = bytes[System.Array.index(Bridge.identity(position, (position = (position + 1) | 0)), bytes)];
                    var c = bytes[System.Array.index(Bridge.identity(position, (position = (position + 1) | 0)), bytes)];
                    var d = bytes[System.Array.index(Bridge.identity(position, (position = (position + 1) | 0)), bytes)];

                    if (this.bigEndian) {
                        var tmp = b;
                        b = c;
                        c = tmp;

                        tmp = a;
                        a = d;
                        d = tmp;
                    }

                    return ((d << 24) | (c << 16) | (b << 8) | a);
                });

                while (position < endpoint) {
                    var unicode_code = read32();

                    if (unicode_code == null) {
                        fallback();
                        this._hasError = true;
                        continue;
                    }

                    if (System.Nullable.lt(unicode_code, 65536) || System.Nullable.gt(unicode_code, 1114111)) {
                        if (System.Nullable.lt(unicode_code, 0) || System.Nullable.gt(unicode_code, 1114111) || (System.Nullable.gte(unicode_code, 55296) && System.Nullable.lte(unicode_code, 57343))) {
                            fallback();
                        } else {
                            result = (result || "") + ((String.fromCharCode(unicode_code)) || "");
                        }
                    } else {
                        result = (result || "") + ((String.fromCharCode((Bridge.Int.clipu32(System.Nullable.add((Bridge.Int.clipu32(Bridge.Int.div((Bridge.Int.clipu32(System.Nullable.sub(unicode_code, (65536)))), (1024)))), 55296))))) || "");
                        result = (result || "") + ((String.fromCharCode((Bridge.Int.clipu32(System.Nullable.add((System.Nullable.mod(unicode_code, (1024))), 56320))))) || "");
                    }
                }

                return result;
            },
            GetMaxByteCount: function (charCount) {
                if (charCount < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("charCount");
                }

                var byteCount = System.Int64(charCount).add(System.Int64(1));
                byteCount = byteCount.mul(System.Int64(4));

                if (byteCount.gt(System.Int64(2147483647))) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("charCount");
                }

                return System.Int64.clip32(byteCount);
            },
            GetMaxCharCount: function (byteCount) {
                if (byteCount < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("byteCount");
                }

                var charCount = (((Bridge.Int.div(byteCount, 2)) | 0) + 2) | 0;

                if (charCount > 2147483647) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("byteCount");
                }

                return charCount;
            }
        }
    });

    // @source UTF7Encoding.js

    Bridge.define("System.Text.UTF7Encoding", {
        inherits: [System.Text.Encoding],
        statics: {
            methods: {
                Escape: function (chars) {
                    return chars.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
                }
            }
        },
        fields: {
            allowOptionals: false
        },
        props: {
            CodePage: {
                get: function () {
                    return 65000;
                }
            },
            EncodingName: {
                get: function () {
                    return "Unicode (UTF-7)";
                }
            }
        },
        ctors: {
            ctor: function () {
                System.Text.UTF7Encoding.$ctor1.call(this, false);
            },
            $ctor1: function (allowOptionals) {
                this.$initialize();
                System.Text.Encoding.ctor.call(this);
                this.allowOptionals = allowOptionals;
                this.fallbackCharacter = 65533;
            }
        },
        methods: {
            Encode$3: function (s, outputBytes, outputIndex, writtenBytes) {
                var setD = "A-Za-z0-9" + (System.Text.UTF7Encoding.Escape("'(),-./:?") || "");

                var encode = $asm.$.System.Text.UTF7Encoding.f1;

                var setO = System.Text.UTF7Encoding.Escape("!\"#$%&*;<=>@[]^_`{|}");
                var setW = System.Text.UTF7Encoding.Escape(" \r\n\t");

                s = s.replace(new RegExp("[^" + setW + setD + (this.allowOptionals ? setO : "") + "]+", "g"), function (chunk) { return "+" + (chunk === "+" ? "" : encode(chunk)) + "-"; });

                var arr = System.String.toCharArray(s, 0, s.length);

                if (outputBytes != null) {
                    var recorded = 0;

                    if (arr.length > (((outputBytes.length - outputIndex) | 0))) {
                        throw new System.ArgumentException.$ctor1("bytes");
                    }

                    for (var j = 0; j < arr.length; j = (j + 1) | 0) {
                        outputBytes[System.Array.index(((j + outputIndex) | 0), outputBytes)] = arr[System.Array.index(j, arr)];
                        recorded = (recorded + 1) | 0;
                    }

                    writtenBytes.v = recorded;
                    return null;
                }

                writtenBytes.v = arr.length;

                return arr;
            },
            Decode$2: function (bytes, index, count, chars, charIndex) {
                var _base64ToArrayBuffer = $asm.$.System.Text.UTF7Encoding.f2;

                var decode = function (s) {
                    var b = _base64ToArrayBuffer(s);
                    var r = System.Array.init(0, 0, System.Char);
                    for (var i = 0; i < b.length; ) {
                        r.push(((b[System.Array.index(Bridge.identity(i, (i = (i + 1) | 0)), b)] << 8 | b[System.Array.index(Bridge.identity(i, (i = (i + 1) | 0)), b)]) & 65535));
                    }
                    return System.String.fromCharArray(r);
                };

                var str = System.String.fromCharArray(bytes, index, count);
                return str.replace(/\+([A-Za-z0-9\/]*)-?/gi, function (_, chunk) { if (chunk === "") { return _ == "+-" ? "+" : ""; } return decode(chunk); });
            },
            GetMaxByteCount: function (charCount) {
                if (charCount < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("charCount");
                }

                var byteCount = System.Int64(charCount).mul(System.Int64(3)).add(System.Int64(2));

                if (byteCount.gt(System.Int64(2147483647))) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("charCount");
                }

                return System.Int64.clip32(byteCount);
            },
            GetMaxCharCount: function (byteCount) {
                if (byteCount < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("byteCount");
                }

                var charCount = byteCount;
                if (charCount === 0) {
                    charCount = 1;
                }

                return charCount | 0;
            }
        }
    });

    Bridge.ns("System.Text.UTF7Encoding", $asm.$);

    Bridge.apply($asm.$.System.Text.UTF7Encoding, {
        f1: function (str) {
            var b = System.Array.init(Bridge.Int.mul(str.length, 2), 0, System.Byte);
            var bi = 0;
            for (var i = 0; i < str.length; i = (i + 1) | 0) {
                var c = str.charCodeAt(i);
                b[System.Array.index(Bridge.identity(bi, (bi = (bi + 1) | 0)), b)] = (c >> 8);
                b[System.Array.index(Bridge.identity(bi, (bi = (bi + 1) | 0)), b)] = (c & 255);
            }
            var base64Str = System.Convert.toBase64String(b, null, null, null);
            return base64Str.replace(/=+$/, "");
        },
        f2: function (base64) {
            try {
                if (typeof window === "undefined") { throw new System.Exception(); };
                var binary_string = window.atob(base64);
                var len = binary_string.length;
                var arr = System.Array.init(len, 0, System.Char);

                if (len === 1 && binary_string.charCodeAt(0) === 0) {
                    return System.Array.init(0, 0, System.Char);
                }

                for (var i = 0; i < len; i = (i + 1) | 0) {
                    arr[System.Array.index(i, arr)] = binary_string.charCodeAt(i);
                }

                return arr;
            } catch ($e1) {
                $e1 = System.Exception.create($e1);
                return System.Array.init(0, 0, System.Char);
            }
        }
    });

    // @source UTF8Encoding.js

    Bridge.define("System.Text.UTF8Encoding", {
        inherits: [System.Text.Encoding],
        fields: {
            encoderShouldEmitUTF8Identifier: false,
            throwOnInvalid: false
        },
        props: {
            CodePage: {
                get: function () {
                    return 65001;
                }
            },
            EncodingName: {
                get: function () {
                    return "Unicode (UTF-8)";
                }
            }
        },
        ctors: {
            ctor: function () {
                System.Text.UTF8Encoding.$ctor1.call(this, false);
            },
            $ctor1: function (encoderShouldEmitUTF8Identifier) {
                System.Text.UTF8Encoding.$ctor2.call(this, encoderShouldEmitUTF8Identifier, false);
            },
            $ctor2: function (encoderShouldEmitUTF8Identifier, throwOnInvalidBytes) {
                this.$initialize();
                System.Text.Encoding.ctor.call(this);
                this.encoderShouldEmitUTF8Identifier = encoderShouldEmitUTF8Identifier;
                this.throwOnInvalid = throwOnInvalidBytes;
                this.fallbackCharacter = 65533;
            }
        },
        methods: {
            Encode$3: function (s, outputBytes, outputIndex, writtenBytes) {
                var hasBuffer = outputBytes != null;
                var record = 0;

                var write = function (args) {
                    var len = args.length;
                    for (var j = 0; j < len; j = (j + 1) | 0) {
                        var code = args[System.Array.index(j, args)];
                        if (hasBuffer) {
                            if (outputIndex >= outputBytes.length) {
                                throw new System.ArgumentException.$ctor1("bytes");
                            }

                            outputBytes[System.Array.index(Bridge.identity(outputIndex, (outputIndex = (outputIndex + 1) | 0)), outputBytes)] = code;
                        } else {
                            outputBytes.push(code);
                        }
                        record = (record + 1) | 0;
                    }
                };

                var fallback = Bridge.fn.bind(this, $asm.$.System.Text.UTF8Encoding.f1);

                if (!hasBuffer) {
                    outputBytes = System.Array.init(0, 0, System.Byte);
                }

                for (var i = 0; i < s.length; i = (i + 1) | 0) {
                    var charcode = s.charCodeAt(i);

                    if ((charcode >= 55296) && (charcode <= 56319)) {
                        var next = s.charCodeAt(((i + 1) | 0));
                        if (!((next >= 56320) && (next <= 57343))) {
                            charcode = fallback();
                        }
                    } else if ((charcode >= 56320) && (charcode <= 57343)) {
                        charcode = fallback();
                    }

                    if (charcode < 128) {
                        write(System.Array.init([charcode], System.Byte));
                    } else if (charcode < 2048) {
                        write(System.Array.init([(192 | (charcode >> 6)), (128 | (charcode & 63))], System.Byte));
                    } else if (charcode < 55296 || charcode >= 57344) {
                        write(System.Array.init([(224 | (charcode >> 12)), (128 | ((charcode >> 6) & 63)), (128 | (charcode & 63))], System.Byte));
                    } else {
                        i = (i + 1) | 0;
                        var code = (65536 + (((charcode & 1023) << 10) | (s.charCodeAt(i) & 1023))) | 0;
                        write(System.Array.init([(240 | (code >> 18)), (128 | ((code >> 12) & 63)), (128 | ((code >> 6) & 63)), (128 | (code & 63))], System.Byte));
                    }
                }

                writtenBytes.v = record;

                if (hasBuffer) {
                    return null;
                }

                return outputBytes;
            },
            Decode$2: function (bytes, index, count, chars, charIndex) {
                this._hasError = false;
                var position = index;
                var result = "";
                var surrogate1 = 0;
                var addFallback = false;
                var endpoint = (position + count) | 0;

                for (; position < endpoint; position = (position + 1) | 0) {
                    var accumulator = 0;
                    var extraBytes = 0;
                    var hasError = false;
                    var firstByte = bytes[System.Array.index(position, bytes)];

                    if (firstByte <= 127) {
                        accumulator = firstByte;
                    } else if ((firstByte & 64) === 0) {
                        hasError = true;
                    } else if ((firstByte & 224) === 192) {
                        accumulator = firstByte & 31;
                        extraBytes = 1;
                    } else if ((firstByte & 240) === 224) {
                        accumulator = firstByte & 15;
                        extraBytes = 2;
                    } else if ((firstByte & 248) === 240) {
                        accumulator = firstByte & 7;
                        extraBytes = 3;
                    } else if ((firstByte & 252) === 248) {
                        accumulator = firstByte & 3;
                        extraBytes = 4;
                        hasError = true;
                    } else if ((firstByte & 254) === 252) {
                        accumulator = firstByte & 3;
                        extraBytes = 5;
                        hasError = true;
                    } else {
                        accumulator = firstByte;
                        hasError = false;
                    }

                    while (extraBytes > 0) {
                        position = (position + 1) | 0;

                        if (position >= endpoint) {
                            hasError = true;
                            break;
                        }

                        var extraByte = bytes[System.Array.index(position, bytes)];
                        extraBytes = (extraBytes - 1) | 0;

                        if ((extraByte & 192) !== 128) {
                            position = (position - 1) | 0;
                            hasError = true;
                            break;
                        }

                        accumulator = (accumulator << 6) | (extraByte & 63);
                    }

                    /* if ((accumulator == 0xFFFE) || (accumulator == 0xFFFF)) {
                       hasError = true;
                    }*/

                    var characters = null;
                    addFallback = false;
                    if (!hasError) {
                        if (surrogate1 > 0 && !((accumulator >= 56320) && (accumulator <= 57343))) {
                            hasError = true;
                            surrogate1 = 0;
                        } else if ((accumulator >= 55296) && (accumulator <= 56319)) {
                            surrogate1 = accumulator & 65535;
                        } else if ((accumulator >= 56320) && (accumulator <= 57343)) {
                            hasError = true;
                            addFallback = true;
                            surrogate1 = 0;
                        } else {
                            characters = System.String.fromCharCode(accumulator);
                            surrogate1 = 0;
                        }
                    }

                    if (hasError) {
                        if (this.throwOnInvalid) {
                            throw new System.Exception("Invalid character in UTF8 text");
                        }

                        result = (result || "") + String.fromCharCode(this.fallbackCharacter);
                        this._hasError = true;
                    } else if (surrogate1 === 0) {
                        result = (result || "") + (characters || "");
                    }
                }

                if (surrogate1 > 0 || addFallback) {
                    if (this.throwOnInvalid) {
                        throw new System.Exception("Invalid character in UTF8 text");
                    }

                    if (result.length > 0 && result.charCodeAt(((result.length - 1) | 0)) === this.fallbackCharacter) {
                        result = (result || "") + String.fromCharCode(this.fallbackCharacter);
                    } else {
                        result = (result || "") + (((this.fallbackCharacter + this.fallbackCharacter) | 0));
                    }

                    this._hasError = true;
                }

                return result;
            },
            GetMaxByteCount: function (charCount) {
                if (charCount < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("charCount");
                }


                var byteCount = System.Int64(charCount).add(System.Int64(1));
                byteCount = byteCount.mul(System.Int64(3));

                if (byteCount.gt(System.Int64(2147483647))) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("charCount");
                }

                return System.Int64.clip32(byteCount);
            },
            GetMaxCharCount: function (byteCount) {
                if (byteCount < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("byteCount");
                }

                var charCount = System.Int64(byteCount).add(System.Int64(1));

                if (charCount.gt(System.Int64(2147483647))) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("byteCount");
                }

                return System.Int64.clip32(charCount);
            }
        }
    });

    Bridge.ns("System.Text.UTF8Encoding", $asm.$);

    Bridge.apply($asm.$.System.Text.UTF8Encoding, {
        f1: function () {
            if (this.throwOnInvalid) {
                throw new System.Exception("Invalid character in UTF8 text");
            }

            return this.fallbackCharacter;
        }
    });

    // @source Timer.js

    Bridge.define("System.Threading.Timer", {
        inherits: [System.IDisposable],
        statics: {
            fields: {
                MAX_SUPPORTED_TIMEOUT: 0,
                EXC_LESS: null,
                EXC_MORE: null,
                EXC_DISPOSED: null
            },
            ctors: {
                init: function () {
                    this.MAX_SUPPORTED_TIMEOUT = 4294967294;
                    this.EXC_LESS = "Number must be either non-negative and less than or equal to Int32.MaxValue or -1.";
                    this.EXC_MORE = "Time-out interval must be less than 2^32-2.";
                    this.EXC_DISPOSED = "The timer has been already disposed.";
                }
            }
        },
        fields: {
            dueTime: System.Int64(0),
            period: System.Int64(0),
            timerCallback: null,
            state: null,
            id: null,
            disposed: false
        },
        alias: ["Dispose", "System$IDisposable$Dispose"],
        ctors: {
            $ctor1: function (callback, state, dueTime, period) {
                this.$initialize();
                this.TimerSetup(callback, state, System.Int64(dueTime), System.Int64(period));
            },
            $ctor3: function (callback, state, dueTime, period) {
                this.$initialize();
                var dueTm = Bridge.Int.clip64(dueTime.getTotalMilliseconds());
                var periodTm = Bridge.Int.clip64(period.getTotalMilliseconds());

                this.TimerSetup(callback, state, dueTm, periodTm);
            },
            $ctor4: function (callback, state, dueTime, period) {
                this.$initialize();
                this.TimerSetup(callback, state, System.Int64(dueTime), System.Int64(period));
            },
            $ctor2: function (callback, state, dueTime, period) {
                this.$initialize();
                this.TimerSetup(callback, state, dueTime, period);
            },
            ctor: function (callback) {
                this.$initialize();
                var dueTime = -1;
                var period = -1;

                this.TimerSetup(callback, this, System.Int64(dueTime), System.Int64(period));
            }
        },
        methods: {
            TimerSetup: function (callback, state, dueTime, period) {
                if (this.disposed) {
                    throw new System.InvalidOperationException.$ctor1(System.Threading.Timer.EXC_DISPOSED);
                }

                if (Bridge.staticEquals(callback, null)) {
                    throw new System.ArgumentNullException.$ctor1("TimerCallback");
                }

                if (dueTime.lt(System.Int64(-1))) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("dueTime", System.Threading.Timer.EXC_LESS);
                }
                if (period.lt(System.Int64(-1))) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("period", System.Threading.Timer.EXC_LESS);
                }
                if (dueTime.gt(System.Int64(System.Threading.Timer.MAX_SUPPORTED_TIMEOUT))) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("dueTime", System.Threading.Timer.EXC_MORE);
                }
                if (period.gt(System.Int64(System.Threading.Timer.MAX_SUPPORTED_TIMEOUT))) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("period", System.Threading.Timer.EXC_MORE);
                }

                this.dueTime = dueTime;
                this.period = period;

                this.state = state;
                this.timerCallback = callback;

                return this.RunTimer(this.dueTime);
            },
            HandleCallback: function () {
                if (this.disposed) {
                    return;
                }

                if (!Bridge.staticEquals(this.timerCallback, null)) {
                    var myId = this.id;
                    this.timerCallback(this.state);

                    if (System.Nullable.eq(this.id, myId)) {
                        this.RunTimer(this.period, false);
                    }
                }
            },
            RunTimer: function (period, checkDispose) {
                if (checkDispose === void 0) { checkDispose = true; }
                if (checkDispose && this.disposed) {
                    throw new System.InvalidOperationException.$ctor1(System.Threading.Timer.EXC_DISPOSED);
                }

                if (period.ne(System.Int64(-1)) && !this.disposed) {
                    var p = period.toNumber();
                    this.id = Bridge.global.setTimeout(Bridge.fn.cacheBind(this, this.HandleCallback), p);
                    return true;
                }

                return false;
            },
            Change: function (dueTime, period) {
                return this.ChangeTimer(System.Int64(dueTime), System.Int64(period));
            },
            Change$2: function (dueTime, period) {
                return this.ChangeTimer(Bridge.Int.clip64(dueTime.getTotalMilliseconds()), Bridge.Int.clip64(period.getTotalMilliseconds()));
            },
            Change$3: function (dueTime, period) {
                return this.ChangeTimer(System.Int64(dueTime), System.Int64(period));
            },
            Change$1: function (dueTime, period) {
                return this.ChangeTimer(dueTime, period);
            },
            ChangeTimer: function (dueTime, period) {
                this.ClearTimeout();
                return this.TimerSetup(this.timerCallback, this.state, dueTime, period);
            },
            ClearTimeout: function () {
                if (System.Nullable.hasValue(this.id)) {
                    Bridge.global.clearTimeout(System.Nullable.getValue(this.id));
                    this.id = null;
                }
            },
            Dispose: function () {
                this.ClearTimeout();
                this.disposed = true;
            }
        }
    });

    // @source TaskCanceledException.js

    Bridge.define("System.Threading.Tasks.TaskCanceledException", {
        inherits: [System.OperationCanceledException],
        fields: {
            _canceledTask: null
        },
        props: {
            Task: {
                get: function () {
                    return this._canceledTask;
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.OperationCanceledException.$ctor1.call(this, "A task was canceled.");
            },
            $ctor1: function (message) {
                this.$initialize();
                System.OperationCanceledException.$ctor1.call(this, message);
            },
            $ctor2: function (message, innerException) {
                this.$initialize();
                System.OperationCanceledException.$ctor2.call(this, message, innerException);
            },
            $ctor3: function (task) {
                this.$initialize();
                System.OperationCanceledException.$ctor4.call(this, "A task was canceled.", task != null ? new System.Threading.CancellationToken() : new System.Threading.CancellationToken());
                this._canceledTask = task;
            }
        }
    });

    // @source TaskSchedulerException.js

    Bridge.define("System.Threading.Tasks.TaskSchedulerException", {
        inherits: [System.Exception],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Exception.ctor.call(this, "An exception was thrown by a TaskScheduler.");
            },
            $ctor2: function (message) {
                this.$initialize();
                System.Exception.ctor.call(this, message);
            },
            $ctor1: function (innerException) {
                this.$initialize();
                System.Exception.ctor.call(this, "An exception was thrown by a TaskScheduler.", innerException);
            },
            $ctor3: function (message, innerException) {
                this.$initialize();
                System.Exception.ctor.call(this, message, innerException);
            }
        }
    });

    // @source Version.js

    Bridge.define("System.Version", {
        inherits: function () { return [System.ICloneable,System.IComparable$1(System.Version),System.IEquatable$1(System.Version)]; },
        statics: {
            fields: {
                separatorsArray: 0,
                ZERO_CHAR_VALUE: 0
            },
            ctors: {
                init: function () {
                    this.separatorsArray = 46;
                    this.ZERO_CHAR_VALUE = 48;
                }
            },
            methods: {
                appendPositiveNumber: function (num, sb) {
                    var index = sb.getLength();
                    var reminder;

                    do {
                        reminder = num % 10;
                        num = (Bridge.Int.div(num, 10)) | 0;
                        sb.insert(index, String.fromCharCode(((((System.Version.ZERO_CHAR_VALUE + reminder) | 0)) & 65535)));
                    } while (num > 0);
                },
                parse: function (input) {
                    if (input == null) {
                        throw new System.ArgumentNullException.$ctor1("input");
                    }

                    var r = { v : new System.Version.VersionResult() };
                    r.v.init("input", true);
                    if (!System.Version.tryParseVersion(input, r)) {
                        throw r.v.getVersionParseException();
                    }
                    return r.v.m_parsedVersion;
                },
                tryParse: function (input, result) {
                    var r = { v : new System.Version.VersionResult() };
                    r.v.init("input", false);
                    var b = System.Version.tryParseVersion(input, r);
                    result.v = r.v.m_parsedVersion;
                    return b;
                },
                tryParseVersion: function (version, result) {
                    var major = { }, minor = { }, build = { }, revision = { };

                    if (version == null) {
                        result.v.setFailure(System.Version.ParseFailureKind.ArgumentNullException);

                        return false;
                    }

                    var parsedComponents = System.String.split(version, [System.Version.separatorsArray].map(function (i) {{ return String.fromCharCode(i); }}));
                    var parsedComponentsLength = parsedComponents.length;

                    if ((parsedComponentsLength < 2) || (parsedComponentsLength > 4)) {
                        result.v.setFailure(System.Version.ParseFailureKind.ArgumentException);
                        return false;
                    }

                    if (!System.Version.tryParseComponent(parsedComponents[System.Array.index(0, parsedComponents)], "version", result, major)) {
                        return false;
                    }

                    if (!System.Version.tryParseComponent(parsedComponents[System.Array.index(1, parsedComponents)], "version", result, minor)) {
                        return false;
                    }

                    parsedComponentsLength = (parsedComponentsLength - 2) | 0;

                    if (parsedComponentsLength > 0) {
                        if (!System.Version.tryParseComponent(parsedComponents[System.Array.index(2, parsedComponents)], "build", result, build)) {
                            return false;
                        }

                        parsedComponentsLength = (parsedComponentsLength - 1) | 0;

                        if (parsedComponentsLength > 0) {
                            if (!System.Version.tryParseComponent(parsedComponents[System.Array.index(3, parsedComponents)], "revision", result, revision)) {
                                return false;
                            } else {
                                result.v.m_parsedVersion = new System.Version.$ctor3(major.v, minor.v, build.v, revision.v);
                            }
                        } else {
                            result.v.m_parsedVersion = new System.Version.$ctor2(major.v, minor.v, build.v);
                        }
                    } else {
                        result.v.m_parsedVersion = new System.Version.$ctor1(major.v, minor.v);
                    }

                    return true;
                },
                tryParseComponent: function (component, componentName, result, parsedComponent) {
                    if (!System.Int32.tryParse(component, parsedComponent)) {
                        result.v.setFailure$1(System.Version.ParseFailureKind.FormatException, component);
                        return false;
                    }

                    if (parsedComponent.v < 0) {
                        result.v.setFailure$1(System.Version.ParseFailureKind.ArgumentOutOfRangeException, componentName);
                        return false;
                    }

                    return true;
                },
                op_Equality: function (v1, v2) {
                    if (Bridge.referenceEquals(v1, null)) {
                        return Bridge.referenceEquals(v2, null);
                    }

                    return v1.equalsT(v2);
                },
                op_Inequality: function (v1, v2) {
                    return !(System.Version.op_Equality(v1, v2));
                },
                op_LessThan: function (v1, v2) {
                    if (v1 == null) {
                        throw new System.ArgumentNullException.$ctor1("v1");
                    }

                    return (v1.compareTo(v2) < 0);
                },
                op_LessThanOrEqual: function (v1, v2) {
                    if (v1 == null) {
                        throw new System.ArgumentNullException.$ctor1("v1");
                    }

                    return (v1.compareTo(v2) <= 0);
                },
                op_GreaterThan: function (v1, v2) {
                    return (System.Version.op_LessThan(v2, v1));
                },
                op_GreaterThanOrEqual: function (v1, v2) {
                    return (System.Version.op_LessThanOrEqual(v2, v1));
                }
            }
        },
        fields: {
            _Major: 0,
            _Minor: 0,
            _Build: 0,
            _Revision: 0
        },
        props: {
            Major: {
                get: function () {
                    return this._Major;
                }
            },
            Minor: {
                get: function () {
                    return this._Minor;
                }
            },
            Build: {
                get: function () {
                    return this._Build;
                }
            },
            Revision: {
                get: function () {
                    return this._Revision;
                }
            },
            MajorRevision: {
                get: function () {
                    return Bridge.Int.sxs((this._Revision >> 16) & 65535);
                }
            },
            MinorRevision: {
                get: function () {
                    return Bridge.Int.sxs((this._Revision & 65535) & 65535);
                }
            }
        },
        alias: [
            "clone", "System$ICloneable$clone",
            "compareTo", ["System$IComparable$1$System$Version$compareTo", "System$IComparable$1$compareTo"],
            "equalsT", "System$IEquatable$1$System$Version$equalsT"
        ],
        ctors: {
            init: function () {
                this._Build = -1;
                this._Revision = -1;
            },
            $ctor3: function (major, minor, build, revision) {
                this.$initialize();
                if (major < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("major", "Cannot be < 0");
                }

                if (minor < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("minor", "Cannot be < 0");
                }

                if (build < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("build", "Cannot be < 0");
                }

                if (revision < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("revision", "Cannot be < 0");
                }

                this._Major = major;
                this._Minor = minor;
                this._Build = build;
                this._Revision = revision;
            },
            $ctor2: function (major, minor, build) {
                this.$initialize();
                if (major < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("major", "Cannot be < 0");
                }

                if (minor < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("minor", "Cannot be < 0");
                }

                if (build < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("build", "Cannot be < 0");
                }

                this._Major = major;
                this._Minor = minor;
                this._Build = build;
            },
            $ctor1: function (major, minor) {
                this.$initialize();
                if (major < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("major", "Cannot be < 0");
                }

                if (minor < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("minor", "Cannot be < 0");
                }

                this._Major = major;
                this._Minor = minor;
            },
            $ctor4: function (version) {
                this.$initialize();
                var v = System.Version.parse(version);
                this._Major = v.Major;
                this._Minor = v.Minor;
                this._Build = v.Build;
                this._Revision = v.Revision;
            },
            ctor: function () {
                this.$initialize();
                this._Major = 0;
                this._Minor = 0;
            }
        },
        methods: {
            clone: function () {
                var v = new System.Version.ctor();
                v._Major = this._Major;
                v._Minor = this._Minor;
                v._Build = this._Build;
                v._Revision = this._Revision;
                return (v);
            },
            compareTo$1: function (version) {
                if (version == null) {
                    return 1;
                }

                var v = Bridge.as(version, System.Version);
                if (System.Version.op_Equality(v, null)) {
                    throw new System.ArgumentException.$ctor1("version should be of System.Version type");
                }

                if (this._Major !== v._Major) {
                    if (this._Major > v._Major) {
                        return 1;
                    } else {
                        return -1;
                    }
                }

                if (this._Minor !== v._Minor) {
                    if (this._Minor > v._Minor) {
                        return 1;
                    } else {
                        return -1;
                    }
                }

                if (this._Build !== v._Build) {
                    if (this._Build > v._Build) {
                        return 1;
                    } else {
                        return -1;
                    }
                }

                if (this._Revision !== v._Revision) {
                    if (this._Revision > v._Revision) {
                        return 1;
                    } else {
                        return -1;
                    }
                }

                return 0;
            },
            compareTo: function (value) {
                if (System.Version.op_Equality(value, null)) {
                    return 1;
                }

                if (this._Major !== value._Major) {
                    if (this._Major > value._Major) {
                        return 1;
                    } else {
                        return -1;
                    }
                }

                if (this._Minor !== value._Minor) {
                    if (this._Minor > value._Minor) {
                        return 1;
                    } else {
                        return -1;
                    }
                }

                if (this._Build !== value._Build) {
                    if (this._Build > value._Build) {
                        return 1;
                    } else {
                        return -1;
                    }
                }

                if (this._Revision !== value._Revision) {
                    if (this._Revision > value._Revision) {
                        return 1;
                    } else {
                        return -1;
                    }
                }

                return 0;
            },
            equals: function (obj) {
                return this.equalsT(Bridge.as(obj, System.Version));
            },
            equalsT: function (obj) {
                if (System.Version.op_Equality(obj, null)) {
                    return false;
                }

                if ((this._Major !== obj._Major) || (this._Minor !== obj._Minor) || (this._Build !== obj._Build) || (this._Revision !== obj._Revision)) {
                    return false;
                }

                return true;
            },
            getHashCode: function () {

                var accumulator = 0;

                accumulator = accumulator | ((this._Major & 15) << 28);
                accumulator = accumulator | ((this._Minor & 255) << 20);
                accumulator = accumulator | ((this._Build & 255) << 12);
                accumulator = accumulator | (this._Revision & 4095);

                return accumulator;
            },
            toString: function () {
                if (this._Build === -1) {
                    return (this.toString$1(2));
                }
                if (this._Revision === -1) {
                    return (this.toString$1(3));
                }
                return (this.toString$1(4));
            },
            toString$1: function (fieldCount) {
                var sb;
                switch (fieldCount) {
                    case 0: 
                        return ("");
                    case 1: 
                        return (Bridge.toString(this._Major));
                    case 2: 
                        sb = new System.Text.StringBuilder();
                        System.Version.appendPositiveNumber(this._Major, sb);
                        sb.append(String.fromCharCode(46));
                        System.Version.appendPositiveNumber(this._Minor, sb);
                        return sb.toString();
                    default: 
                        if (this._Build === -1) {
                            throw new System.ArgumentException.$ctor3("Build should be > 0 if fieldCount > 2", "fieldCount");
                        }
                        if (fieldCount === 3) {
                            sb = new System.Text.StringBuilder();
                            System.Version.appendPositiveNumber(this._Major, sb);
                            sb.append(String.fromCharCode(46));
                            System.Version.appendPositiveNumber(this._Minor, sb);
                            sb.append(String.fromCharCode(46));
                            System.Version.appendPositiveNumber(this._Build, sb);
                            return sb.toString();
                        }
                        if (this._Revision === -1) {
                            throw new System.ArgumentException.$ctor3("Revision should be > 0 if fieldCount > 3", "fieldCount");
                        }
                        if (fieldCount === 4) {
                            sb = new System.Text.StringBuilder();
                            System.Version.appendPositiveNumber(this._Major, sb);
                            sb.append(String.fromCharCode(46));
                            System.Version.appendPositiveNumber(this._Minor, sb);
                            sb.append(String.fromCharCode(46));
                            System.Version.appendPositiveNumber(this._Build, sb);
                            sb.append(String.fromCharCode(46));
                            System.Version.appendPositiveNumber(this._Revision, sb);
                            return sb.toString();
                        }
                        throw new System.ArgumentException.$ctor3("Should be < 5", "fieldCount");
                }
            }
        }
    });

    // @source ParseFailureKind.js

    Bridge.define("System.Version.ParseFailureKind", {
        $kind: "nested enum",
        statics: {
            fields: {
                ArgumentNullException: 0,
                ArgumentException: 1,
                ArgumentOutOfRangeException: 2,
                FormatException: 3
            }
        }
    });

    // @source VersionResult.js

    Bridge.define("System.Version.VersionResult", {
        $kind: "nested struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new System.Version.VersionResult(); }
            }
        },
        fields: {
            m_parsedVersion: null,
            m_failure: 0,
            m_exceptionArgument: null,
            m_argumentName: null,
            m_canThrow: false
        },
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            init: function (argumentName, canThrow) {
                this.m_canThrow = canThrow;
                this.m_argumentName = argumentName;
            },
            setFailure: function (failure) {
                this.setFailure$1(failure, "");
            },
            setFailure$1: function (failure, argument) {
                this.m_failure = failure;
                this.m_exceptionArgument = argument;
                if (this.m_canThrow) {
                    throw this.getVersionParseException();
                }
            },
            getVersionParseException: function () {
                switch (this.m_failure) {
                    case System.Version.ParseFailureKind.ArgumentNullException: 
                        return new System.ArgumentNullException.$ctor1(this.m_argumentName);
                    case System.Version.ParseFailureKind.ArgumentException: 
                        return new System.ArgumentException.$ctor1("VersionString");
                    case System.Version.ParseFailureKind.ArgumentOutOfRangeException: 
                        return new System.ArgumentOutOfRangeException.$ctor4(this.m_exceptionArgument, "Cannot be < 0");
                    case System.Version.ParseFailureKind.FormatException: 
                        try {
                            System.Int32.parse(this.m_exceptionArgument);
                        } catch ($e1) {
                            $e1 = System.Exception.create($e1);
                            var e;
                            if (Bridge.is($e1, System.FormatException)) {
                                e = $e1;
                                return e;
                            } else if (Bridge.is($e1, System.OverflowException)) {
                                e = $e1;
                                return e;
                            } else {
                                throw $e1;
                            }
                        }
                        return new System.FormatException.$ctor1("InvalidString");
                    default: 
                        return new System.ArgumentException.$ctor1("VersionString");
                }
            },
            getHashCode: function () {
                var h = Bridge.addHash([5139482776, this.m_parsedVersion, this.m_failure, this.m_exceptionArgument, this.m_argumentName, this.m_canThrow]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, System.Version.VersionResult)) {
                    return false;
                }
                return Bridge.equals(this.m_parsedVersion, o.m_parsedVersion) && Bridge.equals(this.m_failure, o.m_failure) && Bridge.equals(this.m_exceptionArgument, o.m_exceptionArgument) && Bridge.equals(this.m_argumentName, o.m_argumentName) && Bridge.equals(this.m_canThrow, o.m_canThrow);
            },
            $clone: function (to) {
                var s = to || new System.Version.VersionResult();
                s.m_parsedVersion = this.m_parsedVersion;
                s.m_failure = this.m_failure;
                s.m_exceptionArgument = this.m_exceptionArgument;
                s.m_argumentName = this.m_argumentName;
                s.m_canThrow = this.m_canThrow;
                return s;
            }
        }
    });

    // @source End.js

    // module export
    if (typeof define === "function" && define.amd) {
        // AMD
        define("bridge", [], function () { return Bridge; });
    } else if (typeof module !== "undefined" && module.exports) {
        // Node
        module.exports = Bridge;
    }

    // @source Finally.js

})(this);
