-- Generated by CSharp.lua Compiler 1.0.0.0
local System = System;
local Linq = System.Linq.Enumerable;
local MicrosoftCodeAnalysis = Microsoft.CodeAnalysis;
local MicrosoftCodeAnalysisCSharp = Microsoft.CodeAnalysis.CSharp;
local MicrosoftCodeAnalysisCSharpSyntax = Microsoft.CodeAnalysis.CSharp.Syntax;
local SystemCollectionsImmutable = System.Collections.Immutable;
local SystemTextRegularExpressions = System.Text.RegularExpressions;
local CSharpLua;
local CSharpLuaLuaAst;
local CSharpLuaLuaSyntaxNodeTransfor;
local CSharpLuaLuaSyntaxNodeTransforLuaSyntaxSearcher;
System.usingDeclare(function (global) 
    CSharpLua = global.CSharpLua;
    CSharpLuaLuaAst = CSharpLua.LuaAst;
    CSharpLuaLuaSyntaxNodeTransfor = CSharpLua.LuaSyntaxNodeTransfor;
    CSharpLuaLuaSyntaxNodeTransforLuaSyntaxSearcher = CSharpLua.LuaSyntaxNodeTransfor.LuaSyntaxSearcher;
end);
System.namespace("CSharpLua", function (namespace) 
    namespace.class("LuaSyntaxNodeTransfor", function (namespace) 
        namespace.class("BlockCommonNode", function (namespace) 
            local CompareTo, Contains, Visit, __ctor1__, __ctor2__;
            CompareTo = function (this, other) 
                return this.LineSpan:getStartLinePosition():CompareTo(other.LineSpan:getStartLinePosition());
            end;
            Contains = function (this, other) 
                local otherLineSpan = other.LineSpan;
                return otherLineSpan:getStartLinePosition() > this.LineSpan:getStartLinePosition() and otherLineSpan:getEndLinePosition() < this.LineSpan:getEndLinePosition();
            end;
            Visit = function (this, transfor, block, lastLine) 
                if lastLine ~= - 1 then
                    local count = this.LineSpan:getStartLinePosition():getLine() - lastLine - 1;
                    if count > 0 then
                        block.Statements:Add1(CSharpLuaLuaAst.LuaBlankLinesStatement:new(1, count));
                    end
                end

                if this.Statement ~= nil then
                    local statementNode = System.cast(CSharpLuaLuaAst.LuaStatementSyntax, this.Statement:Accept(transfor, CSharpLuaLuaAst.LuaSyntaxNode));
                    block.Statements:Add1(statementNode);
                else
                    local content = this.Comment:ToString();
                    if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(this.Comment, 8541 --[[SyntaxKind.SingleLineCommentTrivia]]) then
                        local commentContent = content:Substring(2 --[[BlockCommonNode.kCommentCharCount]]);
                        local singleComment = CSharpLuaLuaAst.LuaShortCommentStatement(commentContent);
                        block.Statements:Add1(singleComment);
                    else
                        local commentContent = content:Substring(2 --[[BlockCommonNode.kCommentCharCount]], #content - 2 --[[BlockCommonNode.kCommentCharCount]] - 2 --[[BlockCommonNode.kCommentCharCount]]);
                        local longComment = CSharpLuaLuaAst.LuaLongCommentStatement(commentContent);
                        block.Statements:Add1(longComment);
                    end
                end

                lastLine = this.LineSpan:getEndLinePosition():getLine();
            end;
            __ctor1__ = function (this, comment) 
                this.Comment = comment;
                this.LineSpan = comment:getSyntaxTree():GetLineSpan(comment:getSpan());
            end;
            __ctor2__ = function (this, statement) 
                this.Statement = statement;
                this.LineSpan = statement:getSyntaxTree():GetLineSpan(statement:getSpan());
            end;
            return {
                __inherits__ = function () 
                    return {
                        System.IComparable_1(CSharpLuaLuaSyntaxNodeTransfor.BlockCommonNode)
                    };
                end, 
                Comment = System.default(MicrosoftCodeAnalysis.SyntaxTrivia), 
                LineSpan = System.default(MicrosoftCodeAnalysis.FileLinePositionSpan), 
                CompareTo = CompareTo, 
                Contains = Contains, 
                Visit = Visit, 
                __ctor__ = {
                    __ctor1__, 
                    __ctor2__
                }
            };
        end);
        local operatorTokenMapps_, getXmlMetaProvider, GetOperatorToken, getIsLuaNewest, getCurCompilationUnit, getCurType, getCurFunction, getCurFunctionOrNull, 
        PushFunction, PopFunction, getCurBlock, VisitCompilationUnit, VisitNamespaceDeclaration, BuildTypeMembers, CheckBaseTypeGenericKind, BuildTypeDeclaration, 
        VisitTypeDeclaration, AcceptPartialType, GetTypeDeclarationName, VisitClassDeclaration, VisitStructDeclaration, VisitInterfaceDeclaration, VisitEnumDeclaration, VisitYield, 
        VisitMethodDeclaration, GetPredefinedTypeDefaultValue, GetTempIdentifier, BuildDefaultValueExpression, VisitBaseFieldDeclarationSyntax, VisitFieldDeclaration, GetFieldValueExpression, AddField, 
        VisitPropertyDeclaration, VisitEventDeclaration, VisitEventFieldDeclaration, VisitEnumMemberDeclaration, VisitIndexerDeclaration, VisitBracketedParameterList, VisitParameterList, BuildParameterList, 
        VisitParameter, VisitBlock, VisitReturnStatement, VisitExpressionStatement, BuildCommonAssignmentExpression, BuildDelegateAssignmentExpression, BuildLuaAssignmentExpression, VisitAssignmentExpression, 
        BuildInvokeRefOrOut, CheckCodeTemplateInvocationExpression, VisitInvocationExpression, BuildExtensionMethodInvocation, AddInvocationTypeArguments, CheckInvocationCallerAttribute, BuildMemberAccessTargetExpression, CheckMemberAccessCodeTemplate, 
        VisitMemberAccessExpression, BuildStaticFieldName, IsInternalNode, VisitFieldOrEventIdentifierName, GetMethodNameExpression, VisitIdentifierName, VisitQualifiedName, BuildArgumentList, 
        VisitArgumentList, VisitArgument, VisitLiteralExpression, VisitLocalDeclarationStatement, VisitVariableDeclaration, VisitVariableDeclarator, VisitEqualsValueClause, VisitPredefinedType, 
        WriteStatementOrBlock, VisitIfStatement, VisitElseClause, VisitSwitchStatement, VisitSwitchSection, VisitCaseSwitchLabel, VisitBreakStatement, WrapStringConcatExpression, 
        BuildStringConcatExpression, BuildStringConcatExpression1, BuildBinaryInvokeExpression, BuildIntegerDivExpression, BuildBinaryExpression, BuildBitExpression, VisitBinaryExpression, GetLuaAssignmentExpressionSyntax, 
        VisitPrefixUnaryExpression, VisitPostfixUnaryExpression, VisitContinueStatement, VisitLoopBody, VisitForEachStatement, VisitWhileStatement, VisitForStatement, VisitDoStatement, 
        VisitYieldStatement, VisitParenthesizedExpression, VisitConditionalExpression, VisitGotoStatement, VisitLabeledStatement, VisitEmptyStatement, VisitCastExpression, VisitCheckedStatement, 
        VisitCheckedExpression, codeTemplateRegex_, IsLocalVarExists, GetNewIdentifierName, FindFromCur, FindParent, FindParent1, GetUniqueIdentifier, 
        CheckReservedWord, AddReservedMapping, CheckParameterName, CheckVariableDeclaratorName, CheckReservedWord1, GetConstructorIndex, IsContinueExists, IsReturnExists, 
        GetCaseLabelIndex, BuildCodeTemplateExpression, AddCodeTemplateExpression, BuildCodeTemplateExpression1, IsPropertyField, GetTypeDeclarationSymbol, IsInternalMember, BuildEmptyArray, 
        GetConstLiteralExpression, GetConstLiteralExpression1, BuildStringLiteralTokenExpression, BuildStringLiteralExpression, BuildVerbatimStringExpression, GetCallerAttributeKind, GetCallerAttributeKind1, IsCallerAttribute, 
        CheckCallerAttribute, CheckUsingStaticNameSyntax, MayBeFalse, MayBeNull, MayBeNullOrFalse, ImportTypeName, GetTypeShortName, GetTypeName, 
        VisitObjectCreationExpression, BuildObjectInitializerExpression, VisitInitializerExpression, VisitBracketedArgumentList, VisitImplicitElementAccess, VisitGenericName, VisitOmittedArraySizeExpression, VisitArrayRankSpecifier, 
        VisitArrayType, FillMultiArrayInitializer, VisitArrayCreationExpression, VisitImplicitArrayCreationExpression, VisitConstructorDeclaration, VisitSimpleBaseType, VisitLambdaExpression, VisitSimpleLambdaExpression, 
        VisitParenthesizedLambdaExpression, VisitTypeParameter, VisitTypeOfExpression, VisitThrowStatement, VisitCatchFilterClause, VisitCatchClause, VisitCatchDeclaration, VisitTryCatchesExpress, 
        BuildCheckReturnInvocationExpression, VisitFinallyClause, VisitTryStatement, VisitUsingStatement, VisitThisExpression, IsBaseEnable, VisitBaseExpression, VisitConditionalAccessExpression, 
        VisitMemberBindingExpression, VisitElementBindingExpression, VisitDefaultExpression, VisitElementAccessExpression, VisitInterpolatedStringExpression, VisitInterpolation, VisitInterpolatedStringText, __staticCtor__, 
        __init__, __ctor__;
        getXmlMetaProvider = function (this) 
            return this.generator_.XmlMetaProvider;
        end;
        GetOperatorToken = function (operatorToken) 
            local token = operatorToken:getValueText();
            return CSharpLua.Utility.GetOrDefault1(operatorTokenMapps_, token, token, System.String, System.String);
        end;
        getIsLuaNewest = function (this) 
            return this.generator_.Setting.IsNewest;
        end;
        getCurCompilationUnit = function (this) 
            return this.compilationUnits_:Peek();
        end;
        getCurType = function (this) 
            return this.typeDeclarations_:Peek();
        end;
        getCurFunction = function (this) 
            return this.functions_:Peek();
        end;
        getCurFunctionOrNull = function (this) 
            local default;
            if #this.functions_ > 0 then
                default = this.functions_:Peek();
            else
                default = nil;
            end
            return default;
        end;
        PushFunction = function (this, function_) 
            this.functions_:Push(function_);
            this.localMappingCounter_ = this.localMappingCounter_ + 1;
        end;
        PopFunction = function (this) 
            this.functions_:Pop();
            this.localMappingCounter_ = this.localMappingCounter_ - 1;
            if this.localMappingCounter_ == 0 then
                this.localReservedNames_:Clear();
            end
        end;
        getCurBlock = function (this) 
            return this.blocks_:Peek();
        end;
        VisitCompilationUnit = function (this, node) 
            local compilationUnit = System.create(CSharpLuaLuaAst.LuaCompilationUnitSyntax(), function (default) 
                default.FilePath = node:getSyntaxTree():getFilePath();
            end);
            this.compilationUnits_:Push(compilationUnit);
            for _, member in System.each(node:getMembers()) do
                local memberNode = System.cast(CSharpLuaLuaAst.LuaStatementSyntax, member:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                local typeDeclaration = System.as(memberNode, CSharpLuaLuaAst.LuaTypeDeclarationSyntax);
                if typeDeclaration ~= nil then
                    compilationUnit:AddTypeDeclaration(typeDeclaration);
                else
                    compilationUnit.Statements:Add1(memberNode);
                end
            end
            this.compilationUnits_:Pop();
            return compilationUnit;
        end;
        VisitNamespaceDeclaration = function (this, node) 
            local name = System.cast(CSharpLuaLuaAst.LuaIdentifierNameSyntax, node:getName():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
            local namespaceDeclaration = CSharpLuaLuaAst.LuaNamespaceDeclarationSyntax(name);
            for _, member in System.each(node:getMembers()) do
                local memberNode = System.cast(CSharpLuaLuaAst.LuaWrapFunctionStatementSynatx, member:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                namespaceDeclaration:AddMemberDeclaration(memberNode);
            end
            return namespaceDeclaration;
        end;
        BuildTypeMembers = function (this, typeDeclaration, node) 
            if not MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node, 8857 --[[SyntaxKind.InterfaceDeclaration]]) then
                for _, member in System.each(node:getMembers()) do
                    local newMember = member:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode);
                    local kind = member:Kind();
                    if kind >= 8855 --[[SyntaxKind.ClassDeclaration]] and kind <= 8858 --[[SyntaxKind.EnumDeclaration]] then
                        typeDeclaration:AddMemberDeclaration(System.cast(CSharpLuaLuaAst.LuaWrapFunctionStatementSynatx, newMember));
                    end
                end
            end
        end;
        CheckBaseTypeGenericKind = function (this, kind, typeSymbol, baseType) 
            if kind ~= 2 --[[BaseTypeGenericKind.ExtendSelf]] then
                if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(baseType, 8865 --[[SyntaxKind.SimpleBaseType]]) then
                    local baseNode = System.cast(MicrosoftCodeAnalysisCSharpSyntax.SimpleBaseTypeSyntax, baseType);
                    if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(baseNode:getType(), 8618 --[[SyntaxKind.GenericName]]) then
                        local baseGenericNameNode = System.cast(MicrosoftCodeAnalysisCSharpSyntax.GenericNameSyntax, baseNode:getType());
                        local baseTypeSymbol = System.cast(MicrosoftCodeAnalysis.INamedTypeSymbol, MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, baseGenericNameNode):getType());
                        for _, baseTypeArgument in System.each(baseTypeSymbol:getTypeArguments()) do
                            if baseTypeSymbol:getKind() ~= 17 --[[SymbolKind.TypeParameter]] then
                                if baseTypeArgument:Equals(typeSymbol) then
                                    if kind == 0 --[[BaseTypeGenericKind.None]] then
                                        kind = 1 --[[BaseTypeGenericKind.HasSelf]];
                                    end
                                elseif CSharpLua.Utility.IsAssignableFrom(typeSymbol, baseTypeArgument) then
                                    if kind ~= 2 --[[BaseTypeGenericKind.ExtendSelf]] then
                                        kind = 2 --[[BaseTypeGenericKind.ExtendSelf]];
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end;
        BuildTypeDeclaration = function (this, typeSymbol, node, typeDeclaration) 
            this.typeDeclarations_:Push(typeDeclaration);
            if node:getTypeParameterList() ~= nil then
                for _, typeParameter in System.each(node:getTypeParameterList():getParameters()) do
                    local typeIdentifier = System.cast(CSharpLuaLuaAst.LuaIdentifierNameSyntax, typeParameter:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                    typeDeclaration:AddTypeIdentifier(typeIdentifier);
                end
            end
            if node:getBaseList() ~= nil then
                local baseTypeGenericKind = 0 --[[BaseTypeGenericKind.None]];
                local baseTypes = System.List(CSharpLuaLuaAst.LuaExpressionSyntax)();
                for _, baseType in System.each(node:getBaseList():getTypes()) do
                    local baseTypeName = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, baseType:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                    baseTypes:Add(baseTypeName);
                    baseTypeGenericKind = CheckBaseTypeGenericKind(this, baseTypeGenericKind, typeSymbol, baseType);
                end
                typeDeclaration:AddBaseTypes(baseTypes, baseTypeGenericKind);
            end
            BuildTypeMembers(this, typeDeclaration, node);
            this.typeDeclarations_:Pop();
            getCurCompilationUnit(this):AddTypeDeclarationCount();
        end;
        VisitTypeDeclaration = function (this, node, typeDeclaration) 
            local typeSymbol = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetDeclaredSymbol(this.semanticModel_, node);
            if CSharpLua.Utility.IsPartial(node:getModifiers()) then
                if not typeSymbol:getDeclaringSyntaxReferences():getIsEmpty() then
                    this.generator_:AddPartialTypeDeclaration(typeSymbol, node, typeDeclaration, getCurCompilationUnit(this));
                    typeDeclaration.IsPartialMark = true;
                else
                    BuildTypeDeclaration(this, typeSymbol, node, typeDeclaration);
                end
            else
                BuildTypeDeclaration(this, typeSymbol, node, typeDeclaration);
            end
            this.generator_:AddTypeSymbol(typeSymbol);
        end;
        AcceptPartialType = function (this, major, typeDeclarations) 
            major.LuaNode.IsPartialMark = false;
            major.CompilationUnit:AddTypeDeclarationCount();

            this.compilationUnits_:Push(major.CompilationUnit);
            this.typeDeclarations_:Push(major.LuaNode);

            if major.Node:getTypeParameterList() ~= nil then
                for _, typeParameter in System.each(major.Node:getTypeParameterList():getParameters()) do
                    local typeIdentifier = System.cast(CSharpLuaLuaAst.LuaIdentifierNameSyntax, typeParameter:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                    major.LuaNode:AddTypeIdentifier(typeIdentifier);
                end
            end

            local baseTypes = Linq.ToList(Linq.SelectMany(typeDeclarations, function (i) 
                local default;
                if i.Node:getBaseList() ~= nil then
                    default = System.cast(System.IEnumerable_1(MicrosoftCodeAnalysisCSharpSyntax.BaseTypeSyntax), i.Node:getBaseList():getTypes());
                else
                    default = System.Array.Empty(MicrosoftCodeAnalysisCSharpSyntax.BaseTypeSyntax);
                end
                return default;
            end, MicrosoftCodeAnalysisCSharpSyntax.BaseTypeSyntax));
            if #baseTypes > 0 then
                if #baseTypes > 1 then
                    local baseTypeIndex = baseTypes:FindIndex(this.generator_:IsBaseType);
                    if baseTypeIndex > 0 then
                        local baseType = baseTypes:get(baseTypeIndex);
                        baseTypes:RemoveAt(baseTypeIndex);
                        baseTypes:Insert(0, baseType);
                    end
                end

                local baseTypeGenericKind = 0 --[[BaseTypeGenericKind.None]];
                local baseTypeExpressions = System.List(CSharpLuaLuaAst.LuaExpressionSyntax)();
                for _, baseType in System.each(baseTypes) do
                    this.semanticModel_ = this.generator_:GetSemanticModel(baseType:getSyntaxTree());
                    local baseTypeName = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, baseType:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                    baseTypeExpressions:Add(baseTypeName);
                    baseTypeGenericKind = CheckBaseTypeGenericKind(this, baseTypeGenericKind, major.Symbol, baseType);
                end
                major.LuaNode:AddBaseTypes(baseTypeExpressions, 0 --[[BaseTypeGenericKind.None]]);
            end

            for _, typeDeclaration in System.each(typeDeclarations) do
                this.semanticModel_ = this.generator_:GetSemanticModel(typeDeclaration.Node:getSyntaxTree());
                BuildTypeMembers(this, typeDeclaration.LuaNode, typeDeclaration.Node);
            end

            this.typeDeclarations_:Pop();
            this.compilationUnits_:Pop();
        end;
        GetTypeDeclarationName = function (this, typeDeclaration) 
            local name = typeDeclaration:getIdentifier():getValueText();
            if typeDeclaration:getTypeParameterList() ~= nil then
                name = name .. "_" .. typeDeclaration:getTypeParameterList():getParameters():getCount();
            end
            return CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, name);
        end;
        VisitClassDeclaration = function (this, node) 
            local name = GetTypeDeclarationName(this, node);
            local classDeclaration = CSharpLuaLuaAst.LuaClassDeclarationSyntax(name);
            VisitTypeDeclaration(this, node, classDeclaration);
            return classDeclaration;
        end;
        VisitStructDeclaration = function (this, node) 
            local name = GetTypeDeclarationName(this, node);
            local structDeclaration = CSharpLuaLuaAst.LuaStructDeclarationSyntax(name);
            VisitTypeDeclaration(this, node, structDeclaration);
            return structDeclaration;
        end;
        VisitInterfaceDeclaration = function (this, node) 
            local name = GetTypeDeclarationName(this, node);
            local interfaceDeclaration = CSharpLuaLuaAst.LuaInterfaceDeclarationSyntax(name);
            VisitTypeDeclaration(this, node, interfaceDeclaration);
            return interfaceDeclaration;
        end;
        VisitEnumDeclaration = function (this, node) 
            local symbol = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetDeclaredSymbol(this.semanticModel_, node);
            local name = CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, node:getIdentifier():getValueText());
            local enumDeclaration = CSharpLuaLuaAst.LuaEnumDeclarationSyntax(symbol:ToString(), name, getCurCompilationUnit(this));
            this.typeDeclarations_:Push(enumDeclaration);
            for _, member in System.each(node:getMembers()) do
                local statement = System.cast(CSharpLuaLuaAst.LuaKeyValueTableItemSyntax, member:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                enumDeclaration:Add(statement);
            end
            this.typeDeclarations_:Pop();
            this.generator_:AddTypeSymbol(symbol);
            this.generator_:AddEnumDeclaration(enumDeclaration);
            return enumDeclaration;
        end;
        VisitYield = function (this, node, function_) 
            assert(function_.HasYield);

            local nameSyntax = System.cast(MicrosoftCodeAnalysisCSharpSyntax.SimpleNameSyntax, node:getReturnType());
            local name = "yield" --[[Tokens.Yield]] .. (nameSyntax:getIdentifier():getValueText() or "");
            local memberAccess = CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(CSharpLuaLuaAst.LuaIdentifierNameSyntax.System, CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, name));
            local invokeExpression = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(1, memberAccess);
            local wrapFunction = CSharpLuaLuaAst.LuaFunctionExpressionSyntax();

            local parameters = function_.ParameterList.Parameters;
            wrapFunction.ParameterList.Parameters:AddRange1(parameters);
            wrapFunction:AddStatements(function_.Body.Statements);
            invokeExpression:AddArgument(wrapFunction);
            if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getReturnType(), 8618 --[[SyntaxKind.GenericName]]) then
                local genericNameSyntax = System.cast(MicrosoftCodeAnalysisCSharpSyntax.GenericNameSyntax, nameSyntax);
                local typeName = genericNameSyntax:getTypeArgumentList():getArguments():First();
                local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, typeName:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                invokeExpression:AddArgument(expression);
            else
                invokeExpression:AddArgument(CSharpLuaLuaAst.LuaIdentifierNameSyntax.Object);
            end
            invokeExpression.ArgumentList.Arguments:AddRange1(Linq.Select(parameters, function (i) return CSharpLuaLuaAst.LuaArgumentSyntax(i.Identifier); end, CSharpLuaLuaAst.LuaArgumentSyntax));

            local returnStatement = CSharpLuaLuaAst.LuaReturnStatementSyntax:new(1, invokeExpression);
            function_.Body.Statements:Clear();
            function_:AddStatement(returnStatement);
        end;
        VisitMethodDeclaration = function (this, node) 
            if not CSharpLua.Utility.IsAbstract(node:getModifiers()) then
                local symbol = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetDeclaredSymbol(this.semanticModel_, node);
                local methodName = this.generator_:GetMethodName(symbol);
                local function_ = CSharpLuaLuaAst.LuaFunctionExpressionSyntax();
                PushFunction(this, function_);
                if not CSharpLua.Utility.IsStatic(node:getModifiers()) then
                    function_:AddParameter(CSharpLuaLuaAst.LuaIdentifierNameSyntax.This);
                end

                for _, parameter in System.each(node:getParameterList():getParameters()) do
                    local luaParameter = System.cast(CSharpLuaLuaAst.LuaParameterSyntax, parameter:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                    luaParameter = CheckParameterName(this, luaParameter, parameter);
                    function_.ParameterList.Parameters:Add1(luaParameter);
                    if parameter:getDefault() ~= nil then
                        if not MicrosoftCodeAnalysis.CSharpExtensions.IsKind(parameter:getDefault():getValue(), 8754 --[[SyntaxKind.NullLiteralExpression]]) then
                            local attributes = Linq.SelectMany(parameter:getAttributeLists(), function (i) return i:getAttributes(); end, MicrosoftCodeAnalysisCSharpSyntax.AttributeSyntax);
                            local hasCaller = Linq.Any(attributes, IsCallerAttribute);
                            if not hasCaller then
                                local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, parameter:getDefault():getValue():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                                local intiStatement = CSharpLuaLuaAst.LuaMethodParameterDefaultValueStatementSyntax(luaParameter.Identifier, expression);
                                function_:AddStatement(intiStatement);
                            end
                        end
                    else
                        if CSharpLua.Utility.IsParams(parameter:getModifiers()) then
                            local typeName = System.cast(CSharpLuaLuaAst.LuaIdentifierNameSyntax, (System.cast(MicrosoftCodeAnalysisCSharpSyntax.ArrayTypeSyntax, parameter:getType())):getElementType():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                            local emptyArray = BuildEmptyArray(this, typeName);
                            local intiStatement = CSharpLuaLuaAst.LuaMethodParameterDefaultValueStatementSyntax(luaParameter.Identifier, emptyArray);
                            function_:AddStatement(intiStatement);
                        end
                    end
                end

                if node:getTypeParameterList() ~= nil then
                    for _, typeParameter in System.each(node:getTypeParameterList():getParameters()) do
                        local typeName = System.cast(CSharpLuaLuaAst.LuaIdentifierNameSyntax, typeParameter:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                        function_:AddParameter(typeName);
                    end
                end

                local block = System.cast(CSharpLuaLuaAst.LuaBlockSyntax, node:getBody():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                function_:AddStatements(block.Statements);
                if function_.HasYield then
                    VisitYield(this, node, function_);
                end
                PopFunction(this);
                getCurType(this):AddMethod(methodName, function_, CSharpLua.Utility.IsPrivate(symbol));
                return function_;
            end

            return MicrosoftCodeAnalysisCSharp.CSharpSyntaxVisitor_1(TResult).VisitMethodDeclaration(this, node);
        end;
        GetPredefinedTypeDefaultValue = function (typeSymbol) 
            repeat
                local default = typeSymbol:getSpecialType();
                if default == 7 --[[SpecialType.System_Boolean]] then
                    do
                        return CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, System.default(System.Boolean):ToString());
                    end
                elseif default == 8 --[[SpecialType.System_Char]] then
                    do
                        return CSharpLuaLuaAst.LuaCharacterLiteralExpression(System.default(System.Char));
                    end
                elseif default == 9 --[[SpecialType.System_SByte]] or default == 10 --[[SpecialType.System_Byte]] or default == 11 --[[SpecialType.System_Int16]] or default == 12 --[[SpecialType.System_UInt16]] or default == 13 --[[SpecialType.System_Int32]] or default == 14 --[[SpecialType.System_UInt32]] or default == 15 --[[SpecialType.System_Int64]] or default == 16 --[[SpecialType.System_UInt64]] then
                    do
                        return CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(2, 0);
                    end
                elseif default == 18 --[[SpecialType.System_Single]] or default == 19 --[[SpecialType.System_Double]] then
                    do
                        return CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, (0):ToString());
                    end
                else
                    return nil;
                end
            until 1;
        end;
        GetTempIdentifier = function (this, node) 
            local default = getCurFunction(this).TempIndex;
            getCurFunction(this).TempIndex = getCurFunction(this).TempIndex + 1;
            local index = default;
            local name = CSharpLua.Utility.GetOrDefault(CSharpLuaLuaAst.LuaSyntaxNode.TempIdentifiers, index, nil, System.String);
            if name == nil then
                System.throw(CSharpLua.CompilationErrorException((("{0} : Your code is startling, {1} "):Format(CSharpLua.Utility.GetLocationString(node), #CSharpLuaLuaAst.LuaSyntaxNode.TempIdentifiers) or "") .. "temporary variables is not enough, please refactor your code."));
            end
            return CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, name);
        end;
        BuildDefaultValueExpression = function (this, type) 
            local identifier = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, type:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
            return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(2, CSharpLuaLuaAst.LuaIdentifierNameSyntax.SystemDefault, identifier);
        end;
        VisitBaseFieldDeclarationSyntax = function (this, node) 
            if not CSharpLua.Utility.IsConst(node:getModifiers()) then
                local isStatic = CSharpLua.Utility.IsStatic(node:getModifiers());
                local isPrivate = CSharpLua.Utility.IsPrivate1(node:getModifiers());
                local isReadOnly = CSharpLua.Utility.IsReadOnly(node:getModifiers());
                local type = node:getDeclaration():getType();
                local typeSymbol = System.cast(MicrosoftCodeAnalysis.ITypeSymbol, MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetSymbolInfo(this.semanticModel_, type):getSymbol());
                local isImmutable = CSharpLua.Utility.IsImmutable(typeSymbol);
                for _, variable in System.each(node:getDeclaration():getVariables()) do
                    local continue;
                    repeat
                        if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node, 8874 --[[SyntaxKind.EventFieldDeclaration]]) then
                            local eventSymbol = System.cast(MicrosoftCodeAnalysis.IEventSymbol, MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetDeclaredSymbol(this.semanticModel_, variable));
                            if CSharpLua.Utility.IsOverridable(eventSymbol) or CSharpLua.Utility.IsInterfaceImplementation(eventSymbol, MicrosoftCodeAnalysis.IEventSymbol) then
                                local valueIsLiteral;
                                local default = variable:getInitializer();
                                if default ~= nil then
                                    default = default.getValue();
                                end
                                local extern;
                                extern, valueIsLiteral = GetFieldValueExpression(this, type, typeSymbol, default, valueIsLiteral);
                                local valueExpression = extern;
                                getCurType(this):AddEvent(variable:getIdentifier():getValueText(), valueExpression, isImmutable and valueIsLiteral, isStatic, isPrivate);
                                continue = true;
                                break;
                            end
                        end
                        local ref = variable:getInitializer();
                        if ref ~= nil then
                            ref = ref.getValue();
                        end
                        AddField(this, type, typeSymbol, variable:getIdentifier(), ref, isImmutable, isStatic, isPrivate, isReadOnly);
                        continue = true;
                    until 1;
                    if not continue then
                        break;
                    end
                end
            else
                local isPrivate = CSharpLua.Utility.IsPrivate1(node:getModifiers());
                local type = node:getDeclaration():getType();
                local typeSymbol = System.cast(MicrosoftCodeAnalysis.ITypeSymbol, MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetSymbolInfo(this.semanticModel_, type):getSymbol());
                if typeSymbol:getSpecialType() == 20 --[[SpecialType.System_String]] then
                    for _, variable in System.each(node:getDeclaration():getVariables()) do
                        local value = System.cast(MicrosoftCodeAnalysisCSharpSyntax.LiteralExpressionSyntax, variable:getInitializer():getValue());
                        if #value:getToken():getValueText() > 25 --[[LuaSyntaxNode.StringConstInlineCount]] then
                            AddField(this, type, typeSymbol, variable:getIdentifier(), value, true, true, isPrivate, true);
                        end
                    end
                end
            end
        end;
        VisitFieldDeclaration = function (this, node) 
            VisitBaseFieldDeclarationSyntax(this, node);
            return MicrosoftCodeAnalysisCSharp.CSharpSyntaxVisitor_1(TResult).VisitFieldDeclaration(this, node);
        end;
        GetFieldValueExpression = function (this, type, typeSymbol, expression, valueIsLiteral) 
            local valueExpression = nil;
            valueIsLiteral = false;
            if expression ~= nil then
                valueExpression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, expression:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                valueIsLiteral = System.is(expression, MicrosoftCodeAnalysisCSharpSyntax.LiteralExpressionSyntax);
            end
            if valueExpression == nil then
                if typeSymbol:getIsValueType() then
                    if typeSymbol:getIsDefinition() then
                        local defalutValue = GetPredefinedTypeDefaultValue(this, typeSymbol);
                        if defalutValue ~= nil then
                            valueExpression = defalutValue;
                        else
                            valueExpression = BuildDefaultValueExpression(this, type);
                        end
                        valueIsLiteral = true;
                    else
                        valueExpression = BuildDefaultValueExpression(this, type);
                    end
                end
            end
            return valueExpression;
        end;
        AddField = function (this, type, typeSymbol, identifier, expression, isImmutable, isStatic, isPrivate, isReadOnly) 
            local name = CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, identifier:getValueText());
            local valueIsLiteral;
            local default;
            default, valueIsLiteral = GetFieldValueExpression(this, type, typeSymbol, expression, valueIsLiteral);
            local valueExpression = default;
            getCurType(this):AddField(name, valueExpression, isImmutable and valueIsLiteral, isStatic, isPrivate, isReadOnly);
        end;
        VisitPropertyDeclaration = function (this, node) 
            if not CSharpLua.Utility.IsAbstract(node:getModifiers()) then
                local isStatic = CSharpLua.Utility.IsStatic(node:getModifiers());
                local isPrivate = CSharpLua.Utility.IsPrivate1(node:getModifiers());
                local hasGet = false;
                local hasSet = false;
                if node:getAccessorList() ~= nil then
                    for _, accessor in System.each(node:getAccessorList():getAccessors()) do
                        if accessor:getBody() ~= nil then
                            local functionExpression = CSharpLuaLuaAst.LuaFunctionExpressionSyntax();
                            if not isStatic then
                                functionExpression:AddParameter(CSharpLuaLuaAst.LuaIdentifierNameSyntax.This);
                            end
                            PushFunction(this, functionExpression);
                            local block = System.cast(CSharpLuaLuaAst.LuaBlockSyntax, accessor:getBody():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                            PopFunction(this);
                            functionExpression:AddStatements(block.Statements);
                            local name = CSharpLuaLuaAst.LuaPropertyOrEventIdentifierNameSyntax(true, node:getIdentifier():getValueText());
                            getCurType(this):AddMethod(name, functionExpression, isPrivate);
                            if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(accessor, 8896 --[[SyntaxKind.GetAccessorDeclaration]]) then
                                assert(not hasGet);
                                hasGet = true;
                            else
                                assert(not hasSet);
                                functionExpression:AddParameter(CSharpLuaLuaAst.LuaIdentifierNameSyntax.Value);
                                name.IsGetOrAdd = false;
                                hasSet = true;
                            end
                        end
                    end
                else
                    assert(not hasGet);
                    local name = CSharpLuaLuaAst.LuaPropertyOrEventIdentifierNameSyntax(true, node:getIdentifier():getValueText());
                    local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getExpressionBody():getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                    local functionExpress = CSharpLuaLuaAst.LuaFunctionExpressionSyntax();
                    if not isStatic then
                        functionExpress:AddParameter(CSharpLuaLuaAst.LuaIdentifierNameSyntax.This);
                    end
                    local returnStatement = CSharpLuaLuaAst.LuaReturnStatementSyntax:new(1, expression);
                    functionExpress:AddStatement(returnStatement);
                    getCurType(this):AddMethod(name, functionExpress, isPrivate);
                    hasGet = true;
                end

                if not hasGet and not hasSet then
                    local type = node:getType();
                    local typeSymbol = System.cast(MicrosoftCodeAnalysis.ITypeSymbol, MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetSymbolInfo(this.semanticModel_, type):getSymbol());
                    local isImmutable = CSharpLua.Utility.IsImmutable(typeSymbol);
                    if isStatic then
                        local isReadOnly = node:getAccessorList():getAccessors():getCount() == 1 and node:getAccessorList():getAccessors():get(0):getBody() == nil;
                        local default = node:getInitializer();
                        if default ~= nil then
                            default = default.getValue();
                        end
                        AddField(this, type, typeSymbol, node:getIdentifier(), default, isImmutable, isStatic, isPrivate, isReadOnly);
                    else
                        local isAuto = CSharpLua.Utility.IsPropertyField(MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetDeclaredSymbol(this.semanticModel_, node));
                        if isAuto then
                            local isReadOnly = node:getAccessorList():getAccessors():getCount() == 1 and node:getAccessorList():getAccessors():get(0):getBody() == nil;
                            local extern = node:getInitializer();
                            if extern ~= nil then
                                extern = extern.getValue();
                            end
                            AddField(this, type, typeSymbol, node:getIdentifier(), extern, isImmutable, isStatic, isPrivate, isReadOnly);
                        else
                            local valueIsLiteral;
                            local ref = node:getInitializer();
                            if ref ~= nil then
                                ref = ref.getValue();
                            end
                            local out;
                            out, valueIsLiteral = GetFieldValueExpression(this, type, typeSymbol, ref, valueIsLiteral);
                            local valueExpression = out;
                            getCurType(this):AddProperty(node:getIdentifier():getValueText(), valueExpression, isImmutable and valueIsLiteral, isStatic, isPrivate);
                        end
                    end
                end
            end
            return MicrosoftCodeAnalysisCSharp.CSharpSyntaxVisitor_1(TResult).VisitPropertyDeclaration(this, node);
        end;
        VisitEventDeclaration = function (this, node) 
            if not CSharpLua.Utility.IsAbstract(node:getModifiers()) then
                local isStatic = CSharpLua.Utility.IsStatic(node:getModifiers());
                local isPrivate = CSharpLua.Utility.IsPrivate1(node:getModifiers());
                for _, accessor in System.each(node:getAccessorList():getAccessors()) do
                    local block = System.cast(CSharpLuaLuaAst.LuaBlockSyntax, accessor:getBody():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                    local functionExpress = CSharpLuaLuaAst.LuaFunctionExpressionSyntax();
                    if not isStatic then
                        functionExpress:AddParameter(CSharpLuaLuaAst.LuaIdentifierNameSyntax.This);
                    end
                    functionExpress:AddParameter(CSharpLuaLuaAst.LuaIdentifierNameSyntax.Value);
                    functionExpress:AddStatements(block.Statements);
                    local name = CSharpLuaLuaAst.LuaPropertyOrEventIdentifierNameSyntax(false, node:getIdentifier():getValueText());
                    getCurType(this):AddMethod(name, functionExpress, isPrivate);
                    if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(accessor, 8899 --[[SyntaxKind.RemoveAccessorDeclaration]]) then
                        name.IsGetOrAdd = false;
                    end
                end
            end
            return MicrosoftCodeAnalysisCSharp.CSharpSyntaxVisitor_1(TResult).VisitEventDeclaration(this, node);
        end;
        VisitEventFieldDeclaration = function (this, node) 
            VisitBaseFieldDeclarationSyntax(this, node);
            return MicrosoftCodeAnalysisCSharp.CSharpSyntaxVisitor_1(TResult).VisitEventFieldDeclaration(this, node);
        end;
        VisitEnumMemberDeclaration = function (this, node) 
            local symbol = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetDeclaredSymbol(this.semanticModel_, node);
            assert(symbol:getHasConstantValue());
            local identifier = CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, node:getIdentifier():getValueText());
            local value = CSharpLuaLuaAst.LuaIdentifierLiteralExpressionSyntax:new(1, symbol:getConstantValue():ToString());
            return CSharpLuaLuaAst.LuaKeyValueTableItemSyntax(CSharpLuaLuaAst.LuaTableLiteralKeySyntax(identifier), value);
        end;
        VisitIndexerDeclaration = function (this, node) 
            local isPrivate = CSharpLua.Utility.IsPrivate1(node:getModifiers());
            local hasGet = false;
            local hasSet = false;

            local parameterList = System.cast(CSharpLuaLuaAst.LuaParameterListSyntax, node:getParameterList():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
            for _, accessor in System.each(node:getAccessorList():getAccessors()) do
                local functionExpression = CSharpLuaLuaAst.LuaFunctionExpressionSyntax();
                functionExpression:AddParameter(CSharpLuaLuaAst.LuaIdentifierNameSyntax.This);
                functionExpression.ParameterList.Parameters:AddRange1(parameterList.Parameters);
                PushFunction(this, functionExpression);

                local block = System.cast(CSharpLuaLuaAst.LuaBlockSyntax, accessor:getBody():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                PopFunction(this);
                functionExpression:AddStatements(block.Statements);
                local name = CSharpLuaLuaAst.LuaPropertyOrEventIdentifierNameSyntax(true, "");
                getCurType(this):AddMethod(name, functionExpression, isPrivate);
                if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(accessor, 8896 --[[SyntaxKind.GetAccessorDeclaration]]) then
                    assert(not hasGet);
                    hasGet = true;
                else
                    assert(not hasSet);
                    functionExpression:AddParameter(CSharpLuaLuaAst.LuaIdentifierNameSyntax.Value);
                    name.IsGetOrAdd = false;
                    hasSet = true;
                end
            end

            return MicrosoftCodeAnalysisCSharp.CSharpSyntaxVisitor_1(TResult).VisitIndexerDeclaration(this, node);
        end;
        VisitBracketedParameterList = function (this, node) 
            return BuildParameterList(this, node:getParameters());
        end;
        VisitParameterList = function (this, node) 
            return BuildParameterList(this, node:getParameters());
        end;
        BuildParameterList = function (this, parameters) 
            local parameterList = CSharpLuaLuaAst.LuaParameterListSyntax();
            for _, parameter in System.each(parameters) do
                local newNode = System.cast(CSharpLuaLuaAst.LuaParameterSyntax, parameter:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                parameterList.Parameters:Add1(newNode);
            end
            return parameterList;
        end;
        VisitParameter = function (this, node) 
            local identifier = CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, node:getIdentifier():getValueText());
            return CSharpLuaLuaAst.LuaParameterSyntax(identifier);
        end;
        VisitBlock = function (this, node) 
            local block = CSharpLuaLuaAst.LuaBlockStatementSyntax();
            this.blocks_:Push(block);

            local comments = Linq.Where(node:DescendantTrivia(), function (i) return MicrosoftCodeAnalysis.CSharpExtensions.IsKind(i, 8541 --[[SyntaxKind.SingleLineCommentTrivia]]) or MicrosoftCodeAnalysis.CSharpExtensions.IsKind(i, 8542 --[[SyntaxKind.MultiLineCommentTrivia]]); end);
            local commentNodes = Linq.Select(comments, function (i) return CSharpLuaLuaSyntaxNodeTransfor.BlockCommonNode:new(1, i); end, CSharpLuaLuaSyntaxNodeTransfor.BlockCommonNode);

            local nodes = Linq.ToList(Linq.Select(node:getStatements(), function (i) return CSharpLuaLuaSyntaxNodeTransfor.BlockCommonNode:new(2, i); end, CSharpLuaLuaSyntaxNodeTransfor.BlockCommonNode));
            local hasComments = false;
            for _, comment in System.each(commentNodes) do
                local isContains = Linq.Any(nodes, function (i) return i:Contains(comment); end);
                if not isContains then
                    nodes:Add(comment);
                    hasComments = true;
                end
            end
            if hasComments then
                nodes:Sort();
            end

            local lastLine = - 1;
            for _, common in System.each(nodes) do
                lastLine = common:Visit(this, block, lastLine);
            end

            this.blocks_:Pop();
            return block;
        end;
        VisitReturnStatement = function (this, node) 
            if System.is(getCurFunction(this), CSharpLuaLuaAst.LuaCheckReturnFunctionExpressionSyntax) then
                local returnStatement = CSharpLuaLuaAst.LuaMultipleReturnStatementSyntax();
                returnStatement.Expressions:Add1(CSharpLuaLuaAst.LuaIdentifierNameSyntax.True);
                if node:getExpression() ~= nil then
                    local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                    returnStatement.Expressions:Add1(expression);
                end
                return returnStatement;
            else
                if node:getExpression() ~= nil then
                    local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                    return CSharpLuaLuaAst.LuaReturnStatementSyntax:new(1, expression);
                end
                return CSharpLuaLuaAst.LuaReturnStatementSyntax:new(2);
            end
        end;
        VisitExpressionStatement = function (this, node) 
            local expressionNode = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
            if expressionNode ~= CSharpLuaLuaAst.LuaExpressionSyntax.EmptyExpression then
                return CSharpLuaLuaAst.LuaExpressionStatementSyntax(expressionNode);
            else
                return CSharpLuaLuaAst.LuaStatementSyntax.Empty;
            end
        end;
        BuildCommonAssignmentExpression = function (this, left, right, operatorToken) 
            local propertyAdapter = System.as(left, CSharpLuaLuaAst.LuaPropertyAdapterExpressionSyntax);
            if propertyAdapter ~= nil then
                propertyAdapter.InvocationExpression:AddArgument(CSharpLuaLuaAst.LuaBinaryExpressionSyntax(propertyAdapter:GetCloneOfGet(), operatorToken, right));
                return propertyAdapter;
            else
                return CSharpLuaLuaAst.LuaAssignmentExpressionSyntax(left, CSharpLuaLuaAst.LuaBinaryExpressionSyntax(left, operatorToken, right));
            end
        end;
        BuildDelegateAssignmentExpression = function (this, left, right, isPlus) 
            if System.is(right, CSharpLuaLuaAst.LuaInternalMethodExpressionSyntax) then
                right = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(3, CSharpLuaLuaAst.LuaIdentifierNameSyntax.DelegateBind, CSharpLuaLuaAst.LuaIdentifierNameSyntax.This, right);
            elseif System.is(right, CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax) then
                local memberAccess = System.cast(CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax, right);
                if memberAccess:getIsObjectColon() then
                    right = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(3, CSharpLuaLuaAst.LuaIdentifierNameSyntax.DelegateBind, memberAccess.Expression, memberAccess.Name);
                end
            end

            local default;
            if isPlus then
                default = CSharpLuaLuaAst.LuaIdentifierNameSyntax.DelegateCombine;
            else
                default = CSharpLuaLuaAst.LuaIdentifierNameSyntax.DelegateRemove;
            end
            local methodName = default;
            local propertyAdapter = System.as(left, CSharpLuaLuaAst.LuaPropertyAdapterExpressionSyntax);
            if propertyAdapter ~= nil then
                if propertyAdapter:getIsProperty() then
                    propertyAdapter.InvocationExpression:AddArgument(CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(3, methodName, propertyAdapter:GetCloneOfGet(), right));
                    return propertyAdapter;
                else
                    propertyAdapter:setIsGetOrAdd(isPlus);
                    propertyAdapter.InvocationExpression:AddArgument(right);
                    return propertyAdapter;
                end
            else
                return CSharpLuaLuaAst.LuaAssignmentExpressionSyntax(left, CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(3, methodName, left, right));
            end
        end;
        BuildLuaAssignmentExpression = function (this, leftNode, rightNode, kind) 
            repeat
                local default = kind;
                if default == 8714 --[[SyntaxKind.SimpleAssignmentExpression]] then
                    do
                        local left = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, leftNode:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                        local right = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, rightNode:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));

                        local propertyAdapter = System.as(left, CSharpLuaLuaAst.LuaPropertyAdapterExpressionSyntax);
                        if propertyAdapter ~= nil then
                            propertyAdapter:setIsGetOrAdd(false);
                            propertyAdapter.InvocationExpression:AddArgument(right);
                            return propertyAdapter;
                        else
                            return CSharpLuaLuaAst.LuaAssignmentExpressionSyntax(left, right);
                        end
                    end
                elseif default == 8715 --[[SyntaxKind.AddAssignmentExpression]] then
                    do
                        local leftType = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, leftNode):getType();
                        if CSharpLua.Utility.IsStringType(leftType) then
                            local left = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, leftNode:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                            local right = WrapStringConcatExpression(this, rightNode);
                            return BuildCommonAssignmentExpression(this, left, right, ".." --[[Tokens.Concatenation]]);
                        else
                            local left = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, leftNode:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                            local right = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, rightNode:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));

                            if CSharpLua.Utility.IsDelegateType(leftType) then
                                return BuildDelegateAssignmentExpression(this, left, right, true);
                            else
                                return BuildCommonAssignmentExpression(this, left, right, "+" --[[Tokens.Plus]]);
                            end
                        end
                    end
                elseif default == 8716 --[[SyntaxKind.SubtractAssignmentExpression]] then
                    do
                        local left = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, leftNode:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                        local right = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, rightNode:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));

                        local leftType = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, leftNode):getType();
                        if CSharpLua.Utility.IsDelegateType(leftType) then
                            return BuildDelegateAssignmentExpression(this, left, right, false);
                        else
                            return BuildCommonAssignmentExpression(this, left, right, "-" --[[Tokens.Sub]]);
                        end
                    end
                else
                    System.throw(System.NotImplementedException());
                end
            until 1;
        end;
        VisitAssignmentExpression = function (this, node) 
            local assignments = System.List(CSharpLuaLuaAst.LuaExpressionSyntax)();

            while true do
                local leftExpression = node:getLeft();
                local rightExpression = node:getRight();
                local kind = node:Kind();

                local assignmentRight = System.as(rightExpression, MicrosoftCodeAnalysisCSharpSyntax.AssignmentExpressionSyntax);
                if assignmentRight == nil then
                    assignments:Add(BuildLuaAssignmentExpression(this, leftExpression, rightExpression, kind));
                    break;
                else
                    assignments:Add(BuildLuaAssignmentExpression(this, leftExpression, assignmentRight:getLeft(), kind));
                    node = assignmentRight;
                end
            end

            if #assignments == 1 then
                return CSharpLua.Utility.First(assignments, CSharpLuaLuaAst.LuaExpressionSyntax);
            else
                assignments:Reverse();
                local multipleAssignment = CSharpLuaLuaAst.LuaLineMultipleExpressionSyntax();
                multipleAssignment.Assignments:AddRange1(assignments);
                return multipleAssignment;
            end
        end;
        BuildInvokeRefOrOut = function (this, node, invocation, refOrOutArguments) 
            if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getParent(), 8797 --[[SyntaxKind.ExpressionStatement]]) then
                local multipleAssignment = CSharpLuaLuaAst.LuaMultipleAssignmentExpressionSyntax();
                local symbolInfo = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetSymbolInfo(this.semanticModel_, node);
                local symbol = System.cast(MicrosoftCodeAnalysis.IMethodSymbol, symbolInfo:getSymbol());
                if not symbol:getReturnsVoid() then
                    local temp = GetTempIdentifier(this, node);
                    getCurBlock(this).Statements:Add1(CSharpLuaLuaAst.LuaLocalVariableDeclaratorSyntax:new(1, CSharpLuaLuaAst.LuaVariableDeclaratorSyntax(temp)));
                    multipleAssignment.Lefts:Add1(temp);
                end
                multipleAssignment.Lefts:AddRange1(refOrOutArguments);
                multipleAssignment.Rights:Add1(invocation);
                return multipleAssignment;
            else
                local temp = GetTempIdentifier(this, node);
                local multipleAssignment = CSharpLuaLuaAst.LuaMultipleAssignmentExpressionSyntax();
                multipleAssignment.Lefts:Add1(temp);
                multipleAssignment.Lefts:AddRange1(refOrOutArguments);
                multipleAssignment.Rights:Add1(invocation);

                getCurBlock(this).Statements:Add1(CSharpLuaLuaAst.LuaLocalVariableDeclaratorSyntax:new(1, CSharpLuaLuaAst.LuaVariableDeclaratorSyntax(temp)));
                getCurBlock(this).Statements:Add1(CSharpLuaLuaAst.LuaExpressionStatementSyntax(multipleAssignment));
                return temp;
            end
        end;
        CheckCodeTemplateInvocationExpression = function (this, symbol, node) 
            local constValue = this.semanticModel_:GetConstantValue(node);
            if constValue:getHasValue() then
                return GetConstLiteralExpression(this, constValue:getValue());
            end

            if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getExpression(), 8689 --[[SyntaxKind.SimpleMemberAccessExpression]]) then
                local codeTemplate = getXmlMetaProvider(this):GetMethodCodeTemplate(symbol);
                if codeTemplate ~= nil then
                    local argumentExpressions = System.List(MicrosoftCodeAnalysisCSharpSyntax.ExpressionSyntax)();
                    local memberAccessExpression = System.cast(MicrosoftCodeAnalysisCSharpSyntax.MemberAccessExpressionSyntax, node:getExpression());
                    if symbol:getIsExtensionMethod() then
                        argumentExpressions:Add(memberAccessExpression:getExpression());
                        if CSharpLua.Utility.IsSystemLinqEnumerable(symbol:getContainingType()) then
                            getCurCompilationUnit(this):ImportLinq();
                        end
                    end
                    argumentExpressions:AddRange(Linq.Select(node:getArgumentList():getArguments(), function (i) return i:getExpression(); end, MicrosoftCodeAnalysisCSharpSyntax.ExpressionSyntax));
                    local invocationExpression = BuildCodeTemplateExpression1(this, codeTemplate, memberAccessExpression:getExpression(), argumentExpressions, symbol:getTypeArguments());
                    local refOrOuts = Linq.Where(node:getArgumentList():getArguments(), function (i) return MicrosoftCodeAnalysis.CSharpExtensions.IsKind(i:getRefOrOutKeyword(), 8360 --[[SyntaxKind.RefKeyword]]) or MicrosoftCodeAnalysis.CSharpExtensions.IsKind(i:getRefOrOutKeyword(), 8361 --[[SyntaxKind.OutKeyword]]); end);
                    if Linq.Any(refOrOuts) then
                        return BuildInvokeRefOrOut(this, node, invocationExpression, Linq.Select(refOrOuts, function (i) return (System.cast(CSharpLuaLuaAst.LuaArgumentSyntax, i:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))).Expression; end, CSharpLuaLuaAst.LuaExpressionSyntax));
                    else
                        return invocationExpression;
                    end
                end
            end
            return nil;
        end;
        VisitInvocationExpression = function (this, node) 
            local symbol = System.cast(MicrosoftCodeAnalysis.IMethodSymbol, MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetSymbolInfo(this.semanticModel_, node):getSymbol());
            local codeTemplateExpression = CheckCodeTemplateInvocationExpression(this, symbol, node);
            if codeTemplateExpression ~= nil then
                return codeTemplateExpression;
            end

            local arguments = System.List(CSharpLuaLuaAst.LuaArgumentSyntax)();
            local refOrOutArguments = System.List(CSharpLuaLuaAst.LuaExpressionSyntax)();

            for _, argument in System.each(node:getArgumentList():getArguments()) do
                local luaArgument = System.cast(CSharpLuaLuaAst.LuaArgumentSyntax, argument:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                arguments:Add(luaArgument);
                if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(argument:getRefOrOutKeyword(), 8360 --[[SyntaxKind.RefKeyword]]) or MicrosoftCodeAnalysis.CSharpExtensions.IsKind(argument:getRefOrOutKeyword(), 8361 --[[SyntaxKind.OutKeyword]]) then
                    refOrOutArguments:Add(luaArgument.Expression);
                end
            end

            local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
            local invocation;
            if not symbol:getIsExtensionMethod() then
                local memberAccess = System.as(expression, CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax);
                if memberAccess ~= nil then
                    if System.is(memberAccess.Name, CSharpLuaLuaAst.LuaInternalMethodExpressionSyntax) then
                        invocation = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(1, memberAccess.Name);
                        invocation:AddArgument(memberAccess.Expression);
                    else
                        invocation = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(1, memberAccess);
                    end
                else
                    invocation = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(1, expression);
                    if System.is(expression, CSharpLuaLuaAst.LuaInternalMethodExpressionSyntax) then
                        invocation:AddArgument(CSharpLuaLuaAst.LuaIdentifierNameSyntax.This);
                    end
                end
            else
                local memberAccess = System.as(expression, CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax);
                if memberAccess ~= nil then
                    if System.is(memberAccess.Name, CSharpLuaLuaAst.LuaInternalMethodExpressionSyntax) then
                        invocation = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(1, memberAccess.Name);
                        invocation:AddArgument(memberAccess.Expression);
                    else
                        invocation = BuildExtensionMethodInvocation(this, symbol:getReducedFrom(), memberAccess.Expression, node);
                    end
                else
                    invocation = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(1, expression);
                end
            end

            invocation.ArgumentList.Arguments:AddRange1(arguments);
            CheckInvocationCallerAttribute(this, symbol, node, invocation);
            AddInvocationTypeArguments(this, symbol, node, invocation);

            if #refOrOutArguments > 0 then
                return BuildInvokeRefOrOut(this, node, invocation, refOrOutArguments);
            end
            return invocation;
        end;
        BuildExtensionMethodInvocation = function (this, reducedFrom, expression, node) 
            local typeName = GetTypeName(this, reducedFrom:getContainingType(), node);
            local methodName = this.generator_:GetMethodName(reducedFrom);
            local typeMemberAccess = CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(typeName, methodName);
            local invocation = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(1, typeMemberAccess);
            invocation:AddArgument(expression);
            return invocation;
        end;
        AddInvocationTypeArguments = function (this, symbol, node, invocation) 
            if symbol:getTypeArguments():getLength() > 0 then
                local optionalCount = symbol:getParameters():getLength() - node:getArgumentList():getArguments():getCount();
                while optionalCount > 0 do
                    invocation:AddArgument(CSharpLuaLuaAst.LuaIdentifierNameSyntax.Nil);
                    optionalCount = optionalCount - 1;
                end
                for _, typeArgument in System.each(symbol:getTypeArguments()) do
                    local typeName = GetTypeName(this, typeArgument, node);
                    invocation:AddArgument(typeName);
                end
            end
        end;
        CheckInvocationCallerAttribute = function (this, symbol, node, invocation) 
            local argumentCount = node:getArgumentList():getArguments():getCount();
            if symbol:getParameters():getLength() > argumentCount then
                local optionalParameters = Linq.Skip(symbol:getParameters(), argumentCount);
                local prevCallerIndex = - 1;
                local index = 0;
                for _, parameter in System.each(optionalParameters) do
                    local callerExpression = CheckCallerAttribute(this, parameter, node);
                    if callerExpression ~= nil then
                        local placeholderCount = index - prevCallerIndex - 1;
                        if placeholderCount > 0 then
                            do
                                local i = 0;
                                while i < placeholderCount do
                                    invocation:AddArgument(CSharpLuaLuaAst.LuaIdentifierNameSyntax.Nil);
                                    i = i + 1;
                                end
                            end
                        end
                        invocation:AddArgument(callerExpression);
                        prevCallerIndex = index;
                    end
                    index = index + 1;
                end
            end
        end;
        BuildMemberAccessTargetExpression = function (this, targetExpression) 
            local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, targetExpression:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
            local kind = targetExpression:Kind();
            if (kind >= 8749 --[[SyntaxKind.NumericLiteralExpression]] and kind <= 8754 --[[SyntaxKind.NullLiteralExpression]]) or (System.is(expression, CSharpLuaLuaAst.LuaLiteralExpressionSyntax)) then
                expression = CSharpLuaLuaAst.LuaParenthesizedExpressionSyntax(expression);
            end
            return expression;
        end;
        CheckMemberAccessCodeTemplate = function (this, symbol, node) 
            if symbol:getKind() == 6 --[[SymbolKind.Field]] then
                local fieldSymbol = System.cast(MicrosoftCodeAnalysis.IFieldSymbol, symbol);
                local codeTemplate = getXmlMetaProvider(this):GetFieldCodeTemplate(fieldSymbol);
                if codeTemplate ~= nil then
                    return BuildCodeTemplateExpression(this, codeTemplate, node:getExpression());
                end

                if fieldSymbol:getHasConstantValue() then
                    return GetConstLiteralExpression1(this, fieldSymbol);
                end
            elseif symbol:getKind() == 15 --[[SymbolKind.Property]] then
                local propertySymbol = System.cast(MicrosoftCodeAnalysis.IPropertySymbol, symbol);
                local isGet = not CSharpLua.Utility.IsAssignment(MicrosoftCodeAnalysisCSharp.CSharpExtensions.Kind(node:getParent()));
                local codeTemplate = getXmlMetaProvider(this):GetProertyCodeTemplate(propertySymbol, isGet);
                if codeTemplate ~= nil then
                    return BuildCodeTemplateExpression(this, codeTemplate, node:getExpression());
                end
            end
            return nil;
        end;
        VisitMemberAccessExpression = function (this, node) 
            local symbol = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetSymbolInfo(this.semanticModel_, node):getSymbol();
            local codeTemplateExpression = CheckMemberAccessCodeTemplate(this, symbol, node);
            if codeTemplateExpression ~= nil then
                return codeTemplateExpression;
            end

            if symbol:getKind() == 15 --[[SymbolKind.Property]] or symbol:getKind() == 5 --[[SymbolKind.Event]] then
                if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getExpression(), 8746 --[[SyntaxKind.ThisExpression]]) then
                    local propertyIdentifier = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getName():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                    local propertyAdapter = System.as(propertyIdentifier, CSharpLuaLuaAst.LuaPropertyAdapterExpressionSyntax);
                    if propertyAdapter ~= nil then
                        return propertyAdapter;
                    else
                        return CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(CSharpLuaLuaAst.LuaIdentifierNameSyntax.This, propertyIdentifier);
                    end
                end

                if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getExpression(), 8747 --[[SyntaxKind.BaseExpression]]) then
                    local expression = System.cast(CSharpLuaLuaAst.LuaIdentifierNameSyntax, node:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                    local nameIdentifier = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getName():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                    local propertyMethod = System.as(nameIdentifier, CSharpLuaLuaAst.LuaPropertyAdapterExpressionSyntax);
                    if propertyMethod ~= nil then
                        if expression ~= CSharpLuaLuaAst.LuaIdentifierNameSyntax.This then
                            propertyMethod.InvocationExpression:AddArgument(CSharpLuaLuaAst.LuaIdentifierNameSyntax.This);
                        end

                        local memberAccessExpression = CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(expression, propertyMethod.InvocationExpression.Expression, true);
                        propertyMethod:Update(memberAccessExpression);
                        return propertyMethod;
                    else
                        return CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(expression, nameIdentifier);
                    end
                else
                    if symbol:getIsStatic() then
                        if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getExpression(), 8616 --[[SyntaxKind.IdentifierName]]) then
                            local identifierName = System.cast(MicrosoftCodeAnalysisCSharpSyntax.IdentifierNameSyntax, node:getExpression());
                            if GetTypeDeclarationSymbol(this, node) == symbol:getContainingSymbol() then
                                return node:getName():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode);
                            end
                        end
                    end

                    local expression = BuildMemberAccessTargetExpression(this, node:getExpression());
                    local nameExpression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getName():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                    local propertyMethod = System.as(nameExpression, CSharpLuaLuaAst.LuaPropertyAdapterExpressionSyntax);
                    if propertyMethod ~= nil then
                        local arguments = propertyMethod.InvocationExpression.ArgumentList.Arguments;
                        if #arguments == 1 then
                            if arguments:get(0).Expression == CSharpLuaLuaAst.LuaIdentifierNameSyntax.This then
                                propertyMethod.InvocationExpression.ArgumentList.Arguments:set(0, CSharpLuaLuaAst.LuaArgumentSyntax(expression));
                            end
                        else
                            local memberAccessExpression = CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(expression, propertyMethod.InvocationExpression.Expression, not symbol:getIsStatic());
                            propertyMethod:Update(memberAccessExpression);
                        end
                        return propertyMethod;
                    else
                        return CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(expression, nameExpression);
                    end
                end
            else
                if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getExpression(), 8746 --[[SyntaxKind.ThisExpression]]) then
                    return node:getName():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode);
                end

                if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getExpression(), 8747 --[[SyntaxKind.BaseExpression]]) then
                    local baseExpression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                    local identifier = System.cast(CSharpLuaLuaAst.LuaIdentifierNameSyntax, node:getName():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                    if baseExpression == CSharpLuaLuaAst.LuaIdentifierNameSyntax.This then
                        return CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(baseExpression, identifier, symbol:getKind() == 9 --[[SymbolKind.Method]]);
                    else
                        local memberAccess = CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(baseExpression, identifier);
                        return CSharpLuaLuaAst.LuaInternalMethodExpressionSyntax(memberAccess);
                    end
                else
                    if symbol:getIsStatic() then
                        if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getExpression(), 8616 --[[SyntaxKind.IdentifierName]]) then
                            local identifierName = System.cast(MicrosoftCodeAnalysisCSharpSyntax.IdentifierNameSyntax, node:getExpression());
                            if GetTypeDeclarationSymbol(this, node) == symbol:getContainingSymbol() then
                                return node:getName():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode);
                            end
                        end
                    end

                    local expression = BuildMemberAccessTargetExpression(this, node:getExpression());
                    local identifier = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getName():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                    return CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(expression, identifier, not symbol:getIsStatic() and symbol:getKind() == 9 --[[SymbolKind.Method]]);
                end
            end
        end;
        BuildStaticFieldName = function (this, symbol, isReadOnly, node) 
            assert(symbol:getIsStatic());
            local name;
            if CSharpLua.Utility.IsPrivate(symbol) then
                name = symbol:getName();
            else
                if isReadOnly then
                    name = symbol:getName();
                    if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getParent(), 8714 --[[SyntaxKind.SimpleAssignmentExpression]]) then
                        local assignmentExpression = System.cast(MicrosoftCodeAnalysisCSharpSyntax.AssignmentExpressionSyntax, node:getParent());
                        if assignmentExpression:getLeft() == node then
                            getCurType(this):AddStaticReadOnlyAssignmentName(name);
                        end
                    end
                    local usingStaticType = CheckUsingStaticNameSyntax(this, symbol, node);
                    if usingStaticType ~= nil then
                        return CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(usingStaticType, CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, name));
                    end
                else
                    if IsInternalNode(this, node) then
                        local constructor = System.as(getCurFunctionOrNull(this), CSharpLuaLuaAst.LuaConstructorAdapterExpressionSyntax);
                        if constructor ~= nil then
                            name = "this" --[[Tokens.This]] .. '.' .. (symbol:getName() or "");
                        else
                            name = symbol:ToString();
                        end
                    else
                        name = symbol:getName();
                        local usingStaticType = CheckUsingStaticNameSyntax(this, symbol, node);
                        if usingStaticType ~= nil then
                            return CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(usingStaticType, CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, name));
                        end
                    end
                end
            end
            return CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, name);
        end;
        IsInternalNode = function (this, node) 
            repeat
                local default = MicrosoftCodeAnalysisCSharp.CSharpExtensions.Kind(node:getParent());
                if default == 8689 --[[SyntaxKind.SimpleMemberAccessExpression]] then
                    do
                        local parent = System.cast(MicrosoftCodeAnalysisCSharpSyntax.MemberAccessExpressionSyntax, node:getParent());
                        if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(parent:getExpression(), 8746 --[[SyntaxKind.ThisExpression]]) then
                            return true;
                        elseif parent:getExpression() == node then
                            return true;
                        end
                        return false;
                    end
                elseif default == 8707 --[[SyntaxKind.MemberBindingExpression]] then
                    do
                        return false;
                    end
                else
                    do
                        return true;
                    end
                end
            until 1;
        end;
        VisitFieldOrEventIdentifierName = function (this, node, symbol, isProperty) 
            local name;
            local isField, isReadOnly;
            if isProperty then
                local propertySymbol = System.cast(MicrosoftCodeAnalysis.IPropertySymbol, symbol);
                isField = IsPropertyField(this, propertySymbol);
                isReadOnly = propertySymbol:getIsReadOnly();
            else
                local eventSymbol = System.cast(MicrosoftCodeAnalysis.IEventSymbol, symbol);
                isField = CSharpLua.Utility.IsEventFiled(eventSymbol);
                isReadOnly = false;
            end

            if symbol:getIsStatic() then
                if isField then
                    return BuildStaticFieldName(this, symbol, isReadOnly, node);
                else
                    local identifierExpression = CSharpLuaLuaAst.LuaPropertyAdapterExpressionSyntax:new(1, CSharpLuaLuaAst.LuaPropertyOrEventIdentifierNameSyntax(isProperty, symbol:getName()));
                    local usingStaticType = CheckUsingStaticNameSyntax(this, symbol, node);
                    if usingStaticType ~= nil then
                        return CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(usingStaticType, identifierExpression);
                    end
                    return identifierExpression;
                end
            else
                if isField then
                    if IsInternalNode(this, node) then
                        name = "this" --[[Tokens.This]] .. '.' .. (symbol:getName() or "");
                    else
                        name = symbol:getName();
                    end
                else
                    if IsInternalMember(this, node, symbol) then
                        local propertyAdapter = CSharpLuaLuaAst.LuaPropertyAdapterExpressionSyntax:new(1, CSharpLuaLuaAst.LuaPropertyOrEventIdentifierNameSyntax(isProperty, symbol:getName()));
                        propertyAdapter.InvocationExpression:AddArgument(CSharpLuaLuaAst.LuaIdentifierNameSyntax.This);
                        return propertyAdapter;
                    else
                        if IsInternalNode(this, node) then
                            local identifierName = CSharpLuaLuaAst.LuaPropertyOrEventIdentifierNameSyntax(isProperty, symbol:getName());
                            local memberAccess = CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(CSharpLuaLuaAst.LuaIdentifierNameSyntax.This, identifierName, true);
                            return CSharpLuaLuaAst.LuaPropertyAdapterExpressionSyntax:new(2, memberAccess, identifierName);
                        else
                            return CSharpLuaLuaAst.LuaPropertyAdapterExpressionSyntax:new(1, CSharpLuaLuaAst.LuaPropertyOrEventIdentifierNameSyntax(isProperty, symbol:getName()));
                        end
                    end
                end
            end
            return CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, name);
        end;
        GetMethodNameExpression = function (this, symbol, node) 
            local methodName = this.generator_:GetMethodName(symbol);
            if symbol:getIsStatic() then
                local usingStaticType = CheckUsingStaticNameSyntax(this, symbol, node);
                if usingStaticType ~= nil then
                    return CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(usingStaticType, methodName);
                end
                if IsInternalMember(this, node, symbol) then
                    return CSharpLuaLuaAst.LuaInternalMethodExpressionSyntax(methodName);
                end
                return methodName;
            else
                if IsInternalMember(this, node, symbol) then
                    return CSharpLuaLuaAst.LuaInternalMethodExpressionSyntax(methodName);
                else
                    if IsInternalNode(this, node) then
                        local memberAccess = CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(CSharpLuaLuaAst.LuaIdentifierNameSyntax.This, methodName, true);
                        return memberAccess;
                    end
                end
            end
            return methodName;
        end;
        VisitIdentifierName = function (this, node) 
            local symbolInfo = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetSymbolInfo(this.semanticModel_, node);
            local symbol = symbolInfo:getSymbol();
            assert(symbol ~= nil);
            local name;
            repeat
                local default = symbol:getKind();
                if default == 8 --[[SymbolKind.Local]] or default == 13 --[[SymbolKind.Parameter]] then
                    do
                        name = symbol:getName();
                        name = CheckReservedWord1(this, name, symbol);
                        break;
                    end
                elseif default == 17 --[[SymbolKind.TypeParameter]] or default == 7 --[[SymbolKind.Label]] then
                    do
                        name = symbol:getName();
                        break;
                    end
                elseif default == 11 --[[SymbolKind.NamedType]] then
                    do
                        if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getParent(), 8689 --[[SyntaxKind.SimpleMemberAccessExpression]]) then
                            local parent = System.cast(MicrosoftCodeAnalysisCSharpSyntax.MemberAccessExpressionSyntax, node:getParent());
                            if parent:getName() == node then
                                name = symbol:getName();
                                break;
                            end
                        end
                        return GetTypeName(this, symbol, node);
                    end
                elseif default == 12 --[[SymbolKind.Namespace]] then
                    do
                        name = symbol:ToString();
                        break;
                    end
                elseif default == 6 --[[SymbolKind.Field]] then
                    do
                        if symbol:getIsStatic() then
                            local fieldSymbol = System.cast(MicrosoftCodeAnalysis.IFieldSymbol, symbol);
                            if fieldSymbol:getHasConstantValue() then
                                if fieldSymbol:getType():getSpecialType() == 20 --[[SpecialType.System_String]] then
                                    if #(System.cast(System.String, fieldSymbol:getConstantValue())) < 25 --[[LuaSyntaxNode.StringConstInlineCount]] then
                                        return GetConstLiteralExpression1(this, fieldSymbol);
                                    end
                                else
                                    return GetConstLiteralExpression1(this, fieldSymbol);
                                end
                            end
                            return BuildStaticFieldName(this, symbol, fieldSymbol:getIsReadOnly(), node);
                        else
                            if IsInternalNode(this, node) then
                                name = "this" --[[Tokens.This]] .. '.' .. (symbol:getName() or "");
                            else
                                name = symbol:getName();
                            end
                        end
                        break;
                    end
                elseif default == 9 --[[SymbolKind.Method]] then
                    do
                        return GetMethodNameExpression(this, System.cast(MicrosoftCodeAnalysis.IMethodSymbol, symbol), node);
                    end
                elseif default == 15 --[[SymbolKind.Property]] then
                    do
                        return VisitFieldOrEventIdentifierName(this, node, symbol, true);
                    end
                elseif default == 5 --[[SymbolKind.Event]] then
                    do
                        return VisitFieldOrEventIdentifierName(this, node, symbol, false);
                    end
                else
                    do
                        System.throw(System.NotSupportedException());
                    end
                end
            until 1;
            return CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, name);
        end;
        VisitQualifiedName = function (this, node) 
            return CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, node:ToString());
        end;
        BuildArgumentList = function (this, arguments) 
            local argumentList = CSharpLuaLuaAst.LuaArgumentListSyntax();
            for _, argument in System.each(arguments) do
                local newNode = System.cast(CSharpLuaLuaAst.LuaArgumentSyntax, argument:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                argumentList.Arguments:Add1(newNode);
            end
            return argumentList;
        end;
        VisitArgumentList = function (this, node) 
            return BuildArgumentList(this, node:getArguments());
        end;
        VisitArgument = function (this, node) 
            local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
            local argument = CSharpLuaLuaAst.LuaArgumentSyntax(expression);
            return argument;
        end;
        VisitLiteralExpression = function (this, node) 
            repeat
                local default = node:Kind();
                if default == 8751 --[[SyntaxKind.CharacterLiteralExpression]] then
                    do
                        return CSharpLuaLuaAst.LuaCharacterLiteralExpression(System.cast(System.Char, node:getToken():getValue()));
                    end
                elseif default == 8754 --[[SyntaxKind.NullLiteralExpression]] then
                    do
                        return CSharpLuaLuaAst.LuaIdentifierLiteralExpressionSyntax:new(2, CSharpLuaLuaAst.LuaIdentifierNameSyntax.Nil);
                    end
                elseif default == 8750 --[[SyntaxKind.StringLiteralExpression]] then
                    do
                        return BuildStringLiteralTokenExpression(this, node:getToken());
                    end
                else
                    do
                        return CSharpLuaLuaAst.LuaIdentifierLiteralExpressionSyntax:new(1, node:getToken():getValueText());
                    end
                end
            until 1;
        end;
        VisitLocalDeclarationStatement = function (this, node) 
            local declaration = System.cast(CSharpLuaLuaAst.LuaVariableDeclarationSyntax, node:getDeclaration():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
            return CSharpLuaLuaAst.LuaLocalDeclarationStatementSyntax(declaration);
        end;
        VisitVariableDeclaration = function (this, node) 
            local variableListDeclaration = CSharpLuaLuaAst.LuaVariableListDeclarationSyntax();
            for _, variable in System.each(node:getVariables()) do
                local variableDeclarator = System.cast(CSharpLuaLuaAst.LuaVariableDeclaratorSyntax, variable:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                variableListDeclaration.Variables:Add1(variableDeclarator);
            end
            local isMultiNil = #variableListDeclaration.Variables > 0 and Linq.All(variableListDeclaration.Variables, function (i) return i.Initializer == nil; end);
            if isMultiNil then
                local declarationStatement = CSharpLuaLuaAst.LuaLocalVariablesStatementSyntax();
                for _, variable in System.each(variableListDeclaration.Variables) do
                    declarationStatement.Variables:Add1(variable.Identifier);
                end
                return declarationStatement;
            else
                return variableListDeclaration;
            end
        end;
        VisitVariableDeclarator = function (this, node) 
            local identifier = CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, node:getIdentifier():getValueText());
            identifier = CheckVariableDeclaratorName(this, identifier, node);
            local variableDeclarator = CSharpLuaLuaAst.LuaVariableDeclaratorSyntax(identifier);
            if node:getInitializer() ~= nil then
                variableDeclarator.Initializer = System.cast(CSharpLuaLuaAst.LuaEqualsValueClauseSyntax, node:getInitializer():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
            end
            return variableDeclarator;
        end;
        VisitEqualsValueClause = function (this, node) 
            local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getValue():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
            return CSharpLuaLuaAst.LuaEqualsValueClauseSyntax(expression);
        end;
        VisitPredefinedType = function (this, node) 
            local symbol = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetSymbolInfo(this.semanticModel_, node):getSymbol();
            return GetTypeShortName(this, symbol);
        end;
        WriteStatementOrBlock = function (this, statement, block) 
            if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(statement, 8792 --[[SyntaxKind.Block]]) then
                local blockNode = System.cast(CSharpLuaLuaAst.LuaBlockSyntax, statement:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                block.Statements:AddRange1(blockNode.Statements);
            else
                this.blocks_:Push(block);
                local statementNode = System.cast(CSharpLuaLuaAst.LuaStatementSyntax, statement:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                block.Statements:Add1(statementNode);
                this.blocks_:Pop();
            end
        end;
        VisitIfStatement = function (this, node) 
            local condition = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getCondition():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
            local ifStatement = CSharpLuaLuaAst.LuaIfStatementSyntax(condition);
            WriteStatementOrBlock(this, node:getStatement(), ifStatement.Body);
            this.ifStatements_:Push(ifStatement);
            local default = node:getElse();
            if default ~= nil then
                default:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode);
            end
            this.ifStatements_:Pop();
            return ifStatement;
        end;
        VisitElseClause = function (this, node) 
            if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getStatement(), 8819 --[[SyntaxKind.IfStatement]]) then
                local ifStatement = System.cast(MicrosoftCodeAnalysisCSharpSyntax.IfStatementSyntax, node:getStatement());
                local condition = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, ifStatement:getCondition():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                local elseIfStatement = CSharpLuaLuaAst.LuaElseIfStatementSyntax(condition);
                WriteStatementOrBlock(this, ifStatement:getStatement(), elseIfStatement.Body);
                this.ifStatements_:Peek().ElseIfStatements:Add1(elseIfStatement);
                local default = ifStatement:getElse();
                if default ~= nil then
                    default:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode);
                end
                return elseIfStatement;
            else
                local elseClause = CSharpLuaLuaAst.LuaElseClauseSyntax();
                WriteStatementOrBlock(this, node:getStatement(), elseClause.Body);
                this.ifStatements_:Peek().Else = elseClause;
                return elseClause;
            end
        end;
        VisitSwitchStatement = function (this, node) 
            local temp = GetTempIdentifier(this, node);
            local switchStatement = CSharpLuaLuaAst.LuaSwitchAdapterStatementSyntax(temp);
            this.switchs_:Push(switchStatement);
            local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
            switchStatement:Fill(expression, Linq.Select(node:getSections(), function (i) return System.cast(CSharpLuaLuaAst.LuaStatementSyntax, i:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode)); end, CSharpLuaLuaAst.LuaStatementSyntax));
            this.switchs_:Pop();
            return switchStatement;
        end;
        VisitSwitchSection = function (this, node) 
            local isDefault = Linq.Any(node:getLabels(), function (i) return i:Kind() == 8824 --[[SyntaxKind.DefaultSwitchLabel]]; end);
            if isDefault then
                local block = CSharpLuaLuaAst.LuaBlockSyntax();
                for _, statement in System.each(node:getStatements()) do
                    local luaStatement = System.cast(CSharpLuaLuaAst.LuaStatementSyntax, statement:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                    block.Statements:Add1(luaStatement);
                end
                return block;
            else
                local expressions = Linq.Select(node:getLabels(), function (i) return System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, i:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode)); end, CSharpLuaLuaAst.LuaExpressionSyntax);
                local condition = Linq.Aggregate(expressions, function (x, y) return CSharpLuaLuaAst.LuaBinaryExpressionSyntax(x, "or" --[[Keyword.Or]], y); end);
                local ifStatement = CSharpLuaLuaAst.LuaIfStatementSyntax(condition);
                for _, statement in System.each(node:getStatements()) do
                    local luaStatement = System.cast(CSharpLuaLuaAst.LuaStatementSyntax, statement:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                    ifStatement.Body.Statements:Add1(luaStatement);
                end
                return ifStatement;
            end
        end;
        VisitCaseSwitchLabel = function (this, node) 
            local left = this.switchs_:Peek().Temp;
            local right = System.cast(CSharpLuaLuaAst.LuaLiteralExpressionSyntax, node:getValue():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
            local BinaryExpression = CSharpLuaLuaAst.LuaBinaryExpressionSyntax(left, "==" --[[Tokens.EqualsEquals]], right);
            return BinaryExpression;
        end;
        VisitBreakStatement = function (this, node) 
            return CSharpLuaLuaAst.LuaBreakStatementSyntax.Statement;
        end;
        WrapStringConcatExpression = function (this, expression) 
            local typeInfo = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, expression):getType();
            local original = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, expression:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
            if CSharpLua.Utility.IsStringType(typeInfo) then
                if System.is(expression, MicrosoftCodeAnalysisCSharpSyntax.BinaryExpressionSyntax) then
                    return original;
                end

                local constValue = this.semanticModel_:GetConstantValue(expression);
                if constValue:getHasValue() then
                    return original;
                else
                    local mayBeNull = MayBeNull(this, expression, typeInfo);
                    if mayBeNull then
                        local binaryExpression = CSharpLuaLuaAst.LuaBinaryExpressionSyntax(original, "or" --[[Keyword.Or]], CSharpLuaLuaAst.LuaStringLiteralExpressionSyntax.Empty);
                        return CSharpLuaLuaAst.LuaParenthesizedExpressionSyntax(binaryExpression);
                    else
                        return original;
                    end
                end
            elseif typeInfo:getSpecialType() == 8 --[[SpecialType.System_Char]] then
                local constValue = this.semanticModel_:GetConstantValue(expression);
                if constValue:getHasValue() then
                    local text = MicrosoftCodeAnalysisCSharp.SyntaxFactory.Literal(System.cast(System.Char, constValue:getValue())):getText();
                    return CSharpLuaLuaAst.LuaIdentifierLiteralExpressionSyntax:new(1, text);
                else
                    return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(2, CSharpLuaLuaAst.LuaIdentifierNameSyntax.StringChar, original);
                end
            elseif typeInfo:getSpecialType() >= 7 --[[SpecialType.System_Boolean]] and typeInfo:getSpecialType() <= 19 --[[SpecialType.System_Double]] then
                return original;
            elseif typeInfo:getTypeKind() == 5 --[[TypeKind.Enum]] then
                if System.is(original, CSharpLuaLuaAst.LuaLiteralExpressionSyntax) then
                    local symbol = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetSymbolInfo(this.semanticModel_, expression):getSymbol();
                    return CSharpLuaLuaAst.LuaConstLiteralExpression:new(1, symbol:getName(), typeInfo:ToString());
                else
                    this.generator_:AddExportEnum(typeInfo:ToString());
                    local typeName = GetTypeShortName(this, typeInfo, expression);
                    local memberAccess = CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(original, CSharpLuaLuaAst.LuaIdentifierNameSyntax.ToEnumString, true);
                    return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(2, memberAccess, typeName);
                end
            elseif typeInfo:getIsValueType() then
                local memberAccess = CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(original, CSharpLuaLuaAst.LuaIdentifierNameSyntax.ToStr, true);
                return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(1, memberAccess);
            else
                local memberAccess = CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(original, CSharpLuaLuaAst.LuaIdentifierNameSyntax.ToStr, true);
                local andExpression = CSharpLuaLuaAst.LuaBinaryExpressionSyntax(original, "and" --[[Keyword.And]], CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(1, memberAccess));
                local orExpression = CSharpLuaLuaAst.LuaBinaryExpressionSyntax(andExpression, "or" --[[Keyword.Or]], CSharpLuaLuaAst.LuaStringLiteralExpressionSyntax.Empty);
                return CSharpLuaLuaAst.LuaParenthesizedExpressionSyntax(orExpression);
            end
        end;
        BuildStringConcatExpression = function (this, node) 
            return BuildStringConcatExpression1(this, node:getLeft(), node:getRight());
        end;
        BuildStringConcatExpression1 = function (this, leftNode, rightNode) 
            local left = WrapStringConcatExpression(this, leftNode);
            local right = WrapStringConcatExpression(this, rightNode);
            return CSharpLuaLuaAst.LuaBinaryExpressionSyntax(left, ".." --[[Tokens.Concatenation]], right);
        end;
        BuildBinaryInvokeExpression = function (this, node, name) 
            local left = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getLeft():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
            local right = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getRight():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
            return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(3, name, left, right);
        end;
        BuildIntegerDivExpression = function (this, node) 
            if getIsLuaNewest(this) then
                return BuildBinaryExpression(this, node, "//" --[[Tokens.Div]]);
            else
                return BuildBinaryInvokeExpression(this, node, CSharpLuaLuaAst.LuaIdentifierNameSyntax.IntegerDiv);
            end
        end;
        BuildBinaryExpression = function (this, node, operatorToken) 
            local left = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getLeft():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
            local right = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getRight():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
            return CSharpLuaLuaAst.LuaBinaryExpressionSyntax(left, operatorToken, right);
        end;
        BuildBitExpression = function (this, node, boolOperatorToken, otherName) 
            local leftType = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, node:getLeft()):getType();
            if leftType:getSpecialType() == 7 --[[SpecialType.System_Boolean]] then
                return BuildBinaryExpression(this, node, boolOperatorToken);
            elseif not getIsLuaNewest(this) then
                return BuildBinaryInvokeExpression(this, node, otherName);
            else
                local operatorToken = GetOperatorToken(this, node:getOperatorToken());
                return BuildBinaryExpression(this, node, operatorToken);
            end
        end;
        VisitBinaryExpression = function (this, node) 
            repeat
                local default = node:Kind();
                if default == 8668 --[[SyntaxKind.AddExpression]] then
                    do
                        local methodSymbol = System.as(MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetSymbolInfo(this.semanticModel_, node):getSymbol(), MicrosoftCodeAnalysis.IMethodSymbol);
                        if methodSymbol ~= nil then
                            if CSharpLua.Utility.IsStringType(methodSymbol:getContainingType()) then
                                return BuildStringConcatExpression(this, node);
                            elseif CSharpLua.Utility.IsDelegateType(methodSymbol:getContainingType()) then
                                return BuildBinaryInvokeExpression(this, node, CSharpLuaLuaAst.LuaIdentifierNameSyntax.DelegateCombine);
                            end
                        end
                        break;
                    end
                elseif default == 8669 --[[SyntaxKind.SubtractExpression]] then
                    do
                        local methodSymbol = System.as(MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetSymbolInfo(this.semanticModel_, node):getSymbol(), MicrosoftCodeAnalysis.IMethodSymbol);
                        if methodSymbol ~= nil and CSharpLua.Utility.IsDelegateType(methodSymbol:getContainingType()) then
                            return BuildBinaryInvokeExpression(this, node, CSharpLuaLuaAst.LuaIdentifierNameSyntax.DelegateRemove);
                        end
                        break;
                    end
                elseif default == 8671 --[[SyntaxKind.DivideExpression]] then
                    do
                        local leftType = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, node:getLeft()):getType();
                        local rightType = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, node:getRight()):getType();
                        if CSharpLua.Utility.IsIntegerType(leftType) and CSharpLua.Utility.IsIntegerType(rightType) then
                            return BuildIntegerDivExpression(this, node);
                        end
                        break;
                    end
                elseif default == 8672 --[[SyntaxKind.ModuloExpression]] then
                    do
                        if not getIsLuaNewest(this) then
                            local leftType = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, node:getLeft()):getType();
                            local rightType = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, node:getRight()):getType();
                            if CSharpLua.Utility.IsIntegerType(leftType) and CSharpLua.Utility.IsIntegerType(rightType) then
                                return BuildBinaryInvokeExpression(this, node, CSharpLuaLuaAst.LuaIdentifierNameSyntax.IntegerMod);
                            end
                        end
                        break;
                    end
                elseif default == 8673 --[[SyntaxKind.LeftShiftExpression]] then
                    do
                        if not getIsLuaNewest(this) then
                            return BuildBinaryInvokeExpression(this, node, CSharpLuaLuaAst.LuaIdentifierNameSyntax.ShiftLeft);
                        end
                        break;
                    end
                elseif default == 8674 --[[SyntaxKind.RightShiftExpression]] then
                    do
                        if not getIsLuaNewest(this) then
                            return BuildBinaryInvokeExpression(this, node, CSharpLuaLuaAst.LuaIdentifierNameSyntax.ShiftRight);
                        end
                        break;
                    end
                elseif default == 8677 --[[SyntaxKind.BitwiseOrExpression]] then
                    do
                        return BuildBitExpression(this, node, "or" --[[Keyword.Or]], CSharpLuaLuaAst.LuaIdentifierNameSyntax.BitOr);
                    end
                elseif default == 8678 --[[SyntaxKind.BitwiseAndExpression]] then
                    do
                        return BuildBitExpression(this, node, "and" --[[Keyword.And]], CSharpLuaLuaAst.LuaIdentifierNameSyntax.BitAnd);
                    end
                elseif default == 8679 --[[SyntaxKind.ExclusiveOrExpression]] then
                    do
                        return BuildBitExpression(this, node, "~=" --[[Tokens.NotEquals]], CSharpLuaLuaAst.LuaIdentifierNameSyntax.BitXor);
                    end
                elseif default == 8686 --[[SyntaxKind.IsExpression]] then
                    do
                        return BuildBinaryInvokeExpression(this, node, CSharpLuaLuaAst.LuaIdentifierNameSyntax.Is);
                    end
                elseif default == 8687 --[[SyntaxKind.AsExpression]] then
                    do
                        return BuildBinaryInvokeExpression(this, node, CSharpLuaLuaAst.LuaIdentifierNameSyntax.As);
                    end
                end
            until 1;
            local operatorToken = GetOperatorToken(this, node:getOperatorToken());
            return BuildBinaryExpression(this, node, operatorToken);
        end;
        GetLuaAssignmentExpressionSyntax = function (this, operand, isPlus) 
            local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, operand:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
            local operatorToken = isPlus and "+" --[[Tokens.Plus]] or "-" --[[Tokens.Sub]];
            local binary = CSharpLuaLuaAst.LuaBinaryExpressionSyntax(expression, operatorToken, CSharpLuaLuaAst.LuaIdentifierNameSyntax.One);
            local assignment = CSharpLuaLuaAst.LuaAssignmentExpressionSyntax(expression, binary);
            return assignment;
        end;
        VisitPrefixUnaryExpression = function (this, node) 
            local kind = node:Kind();
            if kind == 8734 --[[SyntaxKind.PreIncrementExpression]] or kind == 8735 --[[SyntaxKind.PreDecrementExpression]] then
                local assignment = GetLuaAssignmentExpressionSyntax(this, node:getOperand(), kind == 8734 --[[SyntaxKind.PreIncrementExpression]]);
                if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getParent(), 8797 --[[SyntaxKind.ExpressionStatement]]) or MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getParent(), 8811 --[[SyntaxKind.ForStatement]]) then
                    return assignment;
                else
                    getCurBlock(this).Statements:Add1(CSharpLuaLuaAst.LuaExpressionStatementSyntax(assignment));
                    return assignment.Left;
                end
            else
                local operand = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getOperand():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                local operatorToken = GetOperatorToken(this, node:getOperatorToken());
                local unaryExpression = CSharpLuaLuaAst.LuaPrefixUnaryExpressionSyntax(operand, operatorToken);
                return unaryExpression;
            end
        end;
        VisitPostfixUnaryExpression = function (this, node) 
            local kind = node:Kind();
            if kind ~= 8738 --[[SyntaxKind.PostIncrementExpression]] and kind ~= 8739 --[[SyntaxKind.PostDecrementExpression]] then
                System.throw(System.NotSupportedException());
            end
            local assignment = GetLuaAssignmentExpressionSyntax(this, node:getOperand(), kind == 8738 --[[SyntaxKind.PostIncrementExpression]]);
            if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getParent(), 8797 --[[SyntaxKind.ExpressionStatement]]) or MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getParent(), 8811 --[[SyntaxKind.ForStatement]]) then
                return assignment;
            else
                local temp = GetTempIdentifier(this, node);
                getCurBlock(this).Statements:Add1(CSharpLuaLuaAst.LuaLocalVariableDeclaratorSyntax:new(2, temp, assignment.Left));
                getCurBlock(this).Statements:Add1(CSharpLuaLuaAst.LuaExpressionStatementSyntax(assignment));
                return temp;
            end
        end;
        VisitContinueStatement = function (this, node) 
            return CSharpLuaLuaAst.LuaContinueAdapterStatementSyntax.Statement;
        end;
        VisitLoopBody = function (this, bodyStatement, block) 
            local hasContinue = IsContinueExists(this, bodyStatement);
            if hasContinue then
                -- http://lua-users.org/wiki/ContinueProposal
                local continueIdentifier = CSharpLuaLuaAst.LuaIdentifierNameSyntax.Continue;
                block.Statements:Add1(CSharpLuaLuaAst.LuaLocalVariableDeclaratorSyntax:new(1, CSharpLuaLuaAst.LuaVariableDeclaratorSyntax(continueIdentifier)));
                local repeatStatement = CSharpLuaLuaAst.LuaRepeatStatementSyntax(CSharpLuaLuaAst.LuaIdentifierNameSyntax.One);
                WriteStatementOrBlock(this, bodyStatement, repeatStatement.Body);
                local assignment = CSharpLuaLuaAst.LuaAssignmentExpressionSyntax(continueIdentifier, CSharpLuaLuaAst.LuaIdentifierNameSyntax.True);
                repeatStatement.Body.Statements:Add1(CSharpLuaLuaAst.LuaExpressionStatementSyntax(assignment));
                block.Statements:Add1(repeatStatement);
                local IfStatement = CSharpLuaLuaAst.LuaIfStatementSyntax(CSharpLuaLuaAst.LuaPrefixUnaryExpressionSyntax(continueIdentifier, "not" --[[Keyword.Not]]));
                IfStatement.Body.Statements:Add1(CSharpLuaLuaAst.LuaBreakStatementSyntax.Statement);
                block.Statements:Add1(IfStatement);
            else
                WriteStatementOrBlock(this, bodyStatement, block);
            end
        end;
        VisitForEachStatement = function (this, node) 
            local identifier = CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, node:getIdentifier():getValueText());
            local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
            local forInStatement = CSharpLuaLuaAst.LuaForInStatementSyntax(identifier, expression);
            VisitLoopBody(this, node:getStatement(), forInStatement.Body);
            return forInStatement;
        end;
        VisitWhileStatement = function (this, node) 
            local condition = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getCondition():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
            local whileStatement = CSharpLuaLuaAst.LuaWhileStatementSyntax(condition);
            VisitLoopBody(this, node:getStatement(), whileStatement.Body);
            return whileStatement;
        end;
        VisitForStatement = function (this, node) 
            local block = CSharpLuaLuaAst.LuaBlockStatementSyntax();
            this.blocks_:Push(block);

            if node:getDeclaration() ~= nil then
                block.Statements:Add1(System.cast(CSharpLuaLuaAst.LuaVariableDeclarationSyntax, node:getDeclaration():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode)));
            end
            local initializers = Linq.Select(node:getInitializers(), function (i) return CSharpLuaLuaAst.LuaExpressionStatementSyntax(System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, i:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))); end, CSharpLuaLuaAst.LuaExpressionStatementSyntax);
            block.Statements:AddRange1(initializers);

            local default;
            if node:getCondition() ~= nil then
                default = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getCondition():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
            else
                default = CSharpLuaLuaAst.LuaIdentifierNameSyntax.True;
            end
            local condition = default;
            local whileStatement = CSharpLuaLuaAst.LuaWhileStatementSyntax(condition);
            this.blocks_:Push(whileStatement.Body);
            VisitLoopBody(this, node:getStatement(), whileStatement.Body);
            local incrementors = Linq.Select(node:getIncrementors(), function (i) return CSharpLuaLuaAst.LuaExpressionStatementSyntax(System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, i:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))); end, CSharpLuaLuaAst.LuaExpressionStatementSyntax);
            whileStatement.Body.Statements:AddRange1(incrementors);
            this.blocks_:Pop();
            block.Statements:Add1(whileStatement);
            this.blocks_:Pop();

            return block;
        end;
        VisitDoStatement = function (this, node) 
            local condition = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getCondition():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
            local newCondition = CSharpLuaLuaAst.LuaPrefixUnaryExpressionSyntax(CSharpLuaLuaAst.LuaParenthesizedExpressionSyntax(condition), "not" --[[Keyword.Not]]);
            local repeatStatement = CSharpLuaLuaAst.LuaRepeatStatementSyntax(newCondition);
            VisitLoopBody(this, node:getStatement(), repeatStatement.Body);
            return repeatStatement;
        end;
        VisitYieldStatement = function (this, node) 
            getCurFunction(this).HasYield = true;
            local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
            if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node, 8807 --[[SyntaxKind.YieldBreakStatement]]) then
                local returnStatement = CSharpLuaLuaAst.LuaReturnStatementSyntax:new(1, expression);
                return returnStatement;
            else
                local invocationExpression = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(1, CSharpLuaLuaAst.LuaIdentifierNameSyntax.YieldReturn);
                invocationExpression:AddArgument(expression);
                return CSharpLuaLuaAst.LuaExpressionStatementSyntax(invocationExpression);
            end
        end;
        VisitParenthesizedExpression = function (this, node) 
            local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
            return CSharpLuaLuaAst.LuaParenthesizedExpressionSyntax(expression);
        end;
        VisitConditionalExpression = function (this, node) 
            local mayBeNullOrFalse = MayBeNullOrFalse(this, node:getWhenTrue());
            if mayBeNullOrFalse then
                local temp = GetTempIdentifier(this, node);
                local condition = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getCondition():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                local ifStatement = CSharpLuaLuaAst.LuaIfStatementSyntax(condition);
                this.blocks_:Push(ifStatement.Body);
                local whenTrue = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getWhenTrue():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                this.blocks_:Pop();
                ifStatement.Body.Statements:Add1(CSharpLuaLuaAst.LuaExpressionStatementSyntax(CSharpLuaLuaAst.LuaAssignmentExpressionSyntax(temp, whenTrue)));

                local elseClause = CSharpLuaLuaAst.LuaElseClauseSyntax();
                this.blocks_:Push(elseClause.Body);
                local whenFalse = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getWhenFalse():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                this.blocks_:Pop();
                elseClause.Body.Statements:Add1(CSharpLuaLuaAst.LuaExpressionStatementSyntax(CSharpLuaLuaAst.LuaAssignmentExpressionSyntax(temp, whenFalse)));

                ifStatement.Else = elseClause;
                getCurBlock(this).Statements:Add1(CSharpLuaLuaAst.LuaLocalVariableDeclaratorSyntax:new(1, CSharpLuaLuaAst.LuaVariableDeclaratorSyntax(temp)));
                getCurBlock(this).Statements:Add1(ifStatement);
                return temp;
            else
                local condition = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getCondition():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                local whenTrue = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getWhenTrue():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                local whenFalse = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getWhenFalse():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                return CSharpLuaLuaAst.LuaBinaryExpressionSyntax(CSharpLuaLuaAst.LuaBinaryExpressionSyntax(condition, "and" --[[Keyword.And]], whenTrue), "or" --[[Keyword.Or]], whenFalse);
            end
        end;
        VisitGotoStatement = function (this, node) 
            if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getCaseOrDefaultKeyword(), 8332 --[[SyntaxKind.CaseKeyword]]) then
                local kCaseLabel = "caseLabel";
                local switchStatement = this.switchs_:Peek();
                local caseIndex = GetCaseLabelIndex(this, node);
                local labelIdentifier = CSharpLua.Utility.GetOrDefault1(switchStatement.CaseLabels, caseIndex, nil, System.Int, CSharpLuaLuaAst.LuaIdentifierNameSyntax);
                if labelIdentifier == nil then
                    local uniqueName = GetUniqueIdentifier(this, kCaseLabel .. caseIndex, node);
                    labelIdentifier = CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, uniqueName);
                    switchStatement.CaseLabels:Add(caseIndex, labelIdentifier);
                end
                return CSharpLuaLuaAst.LuaGotoCaseAdapterStatement(labelIdentifier);
            elseif MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getCaseOrDefaultKeyword(), 8333 --[[SyntaxKind.DefaultKeyword]]) then
                local kDefaultLabel = "defaultLabel";
                local switchStatement = this.switchs_:Peek();
                if switchStatement.DefaultLabel == nil then
                    local identifier = GetUniqueIdentifier(this, kDefaultLabel, node);
                    switchStatement.DefaultLabel = CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, identifier);
                end
                return CSharpLuaLuaAst.LuaGotoCaseAdapterStatement(switchStatement.DefaultLabel);
            else
                local identifier = System.cast(CSharpLuaLuaAst.LuaIdentifierNameSyntax, node:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                return CSharpLuaLuaAst.LuaGotoStatement(identifier);
            end
        end;
        VisitLabeledStatement = function (this, node) 
            local identifier = CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, node:getIdentifier():getValueText());
            local statement = System.cast(CSharpLuaLuaAst.LuaStatementSyntax, node:getStatement():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
            return CSharpLuaLuaAst.LuaLabeledStatement(identifier, statement);
        end;
        VisitEmptyStatement = function (this, node) 
            return CSharpLuaLuaAst.LuaStatementSyntax.Empty;
        end;
        VisitCastExpression = function (this, node) 
            local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));

            local originalType = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, node:getExpression()):getType();
            local targetType = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, node:getType()):getType();
            if CSharpLua.Utility.IsAssignableFrom(targetType, originalType) then
                return expression;
            end

            local typeExpression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getType():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
            return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(3, CSharpLuaLuaAst.LuaIdentifierNameSyntax.Cast, typeExpression, expression);
        end;
        VisitCheckedStatement = function (this, node) 
            local statements = CSharpLuaLuaAst.LuaStatementListSyntax();
            statements.Statements:Add1(CSharpLuaLuaAst.LuaShortCommentStatement(" " .. (node:getKeyword():getValueText() or "")));
            local block = System.cast(CSharpLuaLuaAst.LuaStatementSyntax, node:getBlock():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
            statements.Statements:Add1(block);
            return statements;
        end;
        VisitCheckedExpression = function (this, node) 
            --TODO 
            return node:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode);
        end;
        IsLocalVarExists = function (this, name, root) 
            local searcher = CSharpLuaLuaSyntaxNodeTransfor.LocalVarSearcher(name);
            return searcher:Find(root);
        end;
        GetNewIdentifierName = function (this, name, index) 
            repeat
                local default = index;
                if default == 0 then
                    return name;
                elseif default == 1 then
                    return (name or "") .. "_";
                elseif default == 2 then
                    return "_" .. (name or "");
                else
                    return (name or "") .. (index - 2);
                end
            until 1;
        end;
        FindFromCur = function (this, node, macth) 
            local cur = node;
            while cur ~= nil do
                if macth(cur) then
                    return cur;
                end
                cur = cur:getParent();
            end
            return nil;
        end;
        FindParent = function (this, node, macth) 
            local parent = node:getParent();
            while true do
                if macth(parent) then
                    return parent;
                end
                parent = parent:getParent();
            end
        end;
        FindParent1 = function (this, node, kind) 
            return FindParent(this, node, function (i) return MicrosoftCodeAnalysis.CSharpExtensions.IsKind(i, kind); end);
        end;
        GetUniqueIdentifier = function (this, name, node, index) 
            if index == nil then index = 0 end
            local root = System.cast(MicrosoftCodeAnalysisCSharpSyntax.MethodDeclarationSyntax, FindParent1(this, node, 8875 --[[SyntaxKind.MethodDeclaration]]));
            while true do
                local newName = GetNewIdentifierName(this, name, index);
                local exists = IsLocalVarExists(this, newName, root);
                if not exists then
                    return newName;
                end
                index = index + 1;
            end
        end;
        CheckReservedWord = function (this, name, node) 
            if CSharpLuaLuaAst.LuaSyntaxNode.IsReservedWord(name) then
                name = GetUniqueIdentifier(this, name, node, 1);
                AddReservedMapping(this, name, node);
                return true;
            end
            return false;
        end;
        AddReservedMapping = function (this, name, node) 
            local symbol = MicrosoftCodeAnalysis.ModelExtensions.GetDeclaredSymbol(this.semanticModel_, node);
            assert(symbol ~= nil);
            this.localReservedNames_:Add(symbol, name);
        end;
        CheckParameterName = function (this, parameter, node) 
            local name = parameter.Identifier.ValueText;
            local default;
            default, name = CheckReservedWord(this, name, node);
            local isReserved = default;
            if isReserved then
                parameter = CSharpLuaLuaAst.LuaParameterSyntax(CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, name));
            end
        end;
        CheckVariableDeclaratorName = function (this, identifierName, node) 
            local name = identifierName.ValueText;
            local default;
            default, name = CheckReservedWord(this, name, node);
            local isReserved = default;
            if isReserved then
                identifierName = CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, name);
            end
        end;
        CheckReservedWord1 = function (this, name, symbol) 
            if CSharpLuaLuaAst.LuaSyntaxNode.IsReservedWord(name) then
                name = this.localReservedNames_:get(symbol);
            end
        end;
        GetConstructorIndex = function (this, constructorSymbol) 
            if CSharpLua.Utility.IsFromCode(constructorSymbol) then
                local typeSymbol = System.cast(MicrosoftCodeAnalysis.INamedTypeSymbol, constructorSymbol:getReceiverType());
                if typeSymbol:getConstructors():getLength() > 1 then
                    local index = typeSymbol:getConstructors():IndexOf(constructorSymbol);
                    assert(index ~= - 1);
                    local ctroCounter = index + 1;
                    return ctroCounter;
                end
            end
            return 0;
        end;
        IsContinueExists = function (this, node) 
            local searcher = CSharpLuaLuaSyntaxNodeTransfor.ContinueSearcher();
            return searcher:Find(node);
        end;
        IsReturnExists = function (this, node) 
            local searcher = CSharpLuaLuaSyntaxNodeTransfor.ReturnStatementSearcher();
            return searcher:Find(node);
        end;
        GetCaseLabelIndex = function (this, node) 
            local switchStatement = System.cast(MicrosoftCodeAnalysisCSharpSyntax.SwitchStatementSyntax, FindParent1(this, node, 8821 --[[SyntaxKind.SwitchStatement]]));
            local index = 0;
            for _, section in System.each(switchStatement:getSections()) do
                local isFound = Linq.Any(section:getLabels(), function (i) 
                    if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(i, 8823 --[[SyntaxKind.CaseSwitchLabel]]) then
                        local label = System.cast(MicrosoftCodeAnalysisCSharpSyntax.CaseSwitchLabelSyntax, i);
                        if label:getValue():ToString() == node:getExpression():ToString() then
                            return true;
                        end
                    end
                    return false;
                end);
                if isFound then
                    return index;
                end
            end
            System.throw(System.InvalidOperationException());
        end;
        BuildCodeTemplateExpression = function (this, codeTemplate, targetExpression) 
            return BuildCodeTemplateExpression1(this, codeTemplate, targetExpression, System.Array.Empty(MicrosoftCodeAnalysisCSharpSyntax.ExpressionSyntax), SystemCollectionsImmutable.ImmutableArray_1(MicrosoftCodeAnalysis.ITypeSymbol).Empty);
        end;
        AddCodeTemplateExpression = function (this, expression, comma, codeTemplateExpression) 
            if not System.String.IsNullOrEmpty(comma) then
                codeTemplateExpression.Expressions:Add1(CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, comma));
            end
            codeTemplateExpression.Expressions:Add1(expression);
        end;
        BuildCodeTemplateExpression1 = function (this, codeTemplate, targetExpression, arguments, typeArguments) 
            local codeTemplateExpression = CSharpLuaLuaAst.LuaCodeTemplateExpressionSyntax();

            local matchs = codeTemplateRegex_:Matches(codeTemplate);
            local prevIndex = 0;
            for _, match in System.each(matchs) do
                if match:getIndex() > prevIndex then
                    local prevToken = codeTemplate:Substring(prevIndex, match:getIndex() - prevIndex);
                    codeTemplateExpression.Expressions:Add1(CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, prevToken));
                end
                local comma = match:getGroups():get(1):getValue();
                local key = match:getGroups():get(2):getValue();
                if key == "this" then
                    AddCodeTemplateExpression(this, BuildMemberAccessTargetExpression(this, targetExpression), comma, codeTemplateExpression);
                elseif key == "class" then
                    local type = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, targetExpression):getType();
                    local typeName = GetTypeName(this, type, targetExpression);
                    AddCodeTemplateExpression(this, typeName, comma, codeTemplateExpression);
                elseif key:get(0) == 94 --[['^']] then
                    local typeIndex;
                    local default;
                    default, typeIndex = System.Int.TryParse(key:Substring(1), typeIndex);
                    if default then
                        local typeArgument = CSharpLua.Utility.GetOrDefault(typeArguments, typeIndex, nil, MicrosoftCodeAnalysis.ITypeSymbol);
                        if typeArgument ~= nil then
                            local typeName = GetTypeName(this, typeArgument, targetExpression);
                            AddCodeTemplateExpression(this, typeName, comma, codeTemplateExpression);
                        end
                    end
                elseif key:get(0) == 42 --[['*']] then
                    local paramsIndex;
                    local extern;
                    extern, paramsIndex = System.Int.TryParse(key:Substring(1), paramsIndex);
                    if extern then
                        local paramsExpression = CSharpLuaLuaAst.LuaCodeTemplateExpressionSyntax();
                        for _, argument in System.each(Linq.Skip(arguments, paramsIndex)) do
                            local argumentExpression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, argument:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                            paramsExpression.Expressions:Add1(argumentExpression);
                        end
                        if #paramsExpression.Expressions > 0 then
                            AddCodeTemplateExpression(this, paramsExpression, comma, codeTemplateExpression);
                        end
                    end
                else
                    local argumentIndex;
                    local ref;
                    ref, argumentIndex = System.Int.TryParse(key, argumentIndex);
                    if ref then
                        local argument = CSharpLua.Utility.GetOrDefault(arguments, argumentIndex, nil, MicrosoftCodeAnalysisCSharpSyntax.ExpressionSyntax);
                        if argument ~= nil then
                            local argumentExpression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, argument:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                            AddCodeTemplateExpression(this, argumentExpression, comma, codeTemplateExpression);
                        end
                    end
                end
                prevIndex = match:getIndex() + match:getLength();
            end

            if prevIndex < #codeTemplate then
                local last = codeTemplate:Substring(prevIndex);
                codeTemplateExpression.Expressions:Add1(CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, last));
            end

            return codeTemplateExpression;
        end;
        IsPropertyField = function (this, symbol) 
            return CSharpLua.Utility.IsPropertyField(symbol) or getXmlMetaProvider(this):IsPropertyField(symbol);
        end;
        GetTypeDeclarationSymbol = function (this, node) 
            local typeDeclaration = System.cast(MicrosoftCodeAnalysisCSharpSyntax.TypeDeclarationSyntax, FindParent(this, node, function (i) return MicrosoftCodeAnalysis.CSharpExtensions.IsKind(i, 8855 --[[SyntaxKind.ClassDeclaration]]) or MicrosoftCodeAnalysis.CSharpExtensions.IsKind(i, 8856 --[[SyntaxKind.StructDeclaration]]); end));
            return MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetDeclaredSymbol(this.semanticModel_, typeDeclaration);
        end;
        IsInternalMember = function (this, node, symbol) 
            local isVirtual = CSharpLua.Utility.IsOverridable(symbol) and not symbol:getContainingType():getIsSealed();
            if not isVirtual then
                local typeSymbol = GetTypeDeclarationSymbol(this, node);
                if typeSymbol:Equals(symbol:getContainingType()) then
                    return true;
                end
            end
            return false;
        end;
        BuildEmptyArray = function (this, baseType) 
            return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(2, CSharpLuaLuaAst.LuaIdentifierNameSyntax.ArrayEmpty, baseType);
        end;
        GetConstLiteralExpression = function (this, constantValue) 
            if constantValue ~= nil then
                local code = System.Type.GetTypeCode(constantValue:GetType());
                repeat
                    local default = code;
                    if default == 4 --[[TypeCode.Char]] then
                        do
                            return CSharpLuaLuaAst.LuaCharacterLiteralExpression(System.cast(System.Char, constantValue));
                        end
                    elseif default == 18 --[[TypeCode.String]] then
                        do
                            return BuildStringLiteralExpression(this, System.cast(System.String, constantValue));
                        end
                    else
                        do
                            return CSharpLuaLuaAst.LuaIdentifierLiteralExpressionSyntax:new(1, constantValue:ToString());
                        end
                    end
                until 1;
            else
                return CSharpLuaLuaAst.LuaIdentifierLiteralExpressionSyntax:new(2, CSharpLuaLuaAst.LuaIdentifierNameSyntax.Nil);
            end
        end;
        GetConstLiteralExpression1 = function (this, constField) 
            assert(constField:getHasConstantValue());
            if constField:getType():getSpecialType() == 8 --[[SpecialType.System_Char]] then
                return CSharpLuaLuaAst.LuaCharacterLiteralExpression(System.cast(System.Char, constField:getConstantValue()));
            else
                local constExpression = GetConstLiteralExpression(this, constField:getConstantValue());
                local identifierToken = (constField:getContainingType():getName() or "") .. '.' .. (constField:getName() or "");
                return CSharpLuaLuaAst.LuaConstLiteralExpression:new(2, constExpression, identifierToken);
            end
        end;
        BuildStringLiteralTokenExpression = function (this, token) 
            if token:getText():get(0) == 64 --[['@']] then
                return BuildVerbatimStringExpression(this, token:getValueText());
            else
                return CSharpLuaLuaAst.LuaIdentifierLiteralExpressionSyntax:new(1, token:getText());
            end
        end;
        BuildStringLiteralExpression = function (this, value) 
            local text = MicrosoftCodeAnalysisCSharp.SyntaxFactory.Literal(value):getText();
            return CSharpLuaLuaAst.LuaIdentifierLiteralExpressionSyntax:new(1, text);
        end;
        BuildVerbatimStringExpression = function (this, value) 
            local kCloseBracket = "]" --[[Tokens.CloseBracket]];
            local equals = "=" --[[Tokens.Equals]]:get(0);
            local count = 0;
            while true do
                local closeToken = kCloseBracket .. (System.String(equals, count) or "") .. kCloseBracket;
                if not value:Contains(closeToken) then
                    break;
                end
                count = count + 1;
            end
            if value:get(0) == 10 --[['\n']] then
                value = '\n' .. (value or "");
            end
            return CSharpLuaLuaAst.LuaVerbatimStringLiteralExpressionSyntax(value, count);
        end;
        GetCallerAttributeKind = function (this, typeSymbol) 
            repeat
                local default = typeSymbol:ToString();
                if default == "System.Runtime.CompilerServices.CallerLineNumberAttribute" then
                    return 1 --[[CallerAttributeKind.Line]];
                elseif default == "System.Runtime.CompilerServices.CallerMemberNameAttribute" then
                    return 2 --[[CallerAttributeKind.Member]];
                elseif default == "System.Runtime.CompilerServices.CallerFilePathAttribute" then
                    return 3 --[[CallerAttributeKind.FilePath]];
                else
                    return 0 --[[CallerAttributeKind.None]];
                end
            until 1;
        end;
        GetCallerAttributeKind1 = function (this, parameter) 
            for _, attribute in System.each(parameter:GetAttributes()) do
                local callerKind = GetCallerAttributeKind(this, attribute:getAttributeClass());
                if callerKind ~= 0 --[[CallerAttributeKind.None]] then
                    return callerKind;
                end
            end
            return 0 --[[CallerAttributeKind.None]];
        end;
        IsCallerAttribute = function (this, attribute) 
            local method = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetSymbolInfo(this.semanticModel_, attribute:getName()):getSymbol();
            return GetCallerAttributeKind(this, method:getContainingType()) ~= 0 --[[CallerAttributeKind.None]];
        end;
        CheckCallerAttribute = function (this, parameter, node) 
            local kind = GetCallerAttributeKind1(this, parameter);
            repeat
                local default = kind;
                if default == 1 --[[CallerAttributeKind.Line]] then
                    do
                        local lineSpan = node:getSyntaxTree():GetLineSpan(node:getSpan());
                        return CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(2, lineSpan:getStartLinePosition():getLine() + 1);
                    end
                elseif default == 2 --[[CallerAttributeKind.Member]] then
                    do
                        local parentMethod = System.cast(MicrosoftCodeAnalysisCSharpSyntax.MethodDeclarationSyntax, FindParent1(this, node, 8875 --[[SyntaxKind.MethodDeclaration]]));
                        return CSharpLuaLuaAst.LuaStringLiteralExpressionSyntax:new(1, CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, parentMethod:getIdentifier():getValueText()));
                    end
                elseif default == 3 --[[CallerAttributeKind.FilePath]] then
                    do
                        return BuildStringLiteralExpression(this, node:getSyntaxTree():getFilePath());
                    end
                else
                    return nil;
                end
            until 1;
        end;
        CheckUsingStaticNameSyntax = function (this, symbol, node) 
            if not MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getParent(), 8689 --[[SyntaxKind.SimpleMemberAccessExpression]]) then
                if symbol:getContainingType() ~= GetTypeDeclarationSymbol(this, node) then
                    --using static
                    local luadTypeExpression = GetTypeName(this, symbol:getContainingType(), node);
                    return luadTypeExpression;
                end
            end
            return nil;
        end;
        MayBeFalse = function (this, expression, type) 
            local mayBeFalse = false;
            if type:getIsValueType() then
                if type:getSpecialType() == 7 --[[SpecialType.System_Boolean]] then
                    local constValue = this.semanticModel_:GetConstantValue(expression);
                    if constValue:getHasValue() and System.cast(System.Boolean, constValue:getValue()) then
                        mayBeFalse = false;
                    else
                        mayBeFalse = true;
                    end
                end
            end
            return mayBeFalse;
        end;
        MayBeNull = function (this, expression, type) 
            if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(expression, 8644 --[[SyntaxKind.ObjectInitializerExpression]]) then
                return false;
            end

            local mayBeNull;
            if type:getIsValueType() then
                mayBeNull = false;
            elseif CSharpLua.Utility.IsStringType(type) then
                local constValue = this.semanticModel_:GetConstantValue(expression);
                if constValue:getHasValue() then
                    mayBeNull = false;
                else
                    if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(expression, 8634 --[[SyntaxKind.InvocationExpression]]) then
                        local invocation = System.cast(MicrosoftCodeAnalysisCSharpSyntax.InvocationExpressionSyntax, expression);
                        if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(invocation:getExpression(), 8689 --[[SyntaxKind.SimpleMemberAccessExpression]]) then
                            local memberAccess = System.cast(MicrosoftCodeAnalysisCSharpSyntax.MemberAccessExpressionSyntax, invocation:getExpression());
                            if memberAccess:getName():getIdentifier():getValueText() == CSharpLuaLuaAst.LuaIdentifierNameSyntax.ToStr.ValueText then
                                local typeInfo = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, memberAccess:getExpression()):getType();
                                if typeInfo:getSpecialType() > 1 --[[SpecialType.System_Object]] then
                                    return false;
                                end
                            end
                        end
                    elseif MicrosoftCodeAnalysis.CSharpExtensions.IsKind(expression, 8689 --[[SyntaxKind.SimpleMemberAccessExpression]]) then
                        local memberAccess = System.cast(MicrosoftCodeAnalysisCSharpSyntax.MemberAccessExpressionSyntax, expression);
                        local typeInfo = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, memberAccess:getExpression()):getType();
                        if typeInfo:getSpecialType() > 1 --[[SpecialType.System_Object]] then
                            return false;
                        end
                    end
                    mayBeNull = true;
                end
            else
                mayBeNull = true;
            end
            return mayBeNull;
        end;
        MayBeNullOrFalse = function (this, conditionalWhenTrue) 
            local type = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, conditionalWhenTrue):getType();
            return MayBeNull(this, conditionalWhenTrue, type) or MayBeFalse(this, conditionalWhenTrue, type);
        end;
        ImportTypeName = function (this, name, symbol, node) 
            local pos = name:LastIndexOf(46 --[['.']]);
            if pos ~= - 1 then
                local prefix = name:Substring(0, pos);
                if prefix ~= CSharpLuaLuaAst.LuaIdentifierNameSyntax.System.ValueText then
                    local newPrefix = prefix:Replace(".", "");
                    if node ~= nil then
                        local root = System.cast(MicrosoftCodeAnalysisCSharpSyntax.BaseMethodDeclarationSyntax, FindFromCur(this, node, function (i) return System.is(i, MicrosoftCodeAnalysisCSharpSyntax.BaseMethodDeclarationSyntax); end));
                        if root ~= nil then
                            if IsLocalVarExists(this, newPrefix, root) then
                                return;
                            end
                        end
                    end
                    name = (newPrefix or "") .. (name:Substring(pos) or "");
                    getCurCompilationUnit(this):AddImport1(prefix, newPrefix, CSharpLua.Utility.IsFromCode(symbol));
                end
            end
        end;
        GetTypeShortName = function (this, symbol, node) 
            return getXmlMetaProvider(this):GetTypeShortName(symbol, this, node);
        end;
        GetTypeName = function (this, symbol, node) 
            return getXmlMetaProvider(this):GetTypeName(symbol, this, node);
        end;
        VisitObjectCreationExpression = function (this, node) 
            local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getType():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));

            local symbol = System.cast(MicrosoftCodeAnalysis.IMethodSymbol, MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetSymbolInfo(this.semanticModel_, node):getSymbol());
            local index = GetConstructorIndex(this, symbol);
            if index > 0 then
                expression = CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(expression, CSharpLuaLuaAst.LuaIdentifierNameSyntax.New, true);
            end

            local argumentList = System.cast(CSharpLuaLuaAst.LuaArgumentListSyntax, node:getArgumentList():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
            local invocationExpression = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(1, expression);
            if index > 0 then
                invocationExpression:AddArgument(CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(2, index));
            end
            invocationExpression.ArgumentList.Arguments:AddRange1(argumentList.Arguments);
            if node:getInitializer() == nil then
                return invocationExpression;
            else
                local functionExpression = BuildObjectInitializerExpression(this, node:getInitializer());
                return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(3, CSharpLuaLuaAst.LuaIdentifierNameSyntax.Create, invocationExpression, functionExpression);
            end
        end;
        BuildObjectInitializerExpression = function (this, node) 
            local function_ = CSharpLuaLuaAst.LuaFunctionExpressionSyntax();
            PushFunction(this, function_);
            local temp = GetTempIdentifier(this, node);
            function_:AddParameter(temp);
            for _, expression in System.each(node:getExpressions()) do
                if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(expression, 8714 --[[SyntaxKind.SimpleAssignmentExpression]]) then
                    local assignment = System.cast(MicrosoftCodeAnalysisCSharpSyntax.AssignmentExpressionSyntax, expression);
                    local left = assignment:getLeft():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode);
                    local right = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, assignment:getRight():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));

                    if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(assignment:getLeft(), 8656 --[[SyntaxKind.ImplicitElementAccess]]) then
                        local argumentList = System.cast(CSharpLuaLuaAst.LuaArgumentListSyntax, left);
                        local methodName = CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, "set" --[[Tokens.Set]]);
                        local memberAccess = CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(temp, methodName, true);
                        local invocation = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(1, memberAccess);
                        invocation.ArgumentList.Arguments:AddRange1(argumentList.Arguments);
                        invocation:AddArgument(right);
                        function_:AddStatement1(invocation);
                    else
                        local identifierName = System.cast(CSharpLuaLuaAst.LuaIdentifierNameSyntax, left);
                        local newIdentifier = identifierName.ValueText:Replace(CSharpLuaLuaAst.LuaIdentifierNameSyntax.This.ValueText, temp.ValueText);
                        identifierName = CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, newIdentifier);
                        function_:AddStatement1(CSharpLuaLuaAst.LuaAssignmentExpressionSyntax(identifierName, right));
                    end
                else
                    local memberAccess = CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(temp, CSharpLuaLuaAst.LuaIdentifierNameSyntax.Add, true);
                    local value = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, expression:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                    function_:AddStatement1(CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(2, memberAccess, value));
                end
            end

            PopFunction(this);
            return function_;
        end;
        VisitInitializerExpression = function (this, node) 
            assert(MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node, 8646 --[[SyntaxKind.ArrayInitializerExpression]]));
            local symbol = System.cast(MicrosoftCodeAnalysis.IArrayTypeSymbol, MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, node):getConvertedType());
            if node:getExpressions():getCount() > 0 then
                local arrayType = GetTypeName(this, symbol, node);
                local invocation = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(1, arrayType);
                for _, expression in System.each(node:getExpressions()) do
                    local element = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, expression:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                    invocation:AddArgument(element);
                end
                return invocation;
            else
                local baseType = GetTypeName(this, symbol:getElementType(), node);
                return BuildEmptyArray(this, baseType);
            end
        end;
        VisitBracketedArgumentList = function (this, node) 
            return BuildArgumentList(this, node:getArguments());
        end;
        VisitImplicitElementAccess = function (this, node) 
            return node:getArgumentList():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode);
        end;
        VisitGenericName = function (this, node) 
            local symbolInfo = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetSymbolInfo(this.semanticModel_, node);
            local symbol = symbolInfo:getSymbol();
            if symbol:getKind() == 9 --[[SymbolKind.Method]] then
                return GetMethodNameExpression(this, System.cast(MicrosoftCodeAnalysis.IMethodSymbol, symbol), node);
            else
                local name = GetTypeShortName(this, symbol, node);
                return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(5, name, Linq.Select(node:getTypeArgumentList():getArguments(), function (i) return System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, i:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode)); end, CSharpLuaLuaAst.LuaExpressionSyntax));
            end
        end;
        VisitOmittedArraySizeExpression = function (this, node) 
            return nil;
        end;
        VisitArrayRankSpecifier = function (this, node) 
            local rankSpecifier = CSharpLuaLuaAst.LuaArrayRankSpecifierSyntax(node:getRank());
            for _, size in System.each(node:getSizes()) do
                local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, size:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                rankSpecifier.Sizes:Add(expression);
            end
            return rankSpecifier;
        end;
        VisitArrayType = function (this, node) 
            local elementType = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getElementType():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));

            local typeExpress = nil;
            for _, rank in System.each(Linq.Reverse(node:getRankSpecifiers())) do
                local default;
                if rank:getRank() == 1 then
                    default = CSharpLuaLuaAst.LuaIdentifierNameSyntax.Array;
                else
                    default = CSharpLuaLuaAst.LuaIdentifierNameSyntax.MultiArray;
                end
                local arrayTypeName = default;
                typeExpress = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(2, arrayTypeName, typeExpress or elementType);
            end

            local arrayRankSpecifier = System.cast(CSharpLuaLuaAst.LuaArrayRankSpecifierSyntax, node:getRankSpecifiers():get(0):Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
            local arrayTypeAdapter = CSharpLuaLuaAst.LuaArrayTypeAdapterExpressionSyntax(typeExpress, arrayRankSpecifier);
            return arrayTypeAdapter;
        end;
        FillMultiArrayInitializer = function (this, initializer, rankSpecifier, invocation, isFirst) 
            if isFirst then
                rankSpecifier.Items:Add1(CSharpLuaLuaAst.LuaSingleTableItemSyntax(CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(2, initializer:getExpressions():getCount())));
            end

            local index = 0;
            for _, expression in System.each(initializer:getExpressions()) do
                if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(expression, 8646 --[[SyntaxKind.ArrayInitializerExpression]]) then
                    FillMultiArrayInitializer(this, System.cast(MicrosoftCodeAnalysisCSharpSyntax.InitializerExpressionSyntax, expression), rankSpecifier, invocation, index == 0);
                else
                    local item = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, expression:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                    invocation:AddArgument(item);
                end
                index = index + 1;
            end
        end;
        VisitArrayCreationExpression = function (this, node) 
            local arrayType = System.cast(CSharpLuaLuaAst.LuaArrayTypeAdapterExpressionSyntax, node:getType():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
            if node:getInitializer() ~= nil and node:getInitializer():getExpressions():getCount() > 0 then
                if arrayType:getIsSimapleArray() then
                    return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(5, arrayType, Linq.Select(node:getInitializer():getExpressions(), function (i) return System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, i:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode)); end, CSharpLuaLuaAst.LuaExpressionSyntax));
                else
                    local rankSpecifier = CSharpLuaLuaAst.LuaTableInitializerExpression();
                    local invocationExpression = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(2, arrayType, rankSpecifier);
                    FillMultiArrayInitializer(this, node:getInitializer(), rankSpecifier, invocationExpression, true);
                    return invocationExpression;
                end
            else
                if arrayType:getIsSimapleArray() then
                    local size = arrayType.RankSpecifier.Sizes:get(0);
                    if size == nil then
                        return BuildEmptyArray(this, arrayType:getBaseType());
                    end

                    local constSize = System.as(size, CSharpLuaLuaAst.LuaLiteralExpressionSyntax);
                    if constSize ~= nil and constSize:getText() == (0):ToString() then
                        return BuildEmptyArray(this, arrayType:getBaseType());
                    end

                    local memberAccess = CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(arrayType, CSharpLuaLuaAst.LuaIdentifierNameSyntax.New, true);
                    return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(2, memberAccess, size);
                else
                    local rankSpecifier = CSharpLuaLuaAst.LuaTableInitializerExpression();
                    for _, size in System.each(arrayType.RankSpecifier.Sizes) do
                        if size ~= nil then
                            rankSpecifier.Items:Add1(CSharpLuaLuaAst.LuaSingleTableItemSyntax(size));
                        else
                            rankSpecifier.Items:Add1(CSharpLuaLuaAst.LuaSingleTableItemSyntax(CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(2, 0)));
                        end
                    end
                    return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(2, arrayType, rankSpecifier);
                end
            end
        end;
        VisitImplicitArrayCreationExpression = function (this, node) 
            local symbol = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, node:getInitializer():getExpressions():First()):getType();
            local elementTypeExpression = GetTypeName(this, symbol, node);
            local arrayTypeExpression = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(2, CSharpLuaLuaAst.LuaIdentifierNameSyntax.Array, elementTypeExpression);
            local invocation = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(1, arrayTypeExpression);
            for _, expression in System.each(node:getInitializer():getExpressions()) do
                local element = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, expression:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                invocation:AddArgument(element);
            end
            return invocation;
        end;
        VisitConstructorDeclaration = function (this, node) 
            local function_ = CSharpLuaLuaAst.LuaConstructorAdapterExpressionSyntax();
            PushFunction(this, function_);
            local isStatic = CSharpLua.Utility.IsStatic(node:getModifiers());
            function_.IsStaticCtor = isStatic;
            local parameterList = System.cast(CSharpLuaLuaAst.LuaParameterListSyntax, node:getParameterList():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
            function_:AddParameter(CSharpLuaLuaAst.LuaIdentifierNameSyntax.This);
            function_.ParameterList.Parameters:AddRange1(parameterList.Parameters);
            if node:getInitializer() ~= nil then
                local symbol = System.cast(MicrosoftCodeAnalysis.IMethodSymbol, MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetSymbolInfo(this.semanticModel_, node:getInitializer()):getSymbol());
                local ctroCounter = GetConstructorIndex(this, symbol);
                local otherCtorInvoke;
                if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getInitializer(), 8890 --[[SyntaxKind.ThisConstructorInitializer]]) then
                    assert(ctroCounter ~= 0);
                    local thisCtor = CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, CSharpLuaLuaAst.LuaSyntaxNode.SpecailWord("ctor" --[[Tokens.Ctor]] .. ctroCounter));
                    otherCtorInvoke = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(1, thisCtor);
                    function_.IsInvokeThisCtor = true;
                else
                    local typeName = GetTypeName(this, symbol:getReceiverType(), node);
                    local memberAccess = CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(typeName, CSharpLuaLuaAst.LuaIdentifierNameSyntax.Ctor);
                    if ctroCounter > 0 then
                        otherCtorInvoke = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(1, CSharpLuaLuaAst.LuaTableIndexAccessExpressionSyntax(memberAccess, CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(2, ctroCounter)));
                    else
                        otherCtorInvoke = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(1, memberAccess);
                    end
                end

                otherCtorInvoke:AddArgument(CSharpLuaLuaAst.LuaIdentifierNameSyntax.This);
                local argumentList = System.cast(CSharpLuaLuaAst.LuaArgumentListSyntax, node:getInitializer():getArgumentList():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                otherCtorInvoke.ArgumentList.Arguments:AddRange1(argumentList.Arguments);
                function_:AddStatement1(otherCtorInvoke);
            end
            local block = System.cast(CSharpLuaLuaAst.LuaBlockSyntax, node:getBody():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
            function_:AddStatements(block.Statements);
            PopFunction(this);
            if isStatic then
                getCurType(this):SetStaticCtor(function_);
            else
                getCurType(this):AddCtor(function_);
            end
            return function_;
        end;
        VisitSimpleBaseType = function (this, node) 
            return node:getType():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode);
        end;
        VisitLambdaExpression = function (this, parameters, body) 
            local function_ = CSharpLuaLuaAst.LuaFunctionExpressionSyntax();
            PushFunction(this, function_);

            for _, parameter in System.each(parameters) do
                local luaParameter = System.cast(CSharpLuaLuaAst.LuaParameterSyntax, parameter:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                function_.ParameterList.Parameters:Add1(luaParameter);
            end

            local resultExpression = function_;
            if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(body, 8792 --[[SyntaxKind.Block]]) then
                local block = System.cast(CSharpLuaLuaAst.LuaBlockSyntax, body:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                function_:AddStatements(block.Statements);
            else
                local type = System.cast(MicrosoftCodeAnalysis.INamedTypeSymbol, MicrosoftCodeAnalysis.ModelExtensions.GetTypeInfo(this.semanticModel_, body:getParent()):getConvertedType());
                local delegateInvokeMethod = type:getDelegateInvokeMethod();

                this.blocks_:Push(function_.Body);
                local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, body:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                this.blocks_:Pop();
                if delegateInvokeMethod:getReturnsVoid() then
                    function_:AddStatement1(expression);
                else
                    function_:AddStatement(CSharpLuaLuaAst.LuaReturnStatementSyntax:new(1, expression));
                end
                if #function_.Body.Statements == 1 then
                    resultExpression = CSharpLuaLuaAst.LuaSimpleLambdaAdapterExpression(function_);
                end
            end

            PopFunction(this);
            return resultExpression;
        end;
        VisitSimpleLambdaExpression = function (this, node) 
            return VisitLambdaExpression(this, System.Array(MicrosoftCodeAnalysisCSharpSyntax.ParameterSyntax)(node:getParameter()), node:getBody());
        end;
        VisitParenthesizedLambdaExpression = function (this, node) 
            return VisitLambdaExpression(this, node:getParameterList():getParameters(), node:getBody());
        end;
        VisitTypeParameter = function (this, node) 
            return CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, node:getIdentifier():getValueText());
        end;
        VisitTypeOfExpression = function (this, node) 
            local typeName = System.cast(CSharpLuaLuaAst.LuaIdentifierNameSyntax, node:getType():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
            return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(2, CSharpLuaLuaAst.LuaIdentifierNameSyntax.TypeOf, typeName);
        end;
        VisitThrowStatement = function (this, node) 
            local invocationExpression = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(1, CSharpLuaLuaAst.LuaIdentifierNameSyntax.Throw);
            if node:getExpression() ~= nil then
                local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                invocationExpression:AddArgument(expression);
            else
                local curTryFunction = System.cast(CSharpLuaLuaAst.LuaTryAdapterExpressionSyntax, getCurFunction(this));
                assert(curTryFunction.CatchTemp ~= nil);
                invocationExpression:AddArgument(curTryFunction.CatchTemp);
            end
            return CSharpLuaLuaAst.LuaExpressionStatementSyntax(invocationExpression);
        end;
        VisitCatchFilterClause = function (this, node) 
            return node:getFilterExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode);
        end;
        VisitCatchClause = function (this, node) 
            System.throw(System.InvalidOperationException());
        end;
        VisitCatchDeclaration = function (this, node) 
            return CSharpLuaLuaAst.LuaVariableDeclaratorSyntax(CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, node:getIdentifier():getValueText()));
        end;
        VisitTryCatchesExpress = function (this, catches) 
            local functionExpress = CSharpLuaLuaAst.LuaTryAdapterExpressionSyntax();
            PushFunction(this, functionExpress);
            local temp = GetTempIdentifier(this, catches:First());
            functionExpress.CatchTemp = temp;
            functionExpress:AddParameter(temp);

            local ifStatement = nil;
            local hasCatchRoot = false;
            for _, catchNode in System.each(catches) do
                local isRootExceptionDeclaration = false;
                local ifCondition = nil;
                if catchNode:getFilter() ~= nil then
                    ifCondition = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, catchNode:getFilter():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                end
                if catchNode:getDeclaration() ~= nil then
                    local typeName = System.cast(CSharpLuaLuaAst.LuaIdentifierNameSyntax, catchNode:getDeclaration():getType():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                    if typeName.ValueText ~= "System.Exception" then
                        local mathcTypeInvocation = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(3, CSharpLuaLuaAst.LuaIdentifierNameSyntax.Is, temp, typeName);
                        if ifCondition ~= nil then
                            ifCondition = CSharpLuaLuaAst.LuaBinaryExpressionSyntax(ifCondition, "and" --[[Keyword.And]], mathcTypeInvocation);
                        else
                            ifCondition = mathcTypeInvocation;
                        end
                    else
                        if not MicrosoftCodeAnalysis.CSharpExtensions.IsKind(catchNode:getDeclaration():getIdentifier(), 0 --[[SyntaxKind.None]]) then
                            isRootExceptionDeclaration = true;
                        end
                        hasCatchRoot = true;
                    end
                else
                    hasCatchRoot = true;
                end

                local block = System.cast(CSharpLuaLuaAst.LuaBlockSyntax, catchNode:getBlock():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                if ifCondition ~= nil then
                    local body;
                    if ifStatement == nil then
                        ifStatement = CSharpLuaLuaAst.LuaIfStatementSyntax(ifCondition);
                        body = ifStatement.Body;
                    else
                        local elseIfStatement = CSharpLuaLuaAst.LuaElseIfStatementSyntax(ifCondition);
                        body = elseIfStatement.Body;
                        ifStatement.ElseIfStatements:Add1(elseIfStatement);
                    end
                    if catchNode:getDeclaration() ~= nil and not MicrosoftCodeAnalysis.CSharpExtensions.IsKind(catchNode:getDeclaration():getIdentifier(), 0 --[[SyntaxKind.None]]) then
                        local variableDeclarator = System.cast(CSharpLuaLuaAst.LuaVariableDeclaratorSyntax, catchNode:getDeclaration():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                        variableDeclarator.Initializer = CSharpLuaLuaAst.LuaEqualsValueClauseSyntax(temp);
                        body.Statements:Add1(CSharpLuaLuaAst.LuaLocalVariableDeclaratorSyntax:new(1, variableDeclarator));
                    end
                    body.Statements:AddRange1(block.Statements);
                else
                    if isRootExceptionDeclaration then
                        local variableDeclarator = System.cast(CSharpLuaLuaAst.LuaVariableDeclaratorSyntax, catchNode:getDeclaration():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                        variableDeclarator.Initializer = CSharpLuaLuaAst.LuaEqualsValueClauseSyntax(temp);
                        block.Statements:Insert(0, CSharpLuaLuaAst.LuaLocalVariableDeclaratorSyntax:new(1, variableDeclarator));
                    end

                    if ifStatement ~= nil then
                        local elseClause = CSharpLuaLuaAst.LuaElseClauseSyntax();
                        elseClause.Body.Statements:AddRange1(block.Statements);
                        ifStatement.Else = elseClause;
                    else
                        functionExpress:AddStatements(block.Statements);
                    end
                    break;
                end
            end

            if ifStatement ~= nil then
                if not hasCatchRoot then
                    assert(ifStatement.Else == nil);
                    local rethrowStatement = CSharpLuaLuaAst.LuaMultipleReturnStatementSyntax();
                    rethrowStatement.Expressions:Add1(CSharpLuaLuaAst.LuaIdentifierNameSyntax.One);
                    rethrowStatement.Expressions:Add1(temp);
                    local block = CSharpLuaLuaAst.LuaBlockSyntax();
                    block.Statements:Add1(rethrowStatement);
                    local elseClause = CSharpLuaLuaAst.LuaElseClauseSyntax();
                    elseClause.Body.Statements:AddRange1(block.Statements);
                    ifStatement.Else = elseClause;
                end
                functionExpress:AddStatement(ifStatement);
            end

            PopFunction(this);
            return functionExpress;
        end;
        BuildCheckReturnInvocationExpression = function (this, invocationExpression, node) 
            if IsReturnExists(this, node) then
                local temp1 = GetTempIdentifier(this, node);
                local temp2 = GetTempIdentifier(this, node);
                local localVariables = CSharpLuaLuaAst.LuaLocalVariablesStatementSyntax();
                localVariables.Variables:Add1(temp1);
                localVariables.Variables:Add1(temp2);
                local initializer = CSharpLuaLuaAst.LuaEqualsValueClauseListSyntax();
                initializer.Values:Add1(invocationExpression);
                localVariables.Initializer = initializer;

                local ifStatement = CSharpLuaLuaAst.LuaIfStatementSyntax(temp1);
                if System.is(getCurFunction(this), CSharpLuaLuaAst.LuaCheckReturnFunctionExpressionSyntax) then
                    local returnStatement = CSharpLuaLuaAst.LuaMultipleReturnStatementSyntax();
                    returnStatement.Expressions:Add1(CSharpLuaLuaAst.LuaIdentifierNameSyntax.True);
                    returnStatement.Expressions:Add1(temp2);
                    ifStatement.Body.Statements:Add1(returnStatement);
                else
                    ifStatement.Body.Statements:Add1(CSharpLuaLuaAst.LuaReturnStatementSyntax:new(1, temp2));
                end

                local statements = CSharpLuaLuaAst.LuaStatementListSyntax();
                statements.Statements:Add1(localVariables);
                statements.Statements:Add1(ifStatement);
                return statements;
            else
                return CSharpLuaLuaAst.LuaExpressionStatementSyntax(invocationExpression);
            end
        end;
        VisitFinallyClause = function (this, node) 
            local functionExpress = CSharpLuaLuaAst.LuaFunctionExpressionSyntax();
            PushFunction(this, functionExpress);
            local finallyBlock = System.cast(CSharpLuaLuaAst.LuaBlockSyntax, node:getBlock():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
            PopFunction(this);
            functionExpress:AddStatements(finallyBlock.Statements);
            return functionExpress;
        end;
        VisitTryStatement = function (this, node) 
            local tryInvocationExpression = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(1, CSharpLuaLuaAst.LuaIdentifierNameSyntax.Try);

            local tryBlockFunctionExpress = CSharpLuaLuaAst.LuaTryAdapterExpressionSyntax();
            PushFunction(this, tryBlockFunctionExpress);
            local block = System.cast(CSharpLuaLuaAst.LuaBlockSyntax, node:getBlock():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
            PopFunction(this);
            tryBlockFunctionExpress:AddStatements(block.Statements);
            tryInvocationExpression:AddArgument(tryBlockFunctionExpress);

            if node:getCatches():getCount() > 0 then
                local catchesExpress = VisitTryCatchesExpress(this, node:getCatches());
                tryInvocationExpression:AddArgument(catchesExpress);
            else
                tryInvocationExpression:AddArgument(CSharpLuaLuaAst.LuaIdentifierNameSyntax.Nil);
            end

            if node:getFinally() ~= nil then
                local finallyfunctionExpress = System.cast(CSharpLuaLuaAst.LuaFunctionExpressionSyntax, node:getFinally():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                tryInvocationExpression:AddArgument(finallyfunctionExpress);
            end

            return BuildCheckReturnInvocationExpression(this, tryInvocationExpression, node);
        end;
        VisitUsingStatement = function (this, node) 
            local variableIdentifiers = System.List(CSharpLuaLuaAst.LuaIdentifierNameSyntax)();
            local variableExpressions = System.List(CSharpLuaLuaAst.LuaExpressionSyntax)();
            if node:getDeclaration() ~= nil then
                local variableList = System.cast(CSharpLuaLuaAst.LuaVariableListDeclarationSyntax, node:getDeclaration():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                for _, variable in System.each(variableList.Variables) do
                    variableIdentifiers:Add(variable.Identifier);
                    variableExpressions:Add(variable.Initializer.Value);
                end
            else
                local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                variableExpressions:Add(expression);
            end

            local usingAdapterExpress = CSharpLuaLuaAst.LuaUsingAdapterExpressionSyntax();
            usingAdapterExpress.ParameterList.Parameters:AddRange1(Linq.Select(variableIdentifiers, function (i) return CSharpLuaLuaAst.LuaParameterSyntax(i); end, CSharpLuaLuaAst.LuaParameterSyntax));
            PushFunction(this, usingAdapterExpress);
            WriteStatementOrBlock(this, node:getStatement(), usingAdapterExpress.Body);
            PopFunction(this);

            if #variableExpressions == 1 then
                local usingInvocationExpression = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(1, CSharpLuaLuaAst.LuaIdentifierNameSyntax.Using);
                usingInvocationExpression:AddArgument(CSharpLua.Utility.First(variableExpressions, CSharpLuaLuaAst.LuaExpressionSyntax));
                usingInvocationExpression:AddArgument(usingAdapterExpress);
                return BuildCheckReturnInvocationExpression(this, usingInvocationExpression, node);
            else
                local usingInvocationExpression = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(1, CSharpLuaLuaAst.LuaIdentifierNameSyntax.UsingX);
                usingInvocationExpression:AddArgument(usingAdapterExpress);
                usingInvocationExpression.ArgumentList.Arguments:AddRange1(Linq.Select(variableExpressions, function (i) return CSharpLuaLuaAst.LuaArgumentSyntax(i); end, CSharpLuaLuaAst.LuaArgumentSyntax));
                return BuildCheckReturnInvocationExpression(this, usingInvocationExpression, node);
            end
        end;
        VisitThisExpression = function (this, node) 
            return CSharpLuaLuaAst.LuaIdentifierNameSyntax.This;
        end;
        IsBaseEnable = function (this, parent, symbol, overriddenFunc, T) 
            if CSharpLua.Utility.IsOverridable(symbol) then
                local curTypeSymbol = GetTypeDeclarationSymbol(this, parent);
                if curTypeSymbol:getIsSealed() then
                    local exists = Linq.Any(curTypeSymbol:GetMembers():OfType(T), function (i) 
                        local overriddenSymbol = overriddenFunc(i);
                        return overriddenSymbol ~= nil and overriddenSymbol:Equals(symbol);
                    end);
                    if not exists then
                        return false;
                    end
                end
                return true;
            end
            return false;
        end;
        VisitBaseExpression = function (this, node) 
            local parent = System.cast(MicrosoftCodeAnalysisCSharpSyntax.MemberAccessExpressionSyntax, node:getParent());
            local symbol = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetSymbolInfo(this.semanticModel_, parent):getSymbol();

            local hasBase = false;
            repeat
                local default = symbol:getKind();
                if default == 9 --[[SymbolKind.Method]] then
                    do
                        local methodSymbol = System.cast(MicrosoftCodeAnalysis.IMethodSymbol, symbol);
                        if IsBaseEnable(this, parent, methodSymbol, function (i) return i:getOverriddenMethod(); end, MicrosoftCodeAnalysis.IMethodSymbol) then
                            hasBase = true;
                        end
                        break;
                    end
                elseif default == 15 --[[SymbolKind.Property]] then
                    do
                        local propertySymbol = System.cast(MicrosoftCodeAnalysis.IPropertySymbol, symbol);
                        if not IsPropertyField(this, propertySymbol) then
                            if IsBaseEnable(this, parent, propertySymbol, function (i) return i:getOverriddenProperty(); end, MicrosoftCodeAnalysis.IPropertySymbol) then
                                hasBase = true;
                            end
                        end
                        break;
                    end
                elseif default == 5 --[[SymbolKind.Event]] then
                    do
                        local eventSymbol = System.cast(MicrosoftCodeAnalysis.IEventSymbol, symbol);
                        if not CSharpLua.Utility.IsEventFiled(eventSymbol) then
                            if IsBaseEnable(this, parent, eventSymbol, function (i) return i:getOverriddenEvent(); end, MicrosoftCodeAnalysis.IEventSymbol) then
                                hasBase = true;
                            end
                        end
                        break;
                    end
                end
            until 1;

            if hasBase then
                return GetTypeName(this, symbol:getContainingType());
            else
                return CSharpLuaLuaAst.LuaIdentifierNameSyntax.This;
            end
        end;
        VisitConditionalAccessExpression = function (this, node) 
            local temp = GetTempIdentifier(this, node:getExpression());
            this.conditionalTemps_:Push(temp);

            local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
            getCurBlock(this).Statements:Add1(CSharpLuaLuaAst.LuaLocalVariableDeclaratorSyntax:new(2, temp, expression));

            local condition = CSharpLuaLuaAst.LuaBinaryExpressionSyntax(temp, "~=" --[[Tokens.NotEquals]], CSharpLuaLuaAst.LuaIdentifierNameSyntax.Nil);
            local ifStatement = CSharpLuaLuaAst.LuaIfStatementSyntax(condition);
            getCurBlock(this).Statements:Add1(ifStatement);

            this.blocks_:Push(ifStatement.Body);
            local whenNotNull = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getWhenNotNull():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
            this.blocks_:Pop();
            this.conditionalTemps_:Pop();

            if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getParent(), 8797 --[[SyntaxKind.ExpressionStatement]]) then
                ifStatement.Body.Statements:Add1(CSharpLuaLuaAst.LuaExpressionStatementSyntax(whenNotNull));
                return CSharpLuaLuaAst.LuaExpressionSyntax.EmptyExpression;
            else
                local assignment = CSharpLuaLuaAst.LuaAssignmentExpressionSyntax(temp, whenNotNull);
                ifStatement.Body.Statements:Add1(CSharpLuaLuaAst.LuaExpressionStatementSyntax(assignment));
                return temp;
            end
        end;
        VisitMemberBindingExpression = function (this, node) 
            local symbol = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetSymbolInfo(this.semanticModel_, node):getSymbol();
            if node:getName():getIdentifier():getValueText() == "Invoke" then
                if CSharpLua.Utility.IsDelegateType(symbol:getContainingType()) then
                    return this.conditionalTemps_:Peek();
                end
            end

            local nameExpression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getName():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
            return CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(this.conditionalTemps_:Peek(), nameExpression, symbol:getKind() == 9 --[[SymbolKind.Method]]);
        end;
        VisitElementBindingExpression = function (this, node) 
            local argumentList = System.cast(CSharpLuaLuaAst.LuaArgumentListSyntax, node:getArgumentList():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
            local memberAccess = CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(this.conditionalTemps_:Peek(), CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, "get" --[[Tokens.Get]]), true);
            local invocation = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(1, memberAccess);
            invocation.ArgumentList.Arguments:AddRange1(argumentList.Arguments);
            return invocation;
        end;
        VisitDefaultExpression = function (this, node) 
            return BuildDefaultValueExpression(this, node:getType());
        end;
        VisitElementAccessExpression = function (this, node) 
            local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
            local argumentList = System.cast(CSharpLuaLuaAst.LuaArgumentListSyntax, node:getArgumentList():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
            local identifierName = CSharpLuaLuaAst.LuaPropertyOrEventIdentifierNameSyntax(true, "");
            local memberAccess = CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(expression, identifierName, true);
            local propertyAdapter = CSharpLuaLuaAst.LuaPropertyAdapterExpressionSyntax:new(2, memberAccess, identifierName);
            propertyAdapter.InvocationExpression.ArgumentList.Arguments:AddRange1(argumentList.Arguments);
            return propertyAdapter;
        end;
        VisitInterpolatedStringExpression = function (this, node) 
            local index = 0;
            local sb = System.StringBuilder();
            local expressions = System.List(CSharpLuaLuaAst.LuaExpressionSyntax)();
            for _, content in System.each(node:getContents()) do
                if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(content, 8919 --[[SyntaxKind.InterpolatedStringText]]) then
                    local stringText = System.cast(MicrosoftCodeAnalysisCSharpSyntax.InterpolatedStringTextSyntax, content);
                    sb:Append(stringText:getTextToken():getValueText());
                else
                    local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, content:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode));
                    expressions:Add(expression);
                    sb:Append(123 --[['{']]);
                    sb:Append(index);
                    sb:Append(125 --[['}']]);
                    index = index + 1;
                end
            end

            local format;
            if Linq.Contains(node:getStringStartToken():getValueText(), 64 --[['@']]) then
                format = BuildVerbatimStringExpression(this, sb:ToString());
            else
                format = BuildStringLiteralExpression(this, sb:ToString());
            end
            local memberAccessExpression = CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(CSharpLuaLuaAst.LuaParenthesizedExpressionSyntax(format), CSharpLuaLuaAst.LuaIdentifierNameSyntax.Format, true);
            return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(5, memberAccessExpression, expressions);
        end;
        VisitInterpolation = function (this, node) 
            return node:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode);
        end;
        VisitInterpolatedStringText = function (this, node) 
            System.throw(System.InvalidOperationException());
        end;
        __staticCtor__ = function (this) 
            operatorTokenMapps_ = System.create(System.Dictionary(System.String, System.String)(), function (default) 
                default:set("!=", "~=" --[[Tokens.NotEquals]]);
                default:set("!", "not" --[[Keyword.Not]]);
                default:set("&&", "and" --[[Keyword.And]]);
                default:set("||", "or" --[[Keyword.Or]]);
                default:set("??", "or" --[[Keyword.Or]]);
                default:set("^", "~");
            end);
            codeTemplateRegex_ = SystemTextRegularExpressions.Regex([[(,?\s*)\{(\*?[\w|^]+)\}]], 8 --[[RegexOptions.Compiled]]);
        end;
        __init__ = function (this) 
            this.compilationUnits_ = System.Stack(CSharpLuaLuaAst.LuaCompilationUnitSyntax)();
            this.typeDeclarations_ = System.Stack(CSharpLuaLuaAst.LuaTypeDeclarationSyntax)();
            this.functions_ = System.Stack(CSharpLuaLuaAst.LuaFunctionExpressionSyntax)();
            this.blocks_ = System.Stack(CSharpLuaLuaAst.LuaBlockSyntax)();
            this.ifStatements_ = System.Stack(CSharpLuaLuaAst.LuaIfStatementSyntax)();
            this.switchs_ = System.Stack(CSharpLuaLuaAst.LuaSwitchAdapterStatementSyntax)();
            this.localReservedNames_ = System.Dictionary(MicrosoftCodeAnalysis.ISymbol, System.String)();
            this.conditionalTemps_ = System.Stack(CSharpLuaLuaAst.LuaIdentifierNameSyntax)();
        end;
        __ctor__ = function (this, generator, semanticModel) 
            __init__(this);
            this.generator_ = generator;
            this.semanticModel_ = semanticModel;
        end;
        return {
            __inherits__ = {
                MicrosoftCodeAnalysisCSharp.CSharpSyntaxVisitor_1(CSharpLuaLuaAst.LuaSyntaxNode)
            }, 
            VisitCompilationUnit = VisitCompilationUnit, 
            VisitNamespaceDeclaration = VisitNamespaceDeclaration, 
            AcceptPartialType = AcceptPartialType, 
            VisitClassDeclaration = VisitClassDeclaration, 
            VisitStructDeclaration = VisitStructDeclaration, 
            VisitInterfaceDeclaration = VisitInterfaceDeclaration, 
            VisitEnumDeclaration = VisitEnumDeclaration, 
            VisitMethodDeclaration = VisitMethodDeclaration, 
            VisitFieldDeclaration = VisitFieldDeclaration, 
            VisitPropertyDeclaration = VisitPropertyDeclaration, 
            VisitEventDeclaration = VisitEventDeclaration, 
            VisitEventFieldDeclaration = VisitEventFieldDeclaration, 
            VisitEnumMemberDeclaration = VisitEnumMemberDeclaration, 
            VisitIndexerDeclaration = VisitIndexerDeclaration, 
            VisitBracketedParameterList = VisitBracketedParameterList, 
            VisitParameterList = VisitParameterList, 
            VisitParameter = VisitParameter, 
            VisitBlock = VisitBlock, 
            VisitReturnStatement = VisitReturnStatement, 
            VisitExpressionStatement = VisitExpressionStatement, 
            VisitAssignmentExpression = VisitAssignmentExpression, 
            VisitInvocationExpression = VisitInvocationExpression, 
            VisitMemberAccessExpression = VisitMemberAccessExpression, 
            VisitIdentifierName = VisitIdentifierName, 
            VisitQualifiedName = VisitQualifiedName, 
            VisitArgumentList = VisitArgumentList, 
            VisitArgument = VisitArgument, 
            VisitLiteralExpression = VisitLiteralExpression, 
            VisitLocalDeclarationStatement = VisitLocalDeclarationStatement, 
            VisitVariableDeclaration = VisitVariableDeclaration, 
            VisitVariableDeclarator = VisitVariableDeclarator, 
            VisitEqualsValueClause = VisitEqualsValueClause, 
            VisitPredefinedType = VisitPredefinedType, 
            VisitIfStatement = VisitIfStatement, 
            VisitElseClause = VisitElseClause, 
            VisitSwitchStatement = VisitSwitchStatement, 
            VisitSwitchSection = VisitSwitchSection, 
            VisitCaseSwitchLabel = VisitCaseSwitchLabel, 
            VisitBreakStatement = VisitBreakStatement, 
            VisitBinaryExpression = VisitBinaryExpression, 
            VisitPrefixUnaryExpression = VisitPrefixUnaryExpression, 
            VisitPostfixUnaryExpression = VisitPostfixUnaryExpression, 
            VisitContinueStatement = VisitContinueStatement, 
            VisitForEachStatement = VisitForEachStatement, 
            VisitWhileStatement = VisitWhileStatement, 
            VisitForStatement = VisitForStatement, 
            VisitDoStatement = VisitDoStatement, 
            VisitYieldStatement = VisitYieldStatement, 
            VisitParenthesizedExpression = VisitParenthesizedExpression, 
            VisitConditionalExpression = VisitConditionalExpression, 
            VisitGotoStatement = VisitGotoStatement, 
            VisitLabeledStatement = VisitLabeledStatement, 
            VisitEmptyStatement = VisitEmptyStatement, 
            VisitCastExpression = VisitCastExpression, 
            VisitCheckedStatement = VisitCheckedStatement, 
            VisitCheckedExpression = VisitCheckedExpression, 
            localMappingCounter_ = 0, 
            ImportTypeName = ImportTypeName, 
            VisitObjectCreationExpression = VisitObjectCreationExpression, 
            VisitInitializerExpression = VisitInitializerExpression, 
            VisitBracketedArgumentList = VisitBracketedArgumentList, 
            VisitImplicitElementAccess = VisitImplicitElementAccess, 
            VisitGenericName = VisitGenericName, 
            VisitOmittedArraySizeExpression = VisitOmittedArraySizeExpression, 
            VisitArrayRankSpecifier = VisitArrayRankSpecifier, 
            VisitArrayType = VisitArrayType, 
            VisitArrayCreationExpression = VisitArrayCreationExpression, 
            VisitImplicitArrayCreationExpression = VisitImplicitArrayCreationExpression, 
            VisitConstructorDeclaration = VisitConstructorDeclaration, 
            VisitSimpleBaseType = VisitSimpleBaseType, 
            VisitSimpleLambdaExpression = VisitSimpleLambdaExpression, 
            VisitParenthesizedLambdaExpression = VisitParenthesizedLambdaExpression, 
            VisitTypeParameter = VisitTypeParameter, 
            VisitTypeOfExpression = VisitTypeOfExpression, 
            VisitThrowStatement = VisitThrowStatement, 
            VisitCatchFilterClause = VisitCatchFilterClause, 
            VisitCatchClause = VisitCatchClause, 
            VisitCatchDeclaration = VisitCatchDeclaration, 
            VisitFinallyClause = VisitFinallyClause, 
            VisitTryStatement = VisitTryStatement, 
            VisitUsingStatement = VisitUsingStatement, 
            VisitThisExpression = VisitThisExpression, 
            VisitBaseExpression = VisitBaseExpression, 
            VisitConditionalAccessExpression = VisitConditionalAccessExpression, 
            VisitMemberBindingExpression = VisitMemberBindingExpression, 
            VisitElementBindingExpression = VisitElementBindingExpression, 
            VisitDefaultExpression = VisitDefaultExpression, 
            VisitElementAccessExpression = VisitElementAccessExpression, 
            VisitInterpolatedStringExpression = VisitInterpolatedStringExpression, 
            VisitInterpolation = VisitInterpolation, 
            VisitInterpolatedStringText = VisitInterpolatedStringText, 
            __staticCtor__ = __staticCtor__, 
            __ctor__ = __ctor__
        };
    end);
end);
